<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>标签: runtime - 千行的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="千行的博客"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="千行的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="千行的博客"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="千行的博客"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="千行"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"千行的博客","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"千行"},"publisher":{"@type":"Organization","name":"千行的博客","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-0VD5EHM46E" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-0VD5EHM46E');</script><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="千行的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">runtime</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-05-11T08:04:52.000Z" title="5/11/2020, 4:04:52 PM">2020-05-11</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">1 小时读完 (大约7465个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/05/11/%E6%8E%A2%E7%A9%B6-block-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">探究 block 数据结构及内存管理</a></h1><div class="content"><p>本文首先将介绍一些 block 的基础, 随后着重介绍下面的内容</p>
<ul>
<li>block 的数据结构</li>
<li>block 的内存管理(retain，release)</li>
</ul>
<p>会用到下面这个<br><a target="_blank" rel="noopener" href="https://github.com/LGCooci/objc_debug/tree/master">可编译的源码</a></p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>Block</code> 的语法比较难记, 以至于出现了 <a target="_blank" rel="noopener" href="http://fuckingblocksyntax.com/">fuckingblocksyntax</a> 这样的网站专门用于记录 block 的语法, 摘录如下:</p>
<p>作为变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">returnType (^blockName)(parameterTypes) = ^returnType(parameters) &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>作为属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes);</span><br></pre></td></tr></table></figure>

<p>作为函数声明参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)someMethodThatTakesABlock:(returnType (^nullability)(parameterTypes))blockName;</span><br></pre></td></tr></table></figure>

<p>作为函数调用中的参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[someObject someMethodThatTakesABlock:^returnType (parameters) &#123;...&#125;];</span><br></pre></td></tr></table></figure>

<p>作为 typedef</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef returnType (^TypeName)(parameterTypes);</span><br><span class="line">TypeName blockName = ^returnType(parameters) &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="捕获外部变量"><a href="#捕获外部变量" class="headerlink" title="捕获外部变量"></a>捕获外部变量</h3><p>block 可以捕获来自外部作用域的变量(id 类型, C++类型, 基础数据类型, block), 这是 block 一个很强大的特性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)foo &#123;</span><br><span class="line">    int anInteger = 42;</span><br><span class="line">    void (^testBlock)(void) = ^&#123;</span><br><span class="line">        NSLog(@&quot;Integer is: %i&quot;, anInteger);</span><br><span class="line">    &#125;;</span><br><span class="line">    testBlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下, 捕获的外部变量在 block 里做的修改，在外部是不起作用的。如果想要在外部起作用，需要使用 <code>__block</code> 来声明变量:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int __block anInteger = 42</span><br></pre></td></tr></table></figure>

<p>所以，根据变量是否被 __block 修饰，可以将变量分为两类：</p>
<ul>
<li>by ref： 引用类型。该类的变量被 __block 修饰，在 block 内部对其修改，外部也生效</li>
<li>by copy：拷贝类型。该类的变量不被 __block 修饰，在 block 内部对其修改，外部不生效(全局&#x2F;静态 变量除外)</li>
</ul>
<p>至于原因进阶部分会进行详细的探究</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>运行下面的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^BLK)(void);</span><br><span class="line"></span><br><span class="line">- (void)foo</span><br><span class="line">&#123;</span><br><span class="line">    static int staticInt = 5;</span><br><span class="line">    int ret = 5;</span><br><span class="line">    </span><br><span class="line">    BLK globalBlock = ^&#123;</span><br><span class="line">        int a = staticInt;</span><br><span class="line">    &#125;;</span><br><span class="line">    BLK mallocBlock = ^&#123;</span><br><span class="line">        int a = ret;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;global = %@&quot;, globalBlock);</span><br><span class="line">    NSLog(@&quot;malloc = %@&quot;, mallocBlock);</span><br><span class="line">    NSLog(@&quot;stack = %@&quot;, ^&#123;int a = ret;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">global = &lt;__NSGlobalBlock__: 0x104bb22b0&gt;</span><br><span class="line">malloc = &lt;__NSMallocBlock__: 0x281a21bf0&gt;</span><br><span class="line">stack  = &lt;__NSStackBlock__:  0x16b8266d8&gt;</span><br></pre></td></tr></table></figure>

<p>在 iOS 平台中, 一共有三种类型的 block:</p>
<ul>
<li>_NSConcreteGlobalBlock： 在 .data 区域, block 内部没有访问任何的外部非(静态变量 &amp;&amp; 全局变量)的变量(^{;}同样是该类型)</li>
<li>_NSConcreteMallocBlock： 在堆中创建内存, 使用<code>__strong</code>修饰的 block </li>
<li>_NSConcreteStackBlock：  在栈中创建内存, 使用<code>__weak</code>修饰的 block 或者是匿名 block</li>
</ul>
<p>优先级为 _NSConcreteGlobalBlock &gt; _NSConcreteMallocBlock &#x3D;&#x3D; _NSConcreteStackBlock，即满足 _NSConcreteGlobalBlock 条件的 block 就是 _NSConcreteGlobalBlock 类型的</p>
<p>_NSConcreteGlobalBlock 类型的 block 我不知道初始化的时候是否直接在 .data 区域创建。<br>_NSConcreteMallocBlock 和 _NSConcreteStackBlock类型的 block 在初始化时在栈中创建，随后如果有 __storng 强指针引用的话，<br>则进行 retain 操作，将其内存拷贝到堆中，后续的 retain 操作则只是增加 block 的引用计数</p>
<hr>
<p>使用命令<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-13.0.0 YOUR_FILE_NAME</code>将下面的代码转换成 C++ 实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)foo</span><br><span class="line">&#123;</span><br><span class="line">    static int staticInt = 5;</span><br><span class="line">    NSObject *commonObject = [[NSObject alloc] init];</span><br><span class="line">    __weak NSObject *weakObject = commonObject;</span><br><span class="line">    __block NSObject *byrefObject = [[NSObject alloc] init];</span><br><span class="line">    __block __weak NSObject *byrefWeakObject = commonObject;</span><br><span class="line">    BLK blockObject = ^&#123;</span><br><span class="line">       NSObject *val = commonObject;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">    BLK malocBlock = ^&#123;</span><br><span class="line">        staticInt++;</span><br><span class="line">        NSLog(@&quot;%@&quot;, commonObject);</span><br><span class="line">        NSLog(@&quot;%@&quot;, byrefWeakObject);</span><br><span class="line">        NSLog(@&quot;%@&quot;, weakObject);</span><br><span class="line">        NSLog(@&quot;%@&quot;, byrefObject);</span><br><span class="line">        NSLog(@&quot;%@&quot;, byrefWeakObject);</span><br><span class="line">        NSLog(@&quot;%@&quot;, blockObject);</span><br><span class="line">    &#125;;</span><br><span class="line">    NSLog(@&quot;malloc = %@&quot;, malocBlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换得到的 C++ 实现， 只截取部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">static void __Block_byref_id_object_copy_131(void *dst, void *src) &#123;</span><br><span class="line"> _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);</span><br><span class="line">&#125;</span><br><span class="line">static void __Block_byref_id_object_dispose_131(void *src) &#123;</span><br><span class="line"> _Block_object_dispose(*(void * *) ((char*)src + 40), 131);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct __Block_byref_byrefObject_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_byrefObject_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> void (*__Block_byref_id_object_copy)(void*, void*);</span><br><span class="line"> void (*__Block_byref_id_object_dispose)(void*);</span><br><span class="line"> NSObject *__strong byrefObject;</span><br><span class="line">&#125;;</span><br><span class="line">struct __Block_byref_byrefWeakObject_1 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_byrefWeakObject_1 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> void (*__Block_byref_id_object_copy)(void*, void*);</span><br><span class="line"> void (*__Block_byref_id_object_dispose)(void*);</span><br><span class="line"> NSObject *__weak byrefWeakObject;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __TestObject__foo_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __TestObject__foo_block_desc_0* Desc;</span><br><span class="line">  NSObject *__strong commonObject;</span><br><span class="line">  __TestObject__foo_block_impl_0(void *fp, struct __TestObject__foo_block_desc_0 *desc, NSObject *__strong _commonObject, int flags=0) : commonObject(_commonObject) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __TestObject__foo_block_func_0(struct __TestObject__foo_block_impl_0 *__cself) &#123;</span><br><span class="line">  NSObject *__strong commonObject = __cself-&gt;commonObject; // bound by copy</span><br><span class="line"></span><br><span class="line">       NSObject *val = commonObject;</span><br><span class="line">   &#125;</span><br><span class="line">static void __TestObject__foo_block_copy_0(struct __TestObject__foo_block_impl_0*dst, struct __TestObject__foo_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;commonObject, (void*)src-&gt;commonObject, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __TestObject__foo_block_dispose_0(struct __TestObject__foo_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;commonObject, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static struct __TestObject__foo_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __TestObject__foo_block_impl_0*, struct __TestObject__foo_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __TestObject__foo_block_impl_0*);</span><br><span class="line">&#125; __TestObject__foo_block_desc_0_DATA = &#123; 0, sizeof(struct __TestObject__foo_block_impl_0), __TestObject__foo_block_copy_0, __TestObject__foo_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">struct __TestObject__foo_block_impl_1 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __TestObject__foo_block_desc_1* Desc;</span><br><span class="line">  int *staticInt;</span><br><span class="line">  NSObject *__strong commonObject;</span><br><span class="line">  NSObject *__weak weakObject;</span><br><span class="line">  __strong BLK blockObject;</span><br><span class="line">  __Block_byref_byrefWeakObject_1 *byrefWeakObject; // by ref</span><br><span class="line">  __Block_byref_byrefObject_0 *byrefObject; // by ref</span><br><span class="line">  __TestObject__foo_block_impl_1(void *fp, struct __TestObject__foo_block_desc_1 *desc, int *_staticInt, NSObject *__strong _commonObject, NSObject *__weak _weakObject, __strong BLK _blockObject, __Block_byref_byrefWeakObject_1 *_byrefWeakObject, __Block_byref_byrefObject_0 *_byrefObject, int flags=0) : staticInt(_staticInt), commonObject(_commonObject), weakObject(_weakObject), blockObject(_blockObject), byrefWeakObject(_byrefWeakObject-&gt;__forwarding), byrefObject(_byrefObject-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __TestObject__foo_block_func_1(struct __TestObject__foo_block_impl_1 *__cself) &#123;</span><br><span class="line">  __Block_byref_byrefWeakObject_1 *byrefWeakObject = __cself-&gt;byrefWeakObject; // bound by ref</span><br><span class="line">  __Block_byref_byrefObject_0 *byrefObject = __cself-&gt;byrefObject; // bound by ref</span><br><span class="line">  int *staticInt = __cself-&gt;staticInt; // bound by copy</span><br><span class="line">  NSObject *__strong commonObject = __cself-&gt;commonObject; // bound by copy</span><br><span class="line">  NSObject *__weak weakObject = __cself-&gt;weakObject; // bound by copy</span><br><span class="line">  __strong BLK blockObject = __cself-&gt;blockObject; // bound by copy</span><br><span class="line"></span><br><span class="line">        (*staticInt)++;</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h0_ybj03b8d0mj52n8dx82v2br40000gn_T_TestObject_1a9b07_mi_0, commonObject);</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h0_ybj03b8d0mj52n8dx82v2br40000gn_T_TestObject_1a9b07_mi_1, (byrefWeakObject-&gt;__forwarding-&gt;byrefWeakObject));</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h0_ybj03b8d0mj52n8dx82v2br40000gn_T_TestObject_1a9b07_mi_2, weakObject);</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h0_ybj03b8d0mj52n8dx82v2br40000gn_T_TestObject_1a9b07_mi_3, (byrefObject-&gt;__forwarding-&gt;byrefObject));</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h0_ybj03b8d0mj52n8dx82v2br40000gn_T_TestObject_1a9b07_mi_4, (byrefWeakObject-&gt;__forwarding-&gt;byrefWeakObject));</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h0_ybj03b8d0mj52n8dx82v2br40000gn_T_TestObject_1a9b07_mi_5, blockObject);</span><br><span class="line">    &#125;</span><br><span class="line">static void __TestObject__foo_block_copy_1(struct __TestObject__foo_block_impl_1*dst, struct __TestObject__foo_block_impl_1*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;commonObject, (void*)src-&gt;commonObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_assign((void*)&amp;dst-&gt;byrefWeakObject, (void*)src-&gt;byrefWeakObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;weakObject, (void*)src-&gt;weakObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_assign((void*)&amp;dst-&gt;byrefObject, (void*)src-&gt;byrefObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;blockObject, (void*)src-&gt;blockObject, 7/*BLOCK_FIELD_IS_BLOCK*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __TestObject__foo_block_dispose_1(struct __TestObject__foo_block_impl_1*src) &#123;_Block_object_dispose((void*)src-&gt;commonObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_dispose((void*)src-&gt;byrefWeakObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;weakObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_dispose((void*)src-&gt;byrefObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;blockObject, 7/*BLOCK_FIELD_IS_BLOCK*/);&#125;</span><br><span class="line"></span><br><span class="line">static struct __TestObject__foo_block_desc_1 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __TestObject__foo_block_impl_1*, struct __TestObject__foo_block_impl_1*);</span><br><span class="line">  void (*dispose)(struct __TestObject__foo_block_impl_1*);</span><br><span class="line">&#125; __TestObject__foo_block_desc_1_DATA = &#123; 0, sizeof(struct __TestObject__foo_block_impl_1), __TestObject__foo_block_copy_1, __TestObject__foo_block_dispose_1&#125;;</span><br><span class="line"></span><br><span class="line">static void _I_TestObject_foo(TestObject * self, SEL _cmd) &#123;</span><br><span class="line">    static int staticInt = 5;</span><br><span class="line">    NSObject *commonObject = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));</span><br><span class="line">    __attribute__((objc_ownership(weak))) NSObject *weakObject = commonObject;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_byrefObject_0 byrefObject = &#123;(void*)0,(__Block_byref_byrefObject_0 *)&amp;byrefObject, 33554432, sizeof(__Block_byref_byrefObject_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;))&#125;;</span><br><span class="line">    __attribute__((__blocks__(byref))) __attribute__((objc_ownership(weak))) __Block_byref_byrefWeakObject_1 byrefWeakObject = &#123;(void*)0,(__Block_byref_byrefWeakObject_1 *)&amp;byrefWeakObject, 33554432, sizeof(__Block_byref_byrefWeakObject_1), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, commonObject&#125;;</span><br><span class="line">    BLK blockObject = ((void (*)())&amp;__TestObject__foo_block_impl_0((void *)__TestObject__foo_block_func_0, &amp;__TestObject__foo_block_desc_0_DATA, commonObject, 570425344));</span><br><span class="line"></span><br><span class="line">    BLK malocBlock = ((void (*)())&amp;__TestObject__foo_block_impl_1((void *)__TestObject__foo_block_func_1, &amp;__TestObject__foo_block_desc_1_DATA, &amp;staticInt, commonObject, weakObject, blockObject, (__Block_byref_byrefWeakObject_1 *)&amp;byrefWeakObject, (__Block_byref_byrefObject_0 *)&amp;byrefObject, 570425344));</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h0_ybj03b8d0mj52n8dx82v2br40000gn_T_TestObject_1a9b07_mi_6, malocBlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，上面生成的 C++ 代码中 block 的结构体，并不符合最新版本 objc4-779.1 源码里 block 的结构定义</p>
</blockquote>
<p>在 objc4-779.1 里 block 结构体的定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#define BLOCK_DESCRIPTOR_1 1</span><br><span class="line">struct Block_descriptor_1 &#123;</span><br><span class="line">    uintptr_t reserved;</span><br><span class="line">    uintptr_t size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define BLOCK_DESCRIPTOR_2 1</span><br><span class="line">struct Block_descriptor_2 &#123;</span><br><span class="line">    // requires BLOCK_HAS_COPY_DISPOSE</span><br><span class="line">    void (*copy)(void *dst, const void *src);</span><br><span class="line">    void (*dispose)(const void *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define BLOCK_DESCRIPTOR_3 1</span><br><span class="line">struct Block_descriptor_3 &#123;</span><br><span class="line">    // requires BLOCK_HAS_SIGNATURE</span><br><span class="line">    const char *signature;</span><br><span class="line">    const char *layout;     // contents depend on BLOCK_HAS_EXTENDED_LAYOUT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Block_layout &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    volatile int32_t flags; // contains ref count</span><br><span class="line">    int32_t reserved; </span><br><span class="line">    void (*invoke)(void *, ...);</span><br><span class="line">    struct Block_descriptor_1 *descriptor;</span><br><span class="line">    // imported variables</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不是有三种类型的 BLOCK_DESCRIPTOR 结构体，只是根据功能将其分为三部分，其实是一个整体<br>注意下面两个结构体在内存上是完全一样的，原因是结构体本身并不带有任何额外的附加信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct SampleA &#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">    int c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct SampleB &#123;</span><br><span class="line">    int a;</span><br><span class="line">    struct Part1 &#123;</span><br><span class="line">        int b;</span><br><span class="line">    &#125;;</span><br><span class="line">    struct Part2 &#123;</span><br><span class="line">        int c;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>Block_layout 成员变量介绍:</p>
<ul>
<li>void *isa: isa 指针</li>
<li>int flags: 使用位域来保存信息, 例如引用计数, 是否正在被销毁等信息</li>
<li>int reserved: 保留变量</li>
<li>void (*invoke)(void *, …): 函数指针, 指向 block 实现函数的调用地址</li>
<li>struct Block_descriptor *descriptor: block 的附加描述信息，一般来说都包含 Block_descriptor_1，但是是否包含 Block_descriptor_2 和 Block_descriptor_3 需要根据捕获外部变量的类型来判断</li>
<li>还有一些捕获的外部变量</li>
</ul>
<table>
<thead>
<tr>
<th>位域名</th>
<th>位置</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>BLOCK_DEALLOCATING</td>
<td>0x0001</td>
<td>1 表示正在被销毁</td>
</tr>
<tr>
<td>BLOCK_REFCOUNT_MASK</td>
<td>0xfffe</td>
<td>block 是引用计数</td>
</tr>
<tr>
<td>BLOCK_NEEDS_FREE</td>
<td>1 &lt;&lt; 24</td>
<td>1 表示 block 已拷贝到堆中</td>
</tr>
<tr>
<td>BLOCK_HAS_COPY_DISPOSE</td>
<td>1 &lt;&lt; 25</td>
<td>block 是否有 copy&#x2F;dispos 函数，即 descriptor 是否包含 Block_descriptor_2</td>
</tr>
<tr>
<td>BLOCK_HAS_CTOR</td>
<td>1 &lt;&lt; 26</td>
<td>copy&#x2F;dispose helper 函数里面有 C++代码</td>
</tr>
<tr>
<td>BLOCK_IS_GC</td>
<td>1 &lt;&lt; 27</td>
<td>1 表示使用 GC 管理内存，iOS 平台中不使用 GC</td>
</tr>
<tr>
<td>BLOCK_IS_GLOBAL</td>
<td>1 &lt;&lt; 28</td>
<td>1 表示是个全局 block</td>
</tr>
<tr>
<td>BLOCK_USE_STRET</td>
<td>1 &lt;&lt; 29</td>
<td>arm64 架构下没用，不知道干嘛的</td>
</tr>
<tr>
<td>BLOCK_HAS_SIGNATURE</td>
<td>1 &lt;&lt; 30</td>
<td>是否有函数类型编码</td>
</tr>
<tr>
<td>BLOCK_HAS_EXTENDED_LAYOUT</td>
<td>1 &lt;&lt; 31</td>
<td>GC 下使用</td>
</tr>
</tbody></table>
<p>Block_descriptor 成员变量介绍:</p>
<ul>
<li>unsigned long int reserved: 预留变量</li>
<li>unsigned long int size: block 结构体的 size 大小</li>
<li>void (*copy)(void *dst, void *src): copy 函数，将 block 成员变量 从栈拷贝到堆中。后面会再介绍</li>
<li>void (*dispose)(void *): dispose 函数， 对 block 成员变量内存回收</li>
<li>const char *signature：函数的类型编码</li>
<li>const char *layout: GC 下使用，不知道具体作用</li>
</ul>
<p>让我们对照着 C++ 实现捋一遍，因为实现里的 block 结构体是老版本所以跟上面讲的可能会有出入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __TestObject__foo_block_impl_1 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __TestObject__foo_block_desc_1* Desc;</span><br><span class="line">  int *staticInt;</span><br><span class="line">  NSObject *__strong commonObject;</span><br><span class="line">  NSObject *__weak weakObject;</span><br><span class="line">  __strong BLK blockObject;</span><br><span class="line">  __Block_byref_byrefWeakObject_1 *byrefWeakObject; // by ref</span><br><span class="line">  __Block_byref_byrefObject_0 *byrefObject; // by ref</span><br><span class="line">  __TestObject__foo_block_impl_1(void *fp, struct __TestObject__foo_block_desc_1 *desc, int *_staticInt, NSObject *__strong _commonObject, NSObject *__weak _weakObject, __strong BLK _blockObject, __Block_byref_byrefWeakObject_1 *_byrefWeakObject, __Block_byref_byrefObject_0 *_byrefObject, int flags=0) : staticInt(_staticInt), commonObject(_commonObject), weakObject(_weakObject), blockObject(_blockObject), byrefWeakObject(_byrefWeakObject-&gt;__forwarding), byrefObject(_byrefObject-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>在结构体 __TestObject__foo_block_impl_1 有很多捕获的外部变量充当的成员变量，如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int *staticInt;</span><br><span class="line">NSObject *__strong commonObject;</span><br><span class="line">NSObject *__weak weakObject;</span><br><span class="line">__strong BLK blockObject;</span><br><span class="line">__Block_byref_byrefWeakObject_1 *byrefWeakObject; // by ref</span><br><span class="line">__Block_byref_byrefObject_0 *byrefObject; // by ref</span><br></pre></td></tr></table></figure>

<p>为了尽可能的谈论多的情况，在示例代码中我在 block 加了许多不同类型的外部变量<br>可以看到，全局&#x2F;静态 变量和 __block 变量，都是将变量的地址保存在成员变量中，这样做的目的是为了在内部修改该变量在外部也会生效。<br>而其它非 __block 变量则仅仅拷贝了值，类似于浅拷贝</p>
<p>__Block_byref_byrefWeakObject_1 是 Block_byref 类型的结构体。__block 变量在编译时变成对应的 Block_byref 实例，且实例持有该变量</p>
<p>Block_byref 结构体的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct Block_byref &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    struct Block_byref *forwarding;</span><br><span class="line">    volatile int32_t flags; // contains ref count</span><br><span class="line">    uint32_t size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Block_byref_2 &#123;</span><br><span class="line">    // requires BLOCK_BYREF_HAS_COPY_DISPOSE</span><br><span class="line">    void (*byref_keep)(struct Block_byref *dst, struct Block_byref *src);</span><br><span class="line">    void (*byref_destroy)(struct Block_byref *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Block_byref_3 &#123;</span><br><span class="line">    // requires BLOCK_BYREF_LAYOUT_EXTENDED</span><br><span class="line">    const char *layout;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类似 Block_descriptor，根据功能将其分为三部分<br>成员变量介绍：</p>
<ul>
<li>void *isa：一般指向 0x0，如果该变量还被 __weak 修饰，则指向 _NSConcreteWeakBlockVariable</li>
<li>struct Block_byref *forwarding：指向该结构体。在拷贝到堆的过程中，在堆中新建一个结构体实例，此时栈中的实例并没有被销毁，将栈中实例 forwarding 指向堆中的实例</li>
<li>int flags：引用计数使用的 bit 数目和位置与 block 相同，其它不再介绍</li>
<li>int size：Block_byref 结构体的字节长度</li>
<li>void (*byref_keep)(struct Block_byref *dst, struct Block_byref *src)：Block_byref 的 copy 函数，帮助将实例持有的变量拷贝到堆中</li>
<li>void (*byref_destroy)(struct Block_byref *)：Block_byref 的 dispose 函数，帮助将持有的变量销毁</li>
<li>const char *layout：Block_byref 持有的变量</li>
</ul>
<p>为了方便，后面将 Block_layout 的 copy&#x2F;dispose 函数简称为 Block copy&#x2F;dispose 函数; Block_byref 的 byref_keep&#x2F;byref_destroy 函数简称为 __block copy&#x2F;dispose 函数</p>
<p>在 <code>foo()</code> 函数中我们在 block 捕获了两个 __block 修饰的变量，下面是其中一个的 Block_byref 结构体</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_byrefObject_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_byrefObject_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> void (*__Block_byref_id_object_copy)(void*, void*);</span><br><span class="line"> void (*__Block_byref_id_object_dispose)(void*);</span><br><span class="line"> NSObject *__strong byrefObject;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>编译时，编译器会将 __block 修饰的变量 byrefObject，转换成对应的 Block_byref 结构体 __Block_byref_byrefObject_0 实例，然后让实例持有该变量<code>NSObject *__strong byrefObject;</code></p>
<hr>
<p>block 结构体 __TestObject__foo_block_impl_1 里面还定义了一个初始化方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_TestObject__foo_block_impl_1(void *fp, struct __TestObject__foo_block_desc_1 *desc, int *_staticInt, NSObject *__strong _commonObject, NSObject *__weak _weakObject, __strong BLK _blockObject, __Block_byref_byrefWeakObject_1 *_byrefWeakObject, __Block_byref_byrefObject_0 *_byrefObject, int flags=0) : staticInt(_staticInt), commonObject(_commonObject), weakObject(_weakObject), blockObject(_blockObject), byrefWeakObject(_byrefWeakObject-&gt;__forwarding), byrefObject(_byrefObject-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>其中类似 <code>: commonObject(_commonObject)</code> 的写法是将形参<code>NSObject *__strong _commonObject</code>赋值给成员变量 <code>_commonObject</code></li>
<li>参数 flags 有一个默认值 0, 在本例中传入的值为 570425344, 用二进制表示为 0b00100010000000000000000000000000，即第 30 位(BLOCK_USE_STRET), 第 26 位(BLOCK_HAS_COPY_DISPOSE) bit 的值 1</li>
<li>参数 fp 是函数指针, 在本例中它的实现如下:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void __TestObject__foo_block_func_1(struct __TestObject__foo_block_impl_1 *__cself) &#123;</span><br><span class="line">  __Block_byref_byrefWeakObject_1 *byrefWeakObject = __cself-&gt;byrefWeakObject; // bound by ref</span><br><span class="line">  __Block_byref_byrefObject_0 *byrefObject = __cself-&gt;byrefObject; // bound by ref</span><br><span class="line">  int *staticInt = __cself-&gt;staticInt; // bound by copy</span><br><span class="line">  NSObject *__strong commonObject = __cself-&gt;commonObject; // bound by copy</span><br><span class="line">  NSObject *__weak weakObject = __cself-&gt;weakObject; // bound by copy</span><br><span class="line">  __strong BLK blockObject = __cself-&gt;blockObject; // bound by copy</span><br><span class="line"></span><br><span class="line">        (*staticInt)++;</span><br><span class="line"></span><br><span class="line">       // 省略。。。</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
<p>也就是 block 里面的代码。<br>可以看到非 __block 变量后面都写了注释 <code>bound by copy</code>，__block 变量后面的注释是 <code>bound by ref</code>，__block 变量都会转换成 Block_byref 实例保存在 block 中<br>为了方便，后面将 __block 修饰的变量称为引用变量，否则称为拷贝变量</p>
<ul>
<li>block 初始化参数 desc 的类型是<code>__TestObject__foo_block_desc_1 *</code></li>
</ul>
<p>结构体的定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static struct __TestObject__foo_block_desc_1 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __TestObject__foo_block_impl_1*, struct __TestObject__foo_block_impl_1*);</span><br><span class="line">  void (*dispose)(struct __TestObject__foo_block_impl_1*);</span><br><span class="line">&#125; __TestObject__foo_block_desc_1_DATA = &#123; 0, sizeof(struct __TestObject__foo_block_impl_1), __TestObject__foo_block_copy_1, __TestObject__foo_block_dispose_1&#125;;</span><br></pre></td></tr></table></figure>

<p>并且初始化了一个结构体实例 <code>__TestObject__foo_block_desc_1_DATA</code>，其中 reserved 的值为 0, Block_size 的值为结构体 __TestObject__foo_block_impl_1 的字节长度<br>copy 和 dispose 两个函数指针分别指向函数 __TestObject__foo_block_copy_1 和 __TestObject__foo_block_dispose_1<br>实现如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void __TestObject__foo_block_copy_1(struct __TestObject__foo_block_impl_1*dst, struct __TestObject__foo_block_impl_1*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;commonObject, (void*)src-&gt;commonObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_assign((void*)&amp;dst-&gt;byrefWeakObject, (void*)src-&gt;byrefWeakObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;weakObject, (void*)src-&gt;weakObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_assign((void*)&amp;dst-&gt;byrefObject, (void*)src-&gt;byrefObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;blockObject, (void*)src-&gt;blockObject, 7/*BLOCK_FIELD_IS_BLOCK*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __TestObject__foo_block_dispose_1(struct __TestObject__foo_block_impl_1*src) &#123;_Block_object_dispose((void*)src-&gt;commonObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_dispose((void*)src-&gt;byrefWeakObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;weakObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_dispose((void*)src-&gt;byrefObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;blockObject, 7/*BLOCK_FIELD_IS_BLOCK*/);&#125;</span><br></pre></td></tr></table></figure>

<p>这两个函数很容易看懂，有多少捕获的外部变量，就调用多少次 <code>_Block_object_assign()</code> 和 <code>_Block_object_dispose()</code>  函数。<br>需要注意的是 <code>_Block_object_assign()</code> 的第三个参数，根据变量的类型不同传入不同的标记，后面会详细讲</p>
<p>与其类似的是 Block_byref  的 copy&#x2F;dispose 函数<br>在本例中它们的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void __Block_byref_id_object_copy_131(void *dst, void *src) &#123;</span><br><span class="line"> _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);</span><br><span class="line">&#125;</span><br><span class="line">static void __Block_byref_id_object_dispose_131(void *src) &#123;</span><br><span class="line"> _Block_object_dispose(*(void * *) ((char*)src + 40), 131);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>可以看到，Block_byref 的 copy&#x2F;dispose 函数最终也是调用 _Block_object_assign&#x2F;_Block_object_dispose 函数</p>
<p>至于参数为什么要强转成 char*, 我的理解是这样的：</p>
<p>举个例子，定义一个 int 类型的数组, <code>int a[10]</code>。我们可以使用指针来代替数组的下标, 例如用<code>(int *)a + 1</code>来表示数组的第二个元素, 其距离第一个元素偏移了 4 个字节长度，所以强制转换成 char* 类型是为了每次偏移 1 个字节。上面的代码表示偏移了 40 个字节</p>
<p>而老版本 Block_byref 的定义(因为 C++ 实现符合源码)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Block_byref &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    struct Block_byref *forwarding;</span><br><span class="line">    int flags; /* refcount; */</span><br><span class="line">    int size;</span><br><span class="line">    void (*byref_keep)(struct Block_byref *dst, struct Block_byref *src);</span><br><span class="line">    void (*byref_destroy)(struct Block_byref *);</span><br><span class="line">    /* long shared[0]; */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Block_byref 偏移 40 个字节后的位置刚好是持有变量的首地址，所以在这里传入的参数即是引用变量(被 __block 修饰的变量)<br>至于后面的数字 131 后面再讲</p>
<p>好了，数据结构就分析到这啦。<br>目前我们可以知道的是，block 以及 __block 变量在编译时会生成对应的 Block_layout，Block_byref 结构体，它们都有各自的 copy&#x2F;dispose 函数</p>
<h3 id="验证-block-数据结构"><a href="#验证-block-数据结构" class="headerlink" title="验证 block 数据结构"></a>验证 block 数据结构</h3><p>这一节主要使用 lldb 用来验证 block 的数据结构</p>
<p><img src="https://i.loli.net/2020/05/11/cWBvNK3VRthaqgE.jpg"></p>
<p>打个断点，使用命令 <code>x/8xg ptr</code></p>
<p><img src="https://i.loli.net/2020/05/11/fJgaS9tmeHB7G5V.jpg" alt="block 内部分布"></p>
<p>根据上一节 block 结构体内容，我们可以知道各成员变量的值</p>
<table>
<thead>
<tr>
<th>block 成员变量</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>void *isa</td>
<td>0x00000001ca53c0f0</td>
</tr>
<tr>
<td>volatile int32_t flags</td>
<td>0xc3000002</td>
</tr>
<tr>
<td>int32_t reserved</td>
<td>0x0</td>
</tr>
<tr>
<td>void (*invoke)(void *, …)</td>
<td>0x0000000104bcce80</td>
</tr>
<tr>
<td>struct Block_descriptor_1 *descriptor</td>
<td>0x000000010519e290</td>
</tr>
<tr>
<td>捕获变量 _commonObject</td>
<td>0x0000000281eaac10</td>
</tr>
<tr>
<td>Block_byref * _byrefObject</td>
<td>0x0000000281225170</td>
</tr>
</tbody></table>
<p>验证一下：</p>
<p><img src="https://i.loli.net/2020/05/11/R6xtyLwKA8bg4hc.jpg" alt="isa 验证"></p>
<p>isa 指针指向 __NSMallocBlock__，没问题</p>
<p>flags 用二进制表示为 0b11000011000000000000000000000010，即位域  BLOCK_HAS_SIGNATURE，BLOCK_HAS_EXTENDED_LAYOUT，BLOCK_HAS_COPY_DISPOSE，BLOCK_NEEDS_FREE 为 1 引用计数 BLOCK_REFCOUNT_MASK 为 1</p>
<p><img src="https://i.loli.net/2020/05/11/l3FxiDYJELdte5C.jpg" alt="invoke 验证"><br>可以通过上面的方法打印出函数指针的内容</p>
<p>成员变量 _commonObject 的值于 commonObject 相同，均为 0x0000000281eaac10，说明是浅拷贝</p>
<p>下面来验证 descriptor<br>0x000000010519e290 为 Block_descriptor_1 结构体的首地址</p>
<p><img src="https://i.loli.net/2020/05/11/6TiVct12vSRUbQI.jpg" alt="descriptor 内存分布"></p>
<table>
<thead>
<tr>
<th>Block_descriptor 成员变量</th>
<th>值</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>uintptr_t reserved</td>
<td>0x0</td>
<td>预留字段</td>
</tr>
<tr>
<td>uintptr_t size</td>
<td>0x0000000000000030</td>
<td>十进制为 48，即 block 结构体的字节长度</td>
</tr>
<tr>
<td>void (*copy)(void *dst, const void *src)</td>
<td>0x0000000104bccee8</td>
<td>copy 函数指针</td>
</tr>
<tr>
<td>void (*dispose)(const void *)</td>
<td>0x0000000104bccf54</td>
<td>dispose 函数指针</td>
</tr>
<tr>
<td>const char *signature</td>
<td>0x000000010511847f</td>
<td>函数类型编码</td>
</tr>
<tr>
<td>const char *layout</td>
<td>0x0000000000000110</td>
<td>不知道干嘛的</td>
</tr>
</tbody></table>
<p>打印下 block 函数的类型编码</p>
<p><img src="https://i.loli.net/2020/05/11/cHWtqd6iOk8GzT7.jpg" alt="函数类型编码"></p>
<p>成员变量 const char *layout 应该是在 GC 下使用的，具体作用不明白</p>
<hr>
<p>接下来验证 Block_byref 的结构</p>
<p><img src="https://i.loli.net/2020/05/11/kRQwxf5btaYE97F.jpg" alt="Block_byref 内存分布"></p>
<table>
<thead>
<tr>
<th>Block_byref 成员变量</th>
<th>值</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>void *isa</td>
<td>0x0</td>
<td>isa</td>
</tr>
<tr>
<td>struct Block_byref *forwarding</td>
<td>0x0000000281225170</td>
<td>十进制为 48，即 block 结构体的字节长度</td>
</tr>
<tr>
<td>volatile int32_t flags</td>
<td>0x33000004</td>
<td>标记，二级制表示为 0b00110011000000000000000000000100</td>
</tr>
<tr>
<td>uint32_t size</td>
<td>0x00000030</td>
<td>Block_byref 结构体长度</td>
</tr>
<tr>
<td>byref_keep</td>
<td>0x000000010511847f</td>
<td>__block copy 函数指针</td>
</tr>
<tr>
<td>byref_destroy</td>
<td>0x0000000000000110</td>
<td>__block dispose 函数指针</td>
</tr>
<tr>
<td>const char *layout</td>
<td>0x0000000281eaac50</td>
<td>持有的变量  byrefObject</td>
</tr>
</tbody></table>
<p>flags 表示引用计数为 2，因为初始化有一个，然后 block 有一个。位域 BLOCK_BYREF_LAYOUT_STRONG 为 1，表示该变量是 __strong 类型<br>const char *layout 表示其持有的变量</p>
<h3 id="如何将-block-从栈拷贝到堆中"><a href="#如何将-block-从栈拷贝到堆中" class="headerlink" title="如何将 block 从栈拷贝到堆中"></a>如何将 block 从栈拷贝到堆中</h3><p>现在我们来探究一下 block 是如何从栈中拷贝到堆中的吧。<br>除 global block 类型的 block 均在栈中创建，当被强引用，即 retain block 的话，block 就会从栈拷贝到堆中，如果已经在堆中，则增加其引用计数</p>
<p><img src="https://i.loli.net/2020/05/07/FGZfBguw6mJ4an7.jpg" alt="断点调试"></p>
<p>step into</p>
<p><img src="https://i.loli.net/2020/05/07/OSwbczJdivUKRm8.jpg"></p>
<p>_Block_copy 的函数实现在 <a target="_blank" rel="noopener" href="https://opensource.apple.com/source/clang/clang-800.0.42.1/src/projects/compiler-rt/lib/BlocksRuntime/runtime.c.auto.html">clang-800 源码</a> 中可以看到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void *_Block_copy(const void *arg) &#123;</span><br><span class="line">    return _Block_copy_internal(arg, WANTS_ONE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/05/07/Eb4mvWz5djZIq1c.jpg" alt="_Block_copy_internal 实现"></p>
<p>我们主要看红色框框里面的代码：</p>
<ul>
<li>首先通过 <code>malloc()</code> 在堆中新建一个 block 结构体实例，接着使用<code>memmove()</code>将旧实例的数据拷贝过去</li>
<li>重置新实例成员变量 flags 的 BLOCK_REFCOUNT_MASK(引用计数)部分</li>
<li>将新实例成员变量 flags 的位域 BLOCK_NEEDS_FREE 设置为 1, 表示该 block 在堆中</li>
<li>将新实例的 isa 指向 _NSConcreteMallocBlock</li>
<li>如果存在 Block copy 函数，则调用</li>
</ul>
<p>上一节中已经提到过，这里再贴一下它的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static void __TestObject__foo_block_copy_1(struct __TestObject__foo_block_impl_1*dst, struct __TestObject__foo_block_impl_1*src) </span><br><span class="line">&#123;</span><br><span class="line">_Block_object_assign((void*)&amp;dst-&gt;commonObject, (void*)src-&gt;commonObject, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br><span class="line">_Block_object_assign((void*)&amp;dst-&gt;byrefWeakObject, (void*)src-&gt;byrefWeakObject, 8/*BLOCK_FIELD_IS_BYREF*/);</span><br><span class="line">_Block_object_assign((void*)&amp;dst-&gt;weakObject, (void*)src-&gt;weakObject, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br><span class="line">_Block_object_assign((void*)&amp;dst-&gt;byrefObject, (void*)src-&gt;byrefObject, 8/*BLOCK_FIELD_IS_BYREF*/);</span><br><span class="line">_Block_object_assign((void*)&amp;dst-&gt;blockObject, (void*)src-&gt;blockObject, 7/*BLOCK_FIELD_IS_BLOCK*/);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，如果外部变量是 C++类型，则不会调用 <code>_Block_object_assign()</code>函数，而是其对应的 const 拷贝构造方法。注释如下：<br>In these cases helper functions are synthesized by the compiler for use in Block_copy and Block_release, called the copy and dispose helpers.  The copy helper emits a call to the C++ const copy constructor for C++ stack based objects and for the rest calls into the runtime support function _Block_object_assign.  The dispose helper has a call to the C++ destructor for case 1 and a call into _Block_object_dispose for the rest.</p>
</blockquote>
<p><code>_Block_object_assign</code>函数的实现如下:</p>
<p><img src="https://i.loli.net/2020/05/11/AM2sgQxLlbGeVF9.jpg" alt="_Block_object_assign 函数实现"></p>
<p>参数 flags 有以下几种情况:</p>
<p>由 Block copy 函数调用：</p>
<ul>
<li><pre><code>id                   3       
</code></pre>
<ul>
<li><pre><code>(^Block)             7
</code></pre>
</li>
</ul>
</li>
<li>__block              8     <ul>
<li><pre><code>__weak __block       8+16
</code></pre>
</li>
</ul>
</li>
</ul>
<p>flags 有 4 种可能: 3， 7， 8， (8+16)</p>
<p>由 __block copy 函数调用：</p>
<p>BLOCK_BYREF_CALLER (128)：表示由 __block copy 调用<br>此时, 传入的 flags 有 4 种可能: </p>
<ul>
<li><pre><code>__block id                   128+3       
</code></pre>
<ul>
<li><pre><code>__block (^Block)             128+7
</code></pre>
</li>
</ul>
</li>
<li>__weak __block id           128+3+16     <ul>
<li><pre><code>__weak __block (^Block)      128+7+16
</code></pre>
</li>
</ul>
</li>
</ul>
<p>总共有以上 8 种情况</p>
<blockquote>
<p>需要注意的是，Block copy 调用该函数，第一个参数是指针的地址(void **)，第二个参数传入的是指针的值(void *)<br>而 __block copy 调用该函数，传入的前两个参数均为指针的值(void *)</p>
</blockquote>
<p>下面根据 case 条件分几步来讲解这个函数：</p>
<ul>
<li>代码块 1:</li>
</ul>
<p>Block copy 函数调用，且该变量是 id 类型的</p>
<p>代码<code>_Block_retain_object()</code>最终会调用下面这个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void _Block_retain_object_default(const void *ptr) &#123;</span><br><span class="line">	(void)ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码<code>_Block_assign()</code>最终会调用下面这个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void _Block_assign_default(void *value, void **destptr) &#123;</span><br><span class="line">    *destptr = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不知道调用 _Block_retain_object 函数的目的是什么<br>这一分支仅做了浅拷贝，拷贝指针内容</p>
<ul>
<li>代码块 2:</li>
</ul>
<p>Block copy 函数调用，且该变量也是一个 block</p>
<p>这里首先调用了 <code>_Block_copy_internal()</code> 函数, 先将 block 类型的变量拷贝到堆中<br>然后调用 <code>_Block_assign</code> 将其堆中的地址赋值给 Block 对应的成员变量</p>
<ul>
<li>代码块 3:</li>
</ul>
<p>Block copy 函数调用，且变量被 __block 修饰</p>
<p><img src="https://i.loli.net/2020/05/09/ITPjVSUlEfMoAmZ.jpg" alt="_Block_byref_assign_copy 实现"></p>
<p>这里传入的第一个参数 void *dest 表示的是指针的地址</p>
<p>_Block_byref_assign_copy 实现中代码块 1 的逻辑如下</p>
<ul>
<li>声明一个布尔值 isWeak， 用来表示该变量是否还被 __weak 修饰</li>
<li>_Block_allocator 函数最终调用 <code>malloc()</code> 函数, 在堆上拷贝一份同样内存大小的 Block_byrefs 实例</li>
<li>将旧实例的成员变量 flags 拷贝到新实例中, 并将新实例的引用计数设置为 2。 1 份是因为栈上有一个实例, 1 份是因为堆上也有一个， 1+1 就等于 2 了</li>
<li>将旧实例和新实例的成员变量 forwarding 均赋值为新实例</li>
<li>如果 isWeak 为 true, 则将 Block_byrefs 实例的 isa 指针指向 _NSConcreteWeakBlockVariable</li>
<li>如果实例有 <code>__block copy/dispose helpers</code>(还是调用 _Block_object_assign 函数), 则调用它对实例持有的变量进行拷贝到堆操作; 如果没有的话则将旧实例中 size 后面的成员变量拷贝到新实例的 bit 中</li>
</ul>
<p>函数里面有一行看起来比较让人困扰的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct Block_byref_2 *src2 = (struct Block_byref_2 *)(src+1);</span><br></pre></td></tr></table></figure>

<p>在前面的声明中，src 被声明成了 <code>Block_byref *</code> 类型，所以 <code>src + 1</code> 的意思是从 src 的首地址偏移 sizeof(Block_byref) 个字节，即 Block_byref_2 的首地址<br>结构体拷贝完成后，随后将 Block_byref 持有的变量通过函数 *src2-&gt;byref_keep 也拷贝到堆中<br>_Block_byref_assign_copy 实现中代码块 2 的作用是如果 Block_byref 持有的变量已经拷贝到堆中了, 则增加其引用计数</p>
<ul>
<li>代码块 4:</li>
</ul>
<p>__block copy 函数调用，且持有的变量不被 __weak 修饰</p>
<p>最终会调用下面那个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void _Block_assign_default(void *value, void **destptr) &#123;</span><br><span class="line">    *destptr = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浅拷贝</p>
<ul>
<li>代码块 5:</li>
</ul>
<p>__block copy 函数调用，且持有的变量被 __weak 修饰</p>
<p>最终会调用下面那个函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void _Block_assign_weak_default(const void *ptr, void *dest) &#123;</span><br><span class="line">    *(void **)dest = (void *)ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里讲一下我的理解：<br>void * 是一个指针，里面保存了一个地址，但是我们不能 *(void *) 这样使用它，因为我们不知道它指向的结构是什么类型的。如果要使用的话就需要将其转换成其它类型，例如 int *，所以在这里可以仅仅把它看成是变量，保存了一个地址。<br>而 void **，其表示指向指针的指针，不同于 void *，我们可以 *(void **) 这样使用它，因为我们知道 void ** 指向的内容是一个指针。</p>
<p>在 _Block_assign_weak_default 函数中，我们先将 dest 强转成 void ** 类型，然后就可以对其进行赋值操作啦</p>
<hr>
<p>至此，整个拷贝流程已经讲的差不多了，这里总结一下：</p>
<ul>
<li>一个 block 可能捕获多个外部变量</li>
<li>block 在栈中生成，retain 后，将栈中的内容拷贝到堆中</li>
<li>block 会调用 <code>Block copy</code> 函数，对其捕获的变量也进行拷贝操作<ul>
<li>如果是 C++ 类型，则调用其 const 拷贝构造函数到堆中</li>
<li>如果是 block 类型，则将其拷贝到堆中</li>
<li>如果是 id 类型，因为已经在堆中了，所以进行浅拷贝，仅复制指针值</li>
<li>如果是 __block 修饰的变量，则将其对应的 Block_byref 结构体拷贝到堆中，随后调用 __block copy 函数将其持有的变量也拷贝到堆中</li>
</ul>
</li>
</ul>
<h3 id="如何销毁-block"><a href="#如何销毁-block" class="headerlink" title="如何销毁 block"></a>如何销毁 block</h3><p>这一节我们将探究如何销毁 block</p>
<p>创建一个 malloc block 类型的 block，foo() 结束，block 会被回收。<br>在函数尾巴那里打个断点</p>
<p><img src="https://i.loli.net/2020/05/08/M6XYjobniRguPvk.jpg"></p>
<p>step into</p>
<p><img src="https://i.loli.net/2020/05/08/xjGZJzP2thL7QeR.jpg"></p>
<p>将断点停留在<code>objc_release()</code>函数<br>runtime 通过该函数对 block 进行 release 操作，如果其引用计数变成 0，则销毁</p>
<p>继续 step into</p>
<p><img src="https://i.loli.net/2020/05/08/AqLZp1hWwoRHuDe.jpg"></p>
<p>block 是特殊的类，自己重写了<code>release()</code>函数，所以代码 <code>ISA()-&gt;hasCustomRR()</code> 返回的结果是 true，将执行自己重写的 release() 函数<br>继续 step into</p>
<p><img src="https://i.loli.net/2020/05/08/x2ISisTvBQwLh8k.jpg"></p>
<p>因为没有 block 的 <code>release()</code>源码，通过调用栈发现随后调用了 <code>_Block_release()</code> 函数<br>在<a target="_blank" rel="noopener" href="https://github.com/LGCooci/objc_debug/tree/master">可编译的源码</a>中可以找到该函数的实现(直接在文件夹中搜索)</p>
<p><img src="https://i.loli.net/2020/05/09/85ENFYT9nlZcRiM.jpg" alt="_Block_release 实现"></p>
<p>根据 if 的判断将函数分为三个部分</p>
<ul>
<li>判断条件 1：如果是全局 block 或者其引用计数已经为 0(表示已经在销毁了)， 则返回</li>
<li>判断条件 2：如果使用 GC 管理内存，则执行什么什么操作。因为 iOS 平台不使用 GC，所以略过</li>
<li>判断条件 3：如果 block 已经在堆上了，则将其引用计数减 1，如果减为 0，则调用下面三个函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_Block_call_dispose_helper(aBlock);</span><br><span class="line">_Block_destructInstance(aBlock);</span><br><span class="line">_Block_deallocator(aBlock);</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个函数 <code>_Block_call_dispose_helper</code></li>
</ul>
<p>在同个文件中搜索该函数，其实现如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void _Block_call_dispose_helper(struct Block_layout *aBlock)</span><br><span class="line">&#123;</span><br><span class="line">    struct Block_descriptor_2 *desc = _Block_descriptor_2(aBlock);</span><br><span class="line">    if (!desc) return;</span><br><span class="line"></span><br><span class="line">    (*desc-&gt;dispose)(aBlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果存在 Block dispose 函数，则调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void __TestObject__foo_block_dispose_1(struct __TestObject__foo_block_impl_1*src) </span><br><span class="line">&#123;</span><br><span class="line">_Block_object_dispose((void*)src-&gt;byrefInt, 8/*BLOCK_FIELD_IS_BYREF*/);</span><br><span class="line">_Block_object_dispose((void*)src-&gt;commonObject, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br><span class="line">_Block_object_dispose((void*)src-&gt;byrefWeakObject, 8/*BLOCK_FIELD_IS_BYREF*/);</span><br><span class="line">_Block_object_dispose((void*)src-&gt;weakObject, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br><span class="line">_Block_object_dispose((void*)src-&gt;byrefObject, 8/*BLOCK_FIELD_IS_BYREF*/);</span><br><span class="line">_Block_object_dispose((void*)src-&gt;blockObject, 7/*BLOCK_FIELD_IS_BLOCK*/);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/05/09/mLH7QEBp2TWxbXP.jpg" alt="_Block_object_dispose 实现"></p>
<p>通过判断条件将 _Block_object_dispose 分为几部分</p>
<ul>
<li>判断条件 1：变量由 __block 修饰</li>
</ul>
<p><img src="https://i.loli.net/2020/05/09/AKTYlozkaOIVFQr.jpg" alt="_Block_byref_release 实现"></p>
<p>代码<code>byref = byref-&gt;forwarding;</code>，因为可能会有 byref 在栈中，而 forwarding 此时却在堆中的情况。随后判断 byref 是否在栈中，如果是的话则立即返回。<br>对 Block_byref 的引用计数减 1 随后判断是否为 0，如果是的话则调用其 byref_destroy 函数(也就是 _Block_object_dispose)，销毁其持有的变量<br>最后将 Block_byref 结构体的内存释放掉</p>
<ul>
<li>判断条件 2：变量是 Block 类型</li>
</ul>
<p><img src="https://i.loli.net/2020/05/09/7XBcIrVYCbO2GRp.jpg" alt="_Block_destroy 实现"></p>
<p>调用 _Block_release 来销毁该 block</p>
<ul>
<li>判断条件 3：变量是 id 类型</li>
</ul>
<p>_Block_release_object 最终调用的函数如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void _Block_release_object_default(const void *ptr) &#123;</span><br><span class="line">	(void)ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等于什么都没做，这是因为 id 类型的对象由 ARC 管理其内存。即不再被强指针引用时引用计数减 1 </p>
<ul>
<li>判断条件 4</li>
</ul>
<p>什么都没做，如果走到走一步说明可能系统有异常</p>
<hr>
<p>接着讲 block 销毁时调用的第二个函数 <code>_Block_destructInstance</code>。<br>调试时，调用栈里也有这个函数</p>
<p><img src="https://i.loli.net/2020/05/09/C1snHLtSfzj2BOY.jpg">  </p>
<p>接着 step into</p>
<p><img src="https://i.loli.net/2020/05/09/deEVtqBWhPQMDwZ.jpg"></p>
<p>使用该函数，主要是为了将在弱引用表中注册的使用 __weak 引用 block 的变量置为 nil，因为 block 已经要被销毁了<br>这里不仔细讲了</p>
<hr>
<p>最后调用 <code>_Block_deallocator()</code> 函数，将 block 结构体的内存销毁</p>
<hr>
<p>这里总结一下 block 的内存销毁流程：</p>
<ul>
<li>先将 block 捕获的外部变量进行销毁</li>
<li>将弱引用 block 的指针置为 nil</li>
<li>将 block 结构体的内存销毁</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-04-23T07:59:59.000Z" title="4/23/2020, 3:59:59 PM">2020-04-23</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">12 分钟读完 (大约1862个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/23/%E6%8E%A2%E7%A9%B6runtime%E7%A2%B0%E5%88%B0%E7%9A%84%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/">探究runtime碰到的类和结构体</a></h1><div class="content"><p>在研究 runtime 时能遇到许多的类和结构体, 因为不可能每篇文章碰到就介绍一遍, 所以在这里统一把这些碰到的类和结构体介绍一下</p>
<h3 id="SideTable"><a href="#SideTable" class="headerlink" title="SideTable"></a>SideTable</h3><p>这个类的作用是存放引用计数表和弱引用表, 并使用自旋锁来防止操作表结构时可能的竞态条件<br>定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct SideTable &#123;</span><br><span class="line">    spinlock_t slock;</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    weak_table_t weak_table;</span><br><span class="line"></span><br><span class="line">    SideTable() &#123;</span><br><span class="line">        memset(&amp;weak_table, 0, sizeof(weak_table));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~SideTable() &#123;</span><br><span class="line">        _objc_fatal(&quot;Do not delete SideTable.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void lock() &#123; slock.lock(); &#125;</span><br><span class="line">    void unlock() &#123; slock.unlock(); &#125;</span><br><span class="line">    void forceReset() &#123; slock.forceReset(); &#125;</span><br><span class="line"></span><br><span class="line">    // Address-ordered lock discipline for a pair of side tables.</span><br><span class="line"></span><br><span class="line">    template&lt;HaveOld, HaveNew&gt;</span><br><span class="line">    static void lockTwo(SideTable *lock1, SideTable *lock2);</span><br><span class="line">    template&lt;HaveOld, HaveNew&gt;</span><br><span class="line">    static void unlockTwo(SideTable *lock1, SideTable *lock2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有下面几个成员变量</p>
<ul>
<li><p>spinlock_t slock: 自旋锁</p>
</li>
<li><p>RefcountMap refcnts: 额外引用计数存储表</p>
</li>
<li><p>weak_table_t weak_table: 弱引用表, 用来存储弱引用者(weak 修饰的变量)</p>
<p>  其中<code>RefcountMap</code>是类型<code>objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,RefcountMapValuePurgeable&gt;</code>的别名</p>
</li>
</ul>
<h3 id="DisguisedPtr"><a href="#DisguisedPtr" class="headerlink" title="DisguisedPtr"></a>DisguisedPtr</h3><p>定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class DisguisedPtr &#123;</span><br><span class="line">    uintptr_t value;</span><br><span class="line"></span><br><span class="line">    static uintptr_t disguise(T* ptr) &#123;</span><br><span class="line">        return -(uintptr_t)ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static T* undisguise(uintptr_t val) &#123;</span><br><span class="line">        return (T*)-val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    DisguisedPtr() &#123; &#125;</span><br><span class="line">    DisguisedPtr(T* ptr) </span><br><span class="line">        : value(disguise(ptr)) &#123; &#125;</span><br><span class="line">    DisguisedPtr(const DisguisedPtr&lt;T&gt;&amp; ptr) </span><br><span class="line">        : value(ptr.value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    DisguisedPtr&lt;T&gt;&amp; operator = (T* rhs) &#123;</span><br><span class="line">        value = disguise(rhs);</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    DisguisedPtr&lt;T&gt;&amp; operator = (const DisguisedPtr&lt;T&gt;&amp; rhs) &#123;</span><br><span class="line">        value = rhs.value;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    operator T* () const &#123;</span><br><span class="line">        return undisguise(value);</span><br><span class="line">    &#125;</span><br><span class="line">    T* operator -&gt; () const &#123; </span><br><span class="line">        return undisguise(value);</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; operator * () const &#123; </span><br><span class="line">        return *undisguise(value);</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; operator [] (size_t i) const &#123;</span><br><span class="line">        return undisguise(value)[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // pointer arithmetic operators omitted </span><br><span class="line">    // because we don&#x27;t currently use them anywhere</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个类的作用是伪装指针, 避免引用计数表和弱引用表里面保存的指针被内存泄漏工具<code>leaks</code>当做是内存泄漏.</p>
<ul>
<li>它的成员变量<code>value</code>存储的是经过函数<code>disguise()</code>处理后的指针.</li>
<li>你可以像操作指针一样操作<code>DisguisedPtr</code>实例. 为了实现这个功能, <code>DisguisedPtr</code>重载了许多的操作符, 例如<code>-&gt;</code>, <code>*</code>, <code>=</code>, <code>==</code>, <code>[]</code>. 不了解的同学可以自己查资料, 关键字 <code>运算符重载operator</code></li>
</ul>
<p><code>DisguisedPtr</code>一般用来充当 Key, 保存在结构体中</p>
<h3 id="RefcountMapValuePurgeable"><a href="#RefcountMapValuePurgeable" class="headerlink" title="RefcountMapValuePurgeable"></a>RefcountMapValuePurgeable</h3><p>定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct RefcountMapValuePurgeable &#123;</span><br><span class="line">    static inline bool isPurgeable(size_t x) &#123;</span><br><span class="line">        return x == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>只有一个内联函数<code>RefcountMapValuePurgeable</code>, 用来判断这个值需要是否析构释放内存</p>
<h3 id="DenseMapInfo"><a href="#DenseMapInfo" class="headerlink" title="DenseMapInfo"></a>DenseMapInfo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct DenseMapInfo&lt;DisguisedPtr&lt;T&gt;&gt; &#123;</span><br><span class="line">  static inline DisguisedPtr&lt;T&gt; getEmptyKey() &#123;</span><br><span class="line">    return DisguisedPtr&lt;T&gt;((T*)(uintptr_t)-1);</span><br><span class="line">  &#125;</span><br><span class="line">  static inline DisguisedPtr&lt;T&gt; getTombstoneKey() &#123;</span><br><span class="line">    return DisguisedPtr&lt;T&gt;((T*)(uintptr_t)-2);</span><br><span class="line">  &#125;</span><br><span class="line">  static unsigned getHashValue(const T *PtrVal) &#123;</span><br><span class="line">      return ptr_hash((uintptr_t)PtrVal);</span><br><span class="line">  &#125;</span><br><span class="line">  static bool isEqual(const DisguisedPtr&lt;T&gt; &amp;LHS, const DisguisedPtr&lt;T&gt; &amp;RHS) &#123;</span><br><span class="line">      return LHS == RHS; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它有两个内联函数:</p>
<ul>
<li>getEmptyKey(): 生成 empty 的标记</li>
<li>getTombstoneKey(): 生成墓碑标记(即代表之前被人使用过但现在已经没人用了)</li>
</ul>
<p>有两个静态函数:</p>
<ul>
<li>getHashValue(): 根据指针返回一个哈希值</li>
<li>isEqual(): 判断两个参数是否相等</li>
</ul>
<p><code>DenseMapInfo</code>常常跟<code>DisguisedPtr</code>一起使用. 它的两个内联函数用来标记存储数据的<code>DenseMapPair</code>实例 bucket 的状态是否是 empty 或者 tombstoneKey. 它的<code>getHashValue</code>函数用来生成一个哈希值来确定 bucket 的序号</p>
<h3 id="detail-DenseMapPair"><a href="#detail-DenseMapPair" class="headerlink" title="detail::DenseMapPair"></a>detail::DenseMapPair</h3><p>部分定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename KeyT, typename ValueT&gt;</span><br><span class="line">struct DenseMapPair : public std::pair&lt;KeyT, ValueT&gt; &#123;</span><br><span class="line"></span><br><span class="line">  // FIXME: Switch to inheriting constructors when we drop support for older</span><br><span class="line">  //        clang versions.</span><br><span class="line">  // NOTE: This default constructor is declared with &#x27;&#123;&#125;&#x27; rather than</span><br><span class="line">  //       &#x27;= default&#x27; to work around a separate bug in clang-3.8. This can</span><br><span class="line">  //       also go when we switch to inheriting constructors.</span><br><span class="line">  DenseMapPair() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的父类<code>std::pair</code>是一个结构体模板, 它将两个数据组合成一个数据, 类似于我们经常用的字典.<br><code>DenseMapPair</code>被用来在引用计数表中保存引用计数. 其中 key 的类型为DisguisedPtr<objc_object></p>
<h3 id="DenseMap"><a href="#DenseMap" class="headerlink" title="DenseMap"></a>DenseMap</h3><p>部分定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename KeyT, typename ValueT,</span><br><span class="line">          typename ValueInfoT = DenseMapValueInfo&lt;ValueT&gt;,</span><br><span class="line">          typename KeyInfoT = DenseMapInfo&lt;KeyT&gt;,</span><br><span class="line">          typename BucketT = detail::DenseMapPair&lt;KeyT, ValueT&gt;&gt;</span><br><span class="line">class DenseMap : public DenseMapBase&lt;DenseMap&lt;KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;,</span><br><span class="line">                                     KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt; &#123;</span><br><span class="line">  friend class DenseMapBase&lt;DenseMap, KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;;</span><br><span class="line"></span><br><span class="line">  // Lift some types from the dependent base class into this class for</span><br><span class="line">  // simplicity of referring to them.</span><br><span class="line">  using BaseT = DenseMapBase&lt;DenseMap, KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;;</span><br><span class="line"></span><br><span class="line">  BucketT *Buckets;</span><br><span class="line">  unsigned NumEntries;</span><br><span class="line">  unsigned NumTombstones;</span><br><span class="line">  unsigned NumBuckets;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  /// Create a DenseMap wth an optional \p InitialReserve that guarantee that</span><br><span class="line">  /// this number of elements can be inserted in the map without grow()</span><br><span class="line">  explicit DenseMap(unsigned InitialReserve = 0) &#123; init(InitialReserve); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类就是之前提到的引用计数表, 它的成员里面有一个存储数组, 用来保存引用计数. 数组的元素类型为 <code>detail::DenseMapPair</code><br>如果一个对象的引用计数曾经溢出保存到表中, 当对象被销毁时, 会将表中对象使用过的存储器 bucket 标记为墓碑状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">friend class DenseMapBase&lt;DenseMap, KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;;</span><br></pre></td></tr></table></figure>
<p>用于声明一个友元类, 这样<code>DenseMapBase</code>就能访问<code>DenseMap</code>里面的私有属性和私有方法了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using BaseT = DenseMapBase&lt;DenseMap, KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;;</span><br></pre></td></tr></table></figure>
<p>为<code>DenseMapBase&lt;DenseMap, KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;</code>添加一个类型别名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explicit DenseMap(unsigned InitialReserve = 0) &#123; init(InitialReserve); &#125;</span><br></pre></td></tr></table></figure>
<p>上面那行代码的作用是显示的声明一个构造方式, 这样这类就不能隐式转换了</p>
<p>成员变量如下:</p>
<ul>
<li>Buckets: 一个 bucket 数组, 用于保存数据. 可扩容</li>
<li>NumEntries: Buckets 数组中已经被使用的数目</li>
<li>NumTombstones: Buckets 数组中 tombstone 的数目</li>
<li>NumBuckets: Buckets 数组的数目</li>
</ul>
<h3 id="weak-table-t"><a href="#weak-table-t" class="headerlink" title="weak_table_t"></a>weak_table_t</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct weak_table_t &#123;</span><br><span class="line">    weak_entry_t *weak_entries;</span><br><span class="line">    size_t    num_entries;</span><br><span class="line">    uintptr_t mask;</span><br><span class="line">    uintptr_t max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个结构体用来存储弱引用条目, 弱引用条目里面保存着对象以及它的弱引用者们.<br>当数组数量超过 1024 且被使用的数量占比小于 1&#x2F;16 时, 数组长度会缩小为原来的 1&#x2F;8</p>
<p>它有 4 个成员变量:</p>
<ul>
<li>weak_entry_t *weak_entries: weak_entry_t 类型的数组. 弱引用条目, 用来保存弱引用者(被 weak 修饰的指针)</li>
<li>size_t num_entries: 已经被使用的条目数量</li>
<li>uintptr_t mask: 条目数组的数量</li>
<li>uintptr_t max_hash_displacement: 用来记录数组中被使用条目的 index 的最大值</li>
</ul>
<h3 id="weak-entry-t"><a href="#weak-entry-t" class="headerlink" title="weak_entry_t"></a>weak_entry_t</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">struct weak_entry_t &#123;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent;</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            weak_referrer_t *referrers;</span><br><span class="line">            uintptr_t        out_of_line_ness : 2;</span><br><span class="line">            uintptr_t        num_refs : PTR_MINUS_2;</span><br><span class="line">            uintptr_t        mask;</span><br><span class="line">            uintptr_t        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        struct &#123;</span><br><span class="line">            // out_of_line_ness field is low bits of inline_referrers[1]</span><br><span class="line">            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    bool out_of_line() &#123;</span><br><span class="line">        return (out_of_line_ness == REFERRERS_OUT_OF_LINE);</span><br><span class="line">    &#125;</span><br><span class="line">    weak_entry_t&amp; operator=(const weak_entry_t&amp; other) &#123;</span><br><span class="line">        memcpy(this, &amp;other, sizeof(other));</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weak_entry_t(objc_object *newReferent, objc_object **newReferrer)</span><br><span class="line">        : referent(newReferent)</span><br><span class="line">    &#123;</span><br><span class="line">        inline_referrers[0] = newReferrer;</span><br><span class="line">        for (int i = 1; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            inline_referrers[i] = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个结构体用来保存引用对象以及它的弱引用者, 属于一对多的关系<br>当弱引用比较少的时候会将弱引用者保存在结构体里面, 当弱引用者数量超过 4 时会保存到外部的数组中</p>
<p>它有两个成员变量, 一个是<code>DisguisedPtr&lt;objc_object&gt; referent;</code>, 另一个是联合体 union.<br>referent 表示引用对象, 当一个弱引用者引用了一个新的对象, 那么我们需要从弱引用条目中(weak_entry_t)移除该弱引用者</p>
<p><code>weak_referrer_t</code> 是 <code>DisguisedPtr&lt;objc_object *&gt;</code> 类型的别名</p>
<p>第二个成员变量 union 里面有两个结构体, 我这里称呼它们为 s1, s2.<br>因为是 union, 所以 s1 里面的 out_of_line_ness 跟 s2 里面的 inline_referrers 的第二个元素的低 2 个 bit 是重合的. 数组 inline_referrers 的元素是 weak_referrer_t 类型. 在 arm64 架构下, 指针 8 字节对齐, 意味着指针低 3 位肯定都是 0, 经过<code>DisguisedPtr</code>的伪装后, 它的低 2 位都是 1, 也就是 s1 的 out_of_line_ness 的值为 0b11.<br>这个特性用来标记是否使用内部数组来保存弱引用者, 当使用外部数组时, 内部数组被清空, 将 out_of_line_ness 赋值为 0b10 来表示使用外部数组</p>
<p>当使用内部数组时</p>
<ul>
<li>s1 的成员变量均没有意义</li>
<li>使用 s2 的 inline_referrers 数组来保存弱引用者.</li>
</ul>
<p>当使用外部数组时</p>
<ul>
<li>s1 的成员变量<code>referrers</code>是指向外部数组的指针; <code>out_of_line_ness</code>为常量 2, 表示使用了外部数组; <code>mask</code>表示外部数组的长度 - 1; <code>num_refs</code>表示外部数组中被使用的数量; <code>max_hash_displacement</code>表示哈希最大偏移量</li>
<li>此时 s2 的成员变量 inline_referrers 被清空</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-04-23T07:16:30.000Z" title="4/23/2020, 3:16:30 PM">2020-04-23</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">24 分钟读完 (大约3634个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/23/iOS-weak%E5%BC%B1%E5%BC%95%E7%94%A8%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/">iOS weak弱引用底层实现</a></h1><div class="content"><p>源码版本：objc4-779.1<br>当然还是推荐使用这个来学习：<a target="_blank" rel="noopener" href="https://github.com/LGCooci/objc_debug/tree/master">可编译的源码</a></p>
<p><code>weak</code>是一个所有权修饰符, 它提供弱引用的功能, 即弱引用者(weak 修饰的变量, 后统称为弱引用者)不能持有引用对象, 当引用对象被释放时, 此弱引用者被置为 nil.<br>此文将探究弱引用在底层是如何实现</p>
<h3 id="弱引用者如何注册到弱引用表"><a href="#弱引用者如何注册到弱引用表" class="headerlink" title="弱引用者如何注册到弱引用表"></a>弱引用者如何注册到弱引用表</h3><p>首先我们研究弱引用者是如何注册到弱引用表中的<br>调试代码如下(代码需要在开头提到的可编译版本里面才能运行, 后面不再解释), 注意里面打了个断点, 运行程序</p>
<p><img src="https://i.loli.net/2020/04/21/9Nwyob2e34ntvIu.jpg"></p>
<p>点击 step into, 会跳转到函数<code>objc_initWeak()</code>中</p>
<p><img src="https://i.loli.net/2020/04/21/4hZcXPHIlN6E8s9.jpg"></p>
<p>这个函数的作用是初始化弱引用者.<br>需要注意的是<code>storeWeak</code>模板里面的两个参数 <code>DontHaveOld</code>, <code>DoHaveNew</code>. 它们分别是<code>HaveOld</code>和<code>HaveNew</code>枚举的变量. 枚举里面变量的含义如下</p>
<ul>
<li><p>DontHaveOld: 表示弱引用者之前没有引用对象, 例如在用<code>__weak id weakPtr = [[NSObject alloc] init];</code>初始化弱引用者</p>
</li>
<li><p>DoHaveOld: 表示弱引用者之前有引用对象. 此时需要将弱引用者从弱引用表中注销</p>
</li>
<li><p>DontHaveNew: 表示弱引用者没有引用一个新的对象</p>
</li>
<li><p>DoHaveNew: 表示弱引用者引用了一个新的对象. 此时需要将弱引用者注册到弱引用表中</p>
</li>
</ul>
<p>继续 step into, 跳转到<code>storeWeak()</code>函数里面</p>
<p><img src="https://i.loli.net/2020/04/22/nRwmhYWQS7ovKVH.jpg"></p>
<p>函数里面代码比较多, 为了方便, 我把它分成了几部分来说明</p>
<p><code>SideTable</code>跟弱引用的实现息息相关, 在<a target="_blank" rel="noopener" href="https://kikido.github.io/2020/04/23/%E6%8E%A2%E7%A9%B6runtime%E7%A2%B0%E5%88%B0%E7%9A%84%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/">这里</a>可以看到对这个类的详细说明.<br>这里我就简单的介绍一下, 它是存放引用计数表和弱引用表的结构. 它有三个成员变量:引用计数表, 弱引用表, 自旋锁. 在我们操作引用计数表或者弱引用表的时候自旋锁会加锁防止竞态条件的出现.</p>
<p>代码块 1 的作用:</p>
<ul>
<li>加锁, 防止在修改哈希表时可能出现的竞态条件. 按锁地址(从低到高)顺序加锁, 防止可能出现的锁的排序问题. </li>
<li>如果弱引用者的引用对象改变了(这是因为如果并发修改弱引用者的引用对象, 在加锁之前, 可能原先的引用对象会改变), 则重复执行<code>retry</code>部分的代码</li>
</ul>
<!--FIXME:class初始化-->
<p>代码块 2 的作:</p>
<ul>
<li>保证引用对象的 isa 指针已经初始化过. 如果未初始化, 则对该对象的非元类 Class 进行初始化.</li>
</ul>
<p>代码块 3 的作:</p>
<ul>
<li>在弱引用表上注销弱引用者, 后面会再来讲这个部分</li>
</ul>
<p>代码块 4 的作用:</p>
<ul>
<li>在弱引用表上注册弱引用者</li>
</ul>
<p>代码块 5 的作用:</p>
<ul>
<li>对象被弱引用者引用了, 则修改对象 isa 指针上位域的信息, 将<code>weakly_referenced</code>置为 YES, 表示该对象被一个弱引用者引用.</li>
</ul>
<blockquote>
<p>需要注意的是, 如果这个对象后续不再被弱引用者引用了, isa 指针上的<code>weakly_referenced</code>值仍旧是 YES</p>
</blockquote>
<p>接着, 我们把断点移动到<code>weak_register_no_lock()</code>函数里面, 同样, 我把它分成几部分来讲解.</p>
<p><img src="https://i.loli.net/2020/04/22/9hwX2HTFZn7dyaM.jpg"></p>
<p><code>referent</code> 表示引用对象, <code>referrer</code> 表示弱引用者</p>
<p>代码块 1 的作用是:</p>
<ul>
<li>保证引用对象是可用的. 如果引用对象正处于被销毁的状态, 那么程序会崩溃</li>
</ul>
<p>代码块 2 的作用是:</p>
<ul>
<li>根据引用对象找到对应的 weak_entry_t 实例(后面统称为为弱条目), 并将该弱引用者保存到弱条目中</li>
</ul>
<p>下面是<code>append_referrer()</code>函数的实现, 写了点注释就不展开讲了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">static void append_referrer(weak_entry_t *entry, objc_object **new_referrer)</span><br><span class="line">&#123;</span><br><span class="line">    if (! entry-&gt;out_of_line()) &#123;</span><br><span class="line">    	 // 使用内部数组来保存弱引用者. 遍历内部数组, 如果有空位则用该空位保存弱引用者并返回</span><br><span class="line">        for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            if (entry-&gt;inline_referrers[i] == nil) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = new_referrer;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		 // 如果执行到这里, 说明内部数组都被使用了. 所以需要扩容, 即创建一个外部数组来保存弱引用者</span><br><span class="line">		 // 先初始化一个跟内部数组长度一样的数组, 并将内部数组的数据转移过去</span><br><span class="line">        weak_referrer_t *new_referrers = (weak_referrer_t *)</span><br><span class="line">            calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t));</span><br><span class="line">        // This constructed table is invalid, but grow_refs_and_insert</span><br><span class="line">        // will fix it and rehash it.</span><br><span class="line">        for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            new_referrers[i] = entry-&gt;inline_referrers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        entry-&gt;referrers = new_referrers;</span><br><span class="line">        entry-&gt;num_refs = WEAK_INLINE_COUNT;</span><br><span class="line">        entry-&gt;out_of_line_ness = REFERRERS_OUT_OF_LINE;</span><br><span class="line">        entry-&gt;mask = WEAK_INLINE_COUNT-1;</span><br><span class="line">        entry-&gt;max_hash_displacement = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ASSERT(entry-&gt;out_of_line());</span><br><span class="line">    // 如果外部数组中有 3/4 的元素都被使用了, 则进行扩容</span><br><span class="line">    if (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * 3/4) &#123;</span><br><span class="line">        // 扩容的长度为原来的 2 倍, 最小值为 8.</span><br><span class="line">        return grow_refs_and_insert(entry, new_referrer);</span><br><span class="line">    &#125;</span><br><span class="line">    // 根据指针的哈希值来计算位置 index</span><br><span class="line">    size_t begin = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    size_t index = begin;</span><br><span class="line">    size_t hash_displacement = 0;</span><br><span class="line">    while (entry-&gt;referrers[index] != nil) &#123;</span><br><span class="line">        // 发生了哈希碰撞, 则增加下标, 查看下一个位置是否为空</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        index = (index+1) &amp; entry-&gt;mask;</span><br><span class="line">        if (index == begin) bad_weak_table(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    // 重新计算 entry 的最大哈希偏移量</span><br><span class="line">    if (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">        entry-&gt;max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将新的弱引用者保存到弱引用条目中</span><br><span class="line">    weak_referrer_t &amp;ref = entry-&gt;referrers[index];</span><br><span class="line">    ref = new_referrer;</span><br><span class="line">    // num_refs + 1</span><br><span class="line">    entry-&gt;num_refs++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码块 3 的作用:</p>
<p>生成一个新的弱引用条目, 将弱引用者保存到弱条目中. 随后将弱条目插入到弱引用表中</p>
<ul>
<li>第一行代码的作用是初始化一个<code>weak_entry_t</code>的实例 new_entry</li>
<li>第二行代码里面函数的作用是, 如果弱引用表的成员变量<code>weak_entries</code>数组里面有 3&#x2F;4 的数量的弱条目被使用了, 则进行扩容. 长度为原来的 2 倍, 最小为 64</li>
<li>第三行代码的作用是将新生成的弱条目插入到弱引用表中</li>
</ul>
<p>至此, 我们已经大致了解了弱引用者是如何注册到弱引用条目的, 这里小总结一下:</p>
<ul>
<li>首先判断引用对象是否处于销毁状态, 否则是的话程序会崩溃</li>
<li>根据引用对象获取到对应的<code>SideTable</code>, 它里面有成员变量弱引用表<code>weak_table_t</code></li>
<li>在弱引用表中根据<code>引用对象</code>来查找对应的弱引用条目, 如果存在则将该弱引用者保存在该条目中. 如果不存在则新生成一个条目, 将弱引用者保存到该条目, 随后将条目插入到弱引用表中</li>
<li>在弱引用表中插入弱条目根据引用对象的哈希值来计算 index, 在弱条目中插入弱引用者根据弱引用者的哈希值来计算 index</li>
<li>在此过程中, 不对任何的弱引用者进行赋值, 即不对 <code>*referrer</code> 进行赋值操作</li>
</ul>
<h3 id="弱引用者如何从弱引用表中注销"><a href="#弱引用者如何从弱引用表中注销" class="headerlink" title="弱引用者如何从弱引用表中注销"></a>弱引用者如何从弱引用表中注销</h3><p>这部分用来探究弱引用者如何从弱引用表中注销<br>实验代码如下</p>
<p><img src="https://i.loli.net/2020/04/23/sw4mBRglLEvuq3f.jpg"></p>
<p>点击<code>step into</code>跳转到<code>objc_storeWeak()</code>函数里面</p>
<p><img src="https://i.loli.net/2020/04/23/1GrBHcT2ZiDCIdu.jpg"></p>
<p>首先弱引用者 w1 引用了对象 o1,  w1 会被注册到 o1 对应的弱引用条目中. 随后我们给它设置了一个新的引用对象 o2, 那么, w1 会先从 o1 的条目中注销, 然后注册到 o2 的条目中.</p>
<p>继续调试, 将断点移动到<code>storeWeak()</code>函数里面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">template &lt;HaveOld haveOld, HaveNew haveNew,</span><br><span class="line">          CrashIfDeallocating crashIfDeallocating&gt;</span><br><span class="line">static id </span><br><span class="line">storeWeak(id *location, objc_object *newObj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(haveOld  ||  haveNew);</span><br><span class="line">    if (!haveNew) ASSERT(newObj == nil);</span><br><span class="line"></span><br><span class="line">    Class previouslyInitializedClass = nil;</span><br><span class="line">    id oldObj;</span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line"></span><br><span class="line">    // Acquire locks for old and new values.</span><br><span class="line">    // Order by lock address to prevent lock ordering problems. </span><br><span class="line">    // Retry if the old value changes underneath us.</span><br><span class="line"> retry:</span><br><span class="line">    if (haveOld) &#123;</span><br><span class="line">        oldObj = *location;</span><br><span class="line">        oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        oldTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if (haveNew) &#123;</span><br><span class="line">        newTable = &amp;SideTables()[newObj];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        newTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    if (haveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">        SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">        goto retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Prevent a deadlock between the weak reference machinery</span><br><span class="line">    // and the +initialize machinery by ensuring that no </span><br><span class="line">    // weakly-referenced object has an un-+initialized isa.</span><br><span class="line">    if (haveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        Class cls = newObj-&gt;getIsa();</span><br><span class="line">        if (cls != previouslyInitializedClass  &amp;&amp;  </span><br><span class="line">            !((objc_class *)cls)-&gt;isInitialized()) </span><br><span class="line">        &#123;</span><br><span class="line">            SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">            class_initialize(cls, (id)newObj);</span><br><span class="line"></span><br><span class="line">            // If this class is finished with +initialize then we&#x27;re good.</span><br><span class="line">            // If this class is still running +initialize on this thread </span><br><span class="line">            // (i.e. +initialize called storeWeak on an instance of itself)</span><br><span class="line">            // then we may proceed but it will appear initializing and </span><br><span class="line">            // not yet initialized to the check above.</span><br><span class="line">            // Instead set previouslyInitializedClass to recognize it on retry.</span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line"></span><br><span class="line">            goto retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Clean up old value, if any.</span><br><span class="line">    if (haveOld) &#123;</span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Assign new value, if any.</span><br><span class="line">    if (haveNew) &#123;</span><br><span class="line">        newObj = (objc_object *)</span><br><span class="line">            weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br><span class="line">        // weak_register_no_lock returns nil if weak store should be rejected</span><br><span class="line"></span><br><span class="line">        // Set is-weakly-referenced bit in refcount table.</span><br><span class="line">        if (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Do not set *location anywhere else. That would introduce a race.</span><br><span class="line">        *location = (id)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // No new value. The storage is not changed.</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    return (id)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数里面大部分内容已经在上一节中介绍过, 这里就不重复了<br>这里我们要讲解的是<code>weak_unregister_no_lock()</code>函数. 这个函数的作用是将销弱引用者从引用对象对应的弱引用条目中注销. 函数实现如下:</p>
<p><img src="https://i.loli.net/2020/04/23/WjGzV5O27AaMBHo.jpg"></p>
<p><code>referent</code>表示原先的引用对象, <code>referrer</code>表示弱引用者</p>
<p>代码块 1 的作用是根据引用对象查找弱引用条目, 然后存在则将该弱引用者从条目中注销</p>
<p>函数<code>remove_referrer()</code>的实现如下, 写了点注释就不展开讲了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static void remove_referrer(weak_entry_t *entry, objc_object **old_referrer)</span><br><span class="line">&#123;</span><br><span class="line">    if (! entry-&gt;out_of_line()) &#123;</span><br><span class="line">        //使用内部数组保存弱引用者, 此时遍历该数组, 找到对应的弱引用者, 如果找到的话则将其从数组中移除</span><br><span class="line">        for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            if (entry-&gt;inline_referrers[i] == old_referrer) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = nil;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _objc_inform(&quot;Attempted to unregister unknown __weak variable &quot;</span><br><span class="line">                     &quot;at %p. This is probably incorrect use of &quot;</span><br><span class="line">                     &quot;objc_storeWeak() and objc_loadWeak(). &quot;</span><br><span class="line">                     &quot;Break on objc_weak_error to debug.\n&quot;, </span><br><span class="line">                     old_referrer);</span><br><span class="line">        objc_weak_error();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 此时使用外部数组来保存弱引用者</span><br><span class="line">    // 根据弱引用者的哈希值来得到对应元素的 index </span><br><span class="line">    size_t begin = w_hash_pointer(old_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    size_t index = begin;</span><br><span class="line">    size_t hash_displacement = 0;</span><br><span class="line">    while (entry-&gt;referrers[index] != old_referrer) &#123;</span><br><span class="line">        // 如果发生了哈希碰撞, 则偏移+1 往下继续查找该弱引用者.当偏移量超过最大偏移量时程序崩溃</span><br><span class="line">        index = (index+1) &amp; entry-&gt;mask;</span><br><span class="line">        if (index == begin) bad_weak_table(entry);</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        if (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">            _objc_inform(&quot;Attempted to unregister unknown __weak variable &quot;</span><br><span class="line">                         &quot;at %p. This is probably incorrect use of &quot;</span><br><span class="line">                         &quot;objc_storeWeak() and objc_loadWeak(). &quot;</span><br><span class="line">                         &quot;Break on objc_weak_error to debug.\n&quot;, </span><br><span class="line">                         old_referrer);</span><br><span class="line">            objc_weak_error();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 找到对应弱引用则将其从外部数组中移除</span><br><span class="line">    entry-&gt;referrers[index] = nil;</span><br><span class="line">    entry-&gt;num_refs--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码块 2 的作用是判断弱引用条目中注册的弱引用者的数量是否为 0, 如果为 0 则将该弱引用条目从弱引用表中清除.</p>
<p><code>weak_entry_remove()</code>函数的实现如下, 写了点注释就不展开讲了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void weak_entry_remove(weak_table_t *weak_table, weak_entry_t *entry)</span><br><span class="line">&#123;</span><br><span class="line">    // remove entry</span><br><span class="line">    // 如果使用的外部数组, 则将外部数组销毁. 如果使用内部数组, 则会在销毁条目时将内部数组也销毁</span><br><span class="line">    if (entry-&gt;out_of_line()) free(entry-&gt;referrers);</span><br><span class="line">    // 销毁弱引用条目</span><br><span class="line">    bzero(entry, sizeof(*entry));</span><br><span class="line"></span><br><span class="line">    weak_table-&gt;num_entries--;</span><br><span class="line">	 // 当条目数量超过 1024, 并且使用了不到 1/16, 则将条目数量缩小为原来的 1/8</span><br><span class="line">    weak_compact_maybe(weak_table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此, 我们已经大致了解了弱引用者如何从弱引用表中注销的, 我小总结一下:</p>
<ul>
<li>根据旧引用对象获取<code>SideTable</code></li>
<li>根据就引用对象在<code>SideTable</code>的弱引用表中获取对应的弱引用条目</li>
<li>在弱引用条目中查找是否注册了该弱引用者, 如果存在的话则移除</li>
<li>若弱引用者移除后弱引用表中弱引用者的数量为 0, 则将该条目从弱引用表中移除</li>
<li>如条目移除后, 条目的数量超过 1024, 且使用的数量少于 1&#x2F;16, 则将条目的容量缩小为原先的 1&#x2F;8</li>
</ul>
<h3 id="引用对象销毁后弱引用者如何置为-nil"><a href="#引用对象销毁后弱引用者如何置为-nil" class="headerlink" title="引用对象销毁后弱引用者如何置为 nil"></a>引用对象销毁后弱引用者如何置为 nil</h3><p>我们都知道当引用对象被销毁后, 弱引用者会被置为 nil.<br>这部分用来粗略的讲解其实现</p>
<p><img src="https://i.loli.net/2020/04/23/Hve3mRTuJDK8xth.jpg"></p>
<p>添加一个<code>symbolic breakpoint</code>, 在<code>symbol</code>里面输入<code>[NSObject dealloc]</code></p>
<p><img src="https://i.loli.net/2020/04/23/8QNjCHvP9tTeBkM.jpg"></p>
<p>点击 continue program execution, 跳转到<code>dealloc()</code>函数中</p>
<p>对 o1 的引用计数 -1 , o1 的引用计数就变成了 0, 需要销毁. 即调用 NSObject 的 dealloc 方法</p>
<p><img src="https://i.loli.net/2020/04/23/hmsPVcvUInRi3ok.jpg"></p>
<p>随后一直跳转到<code>objc_object::clearDeallocating_slow()</code>函数里面.<br>这个函数的作用是清除该对象在<code>SideTable</code>中存在于引用计数表或者弱引用表中的数据</p>
<p><img src="https://i.loli.net/2020/04/23/bVIg4rULXSHxyu8.jpg"></p>
<p>因为研究的是对弱引用的操作, 所以这边我们只需要关注<code>weak_clear_no_lock()</code>函数.<br>它的实现如下, 写了注释就不展开讲了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">void </span><br><span class="line">weak_clear_no_lock(weak_table_t *weak_table, id referent_id) </span><br><span class="line">&#123;</span><br><span class="line">    // referent 表示引用对象, 即这里要被销毁的对象</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    // 根据引用对象找到对应的弱引用条目</span><br><span class="line">    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class="line">    if (entry == nil) &#123;</span><br><span class="line">        /// XXX shouldn&#x27;t happen, but does with mismatched CF/objc</span><br><span class="line">        //printf(&quot;XXX no entry for clear deallocating %p\n&quot;, referent);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // zero out references</span><br><span class="line">    // 数组指针</span><br><span class="line">    weak_referrer_t *referrers;</span><br><span class="line">    // 数组长度</span><br><span class="line">    size_t count;</span><br><span class="line">    </span><br><span class="line">    if (entry-&gt;out_of_line()) &#123;</span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">        count = TABLE_SIZE(entry);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (size_t i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        if (referrer) &#123;</span><br><span class="line">            // 将弱引用者置为 nil</span><br><span class="line">            if (*referrer == referent) &#123;</span><br><span class="line">                *referrer = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (*referrer) &#123;</span><br><span class="line">                _objc_inform(&quot;__weak variable at %p holds %p instead of %p. &quot;</span><br><span class="line">                             &quot;This is probably incorrect use of &quot;</span><br><span class="line">                             &quot;objc_storeWeak() and objc_loadWeak(). &quot;</span><br><span class="line">                             &quot;Break on objc_weak_error to debug.\n&quot;, </span><br><span class="line">                             referrer, (void*)*referrer, (void*)referent);</span><br><span class="line">                objc_weak_error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将所有弱引用者置为 nil 后, 将该条目从弱引用表中删除</span><br><span class="line">    weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此, 我们已经大致了解了引用对象销毁后弱引用者如何置为 nil 的, 这里小总结一下:</p>
<p>当对象的引用计数为 0 时, 会调用 dealloc 方法用来销毁对象. 如果有弱引用者引用者该对象, 那么会从弱引用表中找到对象的弱引用条目, 将条目中所有注册的弱引用者置为 nil, 随后将该条目从弱引用表中删除.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-04-16T08:21:05.000Z" title="4/16/2020, 4:21:05 PM">2020-04-16</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">1 小时读完 (大约6745个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/16/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-iOS-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/">深入了解 iOS 引用计数</a></h1><div class="content"><p>iOS 通过引用计数来管理内存，简单的说就是当一个 id 类型的对象引用计数变成 0 的时候就会被销毁，回收内存。<br>本文将通过断点调试来探究引用计数的存储及读取在底层的实现。全程无聊，请配合源码阅读</p>
<p>源码版本：objc4-779.1<br>当然还是推荐使用这个来学习：<a target="_blank" rel="noopener" href="https://github.com/LGCooci/objc_debug/tree/master">可编译的源码</a></p>
<h3 id="引用计数存储在哪"><a href="#引用计数存储在哪" class="headerlink" title="引用计数存储在哪"></a>引用计数存储在哪</h3><p>引用计数只适用于 id 类型的对象</p>
<p>有一种特殊的 id 类型对象，Tagged Pointer，如果不知道的话可以看我另一篇博客 <a target="_blank" rel="noopener" href="https://kikido.github.io/2020/04/02/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Tagged-Pointer/">深入了解Tagged Pointer</a>了解一下</p>
<p>因为 Tagged Pointer 并不是真正的对象，所以它并不通过引用计数来管理其内存。<br>用下面的代码求 n1 的引用计数，输出结果为 9223372036854775807</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 Tagged Pointer 对象</span><br><span class="line">NSNumber *n1 = [NSNumber numberWithInt:1];</span><br><span class="line">NSLog(@&quot;n1 rc = %ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(n1)));</span><br></pre></td></tr></table></figure>

<p>我们知道每个 id 类型对象都有一个 isa 指针，其中只有 33 位用来保存其父类或者元类信息，剩余的31位也不能浪费啊，这其中就会一些 bit 用来保存引用计数。<br>下面是 arm64 架构下的 isa 结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"></span><br><span class="line">    struct &#123;</span><br><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="line">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL</span><br><span class="line">#   define ISA_BITFIELD                                                      \</span><br><span class="line">      uintptr_t nonpointer        : 1;                                       \</span><br><span class="line">      uintptr_t has_assoc         : 1;                                       \</span><br><span class="line">      uintptr_t has_cxx_dtor      : 1;                                       \</span><br><span class="line">      uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \</span><br><span class="line">      uintptr_t magic             : 6;                                       \</span><br><span class="line">      uintptr_t weakly_referenced : 1;                                       \</span><br><span class="line">      uintptr_t deallocating      : 1;                                       \</span><br><span class="line">      uintptr_t has_sidetable_rc  : 1;                                       \</span><br><span class="line">      uintptr_t extra_rc          : 19</span><br><span class="line">#   define RC_ONE   (1ULL&lt;&lt;45)</span><br><span class="line">#   define RC_HALF  (1ULL&lt;&lt;18)</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以发现，isa_t 是一个联合体(union)，几个不同类型的变量 clas 和 bits 及 struct 共用同一段内存。当 isa 指针的第一位<code>nonpointer</code>为 1 时表示它是优化的 isa 指针，即将多余的 bit 用来存储其它信息，从它的名字<code>nonpointer</code>也可以看出它不再是一个纯粹的指针了。当为 1 时，第一个成员变量<code>cls</code>是没有用的，因为 isa 不再使用它来指向父类 cls。下面是 isa 指针各位域的含义</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>nonpointer</td>
<td>表示是否对 isa 指针开启优化 0:纯isa指针，1:存储了额外信息</td>
</tr>
<tr>
<td>has_assoc</td>
<td>表示该对象是否包含 associated object，如果没有，则析构时会更快</td>
</tr>
<tr>
<td>has_cxx_dtor</td>
<td>表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快</td>
</tr>
<tr>
<td>shiftcls</td>
<td>类的指针</td>
</tr>
<tr>
<td>magic</td>
<td>固定值 0x1a, 用于调试器判断当前对象是真的对象还是没有初始化的空间</td>
</tr>
<tr>
<td>weakly_referenced</td>
<td>表示该对象是否有过 weak 对象，如果没有，则析构时更快</td>
</tr>
<tr>
<td>deallocating</td>
<td>表示该对象是否正在析构</td>
</tr>
<tr>
<td>has_sidetable_rc</td>
<td>表示该对象的引用计数值是否过大无法存储在 isa 指针</td>
</tr>
<tr>
<td>extra_rc</td>
<td>存储引用计数值减一后的结果</td>
</tr>
</tbody></table>
<p>在 arm64 下, isa 使用 19 个 bit 用来存储引用计数. 当引用计数超过这个数时，将会把 RC_HALF 数量的引用计数存储在一个全局哈希表中，此时 <code>has_sidetable_rc</code> 变为 1</p>
<h3 id="增加引用计数"><a href="#增加引用计数" class="headerlink" title="增加引用计数"></a>增加引用计数</h3><p>下面让我们通过调试来探究具体的存储过程<br>因为是在模拟器中运行的，isa 最多只能使用 8 个 bit 来存储引用计数, 即在 isa 中只能存储不超过 256 的数目。所以我们只要将对象的引用计数增加到 256 以上，那么系统就会将多余的引用计数存储到哈希表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void foo(void) &#123;</span><br><span class="line">	NSObject *o1 = [[NSObject alloc] init];</span><br><span class="line">	for (int i = 0; i &lt; 500; i++) &#123;</span><br><span class="line">	    _objc_rootRetain(o1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_objc_rootRetain()</code>方法最终会调用<code>objc_object::rootRetain(bool tryRetain, bool handleOverflow)</code>, 这个方法的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE id </span><br><span class="line">objc_object::rootRetain(bool tryRetain, bool handleOverflow)</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line"></span><br><span class="line">    bool sideTableLocked = false;</span><br><span class="line">    bool transcribeToSideTable = false;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">    	 // 是否将引用计数转移到索引表中</span><br><span class="line">        transcribeToSideTable = false;</span><br><span class="line">        // LoadExclusive 的作用是让读取操作原子化</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        // if (slowpath) else ()，表示大概率执行 else 后面的语句，用来提高效率。</span><br><span class="line">        // fastpath 则表示大概率执行 if 后面的语句</span><br><span class="line">        if (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">        	  // arm64 架构下，一般的对象 nonpointer 为YES，但也有特例，例如 block 的 nonpointer 为 False，即不使用 isa 保存额外信息</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            if (rawISA()-&gt;isMetaClass()) return (id)this;</span><br><span class="line">            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;</span><br><span class="line">            else return sidetable_retain();</span><br><span class="line">        &#125;</span><br><span class="line">        // don&#x27;t check newisa.fast_rr; we already called any RR overrides</span><br><span class="line">        if (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        // 用来表示 isa 指针的值是否溢出。因为引用计数存储在指针的高位，当引用计数增加到一定程度，会超过最高位的数字，此时 carry 的值不等于 0，表示溢出</span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        // addc() 是一个内置函数，作用是将 isa 里面的引用计数 + 1 后保存</span><br><span class="line">        newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry);  // extra_rc++</span><br><span class="line"></span><br><span class="line">        if (slowpath(carry)) &#123;</span><br><span class="line">            // newisa.extra_rc++ overflowed</span><br><span class="line">            // 移除的话则需要对多余的引用计数保存到索引表中。</span><br><span class="line">            // 刚开始进入的时候 handleOverflow == false</span><br><span class="line">            if (!handleOverflow) &#123;</span><br><span class="line">                ClearExclusive(&amp;isa.bits);</span><br><span class="line">                return rootRetain_overflow(tryRetain);</span><br><span class="line">            &#125;</span><br><span class="line">            // 加锁</span><br><span class="line">            if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</span><br><span class="line">            // 此时 isa 指针存储的引用计数应该是满的， extra_rc 的 19 位都是 1，将 extra_rc 赋值为原来的一半，也就是将 isa 的最高位赋值为 0，这样做的目的是下次引用计数增加的时候可以直接存储在 isa 中，而不需要调用索引表来存储。将 has_sidetable_rc 赋值为 1，标记有额外的引用计数存储在索引表中</span><br><span class="line">            sideTableLocked = true;</span><br><span class="line">            transcribeToSideTable = true;</span><br><span class="line">            newisa.extra_rc = RC_HALF;</span><br><span class="line">            newisa.has_sidetable_rc = true;</span><br><span class="line">        &#125;</span><br><span class="line">       // StoreExclusive(), 如果&amp;isa.bits和oldisa.bits相等，那么就把newisa.bits的值赋给&amp;isa.bits，并且返回true。</span><br><span class="line">    &#125; while (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    if (slowpath(transcribeToSideTable)) &#123;</span><br><span class="line">        // Copy the other half of the retain counts to the side table.</span><br><span class="line">        // 如果溢出的话，则将 isa 存储的引用计数赋值为最大值的一半，即 RC_HALF，那么减少的一半则转移到索引表中</span><br><span class="line">        sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    if (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</span><br><span class="line">    return (id)this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写了点注释帮助你们理解. 现在我们在<code>sidetable_addExtraRC_nolock(RC_HALF);</code>那一行打个断点，启动程序</p>
<p><img src="https://i.loli.net/2020/05/13/2q6ThJM9igfrKGz.jpg"></p>
<p><code>step into</code>进入这个方法</p>
<p><img src="https://i.loli.net/2020/05/13/cT48MF3VjPEGko6.jpg"></p>
<p>因为用的模拟器，所以 RC_HALF &#x3D;&#x3D; delta_rc &#x3D;&#x3D; 128，符合预期。</p>
<p>代码<code>SideTable&amp; table = SideTables()[this]</code>，通过计算指针值得到哈希值获取到对应的 sidetable<br>让我们点开方法<code>SideTables()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static objc::ExplicitInit&lt;StripedMap&lt;SideTable&gt;&gt; SideTablesMap;</span><br><span class="line"></span><br><span class="line">static StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class="line">    return SideTablesMap.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>class ExplicitInit</code> 的定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Type&gt;</span><br><span class="line">class ExplicitInit &#123;</span><br><span class="line">    alignas(Type) uint8_t _storage[sizeof(Type)];</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    template &lt;typename... Ts&gt;</span><br><span class="line">    void init(Ts &amp;&amp;... Args) &#123;</span><br><span class="line">        new (_storage) Type(std::forward&lt;Ts&gt;(Args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Type &amp;get() &#123;</span><br><span class="line">        return *reinterpret_cast&lt;Type *&gt;(_storage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>ExplicitInit</code>的作用是生成一个模板类型 Type 的实例。<code>alignas(Type) uint8_t _storage[sizeof(Type)];</code>成员变量<code>_storage</code>是一个 sizeof(Type) 长度的 uint8_t 数组，而 uint8_t 占用一个字节，所以实际上<code>_storage</code>的长度跟一个 Type 实例所占用的内存是一样多的。成员函数 <code>Type &amp;get()</code> 将 _storage 数组指针用<code>reinterpret_cast&lt;Type *&gt;</code>强转成了 Type * 类型指针，前面再加一个 *，说明返回的实际上是 Type 实例内存的首地址。而另一个成员函数<code>init</code>用来初始化生成的 Type 实例。</p>
<p>所以<code>static StripedMap&lt;SideTable&gt;&amp; SideTables()</code>函数实际上返回了一个全局静态<code>StripedMap&lt;SideTable&gt;</code>的实例。<br>下面是<code>class StripedMap</code>的部分定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class StripedMap &#123;</span><br><span class="line">#if TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR</span><br><span class="line">    enum &#123; StripeCount = 8 &#125;;</span><br><span class="line">#else</span><br><span class="line">    enum &#123; StripeCount = 64 &#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    struct PaddedT &#123;</span><br><span class="line">        T value alignas(CacheLineSize);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    PaddedT array[StripeCount];</span><br><span class="line"></span><br><span class="line">    static unsigned int indexForPointer(const void *p) &#123;</span><br><span class="line">        uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(p);</span><br><span class="line">        return ((addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)) % StripeCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    T&amp; operator[] (const void *p) &#123; </span><br><span class="line">        return array[indexForPointer(p)].value; </span><br><span class="line">    &#125;</span><br><span class="line">    // ...省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>局部结构体<code>PaddedT</code>的作用是用来内存对齐，常量<code>CacheLineSize</code>是固定值 64。在 arm64 架构下，成员变量<code>array</code>是一个长度为 8，元素类型为 T，每个元素占 64 字节的数组，而在模拟器下是一个长度为 64，每个元素占 64 字节的数组。</li>
<li>成员函数<code>indexForPointer</code>用来根据指针来计算哈希值，确定对应于<code>array</code>里面第几个元素。</li>
<li><code>T&amp; operator[] (const void *p)</code>使用 operator 关键字重载了<code>[]</code>符号。举个例子，StripedMap 有一个实例 sm，有一个 int 类型的变量 a，当执行<code>sm[&amp;a]</code>的代码时，就会跳转到<code>T&amp; operator[] (const void *p)</code>这个方法里面。而在上面的重载<code>[]</code>函数中，传入的参数为指针类型，然后计算出其数组 index，返回对应的元素 T，也就是 <code>SideTable</code>。</li>
</ul>
<p>继续调试，断点此时在<code>SideTable&amp; table = SideTables()[this];</code>这一行。点击 step into</p>
<p><img src="https://i.loli.net/2020/05/13/8KkRmgMFCyporjh.jpg"></p>
<p><code>_storage</code>的数组长度为 4096，也就是 64 * 64，符合预期。继续<code>step into</code>，最终会跳转到下面这里</p>
<p><img src="https://i.loli.net/2020/05/13/gPYtFhH2kpN1KRM.jpg"></p>
<p>跳转到了重载的<code>[]</code>方法里面了。</p>
<p>目前已知道的情报就是，有一个全局的<code>StripedMap</code>条目索引，里面包含了若干个<code>SideTable</code>索引表。在使用时，根据指针得到对应的 sidetable。<code>SideTable</code> 的部分定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct SideTable &#123;</span><br><span class="line">    spinlock_t slock;</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    weak_table_t weak_table;</span><br><span class="line"></span><br><span class="line">    SideTable() &#123;</span><br><span class="line">        memset(&amp;weak_table, 0, sizeof(weak_table));</span><br><span class="line">    &#125;</span><br><span class="line">    void lock() &#123; slock.lock(); &#125;</span><br><span class="line">    void unlock() &#123; slock.unlock(); &#125;</span><br><span class="line">    void forceReset() &#123; slock.forceReset(); &#125;</span><br><span class="line">    // ...省略</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>SideTable 的成员对象里面有一个自旋锁，引用映射表<code>RefcountMap refcnts</code>，弱引用表<code>weak_table_t weak_table</code>。在上面我们提到了每个 sidetable 占用 64 个字节, 那是因为 spinlock_t 占用 4, RefcountMap 占用 24, weak_table_t 占用 32, 加起来就是 64.<br>在这里我们只了解下 RefcountMap, 因为它跟我们引用计数相关.<br><code>RefcountMap</code>是一个类型别名，它的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,RefcountMapValuePurgeable&gt; RefcountMap;</span><br></pre></td></tr></table></figure>

<p>先别急着查看<code>DenseMap</code>的定义，我们先看看<code>DisguisedPtr</code>是个什么类。它的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class DisguisedPtr &#123;</span><br><span class="line">    uintptr_t value;</span><br><span class="line"></span><br><span class="line">    static uintptr_t disguise(T* ptr) &#123;</span><br><span class="line">        return -(uintptr_t)ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static T* undisguise(uintptr_t val) &#123;</span><br><span class="line">        return (T*)-val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    DisguisedPtr() &#123; &#125;</span><br><span class="line">    DisguisedPtr(T* ptr) </span><br><span class="line">        : value(disguise(ptr)) &#123; &#125;</span><br><span class="line">    DisguisedPtr(const DisguisedPtr&lt;T&gt;&amp; ptr) </span><br><span class="line">        : value(ptr.value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    DisguisedPtr&lt;T&gt;&amp; operator = (T* rhs) &#123;</span><br><span class="line">        value = disguise(rhs);</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    DisguisedPtr&lt;T&gt;&amp; operator = (const DisguisedPtr&lt;T&gt;&amp; rhs) &#123;</span><br><span class="line">        value = rhs.value;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    operator T* () const &#123;</span><br><span class="line">        return undisguise(value);</span><br><span class="line">    &#125;</span><br><span class="line">    T* operator -&gt; () const &#123; </span><br><span class="line">        return undisguise(value);</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; operator * () const &#123; </span><br><span class="line">        return *undisguise(value);</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; operator [] (size_t i) const &#123;</span><br><span class="line">        return undisguise(value)[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>简单的说, 你可以像指针<code>Type *</code>一样的使用<code>DisguisedPtr</code>，但是其成员变量<code>value</code>保存的是伪装后的指针值。伪装函数是<code>disguise()</code>，0 和 0x800…00 经过伪装之后还是本身，但指针值也不可能是这两个值，所以无所谓的。</li>
<li>为了能像指针<code>Type *</code>一样的使用<code>DisguisedPtr</code>，在<code>DisguisedPtr</code>内部，重载了许多符号，例如 [], &#x3D;, *, ()。具体就不分析了。</li>
<li>该类的作用是为了避免直接引用指针, 防止被 leaks 内存检测工具检测出内存泄漏</li>
</ul>
<p><code>class RefcountMapValuePurgeable</code>的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct RefcountMapValuePurgeable &#123;</span><br><span class="line">    static inline bool isPurgeable(size_t x) &#123;</span><br><span class="line">        return x == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它只有一个内联函数，根据 x 是否为 0 返回一个 bool 值。它的作用就是根据参数判断是否需要析构这个实例<br>好了，了解完了<code>DisguisedPtr</code>和<code>RefcountMapValuePurgeable</code>，接下来我们来看<code>DenseMap</code>，它的定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename KeyT, typename ValueT,</span><br><span class="line">          typename ValueInfoT = DenseMapValueInfo&lt;ValueT&gt;,</span><br><span class="line">          typename KeyInfoT = DenseMapInfo&lt;KeyT&gt;,</span><br><span class="line">          typename BucketT = detail::DenseMapPair&lt;KeyT, ValueT&gt;&gt;</span><br><span class="line">class DenseMap : public DenseMapBase&lt;DenseMap&lt;KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;,</span><br><span class="line">                                     KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt; &#123;</span><br><span class="line">  friend class DenseMapBase&lt;DenseMap, KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;;</span><br><span class="line"></span><br><span class="line">  using BaseT = DenseMapBase&lt;DenseMap, KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;;</span><br><span class="line"></span><br><span class="line">  BucketT *Buckets;</span><br><span class="line">  unsigned NumEntries;</span><br><span class="line">  unsigned NumTombstones;</span><br><span class="line">  unsigned NumBuckets;</span><br><span class="line">  </span><br><span class="line">  public:</span><br><span class="line">   explicit DenseMap(unsigned InitialReserve = 0) &#123; init(InitialReserve); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码<code>friend class DenseMapBase</code>的作用是声明一个友元类<code>DenseMapBase</code>，这样<code>DenseMapBase</code>在内存可以直接访问<code>DenseMap</code> private 的成员函数。</li>
<li>代码<code>using BaseT = DenseMapBase</code>的作用是为<code>DenseMapBase</code>指定一个别名<code>BaseT</code></li>
<li>函数<code>explicit DenseMap()</code>, <code>explicit</code>的作用是用来声明类构造函数是显示调用的，而非隐式调用。</li>
</ul>
<p><code>DenseMap</code>里面有 4 个成员变量，Buckets 和 NumEntries，NumTombstones， NumBuckets。</p>
<ul>
<li>Buckets, 存储引用计数的数组, 元素类似于字典, key 为指针, value 为引用计数. 数组可扩容</li>
<li>NumEntries 表示数组中用来存储引用计数的元素有几个</li>
<li>NumTombstones 数组中元素被用来存储一个对象的引用计数, 当这个对象被销毁后, 该元素被标记为墓碑. 该变量用来表示有多少个这种元素</li>
<li>NumBuckets 数组 Buckets 的长度</li>
</ul>
<p>再来看一下模板里的几个类型 <code>DenseMapInfo&lt;KeyT&gt;</code>, <code>detail::DenseMapPair&lt;KeyT, ValueT&gt;</code></p>
<p>DenseMapInfo 有很多的模板定义，可以适用于各种类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct DenseMapInfo&lt;DisguisedPtr&lt;T&gt;&gt; &#123;</span><br><span class="line">  static inline DisguisedPtr&lt;T&gt; getEmptyKey() &#123;</span><br><span class="line">    return DisguisedPtr&lt;T&gt;((T*)(uintptr_t)-1);</span><br><span class="line">  &#125;</span><br><span class="line">  static inline DisguisedPtr&lt;T&gt; getTombstoneKey() &#123;</span><br><span class="line">    return DisguisedPtr&lt;T&gt;((T*)(uintptr_t)-2);</span><br><span class="line">  &#125;</span><br><span class="line">  static unsigned getHashValue(const T *PtrVal) &#123;</span><br><span class="line">      return ptr_hash((uintptr_t)PtrVal);</span><br><span class="line">  &#125;</span><br><span class="line">  static bool isEqual(const DisguisedPtr&lt;T&gt; &amp;LHS, const DisguisedPtr&lt;T&gt; &amp;RHS) &#123;</span><br><span class="line">      return LHS == RHS; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内联函数<code>getEmptyKey</code>和<code>getTombstoneKey</code>均返回一个特征值，用来标记 bucket 的状态 Empty 和 Tombstone。<br>静态函数<code>getHashValue</code>根据指针计算出哈希值。<br><code>ptr_hash()</code>的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static inline uint32_t ptr_hash(uint64_t key)</span><br><span class="line">&#123;</span><br><span class="line">    key ^= key &gt;&gt; 4;</span><br><span class="line">    key *= 0x8a970be7488fda55;</span><br><span class="line">    key ^= __builtin_bswap64(key);</span><br><span class="line">    return (uint32_t)key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看不懂，知道是计算哈希值的就好了。</p>
<p>最后一个静态函数<code>isEqual</code>用来比较两个参数是否相等。</p>
<p>接着看<code>detail::DenseMapPair&lt;KeyT, ValueT&gt;</code> 它的定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename KeyT, typename ValueT&gt;</span><br><span class="line">struct DenseMapPair : public std::pair&lt;KeyT, ValueT&gt; &#123;</span><br><span class="line">  DenseMapPair() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  DenseMapPair(const KeyT &amp;Key, const ValueT &amp;Value)</span><br><span class="line">      : std::pair&lt;KeyT, ValueT&gt;(Key, Value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  DenseMapPair(KeyT &amp;&amp;Key, ValueT &amp;&amp;Value)</span><br><span class="line">      : std::pair&lt;KeyT, ValueT&gt;(std::move(Key), std::move(Value)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  template &lt;typename AltKeyT, typename AltValueT&gt;</span><br><span class="line">  DenseMapPair(AltKeyT &amp;&amp;AltKey, AltValueT &amp;&amp;AltValue,</span><br><span class="line">               typename std::enable_if&lt;</span><br><span class="line">                   std::is_convertible&lt;AltKeyT, KeyT&gt;::value &amp;&amp;</span><br><span class="line">                   std::is_convertible&lt;AltValueT, ValueT&gt;::value&gt;::type * = 0)</span><br><span class="line">      : std::pair&lt;KeyT, ValueT&gt;(std::forward&lt;AltKeyT&gt;(AltKey),</span><br><span class="line">                                std::forward&lt;AltValueT&gt;(AltValue)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  template &lt;typename AltPairT&gt;</span><br><span class="line">  DenseMapPair(AltPairT &amp;&amp;AltPair,</span><br><span class="line">               typename std::enable_if&lt;std::is_convertible&lt;</span><br><span class="line">                   AltPairT, std::pair&lt;KeyT, ValueT&gt;&gt;::value&gt;::type * = 0)</span><br><span class="line">      : std::pair&lt;KeyT, ValueT&gt;(std::forward&lt;AltPairT&gt;(AltPair)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  KeyT &amp;getFirst() &#123; return std::pair&lt;KeyT, ValueT&gt;::first; &#125;</span><br><span class="line">  const KeyT &amp;getFirst() const &#123; return std::pair&lt;KeyT, ValueT&gt;::first; &#125;</span><br><span class="line">  ValueT &amp;getSecond() &#123; return std::pair&lt;KeyT, ValueT&gt;::second; &#125;</span><br><span class="line">  const ValueT &amp;getSecond() const &#123; return std::pair&lt;KeyT, ValueT&gt;::second; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看起来很复杂的样子，但其实只要知道它的父类<code>std::pair</code>是干嘛的就好了。<br><code>std::pair</code>的作用是将两个数据组合成一个数据，两个数据可以是同一类型或者不同类型。它是一个模板结构体，主要的两个成员变量是first和second，这两个变量可以直接使用。<br>再根据注释，可以推测出<code>DenseMapPair</code>作用是将 keyT 和 ValueT 两个类型的值保存在一起</p>
<p>继续之前的调试，在代码<code>size_t&amp; refcntStorage = table.refcnts[this];</code>打个断点，然后点击 continue program execution 跳转过去。</p>
<p>注意这里的<code>size_t&amp;</code>符号不是取内存地址意思，&amp; 在这里表示引用的意思。举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int&amp; b = a;</span><br><span class="line">b = 10;</span><br></pre></td></tr></table></figure>
<p>对 b 赋值 10 后，a 的值也变成了 10。好了，继续</p>
<p><img src="https://i.loli.net/2020/05/13/aY9yrcFwqWZogs6.jpg"></p>
<p>继续 step into</p>
<p><img src="https://i.loli.net/2020/05/13/Xt1gp7hS8LswvdU.jpg"></p>
<p>首先会跳转到类<code>DisguisedPtr</code>的一个初始化方法里面，这里对指针进行伪装并赋值给了成员对象 value。<br>继续 step into</p>
<p><img src="https://i.loli.net/2020/05/13/B76S2Og8qobtRXj.jpg"></p>
<p>跳转到了这里。可以看出来<code>DenseMap</code>的父类<code>DenseMapBase</code>也重载了<code>[]</code>方法。<br>参数类型为<code>KeyT &amp;&amp;</code>，也就是<code>DisguisedPtr&lt;objc_object&gt; &amp;&amp;</code>类型。这里的<code>&amp;&amp;</code>符号以及下面的<code>std::move(Key)</code>函数都是为了确定参数是右值引用，实现移动语义，减少不必要的参数拷贝。</p>
<p>继续 step into，跳转到了下面这里</p>
<p><img src="https://i.loli.net/2020/05/13/6QMiPmD7zAfpxqe.jpg"></p>
<p>之前我们讲<code>DenseMapPair&lt;KeyT, ValueT&gt;</code>的时候说到过，这个类的作用是将两个类型的值的组合成一个整体，类似于我们平常使用的字典。key 对应 first， value 对应 second。在<code>FindAndConstruct</code>方法中，首先会通过<code>LookupBucketFor()</code>查找是否已经有存在的 bucket，如果没有则通过<code>InsertIntoBucket</code>函数生成并返回对应的 bucket。</p>
<p>下面是<code>LookupBucketFor()</code>函数的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename LookupKeyT&gt;</span><br><span class="line">  bool LookupBucketFor(const LookupKeyT &amp;Val,</span><br><span class="line">                       const BucketT *&amp;FoundBucket) const &#123;</span><br><span class="line">    // 返回成员变量 Buckets</span><br><span class="line">    const BucketT *BucketsPtr = getBuckets();</span><br><span class="line">    // 返回成员变量 NumBuckets</span><br><span class="line">    const unsigned NumBuckets = getNumBuckets();</span><br><span class="line"></span><br><span class="line">    if (NumBuckets == 0) &#123;</span><br><span class="line">      FoundBucket = nullptr;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 保存在查找过程中碰到的墓碑</span><br><span class="line">    const BucketT *FoundTombstone = nullptr;</span><br><span class="line">    // DenseMapInfo 的内联函数 getEmptyKey </span><br><span class="line">    const KeyT EmptyKey = getEmptyKey();</span><br><span class="line">    // DenseMapInfo 的内联函数 getTombstoneKey </span><br><span class="line">    const KeyT TombstoneKey = getTombstoneKey();</span><br><span class="line">    assert(!KeyInfoT::isEqual(Val, EmptyKey) &amp;&amp;</span><br><span class="line">           !KeyInfoT::isEqual(Val, TombstoneKey) &amp;&amp;</span><br><span class="line">           &quot;Empty/Tombstone value shouldn&#x27;t be inserted into map!&quot;);</span><br><span class="line"></span><br><span class="line">	 //DenseMapInfo 的静态函数 getHashValue 计算哈希值，并与 NumBuckets-1 进行与运算，得到对应 BucketT 实例的 index</span><br><span class="line">    unsigned BucketNo = getHashValue(Val) &amp; (NumBuckets-1);</span><br><span class="line">    // 查找次数</span><br><span class="line">    unsigned ProbeAmt = 1;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">      const BucketT *ThisBucket = BucketsPtr + BucketNo;</span><br><span class="line">      // Found Val&#x27;s bucket?  If so, return it.</span><br><span class="line">      // 找到了对应的 BucketT 实例</span><br><span class="line">      if (LLVM_LIKELY(KeyInfoT::isEqual(Val, ThisBucket-&gt;getFirst()))) &#123;</span><br><span class="line">        FoundBucket = ThisBucket;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // If we found an empty bucket, the key doesn&#x27;t exist in the set.</span><br><span class="line">      // Insert it and return the default value.</span><br><span class="line">      // 如果对应的 bucket 是空的。如果是第一次查找的话则在这个 bucket 里面插入 key 和 value(在InsertIntoBucket函数中执行)。如果不是第一次并且之前找到了墓碑，则使用墓碑bucket插入key和value</span><br><span class="line">      if (LLVM_LIKELY(KeyInfoT::isEqual(ThisBucket-&gt;getFirst(), EmptyKey))) &#123;</span><br><span class="line">        // If we&#x27;ve already seen a tombstone while probing, fill it in instead</span><br><span class="line">        // of the empty bucket we eventually probed to.</span><br><span class="line">        FoundBucket = FoundTombstone ? FoundTombstone : ThisBucket;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // If this is a tombstone, remember it.  If Val ends up not in the map, we</span><br><span class="line">      // prefer to return it than something that would require more probing.</span><br><span class="line">      // Ditto for zero values.</span><br><span class="line">      // 如果找到一个墓碑，则使用 FoundTombstone  将这个墓碑记录下来</span><br><span class="line">      if (KeyInfoT::isEqual(ThisBucket-&gt;getFirst(), TombstoneKey) &amp;&amp;</span><br><span class="line">          !FoundTombstone)</span><br><span class="line">        FoundTombstone = ThisBucket;  // Remember the first tombstone found.</span><br><span class="line">        // 如果 FoundTombstone 为空并且 对应的 bucket 的 second 是 0，则用FoundTombstone保存下这个bucket</span><br><span class="line">      if (ValueInfoT::isPurgeable(ThisBucket-&gt;getSecond())  &amp;&amp;  !FoundTombstone)</span><br><span class="line">        FoundTombstone = ThisBucket;</span><br><span class="line"></span><br><span class="line">      // Otherwise, it&#x27;s a hash collision or a tombstone, continue quadratic</span><br><span class="line">      // probing.</span><br><span class="line">      // 如果查找次数多余 NumBuckets ，则报错</span><br><span class="line">      if (ProbeAmt &gt; NumBuckets) &#123;</span><br><span class="line">        FatalCorruptHashTables(BucketsPtr, NumBuckets);</span><br><span class="line">      &#125;</span><br><span class="line">      // 重新计算 BucketNo，重新查找</span><br><span class="line">      BucketNo += ProbeAmt++;</span><br><span class="line">      BucketNo &amp;= (NumBuckets-1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码里写了点注释帮助理解。<br>bucket 有两种状态，一种是 Empty，这个表示当前这个 bucket 还没有被使用的标记；另一个状态是 TombstoneKey，当一个 bucket 被使用了，当对象释放后该 bucket 被定义为这种状态</p>
<p>通过<code>FindAndConstruct</code>函数的分析我们知道，如果已经存在 bucket，则返回 YES，并将指针 TheBucket 指向这个 bucket。如果存在一个墓碑或者空的 bucket，则返回 false，并将指针 TheBucket 指向这个 bucket。</p>
<p>接着分析<code>InsertIntoBucket()</code>，下面是它的实现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename KeyArg, typename... ValueArgs&gt;</span><br><span class="line">  BucketT *InsertIntoBucket(BucketT *TheBucket, KeyArg &amp;&amp;Key,</span><br><span class="line">                            ValueArgs &amp;&amp;... Values) &#123;</span><br><span class="line">    TheBucket = InsertIntoBucketImpl(Key, Key, TheBucket);</span><br><span class="line">	</span><br><span class="line">	 // 保存 key 到 bucket 的成员变量 first 中</span><br><span class="line">    TheBucket-&gt;getFirst() = std::forward&lt;KeyArg&gt;(Key);</span><br><span class="line">    // 初始化 ValueT 的实例并保存到 bucket 的成员变量 second 中</span><br><span class="line">    ::new (&amp;TheBucket-&gt;getSecond()) ValueT(std::forward&lt;ValueArgs&gt;(Values)...);</span><br><span class="line">    return TheBucket;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  template &lt;typename LookupKeyT&gt;</span><br><span class="line">  BucketT *InsertIntoBucketImpl(const KeyT &amp;Key, const LookupKeyT &amp;Lookup,</span><br><span class="line">                                BucketT *TheBucket) &#123;</span><br><span class="line">    // If the load of the hash table is more than 3/4, or if fewer than 1/8 of</span><br><span class="line">    // the buckets are empty (meaning that many are filled with tombstones),</span><br><span class="line">    // grow the table.</span><br><span class="line">    //</span><br><span class="line">    // The later case is tricky.  For example, if we had one empty bucket with</span><br><span class="line">    // tons of tombstones, failing lookups (e.g. for insertion) would have to</span><br><span class="line">    // probe almost the entire table until it found the empty bucket.  If the</span><br><span class="line">    // table completely filled with tombstones, no lookup would ever succeed,</span><br><span class="line">    // causing infinite loops in lookup.</span><br><span class="line">    unsigned NewNumEntries = getNumEntries() + 1;</span><br><span class="line">    unsigned NumBuckets = getNumBuckets();</span><br><span class="line">    // 当 buckets 数组已经使用了超过 3/4 或者 空bucket的数量小于 1/8，则增加 buckets 数组的长度。</span><br><span class="line">    if (LLVM_UNLIKELY(NewNumEntries * 4 &gt;= NumBuckets * 3)) &#123;</span><br><span class="line">      // 扩增原来的 NumBuckets，新的 buckets 长度为旧的两倍，长度至少为 4。新的 buckets 生成后将旧数组里面的数据转移过去，并且旧数组删除</span><br><span class="line">      this-&gt;grow(NumBuckets * 2);</span><br><span class="line">      // 因为重新生成了 buckets 数组，所以需要使用LookupBucketFor重新查找对应bucket，并用指针 TheBucket 指向</span><br><span class="line">      LookupBucketFor(Lookup, TheBucket);</span><br><span class="line">      NumBuckets = getNumBuckets();</span><br><span class="line">    &#125; else if (LLVM_UNLIKELY(NumBuckets-(NewNumEntries+getNumTombstones()) &lt;=</span><br><span class="line">                             NumBuckets/8)) &#123;</span><br><span class="line">      this-&gt;grow(NumBuckets);</span><br><span class="line">      LookupBucketFor(Lookup, TheBucket);</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT(TheBucket);</span><br><span class="line"></span><br><span class="line">    // Only update the state after we&#x27;ve grown our bucket space appropriately</span><br><span class="line">    // so that when growing buckets we have self-consistent entry count.</span><br><span class="line">    // If we are writing over a tombstone or zero value, remember this.</span><br><span class="line">    if (KeyInfoT::isEqual(TheBucket-&gt;getFirst(), getEmptyKey())) &#123;</span><br><span class="line">      // Replacing an empty bucket.</span><br><span class="line">      // 使用空bucket，NumEntries + 1 </span><br><span class="line">      incrementNumEntries();</span><br><span class="line">    &#125; else if (KeyInfoT::isEqual(TheBucket-&gt;getFirst(), getTombstoneKey())) &#123;</span><br><span class="line">      // Replacing a tombstone.</span><br><span class="line">      // 使用墓碑 bucket，NumEntries + 1， NumTombstones - 1</span><br><span class="line">      incrementNumEntries();</span><br><span class="line">      decrementNumTombstones();</span><br><span class="line">    &#125; else &#123;      </span><br><span class="line">      // we should be purging a zero. No accounting changes.</span><br><span class="line">      // 如果 second 等于 0，则析构 second</span><br><span class="line">      ASSERT(ValueInfoT::isPurgeable(TheBucket-&gt;getSecond()));</span><br><span class="line">      TheBucket-&gt;getSecond().~ValueT();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return TheBucket;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<p>通过<code>InsertIntoBucket</code>函数我们了解到，当 buckets 数组已经使用了超过 3&#x2F;4 或者 空bucket的数量小于 1&#x2F;8，则会生成一个新的 buckets，长度为原来的2倍（最小为4），并将旧数组的数据转移到新数组中，并重新查找 TheBucket 的 index。最后将伪装后的指针保存到bucket的first中，将引用计数保存到bucket的second中。</p>
<p>理论分析到这里。这几个函数的调试我就不贴出来了，比较长，你们可以自己调试下。</p>
<p>接下来在代码<code>size_t oldRefcnt = refcntStorage;</code>中打个断点，点击 continue program execution 跳转过去。</p>
<p><img src="https://i.loli.net/2020/05/13/9gODFkVRhG1ZYEP.jpg"></p>
<p>让我们回到<code>objc_object::sidetable_addExtraRC_nolock</code>函数中。因为我们刚刚在 sidetable 索引表里面插入了 bucket，所以这里 oldRefcnt 的值 为 0。<br>接下来会对 oldRefcnt 进行校验，这说明 oldRefcnt 并没有把所有的 bit 都用来保存引用计数。</p>
<ul>
<li>低 1 位(从低位往高位数第一位)用来标记是否是弱引用</li>
<li>低 2 位用来标记该变量是否在析构 </li>
<li>高 1 位(从高位往低位数第一位)用来标记保存的引用计数是否已经溢出。</li>
</ul>
<p>下面的代码我们好像看到过了，对，在将引用计数保存在 isa 指针那里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t carry;</span><br><span class="line">size_t newRefcnt = </span><br><span class="line">    addc(oldRefcnt, delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT, 0, &amp;carry);</span><br><span class="line">if (carry) &#123;</span><br><span class="line">    refcntStorage =</span><br><span class="line">        SIDE_TABLE_RC_PINNED | (oldRefcnt &amp; SIDE_TABLE_FLAG_MASK);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    refcntStorage = newRefcnt;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这几句的代码的作用是将  newRefcnt &#x3D; oldRefcnt + delta_rc，如果值太大了溢出了则将 carry 赋值为1，并将 refcntStorage 的高1位赋值为1，并返回true。如果没有溢出的话则将 newRefcnt 赋值到 refcntStorage，并返回 false。</p>
<p>到这里，我们探究了当引用计数增加时，如何保存多余的引用计数。简单的归纳下：</p>
<ul>
<li>有一个静态全局变量 SideTablesMap，实际上是 StripedMap<SideTable> 的实例。以便于在程序初始化的时候就能用到</li>
<li>变量 SideTablesMap 里面有一个长度为 8，类型为 SideTable 的数组成员<code>array</code>，每个元素占用的内存为64(spinlock_t内存4， RefcountMap内存24，weak_table_t内存32)。在保存引用计数的时候，根据指针地址来计算出相应 SideTable 的 index。</li>
<li>获取到相应的 SideTable 后，根据指针地址计算出相应的哈希值，然后查找 bucket。如果 bucket 不存在，则使用空 bucket 或者 墓碑 bucket。如果 bucket 的数量不够则扩容。将指针为 key 和 引用计数 为 value 保存到 bucket 当中。</li>
</ul>
<p>注意：当一个对象创建后它的引用计数为 1，但是 isa 指针里的引用计数还是 0。因为初始化的时候并没有对引用计数进行操作。</p>
<h3 id="减少引用计数"><a href="#减少引用计数" class="headerlink" title="减少引用计数"></a>减少引用计数</h3><p>这里我们只讨论有额外引用计数存储在 sidetable，且 isa 指针里面存储的引用计数为 0 时的临界情况。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void aoo(void) &#123;</span><br><span class="line">    NSObject *o1 = [[NSObject alloc] init];</span><br><span class="line">    for (int i = 0; i &lt; 512; i++) &#123;</span><br><span class="line">        _objc_rootRetain(o1);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; 129; i++) &#123;</span><br><span class="line">        if (i == 128) &#123;</span><br><span class="line">            int a = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        _objc_rootRelease(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在代码<code>int a = 1;</code>处打个断点，此时 isa 保存的引用计数为 0。一直 step over，直到跳转到<code>objc_object::rootRelease(bool performDealloc, bool handleUnderflow)</code>函数。</p>
<p><img src="https://i.loli.net/2020/05/13/turvFcU5IZGkP1b.jpg"><br><img src="https://i.loli.net/2020/05/13/AoLIWTViEd748xq.jpg"></p>
<p>一直点击 step over，直到停在<code>newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry);</code>那一行<br><img src="https://i.loli.net/2020/05/13/Ceoih1Q2jDKfuSs.jpg"></p>
<p>用调试命令打印看一下此时 isa 指针里面的内容</p>
<p><img src="https://i.loli.net/2020/05/13/2iEFlJGR5UpIMQr.jpg"></p>
<p>因为使用的是模拟器，所以 isa 里面只有最高的 8 个bit用来保存引用计数，之前我们减少它的引用计数 128。所以此时它 isa 指针里面保存的引用计数为 0。调试输出结果<code>extra_rc</code>也为0，符合预期(0b是二进制符号)</p>
<p>接下来系统要将引用保存在 isa 指针的引用计数 -1，并判断是否溢流。此刻它的引用计数已经为 0 了，那么对它进行 -1 操作会发生什么呢？我们接着调试，点击 step over</p>
<p><img src="https://i.loli.net/2020/05/13/HbF41O3NWoDEYVj.jpg"><br>可以看到变量<code>carry</code> &#x3D;&#x3D; 1，表示出现溢流。让我们再看一下 isa 指针里面发生了什么。</p>
<p><img src="https://i.loli.net/2020/05/13/paOHdgJVhnSu8wb.jpg"><br>我们可以看到保存引用计数的 8 个 bit 都变成了 1，这其实就是 -1 在无符号整数中的表现形式，不懂的同学可以去了解一下补码。</p>
<p>接着一直 step over，我们可以看到因为溢流所以跳转到了<code>underflow</code>部分。一直 step over 直到跳转到如下的位置</p>
<p><img src="https://i.loli.net/2020/05/13/BgOwLK4MUATkHPW.jpg"></p>
<p><code>rootRelease_underflow</code>最终调用的还是<code>objc_object::rootRelease()</code>函数，只不过参数 handleUnderflow 变成了 YES。<br>进入该函数后，又会执行之前的那些代码，过程也是一样的，就不重复说了。接下来会来到这个位置</p>
<p><img src="https://i.loli.net/2020/05/13/2dtp15ZBOQ6xefN.jpg"></p>
<p>是的，因为没上锁，所以又会回到<code>retry</code>部分的代码。注释里写着是因为</p>
<blockquote>
<p>Need to start over to avoid a race against the nonpointer -&gt; raw pointer transition.</p>
</blockquote>
<p>不是很明白，但是过了。继续 step over</p>
<p><img src="https://i.loli.net/2020/05/13/n6PAYWwuTN9kirV.jpg"></p>
<p>之前引用计数溢出时，我们将<code>RC_HALF</code>数目的引用计数存储到了<code>sidetable</code>当中，此时因为溢流，所以我们从<code>sidetable</code>中取回同样数目的引用计数。 </p>
<p>step into 进入<code>objc_object::sidetable_subExtraRC_nolock()</code>函数</p>
<p><img src="https://i.loli.net/2020/05/13/9H2gtCbzZih6avs.jpg"></p>
<p>在最开始的代码中,我们增加了变量<code>o1</code> 512 的引用计数, 在 isa 指针中保存了 128, 还剩余 384. 但是因为最低两位没有用来保存数据, 所以在 bucket 中存储的数字应该是 384 &lt;&lt; 2, 即 1536, 符合预期</p>
<p>接下来的代码作用就是判断保存在 bucket 中的引用计数是否合理, 如何合理的话则将原有的数据减去<code>RC_HALF</code>并重新保存. 点击 step out 返回之前的函数</p>
<p><img src="https://i.loli.net/2020/05/13/jkhWHiRPa2LTmzX.jpg"></p>
<ul>
<li>代码块1的作用是将从 sidetable 取回了保存着的一部分引用计数, -1 保存到 isa 指针里面</li>
<li>如果代码块1保存失败, 则用代码块2重新保存一次</li>
<li>如果代码块2保存失败了, 则将从 sidetable 取出的引用计数重新放回去. 然后又跳回到 retry 部分</li>
<li>保存成功则解锁, 并返回 false. 返回 true 表示这个对象需要 dealloc 了</li>
</ul>
<p>另一种情况, 如果一个对象 isa 引用计数为 0, 且没有额外的引用计数. 那么它从 sidetable ‘借来的’  borrowed 为 0, 那么会将 isa 的 deallocating 赋值为 1, 并随后对其发送 delloc 消息进行内存消耗</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>以上就是此次对引用计数的探究, 欢迎留言告诉我错的或者不明白的地方~</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-04-02T13:08:22.000Z" title="4/2/2020, 9:08:22 PM">2020-04-02</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">12 分钟读完 (大约1872个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/02/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Tagged-Pointer/">深入了解Tagged Pointer</a></h1><div class="content"><p><code>objc</code> 源码版本：<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/objc4/">779.1</a><br>当然还是推荐使用这个来学习：<a target="_blank" rel="noopener" href="https://github.com/LGCooci/objc_debug/tree/master">可编译的源码</a></p>
<p>在 2013 年苹果推出了首个使用 64 位架构的双核处理器的手机 iphone 5s。为了节约内存以及提高执行效率，苹果使用了一种叫做 ‘Tagged Pointer’ 的技术，现在跟着我来了解一下它吧。</p>
<h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h3><p>从 5s 开始，iPhone 均使用 arm64 指令集的处理器。在 64 位系统上，一个指针占 8 个字节，而指针指向的实例变量至少需要 16 个字节，并且还需要执行额外的一些操作，例如：申请内存，销毁内存。为了达到优化的目的，苹果将一些存储数据的类，例如 NSString，NSNumber，当它们需要保存的数据不需要占用那么多的字节时，直接将数据保存在“指针”里面。</p>
<p>下面让我们用代码来证实<code>Tagged Pointer</code>的存在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSNumber *a = [NSNumber numberWithInt:1];</span><br></pre></td></tr></table></figure>

<p>然后打个断点，使用 lldb 的命令调试，<code>x/8xg a</code>，该命令的意思是从a的起始地址开始，打印 8 个 16进制的 8字节长度的值<br>输出结果</p>
<p><img src="https://i.loli.net/2020/05/13/UDcHTtGa3iBZ9QM.jpg"></p>
<p>说明指针 a 并不是指向 NSNumber 实例的指针。</p>
<p>或者下面这样更加直观一点</p>
<p><img src="https://i.loli.net/2020/05/13/cEUe3thCQ1L5mlX.jpg"></p>
<p>可以看到 a 并没有 isa 指针，所以它并不是一个 NSNumber 实例指针。</p>
<h3 id="Tagged-Pointer-如何存储数据"><a href="#Tagged-Pointer-如何存储数据" class="headerlink" title="Tagged Pointer 如何存储数据"></a>Tagged Pointer 如何存储数据</h3><p>这里你最好打开源码对照着看。</p>
<h4 id="LSB"><a href="#LSB" class="headerlink" title="LSB"></a>LSB</h4><p>在非 arm64 架构中，将最低位即 LSB 设置为 1，与正常的指针进行区分。<br>这样做的原因是，OC 类在创建实例最终调用的是 C 标准库中的 calloc 函数，它所返回的内存地址是 16 字节对齐的，参考 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/5061392/aligned-memory-management/5061435#5061435">Aligned memory management?</a>。这样的结果就是指针地址低 4 位都是 0，用最低位来表示也合理的</p>
<p><img src="https://image-static.segmentfault.com/181/831/1818316709-5b52534856049_articlex" alt="非 arm64 架构下标记位的设定"></p>
<h4 id="MSB"><a href="#MSB" class="headerlink" title="MSB"></a>MSB</h4><p>在 arm64 架构中，将最高位即 MSB 设置为 1，与正常的指针进行区分。<br>这样做的原因的是因为在 arm64 架构中，指针只用了低位的 48 位，高 16 位都是空着的，原因可以看下这个 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28638698">为什么64位机指针只用48个位?</a></p>
<p>在 <code>objc-internal.h</code> 372 行以及 384 行，我们 我们可以看到掩码 _OBJC_TAG_MASK 的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if OBJC_MSB_TAGGED_POINTERS</span><br><span class="line">#   define _OBJC_TAG_MASK (1UL&lt;&lt;63)</span><br><span class="line">#   define _OBJC_TAG_INDEX_SHIFT 60</span><br><span class="line">#else</span><br><span class="line">#   define _OBJC_TAG_MASK 1UL</span><br><span class="line">#   define _OBJC_TAG_INDEX_SHIFT 1</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h4 id="内置类型和扩展类型"><a href="#内置类型和扩展类型" class="headerlink" title="内置类型和扩展类型"></a>内置类型和扩展类型</h4><p>系统启动时生成两个全局的数组 objc_debug_taggedpointer_classes 和 objc_debug_taggedpointer_ext_classes。一个用来存储系统内置的<code>Tagged Pointer</code>类型，而另一个数组存储扩展的<code>Tagged Pointer</code>类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; &#123; </span><br><span class="line">    extern Class objc_debug_taggedpointer_classes[_OBJC_TAG_SLOT_COUNT];</span><br><span class="line">    extern Class objc_debug_taggedpointer_ext_classes[_OBJC_TAG_EXT_SLOT_COUNT];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>内置类型数组的数目为 8，使用高 2 - 高 4 的 3 个 bit 来存储数据  </li>
<li>扩展类型数组的数目为 256，，使用高 5 - 高 12 的 8 个 bit 来存储数据</li>
</ul>
<p>是否剩余的 bit 都用来保存数据了呢？答案是否定的，拿 NSUmber 举个例子，它属于内置类型，其 tagged pointer 额外使用 低 1 - 低 4 的 5 个 bit 用来保存数字的类型信息，即使用 56 个 bit 来保存数据。</p>
<p>内置类型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">    // 60-bit payloads</span><br><span class="line">    OBJC_TAG_NSAtom            = 0, </span><br><span class="line">    OBJC_TAG_1                 = 1, </span><br><span class="line">    OBJC_TAG_NSString          = 2, </span><br><span class="line">    OBJC_TAG_NSNumber          = 3, </span><br><span class="line">    OBJC_TAG_NSIndexPath       = 4, </span><br><span class="line">    OBJC_TAG_NSManagedObjectID = 5, </span><br><span class="line">    OBJC_TAG_NSDate            = 6,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而当指针的高 1 - 高 4 的 4 个 bit 位均为 1 时，表示这是一个扩展类型。系统自带的扩展类型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">	// ...</span><br><span class="line">	// 52-bit payloads</span><br><span class="line">    OBJC_TAG_Photos_1          = 8,</span><br><span class="line">    OBJC_TAG_Photos_2          = 9,</span><br><span class="line">    OBJC_TAG_Photos_3          = 10,</span><br><span class="line">    OBJC_TAG_Photos_4          = 11,</span><br><span class="line">    OBJC_TAG_XPC_1             = 12,</span><br><span class="line">    OBJC_TAG_XPC_2             = 13,</span><br><span class="line">    OBJC_TAG_XPC_3             = 14,</span><br><span class="line">    OBJC_TAG_XPC_4             = 15,</span><br><span class="line">    OBJC_TAG_NSColor           = 16,</span><br><span class="line">    OBJC_TAG_UIColor           = 17,</span><br><span class="line">    OBJC_TAG_CGColor           = 18,</span><br><span class="line">    OBJC_TAG_NSIndexSet        = 19,</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据混淆"><a href="#数据混淆" class="headerlink" title="数据混淆"></a>数据混淆</h4><p>运行下面的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)boo</span><br><span class="line">&#123;</span><br><span class="line">    NSNumber *a = [NSNumber numberWithInt:1];</span><br><span class="line">    NSNumber *b = [NSNumber numberWithInt:2];</span><br><span class="line">    NSNumber *c = [NSNumber numberWithInt:16];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;pointer a is %lx&quot;, a);</span><br><span class="line">    NSLog(@&quot;pointer b is %lx&quot;, b);</span><br><span class="line">    NSLog(@&quot;pointer c is %lx&quot;, c);</span><br><span class="line">    NSLog(@&quot;pointer d is %lx&quot;, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pointer a is ef59c3d36981ed4b</span><br><span class="line">pointer b is ef59c3d36981ed7b</span><br><span class="line">pointer c is ef59c3d36981ec5b</span><br></pre></td></tr></table></figure>

<p>等等，不是说 <code>Tagged Pointer</code> 最高 4 位用来保存类型信息，剩下的几位都只用来保存数据嘛，为什么输出结果看起来这么复杂呢？<br>原因是从 iOS12 开始，为了系统安全，将数据与一个随机数进行 异或(^) 操作进行混淆，混淆函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static inline void * _Nonnull</span><br><span class="line">_objc_encodeTaggedPointer(uintptr_t ptr)</span><br><span class="line">&#123;</span><br><span class="line">    return (void *)(objc_debug_taggedpointer_obfuscator ^ ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>objc_debug_taggedpointer_obfuscator</code>是一个extern关键字的常量，因为被 extern 声明，所以我们可以用下面的代码来解码，得到真正的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">extern uintptr_t objc_debug_taggedpointer_obfuscator;</span><br><span class="line"></span><br><span class="line">- (void)foo</span><br><span class="line">&#123;</span><br><span class="line">    NSNumber *a = [NSNumber numberWithInt:1];</span><br><span class="line">    NSNumber *b = [NSNumber numberWithInt:2];</span><br><span class="line">    NSNumber *c = [NSNumber numberWithInt:16];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;pointer a real value is %lx&quot;, ((uintptr_t)a ^ objc_debug_taggedpointer_obfuscator));</span><br><span class="line">    NSLog(@&quot;pointer b real value is %lx&quot;, ((uintptr_t)b ^ objc_debug_taggedpointer_obfuscator));</span><br><span class="line">    NSLog(@&quot;pointer c real value is %lx&quot;, ((uintptr_t)c ^ objc_debug_taggedpointer_obfuscator));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pointer a real value is b000000000000012</span><br><span class="line">pointer b real value is b000000000000022</span><br><span class="line">pointer c real value is b000000000000102</span><br></pre></td></tr></table></figure>

<p>从输出结果可以看出，这几个值都是 0Xb 开头，16进制的 b 用 二级制表示为 1011，最高1用来表示这是一个 <code>Tagged Pointer</code>，而剩余 3 位的10进制数为 3，符合之前的定义<code>OBJC_TAG_NSNumber = 3</code>。<br>至于为什么结尾都是 0x2，这个后面再解释。<br>下面让我们测试下 NSNumber 的 Tagged Pointer 使用多少位来保存数据。从之前的探究我们知道内置类型用 60 位来保存数据，而经过上面的实验我们可以看到还有 4 位用来做别的事了，那么是否剩余的 56 位都用来保存数据了呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)foo</span><br><span class="line">&#123;</span><br><span class="line">    NSNumber *d = [NSNumber numberWithLongLong:-0x7FFFFFFFFFFFFF];</span><br><span class="line">    NSLog(@&quot;pointer a real value is %lx&quot;, ((uintptr_t)d ^ objc_debug_taggedpointer_obfuscator));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer d real value is b800000000000013</span><br></pre></td></tr></table></figure>

<p>结果符合预期。至于为什么最高位 b 后面的数字是 8，是因为高位 5 的位置变成了 1，用来表示这个数是负数(0则表示正数), 而 7 的二进制表示为 ob111，高位 5-8 连起来就是 0b1111，也就是16进制的 8 了。<br>还一个值得注意的是低位第一位的数字变成了 3，而不是之前的正整数 2，由此我们可以推测最低位的 4 位是用来表示存储数据类型的数据，例如 int,float,bool 这几个类型生成的 <code>Tagged Pointer</code> 最低4位数字应该是不同的。用下面的代表再来验证下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSNumber *a = [NSNumber numberWithInt:1];</span><br><span class="line">NSNumber *b = [NSNumber numberWithShort:2];</span><br><span class="line">NSNumber *c = [NSNumber numberWithFloat:1.];</span><br><span class="line">NSNumber *d = [NSNumber numberWithLongLong:-0x7FFFFFFFFFFFFF];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;pointer a real value is %lx&quot;, ((uintptr_t)a ^ objc_debug_taggedpointer_obfuscator));</span><br><span class="line">NSLog(@&quot;pointer b real value is %lx&quot;, ((uintptr_t)b ^ objc_debug_taggedpointer_obfuscator));</span><br><span class="line">NSLog(@&quot;pointer c real value is %lx&quot;, ((uintptr_t)c ^ objc_debug_taggedpointer_obfuscator));</span><br><span class="line">NSLog(@&quot;pointer d real value is %lx&quot;, ((uintptr_t)d ^ objc_debug_taggedpointer_obfuscator));</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pointer a real value is b000000000000012</span><br><span class="line">pointer b real value is b000000000000021</span><br><span class="line">pointer c real value is b000000000000014</span><br><span class="line">pointer d real value is b800000000000013</span><br></pre></td></tr></table></figure>

<p>结果符合预期，说明我们的推测是正确的</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34100227/article/details/88772219">NSNumber 与 Tagged Pointer</a><br><a target="_blank" rel="noopener" href="https://toutiao.io/posts/v071dp/preview">深入解构 objc_msgSend 函数的实现</a></p>
<p>希望大家看了有所收获吧。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-07-19T06:02:28.000Z" title="7/19/2019, 2:02:28 PM">2019-07-19</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">32 分钟读完 (大约4753个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/19/iOS%E5%BA%94%E7%94%A8-main-%E6%89%A7%E8%A1%8C%E5%89%8D%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B%E6%83%85/">iOS应用 main 执行前发生的事情</a></h1><div class="content"><p>这篇是对 iOS 应用启动时，main 函数执行前发生的事的一点总结，限于水平，如有错误请指正~</p>
<h3 id="FAT-二进制"><a href="#FAT-二进制" class="headerlink" title="FAT 二进制"></a>FAT 二进制</h3><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fat_binary">FAT 二进制文件</a>，将多种架构的 Mach-O 文件合并而成。它通过 Fat Header 来记录不同架构在文件中的偏移量，Fat Header 占一页(64位16kb，32位4kb)的空间。<br>按分页来存储这些 segement 和 header 会浪费空间，但这有利于虚拟内存的实现。</p>
<p><img src="https://i.loli.net/2019/07/16/5d2d7fbfbad2d16193.png"></p>
<h3 id="Mach-O-文件"><a href="#Mach-O-文件" class="headerlink" title="Mach-O 文件"></a>Mach-O 文件</h3><p><code>Mach-O</code>为 Mach Object 文件格式的缩写，它是一种用于可执行文件，目标代码，动态库，内核转储的文件格式。<br>在 Mac OS X 系统中使用 Mach-O 作为其可执行文件类型。<br>它的组成结构如下图所示：</p>
<p><img src="https://i.loli.net/2019/07/16/5d2d33a11b54759536.png" alt="Mach-O 文件结构"></p>
<p>每个 Mach-O 文件包括一个 Mach-O Header，然后是一系列的载入命令 load commands，再是一个或多个段(segment)，每个段包括0到255个节(section)。Mach-O使用REL再定位格式控制对符号的引用。Mach-O在两级命名空间中将每个符号编码成“对象-符号名”对（所以需要保持 selector 的唯一），在查找符号时则采用线性搜索法。</p>
<p>Mach-O包含了几个 segment，每个 segment 又包含几个 section。segment的名字都是大写的，例如__DATA;section的名字都是小写的, 例如 __text。在 Mach-O 的类型不为<code>MH_OBJECT</code>时，空间大小为页的整数倍。页的大小跟硬件有关，在 arm64 架构一页是16kb，其余为4kb。<br>section 虽然没有整数倍页大小的限制，但是 section 之间不会有重叠。</p>
<h3 id="Mach-O-Header"><a href="#Mach-O-Header" class="headerlink" title="Mach-O Header"></a>Mach-O Header</h3><p>推荐使用<code>MachOView</code>这个软件查看 Mach-O 的文件结构。注意需要<code>手动关闭 processing</code>，不然会闪退。下面是用 MachOView 查看自己的应用结构：<br><img src="https://upload-images.jianshu.io/upload_images/1929756-afb6f9e44e85a834.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用MachOView查看文件结构"></p>
<p>东西有点多就没有截取全部。我们查看一下<code>Mach-O Header</code>部分<br><img src="https://upload-images.jianshu.io/upload_images/1929756-f08a65e6164284a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Header结构"></p>
<p>下面是64位架构下<code>header</code>的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span>	magic;		<span class="comment">/* mach magic number identifier */</span></span><br><span class="line">	<span class="type">cpu_type_t</span>	cputype;	<span class="comment">/* cpu specifier */</span></span><br><span class="line">	<span class="type">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* machine specifier */</span></span><br><span class="line">	<span class="type">uint32_t</span>	filetype;	<span class="comment">/* type of file */</span></span><br><span class="line">	<span class="type">uint32_t</span>	ncmds;		<span class="comment">/* number of load commands */</span></span><br><span class="line">	<span class="type">uint32_t</span>	sizeofcmds;	<span class="comment">/* the size of all the load commands */</span></span><br><span class="line">	<span class="type">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">	<span class="type">uint32_t</span>	reserved;	<span class="comment">/* reserved */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1929756-632845e24fd90afd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>Mach-O 全部的 filetype 和 flags 可以在<code>loader.h</code>中找到。</p>
<hr>
<p>除了<code>MH_OBJECT</code>以外的所有类型，段(Segment)的空间大小均为页的整数倍。页的大小跟硬件有关系，在 arm64 架构下一页为16kb，其它为4kb。</p>
<h3 id="Load-commands"><a href="#Load-commands" class="headerlink" title="Load commands"></a>Load commands</h3><p><code>Load commands</code>紧跟在头部之后, 当加载过 header 之后，会通过解析<code>Load commands</code>来加载剩下的数据，确定其内存的分布。<br>下面是 load commands 的结构定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct load_command &#123;</span><br><span class="line">	uint32_t cmd;		/* 载入命令类型 */</span><br><span class="line">	uint32_t cmdsize;	/* total size of command in bytes */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所有<code>load commands</code>的大小即为 Header-&gt;sizeofcmds, 共有 Header-&gt;ncmds 条<code>load command</code>。<br>load command 以<code>LC</code>开头，不同的加载命令有不同的专有的结构体，cmd 和 cmdsize 是都有的，分别为命令类型（即命令名称），这条命令的长度。这些加载命令告诉系统应该如何处理后面的二进制数据，对系统内核加载器和动态链接器起指导作用。如果当前 LC_SEGMENT 包含 section，那么 section 的结构体紧跟在 LC_SEGMENT 的结构体之后，所占字节数由 SEGMENT 的 cmdsize 字段给出。</p>
<table>
<thead>
<tr>
<th>cmd(命令名称)</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>LC_SEGMENT_64</td>
<td>将对应的段中的数据加载并映射到进程的内存空间去</td>
</tr>
<tr>
<td>LC_SYMTAB</td>
<td>符号表信息</td>
</tr>
<tr>
<td>LC_DYSYMTAB</td>
<td>动态符号表信息</td>
</tr>
<tr>
<td>LC_LOAD_DYLINKER</td>
<td>启动动态加载连接器&#x2F;usr&#x2F;lib&#x2F;dyld程序</td>
</tr>
<tr>
<td>LC_UUID</td>
<td>唯一的 UUID，标示该二进制文件，128bit</td>
</tr>
<tr>
<td>LC_VERSION_MIN_IPHONEOS&#x2F;MACOSX</td>
<td>要求的最低系统版本（Xcode中的Deployment Target）</td>
</tr>
<tr>
<td>LC_MAIN</td>
<td>设置程序主线程的入口地址和栈大小</td>
</tr>
<tr>
<td>LC_ENCRYPTION_INFO</td>
<td>加密信息</td>
</tr>
<tr>
<td>LC_LOAD_DYLIB</td>
<td>加载的动态库，包括动态库地址、名称、版本号等</td>
</tr>
<tr>
<td>LC_FUNCTION_STARTS</td>
<td>函数地址起始表</td>
</tr>
<tr>
<td>LC_CODE_SIGNATURE</td>
<td>代码签名信息</td>
</tr>
</tbody></table>
<p>注意：不同类型的 segment 会使用不同的函数来加载</p>
<h3 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h3><p>Mach-O 文件中由许多个段（Segment），每个段都有不同的功能，每个段包含了许多个小的Section。<code>LC_SEGMENT</code>意味着这部分文件需要映射到进程的地址空间去，几乎所有 Mach-O 都包含这三个段：</p>
<ol>
<li>__TEXT：包含了执行代码和其它只读数据(如C 字符串)。权限：只读(VM_PROT_READ)，可执行(VM_PROT_EXECUTE)</li>
<li>__DATA：程序数据，包含全局变量，静态变量等。权限：可读写(VM_PROT_WRITE&#x2F;READ) 可执行(VM_PROT_EXECUTE)</li>
<li>__LINKEDIT：包含了加载程序的”元数据”，比如函数的名称和地址。权限：只读(VM_PROT_READ)</li>
</ol>
<p>除了上面三个，还有一个常见的 segment：</p>
<ul>
<li>__PAGEZERO：空指针陷阱段，映射到虚拟内存空间的第一页，用于捕捉对 NULL 指针的引用</li>
</ul>
<p><code>LC_SEGMENT_64</code> 的结构定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command_64</span> &#123;</span> <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmd;		<span class="comment">/* LC_SEGMENT_64 */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmdsize;	<span class="comment">/* includes sizeof section_64 structs */</span></span><br><span class="line">	<span class="type">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment name */</span></span><br><span class="line">	<span class="type">uint64_t</span>	vmaddr;		<span class="comment">/* memory address of this segment */</span></span><br><span class="line">	<span class="type">uint64_t</span>	vmsize;		<span class="comment">/* memory size of this segment */</span></span><br><span class="line">	<span class="type">uint64_t</span>	fileoff;	<span class="comment">/* file offset of this segment */</span></span><br><span class="line">	<span class="type">uint64_t</span>	filesize;	<span class="comment">/* amount to map from the file */</span></span><br><span class="line">	<span class="type">vm_prot_t</span>	maxprot;	<span class="comment">/* maximum VM protection */</span></span><br><span class="line">	<span class="type">vm_prot_t</span>	initprot;	<span class="comment">/* initial VM protection */</span></span><br><span class="line">	<span class="type">uint32_t</span>	nsects;		<span class="comment">/* number of sections in segment */</span></span><br><span class="line">	<span class="type">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到这里大部分的成员变量都是帮助内核将 segment 映射到虚拟内存的。<code>nsects</code>即表明该段中包含多少个 section，section是具体数据存放的地方。<code>cmdsize</code>表示当前 segment 结构体以及它所包含的所有 section 结构体的总大小。</p>
<p>文件映射的起始位置由<code>fileoff</code>给出，映射到地址空间的<code>vmaddr</code>处。</p>
<h3 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h3><p>section 的名字均为小写。section 是具体数据存放的地方，它的结构体跟随在 LC_SEGMENT 结构体之后。在64位环境中它的结构定义为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct section_64 &#123; /* for 64-bit architectures */</span><br><span class="line">	char		sectname[16];	/* name of this section */</span><br><span class="line">	char		segname[16];	/* segment this section goes in */</span><br><span class="line">	uint64_t	addr;		/* memory address of this section */</span><br><span class="line">	uint64_t	size;		/* size in bytes of this section */</span><br><span class="line">	uint32_t	offset;		/* file offset of this section */</span><br><span class="line">	uint32_t	align;		/* section alignment (power of 2) */</span><br><span class="line">	uint32_t	reloff;		/* file offset of relocation entries */</span><br><span class="line">	uint32_t	nreloc;		/* number of relocation entries */</span><br><span class="line">	uint32_t	flags;		/* flags (section type and attributes)*/</span><br><span class="line">	uint32_t	reserved1;	/* reserved (for offset or index) */</span><br><span class="line">	uint32_t	reserved2;	/* reserved (for count or sizeof) */</span><br><span class="line">	uint32_t	reserved3;	/* reserved */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>flasg</code>字段储存了两个属性的值：type 和 attributes。type 只能有一个值，而 attributes 的值可以有多个。如果 segment 中任何一个 section 拥有属性 S_ATTR_DEBUG，那么该段所有的 section 都会拥有这个属性。属性详情可以参考<code>loader.h</code></p>
<table>
<thead>
<tr>
<th>section name</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>__text</td>
<td>主程序代码</td>
</tr>
<tr>
<td>__stub_helper</td>
<td>用于动态链接的存根</td>
</tr>
<tr>
<td>__symbolstub1</td>
<td>用于动态链接的存根</td>
</tr>
<tr>
<td>__objc_methname</td>
<td>Objective-C 的方法名</td>
</tr>
<tr>
<td>__objc_classname</td>
<td>Objective-C 的类名</td>
</tr>
<tr>
<td>__cstring</td>
<td>硬编码的字符串</td>
</tr>
<tr>
<td>__lazy_symbol</td>
<td>懒加载，延迟加载节，通过 dyld_stub_binder 辅助链接</td>
</tr>
<tr>
<td>_got</td>
<td>存储引用符号的实际地址，类似于动态符号表</td>
</tr>
<tr>
<td>__nl_symbol_ptr</td>
<td>非延迟加载节</td>
</tr>
<tr>
<td>__mod_init_func</td>
<td>初始化的全局函数地址，在 main 之前被调用</td>
</tr>
<tr>
<td>__mod_term_func</td>
<td>结束函数地址</td>
</tr>
<tr>
<td>__cfstring</td>
<td>Core Foundation 用到的字符串（OC字符串）</td>
</tr>
<tr>
<td>__objc_clsslist</td>
<td>Objective-C 的类列表</td>
</tr>
<tr>
<td>__objc_nlclslist</td>
<td>Objective-C 的 +load 函数列表，比 __mod_init_func 更早执行</td>
</tr>
<tr>
<td>__objc_const</td>
<td>Objective-C 的常量</td>
</tr>
<tr>
<td>__data</td>
<td>初始化的可变的变量</td>
</tr>
<tr>
<td>__bss</td>
<td>未初始化的静态变量</td>
</tr>
</tbody></table>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>在 segment 的结构体中，我们可以看到<code>vmaddr</code>和<code>vmsize</code>两个成员变量，它们分别代表 segment 在虚拟内存中的地址以及大小。</p>
<p><code>虚拟内存</code>就是一层间接寻址（indirection）。软件工程中有句格言就是任何问题都能通过添加一个间接层来解决。虚拟内存解决的是管理所有进程使用物理 RAM 的问题。通过添加间接层来让每个进程使用逻辑地址空间，它可以映射到 RAM 上的某个物理页上。这种映射不是一对一的，逻辑地址可能映射不到 RAM 上，也可能有多个逻辑地址映射到同一个物理 RAM 上。针对第一种情况，当进程要存储逻辑地址内容时会触发 page fault；第二种情况就是多进程共享内存。</p>
<p>对于文件可以不用一次性读入整个文件，可以使用<code>分页映射（mmap()）</code>的方式读取。也就是把文件某个片段映射到进程逻辑内存的某个页上。当某个想要读取的页没有在内存中，就会触发 page fault，内核只会读入那一页，实现文件的懒加载。</p>
<p>也就是说 Mach-O 文件中的<code>__TEXT</code>段可以映射到多个进程，并可以懒加载，且进程之间共享内存。<code>__DATA</code>段是可读写的。这里使用到了<code>Copy-On-Write</code>技术，简称 COW。也就是多个进程共享一页内存空间时，一旦有进程要做写操作，它会先将这页内存内容复制一份出来，然后重新映射逻辑地址到新的 RAM 页上。也就是这个进程自己拥有了那页内存的拷贝。这就涉及到了 clean&#x2F;dirty page 的概念。dirty page 含有进程自己的信息，而 clean page 可以被内核重新生成（重新读磁盘）。所以 dirty page 的代价大于 clean page。</p>
<p>在多个进程加载 Mach-O 文件时<code>__TEXT</code>和<code>__LINKEDIT</code>因为只读，都是可以共享内存的。而<code>__DATA</code>因为可读写，就会产生 dirty page。当 dyld 执行结束后，<code>__LINKEDIT</code>就没用了，对应的内存页会被回收。</p>
<h3 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a>dyld</h3><p><img src="https://i.loli.net/2019/07/18/5d3054bb2f41b84030.jpg" alt="dyld"></p>
<p><em>dyld</em>（the dynamic link editor），Apple 的动态链接器。在内核完成映射进程的工作后会启动<code>dyld</code>，负责加载应用依赖的所有动态链接库，准备好运行所需的一切。<br>在 App 启动的时候，首先会加载 App 的 mach-o 文件，从 load commands 中得到 dyld 的路径，并且运行。随后 dyld 做的事情顺序概括如下：</p>
<ol>
<li>初始化运行环境</li>
<li>加载主程序执行文件 生成 image, 将image添加到一个全局容器中</li>
<li>加载共享缓存</li>
<li>根据依赖链递归加载动态链接库 dylib，如果在缓存中有加载好的 image 则直接拿出来，否则生成一个新的 image，将image添加到一个全局容器中</li>
<li>link 主执行文件</li>
<li>link dylib<ul>
<li>根据依赖链递归修正指针 Rebase</li>
<li>根据依赖链递归符号绑定 Bind</li>
</ul>
</li>
<li>初始化 dylib（runtime 的初始化就在这个时候）</li>
</ol>
<p>在加载完所有的 dylib 之后，它们处于互相独立的状态，所以还需要将它们绑定起来。代码签名让我们不能修改指令，所以不能直接让一个 dylib 调用另一个 dylib，这时需要很多间接层。<br>这个时候需要 dyld 来修正指针(rebasing)和绑定符号(binding)。</p>
<p>详细可以查看 dyld 的<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/dyld/">源码</a>中的<code>_main</code>函数。<br>下面会分析上述的其中几个步骤。</p>
<h3 id="ImageLoader"><a href="#ImageLoader" class="headerlink" title="ImageLoader"></a>ImageLoader</h3><p> <code>ImageLoader</code>是一个将 mach-o 文件里面二进制数据(编译过的代码、符号等)加载到内存的基类，它负责将 mach-o 中的二进制数据映射到内存，它的实例就是我们熟悉的 image。<br> 每一个 mach-o 文件都会有一个对应的 image，实例的类型根据 mach-o 格式的不同也会不同。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/dyld_macho_load/Butterfly-ImageLoader.png"></p>
<ul>
<li>ImageLoaderMachOClassic: 用于加载<code>__LINKEDIT</code>段为传统格式的 mach-o 文件</li>
<li>ImageLoaderMachOCompressed: 用于加载<code>__LINKEDIT</code>段为压缩格式的 mach-o 文件</li>
</ul>
<p>因为<code>dylib</code>之间有依赖关系，所以系统会沿着依赖链递归加载 image。</p>
<h3 id="Rebasing"><a href="#Rebasing" class="headerlink" title="Rebasing"></a>Rebasing</h3><p><code>dylib</code>的二进制数据会随机的映射到内存的一个随机地址ASLR(Address space layout randomization,)中，这个随机的地址跟代码和数据指向的旧地址(preferred_address)会有一定的偏差，<code>dyld</code>需要修正这个偏差(slide)，做法就是将<code>dylib</code>内部的指针地址都加上这个偏移值，偏移值的计算方法如下：</p>
<p>slide &#x3D; actual_address - preferred_address</p>
<p>随后就是不断的将<code>__DATA</code>段中需要修正的指针加上这个偏移值。<br>注意：每次程序启动后的地址都会变化，所以指针的地址都需要重新修正。</p>
<p>在 mach-o 的一个载入命令<code>LC_DYLD_INFO_ONLY</code>可以查看到<code>rebase</code>, <code>bind</code>, <code>week_bind</code>,<code>lazy_bind</code>的偏移量和大小。</p>
<p><img src="https://i.loli.net/2019/07/17/5d2ec84e3414c16255.png"></p>
<h3 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h3><p><code>binding</code>处理那些指向<code>dylib</code>外部的指针，它们实际上被符号名称(symbol)绑定，也就是个字符串。比如我们 objc 代码中需要使用到 NSObject, 即符号_OBJC_CLASS_$_NSObject，但是这个符号不存在当前的 image 中，而是在系统库 Foundation.framework中，因此就需要binding这个操作将对应关系绑定到一起。</p>
<h3 id="Lazy-Binding"><a href="#Lazy-Binding" class="headerlink" title="Lazy Binding"></a>Lazy Binding</h3><p><code>lazyBinding</code>就是在加载动态库的时候不会立即 binding, 当时当第一次调用这个方法的时候再实施 binding。 做到的方法也很简单： 通过<code>dyld_stub_binder</code>这个符号来做。lazy binding 的方法第一次会调用到 dyld_stub_binder, 然后 dyld_stub_binder负责找到真实的方法，并且将地址bind到桩上，下一次就不用再bind了。<br>多数符号都是 lazy binding 的</p>
<h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><p>每一个<code>dylib</code>都有自己的初始化方法，当相应的 image 被加载到内存后，就会调用初始化方法。当然这不是调用名为<code>initialize</code>方法，而是C++静态对象初始化构造器，<code>__attribute__((constructor))</code>标记的方法以及<code>Initializer</code>方法。你可以在程序中设置环境变量<code>DYLD_PRINT_INITIALIZERS</code>来打印<code>dylib</code>的初始化方法。</p>
<p><img src="https://i.loli.net/2019/07/18/5d2fdcba273bf19458.jpg"></p>
<p><img src="https://i.loli.net/2019/07/18/5d2fdcf3c16be55910.jpg" alt="打印信息"></p>
<p>我们可以看到程序首先调用了<code>libSystem</code>这个dylib的初始化方法。<code>libSystem</code>是很多系统的lib的集合，包括 libdispatch(GCD), libsystem_c(c语言库), libsystem_blocks(block)。<br>在<code>libSystem</code>的源码<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/Libsystem/Libsystem-169.3/init.c">init.c</a>中我们可以看到，它的初始化方法<code>libSystem_initializer</code>会调用<code>libdispatch_init();</code>, 然后逐步调用到<code>_objc_init</code>，也就是 objc 和 runtime 的入口。<br>添加一个符号断点<code>_objc_init</code>，下面是方法调用栈：</p>
<p><img src="https://i.loli.net/2019/07/18/5d300eef8d17d46008.png" alt="断点调试"></p>
<p>注意：runtime 和 objc 属于<code>libobjc</code></p>
<hr>
<p>下面是<code>_objc_init</code>的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void _objc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 省略...</span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>map_images</code>不是将 image 添加到内存中的意思，在这个方法被调用的时候，已经完成了 image 的映射以及指针修正，绑定符号的工作了。<br>这个函数实际上是将 image 中 OBJC 相关的信息进行初始化，具体实现可以查看<code>_read_image</code>的源码，因为代码太多所以这里就不贴出来了，下面是具体做的事情：</p>
<ul>
<li>会将所有的 Class 存放在一张映射类名与 Class 的全局表中<code>gdb_objc_realized_classes</code></li>
<li>随后调用<code>readClass</code>函数将 每一个 Class 添加到<code>gdb_objc_realized_classes</code>表中。</li>
<li>确定 selector 是唯一的</li>
<li>read protocols: 读取protocol</li>
<li>realizeClasses：这一步的意义就是动态链接好class, 让class处于可用状态，主要操作如下：<ul>
<li>检查ro是否已经替换为rw,没有就替换一下。</li>
<li>检查类的父类和metaClass是否已经realize,没有就先把它们先realize</li>
<li>重新layout ivar. 因为只有加载好了所有父类，才能确定ivar layout</li>
<li>把一些flags从ro拷贝到rw</li>
<li>链接class的 nextSiblingClass 链表</li>
<li>attach categories: 合并categories的method list、 properties、protocols到 class_rw_t 里面</li>
</ul>
</li>
<li>read categories：读取类目</li>
</ul>
<p>在<code>map_images</code>结束会调用<code>load_images</code>函数。这一步做的事情比较少，就是调用我们熟悉的<code>+(load)</code>函数。父类会先调用，除了 Class，每个类目的<code>+(load)</code>方法也会被调用一次，但顺序就不一定了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这里对 main 函数之前的操作做一个小总结吧：</p>
<ol>
<li>将 App 的 mach-o header 读取到内存中</li>
<li>根据 load commands 获取 dyld 的路径，运行 dyld</li>
<li>初始化运行环境，加载 dylib，如果缓存中存在则从缓存中拿出加载过的 image，否则新建一个 image，加载到内存中</li>
<li>修正指针(rebase)，绑定符号(bind)</li>
<li>初始化 dylib，运行 runtime</li>
<li>runtime 将 image 中有关 OBJC 的数据进行初始化</li>
<li>调用 +(load) 方法</li>
<li>dyld 调用 main 函数</li>
</ol>
<p>花了一周的时间用来研究这部分的内容，终于填完坑了<del>很舒服<br>最大的感受就是学习完后，看 clang 编译后的 C++ 代码能看懂的更多了。比如添加完一个类目之后，会将这个这个类目添加到__DATA的section <code>__objc_catlist</code>中，以前不知道啥意思现在就明白了。也明白 xcode 的许多设置是用来干嘛的，总之好处多多</del><br>学习也是一个递归的过程，加油跳出这个递归吧！</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/">iOS 程序 main 函数之前发生了什么</a><br><a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/#dyld-%E5%8A%A0%E8%BD%BD-dylib-%E6%96%87%E4%BB%B6">优化 App 的启动时间</a><br><a target="_blank" rel="noopener" href="https://turingh.github.io/2016/03/16/dyld%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90load/#0x03_%E5%B0%8F%E7%BB%93">dyld源码分析-动态加载load</a><br><a target="_blank" rel="noopener" href="https://blog.cnbluebox.com/blog/2017/06/20/dyldyu-objc/">dyld与ObjC</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-07-10T07:34:15.000Z" title="7/10/2019, 3:34:15 PM">2019-07-10</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">23 分钟读完 (大约3427个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/10/Objective-C%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/">Objective-C类和对象的内存分布</a></h1><div class="content"><p>之前在别人博客下面看到了一个问题，觉得挺有意思的。但是自己想回答的时候又发现好像有一些知识点还不是很熟悉，觉得有点迷糊，所以准备再研究一下底层再来回答问题。现在把这个坑填上吧。<br><img src="https://i.loli.net/2019/07/10/5d25955c660d280691.png"></p>
<h3 id="OC对象的指针类型"><a href="#OC对象的指针类型" class="headerlink" title="OC对象的指针类型"></a>OC对象的指针类型</h3><p><code>Objective-C </code>是一门动态语言，而动态语言是在运行时确定数据类型，变量使用之前不需要类型声明。但是我们在写代码的时候还是要给对象一个类型或者使用<code>id</code>的，我自己觉得这么做是为了通过编译（例如声明了类型为NSObject的实例sark，却调用了方法foo，那么编译就通不过了）。<br>实际上动态语言的一个特性<code>多态</code>就是这么实现的，即用父类的指针指向子类的实例。</p>
<h3 id="对象的内存分布"><a href="#对象的内存分布" class="headerlink" title="对象的内存分布"></a>对象的内存分布</h3><p>还是举个例子会明白一点。需要注意的是需要在<code>模拟器</code>上调试，在<code>真机</code>调试会有问题的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface Father : NSObject</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)foo &#123;</span><br><span class="line">    Father *father1 = [Father new];</span><br><span class="line">    father1.name = @&quot;001&quot;;</span><br><span class="line">    id father2 = [Father new];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>调试之前，我们要明白几点常识。在计算机中每个字节都是有一个地址的，每个字节有8个bit，每个bit可以存储1或者0，这8个bit就是这个字节的值。在小端系统中，低位的值存储在低地址上。<br>使用 x 命令调试。格式：<code>x/&lt;n/f/u&gt;  &lt;addr&gt;</code></p>
<ul>
<li>x 显示内存</li>
<li>n 正整数，表示需要显示的内存单元的个数</li>
<li>f 表示addr指向的内存内容的输出格式<ul>
<li>s: 对应输出字符串</li>
<li>x: 按十六进制格式显示变量</li>
<li>d: 按十进制格式显示变量</li>
<li>c: 按字符格式显示变量</li>
</ul>
</li>
<li>u 以多少个字节作为一个内存单元<ul>
<li>b: 1 byte</li>
<li>h: 2 bytes</li>
<li>w: 4 bytes</li>
<li>g: 8 bytes</li>
</ul>
</li>
</ul>
<p>打断点，然后输入命令: <code>x/8xg father1</code>, 即：以8个字节为一个单元，从 father1 指针的地址开始起8个单元的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x/8xg father1</span><br><span class="line">0x6000000128f0: 0x000000010be34050(Class) 0x000000010bdcc058(name)                            </span><br><span class="line">0x600000012900: 0x00006000000128a0 0x0000000100000002</span><br><span class="line">0x600000012910: 0x000000010f8f8e58 0x0000000000000000</span><br><span class="line">0x600000012920: 0x0000000000000000 0x0000000000000000</span><br><span class="line"></span><br><span class="line">(lldb) x/8xg father2</span><br><span class="line">0x600000012490: 0x000000010be34050(Class) 0x0000000000000000(name)</span><br><span class="line">0x6000000124a0: 0xbadd2dcdc19dbead 0x00006000000124f0</span><br><span class="line">0x6000000124b0: 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x6000000124c0: 0x00007f8ae3c140c0 0x00006080000092b0</span><br></pre></td></tr></table></figure>

<p>这里我提前将这些地址代表的意思标注好了。<br><code>father2</code>虽然是<code>id</code>类型的，但是它跟<code>father1</code>第一个8字节所存储的地址是相同的，都是<code>0x000000010be34050</code>。其实这个地址就是 <code>Father</code>类的地址。我们可以使用下面的方法验证：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po (Class)0x000000010be34050</span><br><span class="line">Father</span><br></pre></td></tr></table></figure>

<p>所以一个实例对象第一个8字节存储的是这个类的指针，那么后面的字节存储的是什么呢？答案是这个实例的成员变量，在上面的例子中我们给实例<code>father1</code>的成员变量<code>name</code>赋值了<code>001</code>, 现在让我们验证一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po (id)0x000000010bdcc058</span><br><span class="line">001</span><br></pre></td></tr></table></figure>
<p>因为我们没有对<code>father2</code>的成员变量 name 赋值，所以这8个字节的值是空的。</p>
<hr>
<p>打开 <a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">runtime 750版本源码</a>，查看 id 和 Class 的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_class</span> *Class;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_object</span> *id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_object</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">isa_t</span> isa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">isa_t</span> &#123;</span><br><span class="line">    <span class="built_in">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">isa_t</span>(<span class="type">uintptr_t</span> value) : <span class="built_in">bits</span>(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="type">uintptr_t</span> bits;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ISA_BITFIELD)</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        ISA_BITFIELD;  <span class="comment">// defined in isa.h</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_class</span> : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="type">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="type">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">data</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>id的定义很简单，是一个指向 objc_object 的指针，而 objc_object 只有一个私有成员变量 isa。objc_class 继承于 objc_object，所以你也可以用 id 来声明 Class 的变量，例如<code>id foo = [NSObject class];</code>。</li>
<li>isa是一个联合体，里面的 struct 在不同架构的CPU中定义是不同的。在 64 位CPU中，isa 可以用来存储更多的信息，例如引用计数，是否有关联对象等，可以看我的这篇博客<a target="_blank" rel="noopener" href="https://kikido.github.io/2019/07/03/Objective-C%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%8E%9F%E7%90%86/">Objective-C引用计数原理</a></li>
</ol>
<p>使用<code>clang rewrite-objc ViewController.m</code>将代码转化成C++实现，可以看到 Father 这个类变成了如下的结构体</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Father_IMPL &#123;</span><br><span class="line">	struct NSObject_IMPL NSObject_IVARS;</span><br><span class="line">	NSString *_name;</span><br><span class="line">&#125;;</span><br><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">	Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看到这个结构体你是不是就明白了为什么对象的内存分布是下图这个样子的？<br>需要<code>注意</code>的是，NSObject 的实例虽然理论上只有8个字节，但是它的实例实际上有 16 个字节，后面8个字节是空的。</p>
<p><img src="https://i.loli.net/2019/07/10/5d2597437203257924.png" alt="实例内存分布图"></p>
<p>研究到这里，我们就可以回答开头的那个问题了。</p>
<ol>
<li>指针的类型是id类型，而指针指向的类型可以是别的类。因为 OC 是动态语言，变量的类型需要在运行时才能够确定。</li>
<li>指针保存的是对象内存的首地址</li>
<li>64位平台中，对象首地址开始的8个字节存储的是类的指针。也就是通过这个才能确定该类的类型</li>
</ol>
<p>是不是很简单！下面继续让我们研究下 Class 的内存分布问题</p>
<h3 id="Class的内存分布"><a href="#Class的内存分布" class="headerlink" title="Class的内存分布"></a>Class的内存分布</h3><p>让我们继续回到之前的代码调试。上一节中我们已经知道了<code>Father</code>类的地址了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x/16xg 0x000000010be34050</span><br><span class="line">0x10be34050: 0x000000010be34028(meta-class) 0x000000010f8f8e58(superClass)                     </span><br><span class="line">0x10be34060: 0x00006000000972f0(bucket_t *_buckets) 0x0000000200000003(_mask &amp; _occupied )</span><br><span class="line">0x10be34070: 0x0000600000074302 0x000000010f8f8e08</span><br><span class="line">0x10be34080: 0x000000010f8f8e08 0x000000010f548520</span><br><span class="line">0x10be34090: 0x0000000000000000 0x000000010bdd7df0</span><br><span class="line">0x10be340a0: 0x000000010be34078 0x000000010f8f8e58</span><br><span class="line">0x10be340b0: 0x000000010f548520 0x0000000000000000</span><br><span class="line">0x10be340c0: 0x000000010bdd7e38 0x000000010f8f8e08</span><br></pre></td></tr></table></figure>

<p>PS: 注意不要使用<code>真机</code>来调试，因为我调试的时候发现跳不到那个内存地址中，但在<code>模拟器</code>中没这个问题…</p>
<p>配套的我们把 objc_class 的定义放到下面。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_class</span> : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="type">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="type">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">data</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 objc_class 继承于 objc_object，所以 Class 的第一个8字节还是 isa 指针，也就是一个指向元类(meta-Class)的指针。如果你不知道元类是什么意思的话就去百度，我也懒得讲了。第2个8字节储存的是指向父类的指针。先让我们验证一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lldb) po (Class)0x000000010be34028</span><br><span class="line">Father</span><br><span class="line"></span><br><span class="line">(lldb) po (Class)0x000000010f8f8e58</span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure>

<p>结论正确。让我们接着看<code>cache_t</code>的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">    struct bucket_t *_buckets;</span><br><span class="line">    mask_t _mask;</span><br><span class="line">    mask_t _occupied;</span><br><span class="line">&#125;</span><br><span class="line">struct bucket_t &#123;</span><br><span class="line">private:</span><br><span class="line">    // IMP-first is better for arm64e ptrauth and no worse for arm64.</span><br><span class="line">    // SEL-first is better for armv7* and i386 and x86_64.</span><br><span class="line">#if __arm64__</span><br><span class="line">    MethodCacheIMP _imp;</span><br><span class="line">    cache_key_t _key;</span><br><span class="line">#else</span><br><span class="line">    cache_key_t _key;</span><br><span class="line">    MethodCacheIMP _imp;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cache_t</code>关系到方法查找的缓存。当对实例发送消息后，会先到Class的缓存中查找有没有该方法的缓存，如果有则直接调用方法的实现，提高效率。<br> 大致可以看出，<code>bucket_t</code>是一个哈希表，根据<code>_key</code>找到其映射的方法实现<code>_imp</code>，而<code>_key</code>就是 SEL(方法的名字 const char *)。<code>cache_t</code>是中的<code>_mask</code>和<code>_occupied</code>是两个4字节的变量，应该代表的是缓存的数量。所以，Class 第三个8字节存储的是<code>bucket_t *</code>类型的指针，第4个8字节保存的是 _mask 和 _occupied。因为是小端，低位地址存储低位的数据，所以 _mask 的值是<code>0x00000003</code>，而 _occupied 的值是<code>0x00000002</code></p>
<p>接下来看 Class 的第3个成员变量<code>class_data_bits_t bits;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct class_data_bits_t &#123;</span><br><span class="line">    // Values are the FAST_ flags above.</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    </span><br><span class="line">    public:</span><br><span class="line">    class_rw_t* data() &#123;</span><br><span class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在64位下，uintptr_t 为8个字节。class_data_bits_t 的公共方法有很多，主要是配合掩码进行一些读写操作。<br>继续看<code>class_rw_t</code>的定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    // Be warned that Symbolication knows the layout of this structure.</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    char *demangledName;</span><br><span class="line"></span><br><span class="line">#if SUPPORT_INDEXED_ISA</span><br><span class="line">    uint32_t index;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在结构体中，你可以看到有一个成员变量的类型是<code>class_ro_t</code>，是不是很像<code>class_rw_t</code>。从字面意思上可以猜测，一个是readwriite，一个是readonly。因为 OC 是动态语言，可以在运行时添加方法和成员变量，运行时添加的方法或者成员变量就是添加到<code>class_rw_t</code>上的，而<code>class_ro_t</code>存储的是一些编译后Class的信息。<br>在<code>class_data_bits_t</code>的定义中，我们知道了需要掩码<code>FAST_DATA_MASK</code>才能得到 class_rw_t 的地址。下面是 <code>class_rw_t</code>的内存分布</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 得到class_rw_t的内存地址</span><br><span class="line">0x0000600000074302 &amp; 0x00007ffffffffff8 = 0x600000074300;</span><br><span class="line"></span><br><span class="line">(lldb) x/16xg 0x600000074300</span><br><span class="line">0x600000074300: 0x00000000800a0000(flags &amp; version) 0x000000010bdd7da8(ro)</span><br><span class="line">0x600000074310: 0x000000010bdd7d18(methods) 0x000000010bdd7d90(properties)                          </span><br><span class="line">0x600000074320: 0x0000000000000000(protocols) 0x000000010be33f60(firstSubclass)</span><br><span class="line">0x600000074330: 0x000000010ee88c68(nextSiblingClass) 0x0000000000000000(demangledName)</span><br><span class="line">0x600000074340: 0xbadd2dcdc19dbead 0x0000600000074240</span><br></pre></td></tr></table></figure>

<p>因为在代码中我还声明了一个 Father 的子类 Son，没想到在这里出现，没错，就是这个 firstSubclass。至于如果有多个子类，确定哪个是 firstSubclass 我就不清楚了。。。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po (Class)0x000000010be33f60</span><br><span class="line">Son</span><br></pre></td></tr></table></figure>

<p>再来看一下<code>class_ro_t</code>的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">class_ro_t</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="type">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="type">uint32_t</span> instanceSize;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="type">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * name;</span><br><span class="line">    <span class="type">method_list_t</span> * baseMethodList;</span><br><span class="line">    <span class="type">protocol_list_t</span> * baseProtocols;</span><br><span class="line">    <span class="type">const</span> <span class="type">ivar_list_t</span> * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="type">property_list_t</span> *baseProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是它的内存分布：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x/16xg 0x000000010bdd7da8</span><br><span class="line">0x10bdd7da8: 0x0000000800000184(flags &amp; instanceStart) 0x0000000000000010(instanceSize &amp; reserved)</span><br><span class="line">0x10bdd7db8: 0x000000010bd3ea79(ivarLayout) 0x000000010bd3eafc(name)</span><br><span class="line">0x10bdd7dc8: 0x000000010bdd7d18(baseMethodList) 0x0000000000000000(baseProtocols)</span><br><span class="line">0x10bdd7dd8: 0x000000010bdd7d68(ivars) 0x0000000000000000(weakIvarLayout)</span><br><span class="line">0x10bdd7de8: 0x000000010bdd7d90(baseProperties) 0x0000002800000081</span><br></pre></td></tr></table></figure>
<ol>
<li>可以看到 ro 的成员变量中有<code>instanceStart</code>和<code>instanceSize</code>。这两个值的作用是<code>非脆弱成员变量</code>。即如果基类如果增加了成员变量，不需要重新编译，只需要在初始化系统自动修改<code>instanceStart</code>和<code>instanceSize</code>的值，就能够继续使用子类。具体你可以看我的这篇博客 <a target="_blank" rel="noopener" href="https://kikido.github.io/2019/06/27/%E8%B0%88Objective-C%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/">谈Objective-C类成员变量</a></li>
<li>ivarLayout 记录了那些是 storng 的ivar</li>
<li>name 存储的是这个类的名字，你可以使用<code>po (char *)0x000000010bd3eafc</code>打印该名字</li>
<li>ivars 存储的是该类的成员变量(不包括关联对象)</li>
<li>weakIvarLayout  记录了哪一些是 weak 的ivar</li>
</ol>
<p> 还可以看到 ro 的<code>baseMethodList</code>和rw的<code>methods</code>的地址都是<code>0x000000010bdd7d18</code>，ro 的<code>baseProperties</code>和rw的<code>properties</code>的地址都是<code>0x000000010bdd7d90</code></p>
<blockquote>
<p>实际上 rw 的三个成员变量，<code>methods</code>, <code>properties</code>, <code>protocols</code>的类型都继承于<code>list_array_tt</code>，这个列表可能有以下3中值：1. 空值 2. 指向列表的指针 3. 指向列表的指针的数组。所以这就是为什么Class可以在类目中添加方法和协议，只需要在这个列表数组中再添加一个指向类目中方法和协议列表的指针就好了。<br>因为在这个实例中没有使用类目添加方法，所以rw中methods数组仅有一个值，这个值等于ro的baseMethodList。</p>
</blockquote>
<p> 先来研究<code>methods</code>。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> struct method_t &#123;</span><br><span class="line">    SEL name;</span><br><span class="line">    const char *types;</span><br><span class="line">    MethodListIMP imp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct method_list_t &#123;</span><br><span class="line">	uint32_t entsizeAndFlags;</span><br><span class="line">   uint32_t count;</span><br><span class="line">   method_t first;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">(lldb) x/16xg 0x000000010bdd7d18</span><br><span class="line">0x10bdd7d18: 0x000000030000001a(entsizeAndFlags &amp; count) 0x000000010f547965(name)</span><br><span class="line">0x10bdd7d28: 0x000000010bd41271(types) 0x000000010b7e01e0(imp)</span><br><span class="line">0x10bdd7d38: 0x000000010fd3a28e(name) 0x000000010bd41284(types)</span><br><span class="line">0x10bdd7d48: 0x000000010b7e0180(imp) 0x0000000112f11912(name)</span><br><span class="line">0x10bdd7d58: 0x000000010bd4128c(types) 0x000000010b7e01a0(imp)</span><br><span class="line">0x10bdd7d68: 0x0000000100000020 0x000000010be30c50</span><br><span class="line">0x10bdd7d78: 0x000000010bd19fc8 0x000000010bd4130b</span><br><span class="line">0x10bdd7d88: 0x0000000800000003 0x0000000100000010</span><br></pre></td></tr></table></figure>

<p><code>entsizeAndFlags</code> 第一个4字节保存的是 entsize 和标记, entsize 我的理解好像是method_t的长度。第二个4字节保存的是方法的数量，在上面的例子中我们可以知道一共保存了3个方法。后面保存了3个method_t的实例，每个实例占用了24个字节。每个 method_t 实例，第一个8字节为 sel，即方法名字；第二个8自己保存了方法的参数类型；第3个8字节是方法的函数指针。我们把上面保存的3个方法的信息按顺序打印出来</p>
<ul>
<li>.cxx_destruct  v16@0:8</li>
<li>name @16@0:8</li>
<li>setName: v24@0:8@16</li>
</ul>
<p>第2和第3个方法比较好理解，系统为我们自动生成了属性 name 的 getter 和 setter 方法。<br>第1个方法<code>cxx_destruct</code> 的作用是在delloc时释放该类的成员变量的，具体你可以看这篇博客 <a target="_blank" rel="noopener" href="https://kikido.github.io/2019/06/24/%E6%8E%A2%E7%A9%B6ARC%E4%B8%8Bdealloc%E5%AE%9E%E7%8E%B0/">探究ARC下dealloc实现</a></p>
<p>properties 与 methods 类似，因为继承与同一个结构体。这里简单分析一下，内存分布为 <code>entsizeAndFlags</code>(4字节), count(4字节)，property_t数组。property_t里面有两个成员变量，一个是属性的名字，一个是属性的属性。。。</p>
<hr>
<p>大致上这就是 Class 的内存分布了，下面这张图能够简要的概括了：</p>
<p><img src="https://i.loli.net/2019/07/10/5d25a602083b146585.png" alt="类的内存分布"></p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a target="_blank" rel="noopener" href="http://melonteam.com/posts/objectc_dui_xiang_nei_cun_bu_ju_fen_xi/">ObjectC对象内存布局分析</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-07-03T13:32:56.000Z" title="7/3/2019, 9:32:56 PM">2019-07-03</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">28 分钟读完 (大约4241个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/03/Objective-C%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%8E%9F%E7%90%86/">Objective-C引用计数原理</a></h1><div class="content"><p>在 Objective-C 2.0 中，我们无需手动进行内存管理，因为ARC会自动帮我们在编译的时候，在合适的地方对对象进行<code>retain</code>和<code>release</code>操作。<br>本文将结合<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">runtime 750版本源码</a> 探究 ARC 环境下引用计数的实现原理。</p>
<h3 id="如何存储引用计数"><a href="#如何存储引用计数" class="headerlink" title="如何存储引用计数"></a>如何存储引用计数</h3><p>从 5S 开始，iPhone 都采用了64位架构的处理器，为了节省内存和提高执行效率，苹果提出了Tagged Pointer的概念，专门用来存储小的对象，例如 NSNumber 和 NSDate。这一类变量本身的值需要占用的内存大小常常不需要8字节，拿整数来说，4个字节所能表示的有符号整数可以达到20多亿(2^31&#x3D;2147483648，另外 1 位作为符号位)，基本可以处理大多数情况。所以我们将一个对象的指针(64位下8字节)拆成两部分，一部分用来存储数据，另一部分作为特殊标记，表示这是一个 <code>Tagged Pointer</code>, 不指向任何一个地址。也就是当某些类使用 <code>Tagged Pointer</code> 来存储数据后，它就不是一个对象了，因为它并没有指向任何地址，变成了一个披着对象皮的普通变量而已，而对于这一类的‘对象’，它的内存是分配在<code>栈</code>中，由系统分配以及释放，所以它的引用计数也没有意义了，当然你仍然可以使用<code>CFGetRetainCount</code>方法去获取它的引用计数，返回的是它的指针地址。</p>
<p><img src="https://i.loli.net/2019/07/03/5d1caefd8837b15758.jpeg"></p>
<p>而在某些平台中(比如arm64)，isa 实例的一部分空间也会被用来存储引用计数，当引用计数超过一定值之后，runtime 会使用一张散列表(哈希表)来管理其引用计数；如果不使用 isa 存储引用计数则会直接存储到散列表中。</p>
<h3 id="isa-指针"><a href="#isa-指针" class="headerlink" title="isa 指针"></a>isa 指针</h3><p>用64位(8字节)来存储一个内存地址显然是种浪费，于是可以将一部分的空间用来存储引用计数。当 isa 指针第一位为1时即表示使用优化的 isa 指针，这里列出64位环境下的 isa 结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">isa_t</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="type">isa_t</span>(<span class="type">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="type">uintptr_t</span> bits;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __arm64__</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MASK        0x00000001fffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MAGIC_MASK  0x000003fe00000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MAGIC_VALUE 0x000001a400000001ULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">uintptr_t</span> indexed           : <span class="number">1</span>;</span><br><span class="line">        <span class="type">uintptr_t</span> has_assoc         : <span class="number">1</span>;</span><br><span class="line">        <span class="type">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        <span class="type">uintptr_t</span> shiftcls          : <span class="number">30</span>; <span class="comment">// MACH_VM_MAX_ADDRESS 0x1a0000000</span></span><br><span class="line">        <span class="type">uintptr_t</span> magic             : <span class="number">9</span>;</span><br><span class="line">        <span class="type">uintptr_t</span> weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        <span class="type">uintptr_t</span> deallocating      : <span class="number">1</span>;</span><br><span class="line">        <span class="type">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        <span class="type">uintptr_t</span> extra_rc          : <span class="number">19</span>;</span><br><span class="line"><span class="meta">#       <span class="keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line"><span class="meta">#       <span class="keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// SUPPORT_NONPOINTER_ISA</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>SUPPORT_NONPOINTER_ISA</code>表示是否支持在 isa 指针内添加额外的信息，例如引用计数，析构状态，被__weak变量引用的情况等。目前仅支持 <code>arm64</code>架构的设备支持。</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>indexed</td>
<td>0 表示普通的 isa 指针，1 表示可以存储引用计数</td>
</tr>
<tr>
<td>has_assoc</td>
<td>表示该对象是否包含 associated object(关联对象)</td>
</tr>
<tr>
<td>has_cxx_dtor</td>
<td>表示该对象是否有 C++ 的析构函数</td>
</tr>
<tr>
<td>shiftcls</td>
<td>类的指针</td>
</tr>
<tr>
<td>magic</td>
<td>固定值为 0xd2，用于在调试时分辨对象是否未完成初始化</td>
</tr>
<tr>
<td>weakly_referenced</td>
<td>表示该对象是否有过 weak 对象，如果没有，则析构时更快</td>
</tr>
<tr>
<td>deallocating</td>
<td>表示该对象是否正在析构</td>
</tr>
<tr>
<td>has_sidetable_rc</td>
<td>表示该对象的引用计数值是否过大无法存储在 isa 指针</td>
</tr>
<tr>
<td>extra_rc</td>
<td>存储引用计数值减一后的结果</td>
</tr>
</tbody></table>
<p>在64位环境下，isa 会存储引用计数，当 has_sidetable_rc 的值为1时，那么溢出的引用计数将会存储在一张全局散列表中，也就是<code>引用计数 = isa保存的引用计数 + 哈希表保存的引用计数 + 1</code>。后面会详细讲到。</p>
<h3 id="哈希表-DenseMap"><a href="#哈希表-DenseMap" class="headerlink" title="哈希表 DenseMap"></a>哈希表 DenseMap</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,<span class="type">size_t</span>,<span class="literal">true</span>&gt; RefcountMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> KeyT, <span class="keyword">typename</span> ValueT,</span><br><span class="line">         <span class="type">bool</span> ZeroValuesArePurgeable = <span class="literal">false</span>, </span><br><span class="line">         <span class="keyword">typename</span> KeyInfoT = DenseMapInfo&lt;KeyT&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> DenseMap</span><br><span class="line">    : <span class="keyword">public</span> DenseMapBase&lt;DenseMap&lt;KeyT, ValueT, ZeroValuesArePurgeable, KeyInfoT&gt;,</span><br><span class="line">                          KeyT, ValueT, KeyInfoT, ZeroValuesArePurgeable&gt; </span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br><span class="line">                          </span><br></pre></td></tr></table></figure>

<p>runtime 使用 DenseMap 哈希表(也叫散列表，类似NSDictionary)的别名<code>RefcountMap</code>来存储引用计数。DenseMap 继承于 DenseMapBase 这个 C++ 类，通过观察 DenseMapBase 的内部实现我们可以发现以下几点：</p>
<ul>
<li>键 KeyT 的类型为<code>DisguisedPtr&lt;objc_object&gt;</code>，这个类是对<code>objc_object *</code>指针及其一些操作进行的封装，目的是不受内存泄漏工具<code>leaks</code>的检测 </li>
<li>值 ValueT 的类型为 size_t, size_t在64位环境下等同于 unsigned long。保存的值等于<code>引用计数减一</code></li>
<li>模板的 KeyInfoT 类型为 DenseMapInfo<KeyT>，在这里等同于DenseMapInfo&lt;DisguisedPtr<objc_object>&gt;。DenseMapInfo 封装了比较<code>重要</code>的方法，用于在哈希表中查找 key 映射的内容</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DenseMapInfo</span>&lt;T*&gt; &#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">inline</span> T* <span class="title">getEmptyKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uintptr_t</span> Val = <span class="built_in">static_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;T*&gt;(Val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">inline</span> T* <span class="title">getTombstoneKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uintptr_t</span> Val = <span class="built_in">static_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;T*&gt;(Val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="title">getHashValue</span><span class="params">(<span class="type">const</span> T *PtrVal)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">ptr_hash</span>((<span class="type">uintptr_t</span>)PtrVal);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">isEqual</span><span class="params">(<span class="type">const</span> T *LHS, <span class="type">const</span> T *RHS)</span> </span>&#123; <span class="keyword">return</span> LHS == RHS; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>指针哈希算法实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __LP64__</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">ptr_hash</span><span class="params">(<span class="type">uint64_t</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    key ^= key &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    key *= <span class="number">0x8a970be7488fda55</span>;</span><br><span class="line">    key ^= __builtin_bswap64(key);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint32_t</span>)key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>虽然不完美，但是速度很快(注释说的。。。)</p>
<hr>
<blockquote>
<p>简单来讲，DenseMap 通过对象的指针地址来映射其引用计数</p>
</blockquote>
<h3 id="SideTable"><a href="#SideTable" class="headerlink" title="SideTable"></a>SideTable</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SideTable</span> &#123;</span></span><br><span class="line">    <span class="type">spinlock_t</span> slock;</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    <span class="type">weak_table_t</span> weak_table;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>介绍完存储引用计数的哈希表，那么这个哈希表是存储在哪里的呢？<br>答案是保存在一个叫做<code>SideTable</code>的结构体中，通过观察它的结构组成，我们可以可以看到有三个成员变量<code>slock</code>, <code>refcnts</code>和<code>weak_table</code>。</p>
<ul>
<li><code>slock</code>是一个自旋锁，保证线程安全</li>
<li><code>refcnts</code>的类型是 RefcountMap，也就是上一节提到过的 DenseMap 类型的别名。用来保存引用计数</li>
<li><code>weak_table</code>用来保存__weak修饰的指针。当一个对象 delloc 时，通过这个表将这些指向要释放对象的用__weak修饰的指针置为nil，避免野指针的情况出现。</li>
</ul>
<h3 id="StripedMap"><a href="#StripedMap" class="headerlink" title="StripedMap"></a>StripedMap</h3><p>知道引用计数的哈希表是保存在<code>SideTable</code>中，那么<code>SideTable</code>实例保存在哪里呢？<br>答案是在一个全局的<code>StripedMap&lt;SideTable *&gt;</code>类型的静态变量<code>SideTableBuf</code>中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alignas</span>(StripedMap&lt;SideTable&gt;) <span class="type">static</span> <span class="type">uint8_t</span> </span><br><span class="line">    SideTableBuf[<span class="built_in">sizeof</span>(StripedMap&lt;SideTable&gt;)];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">SideTableInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> (SideTableBuf) <span class="built_in">StripedMap</span>&lt;SideTable&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> StripedMap&lt;SideTable&gt;&amp; <span class="title">SideTables</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">reinterpret_cast</span>&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以在初始化时将 SideTableBuf 定义成 uint8_t 是因为方便计算内存大小，在<code>SideTables()</code>方法中我们可以看到<code>SideTableBuf</code>会被强制转换成<code>StripedMap&lt;SideTable&gt;*</code>类型。实际上 SideTableBuf 也是哈希表，根据指针地址映射到相应的<code>SideTable</code>类型的变量。下面是<code>StripedMap</code>这个类的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StripedMap</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">8</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">64</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PaddedT</span> &#123;</span><br><span class="line">        <span class="function">T value <span class="title">alignas</span><span class="params">(CacheLineSize)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    PaddedT array[StripeCount];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">indexForPointer</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p)</span> </span>&#123;</span><br><span class="line">        <span class="type">uintptr_t</span> addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(p);</span><br><span class="line">        <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[] (<span class="type">const</span> <span class="type">void</span> *p) &#123; </span><br><span class="line">        <span class="keyword">return</span> array[<span class="built_in">indexForPointer</span>(p)].value; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>StripedMap</code>中有一个<code>PaddedT</code>类型的数组array，在模拟器中容量为64，在真机中为8。<code>PaddedT</code>结构体大小为64个字节，其成员变量 value 的类型实际是我们之前传入 <code>SideTable</code>。当系统调用<code>SideTable&amp; table = SideTables()[]</code>时首先会执行<code>SideTables()</code>得到SideTableBuf， 然后在StripedMap中执行<code>T&amp; operator[] (const void *p)</code>方法获取相应的SideTable。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T&amp; operator[] (const void *p) &#123; </span><br><span class="line">        return array[indexForPointer(p)].value; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">static unsigned int indexForPointer(const void *p) &#123;</span><br><span class="line">    uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(p);</span><br><span class="line">    return ((addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)) % StripeCount;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在<code>indexForPointer()</code>函数中返回相应 SideTable 的index。<code>(addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)</code>这一步我也不是很懂，应该是类似于产生一个随机数，后面的<code>% StripeCount</code>返回一个 [0, StripeCount)的数，也就是相应 SideTable 的index。所以一个 SideTable 应该是对应许多的对象的。</p>
<hr>
<blockquote>
<p>保存引用计数的哈希表保存在<code>SideTable</code>结构体中，而<code>SideTable</code>保存在一个全局的静态变量<code>StripedMap&lt;SideTable&gt; SideTableBuf</code>中。在真机下，SideTableBuf能够储存8个<code>SideTable</code>实例。<code>StripedMap</code>的方法<code>indexForPointer()</code>通过对象的指针计算出相应 SideTable 的 index。一个 SideTable 对应多个对象</p>
</blockquote>
<h3 id="获取引用计数"><a href="#获取引用计数" class="headerlink" title="获取引用计数"></a>获取引用计数</h3><p>在 ARC 环境下我们可以使用方法<code>CFGetRetainCount</code>得到对象的引用计数。在 runtime 中，通过调用<code>objc_object</code>的<code>rootRetainCount()</code>获取引用计数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uintptr_t</span> </span></span><br><span class="line"><span class="function"><span class="title">objc_object::rootRetainCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span> (<span class="type">uintptr_t</span>)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sidetable_lock</span>();</span><br><span class="line">    <span class="type">isa_t</span> bits = <span class="built_in">LoadExclusive</span>(&amp;isa.bits);</span><br><span class="line">    <span class="built_in">ClearExclusive</span>(&amp;isa.bits);</span><br><span class="line">    <span class="keyword">if</span> (bits.nonpointer) &#123;</span><br><span class="line">        <span class="type">uintptr_t</span> rc = <span class="number">1</span> + bits.extra_rc;</span><br><span class="line">        <span class="keyword">if</span> (bits.has_sidetable_rc) &#123;</span><br><span class="line">            rc += <span class="built_in">sidetable_getExtraRC_nolock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sidetable_unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sidetable_unlock</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sidetable_retainCount</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>isTaggedPointer</code>在前面我们已经分析过了如果是<code>Tagged Pointer</code>类型的对象时是怎么样的。此时对象在栈中分配，由系统自动销毁内存(先进后出）,所以此时对它求引用计数返回其地址。<br>下面让我们重点看一下<code>sidetable_retainCount()</code>这个方法</li>
<li>当 isa 的 nonpointer &#x3D; 1 的情况我们开头也分析过了，此时 isa 指针也用来存储引用计数，如果引用计数溢出则将溢出部分存储在哈希表中</li>
<li>下面让我们研究一下不使用isa优化是怎么从哈希表中获取引用计数的</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">objc_object::sidetable_retainCount()</span><br><span class="line">&#123;</span><br><span class="line">    SideTable&amp; table = SideTables()[this];</span><br><span class="line"></span><br><span class="line">    size_t refcnt_result = 1;</span><br><span class="line">    </span><br><span class="line">    table.lock();</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(this);</span><br><span class="line">    if (it != table.refcnts.end()) &#123;</span><br><span class="line">        // this is valid for SIDE_TABLE_RC_PINNED too</span><br><span class="line">        refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">    return refcnt_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol>
<li>首先得到 SideTable 实例。</li>
<li>成员变量 refcnts 就是之前说的保存引用计数的哈希表，在哈希表中根据指针值查找引用计数。</li>
<li><code>it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT</code> 注意result从第三位才开始保存数据，所以需要将数据向右移动2位才能取到引用计数。第1位用来保存该对象是否被用__weak修饰的变量引用，第2位用来表示该对象是否正在析构</li>
<li>将右移后得到的数+1(refcnt_result)后返回。这也是为什么之前说哈希表保存的引用计数是实际值 -1 之后的值的原因。</li>
</ol>
<h3 id="Retain"><a href="#Retain" class="headerlink" title="Retain"></a>Retain</h3><p>在非 ARC 环境中可以使用<code>retain</code>和<code>release</code>方法对引用计数进行加减操作，在 ARC 环境中我们无需也无法使用这两个方法操作引用计数，但是你可以使用<code>CFRetain()</code>对对象进行 retain 操作。最终会调用 <code>objc_object</code>的<code>rootRetain</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> id </span></span><br><span class="line"><span class="function"><span class="title">objc_object::rootRetain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!UseGC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sidetable_retain</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>类似于上一节中获取引用计数的方法，当对象属于<code>Tagged Pointer</code>时则返回该对象。所以我们接着看<code>sidetable_retain()</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_object::sidetable_retain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    <span class="built_in">assert</span>(!isa.nonpointer);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    SideTable&amp; table = <span class="built_in">SideTables</span>()[<span class="keyword">this</span>];</span><br><span class="line">    </span><br><span class="line">    table.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="type">size_t</span>&amp; refcntStorage = table.refcnts[<span class="keyword">this</span>];</span><br><span class="line">    <span class="keyword">if</span> (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        refcntStorage += SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    table.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先得到 SideTable 实例。从实例中得到存储引用技术的哈希表<code>refcnts</code>，在哈希表中根据对象的地址找到对应的引用计数<code>refcntStorage</code>，判断引用计数的值是否有溢出，如果没有则对引用计数 + 1，返回对象。<br>上一节我们讲过 refcntStorage 中第三位才开始用来存储引用计数，所以读数时需要先往右边移动两位，那为什么这里的代码没有呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIDE_TABLE_DEALLOCATING      (1UL&lt;&lt;1)  <span class="comment">// MSB-ward of weak bit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIDE_TABLE_RC_ONE            (1UL&lt;&lt;2)  <span class="comment">// MSB-ward of deallocating bit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIDE_TABLE_RC_PINNED         (1UL&lt;&lt;(WORD_BITS-1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIDE_TABLE_RC_SHIFT 2</span></span><br></pre></td></tr></table></figure>

<p>注意观察<code>SIDE_TABLE_RC_ONE</code>的定义，是一个8字节的 unsigned long 类型，值为1，向左偏移了两位。<code>refcntStorage += SIDE_TABLE_RC_ONE</code>两者相加的话则直接从第三位开始相加了，所以可以使用 SIDE_TABLE_RC_ONE 对引用计数进行 +1 和 -1 操作。<br>同样的，在上面的代码中, <code>SIDE_TABLE_RC_PINNED</code>用来判断引用计数值是否有溢出。</p>
<h3 id="Release"><a href="#Release" class="headerlink" title="Release"></a>Release</h3><p>release 最终会调用 <code>objc_object</code>的方法<code>rootRelease()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> </span></span><br><span class="line"><span class="function"><span class="title">objc_object::rootRelease</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sidetable_release</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uintptr_t</span> <span class="title">objc_object::sidetable_release</span><span class="params">(<span class="type">bool</span> performDealloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    <span class="built_in">assert</span>(!isa.nonpointer);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    SideTable&amp; table = <span class="built_in">SideTables</span>()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> do_dealloc = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    table.<span class="built_in">lock</span>();</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.<span class="built_in">find</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it == table.refcnts.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        do_dealloc = <span class="literal">true</span>;</span><br><span class="line">        table.refcnts[<span class="keyword">this</span>] = SIDE_TABLE_DEALLOCATING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) &#123;</span><br><span class="line">        <span class="comment">// SIDE_TABLE_WEAKLY_REFERENCED may be set. Don&#x27;t change it.</span></span><br><span class="line">        do_dealloc = <span class="literal">true</span>;</span><br><span class="line">        it-&gt;second |= SIDE_TABLE_DEALLOCATING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        it-&gt;second -= SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    table.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">if</span> (do_dealloc  &amp;&amp;  performDealloc) &#123;</span><br><span class="line">        ((<span class="built_in">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_dealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> do_dealloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法你可以知道为什么哈希表中保存的引用计数是实际值 -1 之后的值。<br><code>it-&gt;second &lt; SIDE_TABLE_DEALLOCATING</code>用来判断保存的引用计数值是否小于1，如果小于1的话则对该值标记为正在析构：<code>it-&gt;second |= SIDE_TABLE_DEALLOCATING;</code>，并且在随后对该对象发送 delloc 消息。<br>举个例子，一个对象 sark，实际的引用计数为1，在哈希表中保存的值为0，当这个对象进行<code>release</code>操作后，sark 的引用计数变成了0，也就是需要进行销毁操作了。而到了该方法中，会判断保存的引用计数的值是否小于1，如果是的话则进行 delloc 操作，并且将哈希表中存储的值标记为<code>正在析构</code>状态。而 sark 原先保存着的引用计数值就是 &#x3D;0，这样设计避免了在哈希表存储的引用计数出现负数的情况。</p>
<h3 id="alloc，new，-copy-和-mutableCopy"><a href="#alloc，new，-copy-和-mutableCopy" class="headerlink" title="alloc，new， copy 和 mutableCopy"></a>alloc，new， copy 和 mutableCopy</h3><p><code>copy</code> 以及 <code>mutableCopy</code>是<code>NSCopying</code>和<code>NSMutableCopying </code>协议上的方法，需要在各类上自己去实现<code>copyWithZone: </code>和<code>mutableCopyWithZone:</code>方法。无论是深拷贝还是浅拷贝都会增加引用计数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (id)new &#123;</span><br><span class="line">    return [callAlloc(self, false/*checkNil*/) init];</span><br><span class="line">&#125;</span><br><span class="line">+ (id)alloc &#123;</span><br><span class="line">    return _objc_rootAlloc(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>[cls alloc]</code>以及<code>[cls allocWithZone:nil]</code>方法最终会调用<code>callAlloc()</code>方法，所以 alloc 和 new 这两个方法后面都会调用<code>callAlloc()</code>这个方法,因为 Objective-C 2.0 忽视垃圾回收和 NSZone，那么后续的调用顺序依次是为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">callAlloc()</span><br><span class="line">class_createInstance()</span><br><span class="line">_class_createInstanceFromZone</span><br><span class="line">calloc()</span><br></pre></td></tr></table></figure>

<p><code>calloc()</code>函数相比于<code>malloc()</code>函数的优点是它将分配的内存区域初始化为0，相当于<code>malloc()</code>后再用<code>memset()</code>方法初始化一遍。</p>
<h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>其实这一节是对上一节内容的补充。<br>记得我刚出来工作的时候，单例是这样写的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Son</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)shareManager</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> Son *son;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        son = [<span class="variable language_">super</span> allocWithZone:<span class="literal">nil</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> son;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> shareManager];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>当时组长问我为什么要这样子写(因为跟他们写的方式不一样)，我也答不上来，因为这种代码都是直接google的。但是看了<code>callAlloc()</code>实现之后我明白为什么了。<br>在上一节我们已经知道了 alloc 和 new 都会接着调用<code>callAlloc()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> ALWAYS_INLINE id</span></span><br><span class="line"><span class="function"><span class="title">callAlloc</span><span class="params">(Class cls, <span class="type">bool</span> checkNil, <span class="type">bool</span> allocWithZone=<span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(checkNil &amp;&amp; !cls)) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(!cls-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">hasCustomAWZ</span>())) &#123;</span><br><span class="line">        <span class="comment">// No alloc/allocWithZone implementation. Go straight to the allocator.</span></span><br><span class="line">        <span class="comment">// fixme store hasCustomAWZ in the non-meta class and </span></span><br><span class="line">        <span class="comment">// add it to canAllocFast&#x27;s summary</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fastpath</span>(cls-&gt;<span class="built_in">canAllocFast</span>())) &#123;</span><br><span class="line">            <span class="comment">// No ctors, raw isa, etc. Go straight to the metal.</span></span><br><span class="line">            <span class="type">bool</span> dtor = cls-&gt;<span class="built_in">hasCxxDtor</span>();</span><br><span class="line">            id obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, cls-&gt;bits.<span class="built_in">fastInstanceSize</span>());</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!obj)) <span class="keyword">return</span> <span class="built_in">callBadAllocHandler</span>(cls);</span><br><span class="line">            obj-&gt;<span class="built_in">initInstanceIsa</span>(cls, dtor);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Has ctor or raw isa or something. Use the slower path.</span></span><br><span class="line">            id obj = <span class="built_in">class_createInstance</span>(cls, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!obj)) <span class="keyword">return</span> <span class="built_in">callBadAllocHandler</span>(cls);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// No shortcuts available.</span></span><br><span class="line">    <span class="keyword">if</span> (allocWithZone) <span class="keyword">return</span> [cls allocWithZone:nil];</span><br><span class="line">    <span class="keyword">return</span> [cls alloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果类重载了<code>allocWithZone</code>方法，那么<code>cls-&gt;ISA()-&gt;hasCustomAWZ()</code>将会返回YES，也就是说当我们用<code>alloc</code>或者<code>new</code>创建实例的时候，就不会走系统的方法，而会走重载的<code>allocWithZone</code>方法了。我们在重载<code>allocWithZone</code>方法时返回<code>[self shareManager]</code>（注意此时的self代表Son类）, 因为<code>shareManager</code>方法返回的是一个静态变量。</p>
<p>还有一个需要注意的点就是在<code>shareManager</code>中，我们使用<code>son = [super allocWithZone:nil];</code>初始化实例，为什么不使用<code>son = [[super alloc] init];</code>来初始化呢？<br>代码中的<code>[super alloc];</code>在编译后会变成<code>objc_msgSendSuper(objc_super super, @selector(alloc))</code>(大致意思是这样)。其中<code>objc_super</code>是一个结构体，只有两个成员变量<code>id receiver</code>和<code>Class class</code>，receiver 仍是 self（Son类）， class 为 Father类。当我们想通过<code>[super alloc]</code>创建实例的时候，会从 Father类中查找 +alloc 方法，如果没有实现则在 NSObject 中查找 +alloc 方法。而方法里面的参数 self 仍旧为 Son 类而不是 Father 类，所以还是会去调用重载的<code>allocWithZone</code>方法，导致死循环。</p>
<!--### 自动释放池 AutoreleasePool

在 ARC 中，AutoreleasePool 其实是一个已`AutoreleasePoolPage`为节点的双向链表。

- 每一个线程的都有一个相对应的 AutoreleasePool，AutoreleasePoolPage 的成员变量`pthread_t const thread;`即为指向该线程的指针
- AutoreleasePoolPage

```

```-->
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2015/12/06/The-Principle-of-Refenrence-Counting/">Objective-C 引用计数原理</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-06-28T06:10:55.000Z" title="6/28/2019, 2:10:55 PM">2019-06-28</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">16 分钟读完 (大约2351个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/06/28/%E8%B0%88Objective-C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/">谈Objective-C关联对象</a></h1><div class="content"><h3 id="前言"><a href="#前言" class="headerlink" title="#前言"></a>#前言</h3><p>前不久刚写了 <a target="_blank" rel="noopener" href="https://kikido.github.io/2019/06/27/%E8%B0%88Objective-C%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/">谈Objective-C类成员变量</a> ，分析了成员变量的实现原理以及不能动态添加的原因，在这篇文章里我们来根据  <a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">objc4-646.tar.gz版本</a> 源码来谈一下 Objective-C 关联对象的实现原理。</p>
<p>关联对象(Associated Objects)是 Objective-C 2.0运行时的一个特性，起始于OS X Snow Leopard和iOS 4。它允许开发者对已经存在的类在扩展中添加自定义的属性。相关参考可以查看 <code>&lt;objc/runtime.h&gt;</code> 中定义的三个允许你将任何键值在运行时关联到对象上的函数：</p>
<ul>
<li>void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) 用于给对象添加关联属性，传入nil则移除已有的关联对象</li>
<li>id objc_getAssociatedObject(id object, const void *key) 用于获取关联属性</li>
<li>void objc_removeAssociatedObjects(id object) 移除一个对象所有的关联属性，但不建议手动调用这个函数，因为这可能会导致其它人对其添加的属性也被移除了。你可以调用<code>objc_setAssociatedObject</code>方法并传入nil来指定移除某个关联</li>
</ul>
<p>下面分析一下 <code>objc_setAssociatedObject</code> 两个参数 <code>key</code> 和 <code>policy</code></p>
<h3 id="key"><a href="#key" class="headerlink" title="#key"></a>#key</h3><p>通常来说该属性应该是常量、唯一的，在getter和setter方法中都可以访问到。这里有两种常见的添加方式：</p>
<p>第一种是添加 static char 类型的变量，当然更推荐是指针型的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">char</span> kAssociatedObjectKey;</span><br><span class="line">- (<span class="type">void</span>)setMenber:(<span class="built_in">NSString</span> *)menber &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;kAssociatedObjectKey, menber, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然更<em>推荐</em>的是使用更简单的方式实现：用 selector(getter方法)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setMenber:(<span class="built_in">NSString</span> *)menber &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(menber), menber, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关联策略-policy"><a href="#关联策略-policy" class="headerlink" title="#关联策略 policy"></a>#关联策略 policy</h3><p>关联策略跟属性修饰符的使用方法差不多，属性可以根据定义在 objc_AssociationPolicy 上的类型被关联到对象上：</p>
<table>
<thead>
<tr>
<th>关联策略</th>
<th>等价属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>OBJC_ASSOCIATION_ASSIGN</td>
<td>@property (assign)或 @property (unsafe_unretained)</td>
<td>弱引用关联对象</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td>@property (nonatomic, strong)</td>
<td>强引用关联对象，且为非原子操作</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td>@property (nonatomic, copy)</td>
<td>复制关联对象，且为非原子操作</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN</td>
<td>@property (atomic, strong)</td>
<td>强引用关联对象，且为原子操作</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY</td>
<td>@property (atomic, copy)</td>
<td>复制关联对象，且为原子操作</td>
</tr>
</tbody></table>
<h3 id="关联对象实现"><a href="#关联对象实现" class="headerlink" title="#关联对象实现"></a>#关联对象实现</h3><p>下面让我们具体来分析一下这几个函数的具体实现吧！</p>
<h4 id="分析objc-setAssociatedObject实现"><a href="#分析objc-setAssociatedObject实现" class="headerlink" title="分析objc_setAssociatedObject实现"></a>分析objc_setAssociatedObject实现</h4><p>在<code>objc_setAssociatedObject</code>的实现被定义在<code>objc-auto.mm</code>文件 467 行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GC_RESOLVER</span>(objc_setAssociatedObject)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GC_RESOLVER(name)                                       \</span></span><br><span class="line"><span class="meta">    OBJC_EXPORT void *name##_resolver(void) __asm__(<span class="string">&quot;_&quot;</span> #name); \</span></span><br><span class="line"><span class="meta">    void *name##_resolver(void)                                 \</span></span><br><span class="line"><span class="meta">    &#123;                                                           \</span></span><br><span class="line"><span class="meta">        __asm__(<span class="string">&quot;.symbol_resolver _&quot;</span> #name);                    \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (UseGC) return (void*)name##_gc;                     \</span></span><br><span class="line"><span class="meta">        <span class="keyword">else</span> return (void*)name##_non_gc;                       \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>## 符号: 连接宏。举个例子：<code>#define COMMAND(A, B) A##B</code> ， int COMMAND(temp, Int) &#x3D; 10 等同于 int tempInt &#x3D; 10</li>
<li>UseGC 是否使用垃圾回收，在 iPhone 平台上被定义为 NO<br> 所以这个宏展开来为下面的代码</li>
</ul>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GC_RESOLVER</span><span class="params">(name)</span>                                 </span></span><br><span class="line"><span class="function"></span>&#123;                                                           </span><br><span class="line">   <span class="keyword">return</span> (<span class="type">void</span>*)<span class="built_in">objc_setAssociatedObject_non_gc</span>();                       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>objc_setAssociatedObject_non_gc</code>的实现在<code>objc-runtime.m</code>文件，再经过一些跳转，可以发现 objc_setAssociatedObject 最终会调用 <code>_object_set_associative_reference</code>方法 （objc-runtime.m 268行）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _object_set_associative_reference(id object, <span class="type">void</span> *key, id value, <span class="type">uintptr_t</span> policy) &#123;</span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    <span class="function">ObjcAssociation <span class="title">old_association</span><span class="params">(<span class="number">0</span>, nil)</span></span>;</span><br><span class="line">    id new_value = value ? <span class="built_in">acquireValue</span>(value, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.associations())</span></span>;</span><br><span class="line">        <span class="type">disguised_ptr_t</span> disguised_object = <span class="built_in">DISGUISE</span>(object);</span><br><span class="line">        <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">            <span class="comment">// break any existing association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.<span class="built_in">find</span>(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i != associations.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="comment">// secondary table exists</span></span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;<span class="built_in">find</span>(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = <span class="built_in">ObjcAssociation</span>(policy, new_value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    (*refs)[key] = <span class="built_in">ObjcAssociation</span>(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// create the new association (first time).</span></span><br><span class="line">                ObjectAssociationMap *refs = <span class="keyword">new</span> ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = <span class="built_in">ObjcAssociation</span>(policy, new_value);</span><br><span class="line">                object-&gt;<span class="built_in">setHasAssociatedObjects</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// setting the association to nil breaks the association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.<span class="built_in">find</span>(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i !=  associations.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;<span class="built_in">find</span>(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;<span class="built_in">erase</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line">    <span class="keyword">if</span> (old_association.<span class="built_in">hasValue</span>()) <span class="built_in">ReleaseValue</span>()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>AssociationsManager manager;</code>, 会创建一个<code>AssociationsManager</code>结构体的变量 manager，在调用它的构造函数时会上锁，调用析构函数时解锁。结构体内有一个静态变量 <code>AssociationsHashMap</code>, 懒加载该变量。</li>
<li>DISGUISE(object) 用来获取 object 的指针地址</li>
<li><code>AssociationsHashMap</code>是一个无序的哈希表，维护了从对象地址到 ObjectAssociationMap 的映射</li>
<li>ObjectAssociationMap 是一个map，维护了从 key 到 ObjcAssociation 的映射</li>
<li>ObjcAssociation 是一个 C++ 类， 主要包括两个成员变量：uintptr_t _policy(关联策略) id _value(关联对象的值)</li>
</ul>
<p>简单的讲解上面那个函数的流程：</p>
<blockquote>
<ol>
<li>新建一个 AssociationsManager 实例 manager，同时上锁。通过 manager 得到 AssociationsHashMap 关联哈希表 associations，通过 DISGUISE()函数得到 object 的指针 disguised_object。在哈希表 associations 中 根据 disguised_object 查找 ObjectAssociationMap，如果没有则新建一个 refs。</li>
<li>新建一个 ObjcAssociation 实例 new_association，存储在 refs 中</li>
<li>如果传入的value是nil，则在 refs 移除该映射关系</li>
<li>释放掉旧的 old_association</li>
<li>作用域结束释放掉 manager，解锁</li>
</ol>
</blockquote>
<p><img src="https://i.loli.net/2019/06/28/5d15d6bfbe06f14691.png" alt="添加关联对象流程图"></p>
<h4 id="分析objc-getAssociatedObject实现"><a href="#分析objc-getAssociatedObject实现" class="headerlink" title="分析objc_getAssociatedObject实现"></a>分析objc_getAssociatedObject实现</h4><p>按照上一节的流程，我们首先找到 objc_getAssociatedObject 的最终实现源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">id _object_get_associative_reference(id object, <span class="type">void</span> *key) &#123;</span><br><span class="line">    id value = nil;</span><br><span class="line">    <span class="type">uintptr_t</span> policy = OBJC_ASSOCIATION_ASSIGN;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.associations())</span></span>;</span><br><span class="line">        <span class="type">disguised_ptr_t</span> disguised_object = <span class="built_in">DISGUISE</span>(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.<span class="built_in">find</span>(disguised_object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j = refs-&gt;<span class="built_in">find</span>(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs-&gt;<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ObjcAssociation &amp;entry = j-&gt;second;</span><br><span class="line">                value = entry.<span class="built_in">value</span>();</span><br><span class="line">                policy = entry.<span class="built_in">policy</span>();</span><br><span class="line">                <span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((<span class="built_in">id</span>(*)(id, SEL))objc_msgSend)(value, SEL_retain);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span><br><span class="line">        ((<span class="built_in">id</span>(*)(id, SEL))objc_msgSend)(value, SEL_autorelease);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码量比上一节少了还挺多哈，过程也类似，就不讲的很细了</p>
<blockquote>
<ol>
<li>先得到 AssociationsHashMap 实例 associations（静态变量）。根据 object 的指针地址，在 associations 得到映射的 ObjectAssociationMap refs。</li>
<li>在 refs 根据 key 得到映射的 ObjcAssociation 实例 entry，在 entry 中可以得到成员变量 _value，也就是我们所关联属性的值。</li>
<li>根据关联策略 policy 进行相应的操作(autorelease, retain)后返回 value</li>
</ol>
</blockquote>
<h4 id="分析objc-removeAssociatedObjects实现"><a href="#分析objc-removeAssociatedObjects实现" class="headerlink" title="分析objc_removeAssociatedObjects实现"></a>分析objc_removeAssociatedObjects实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _object_remove_assocations(id object) &#123;</span><br><span class="line">    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.associations())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (associations.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">disguised_ptr_t</span> disguised_object = <span class="built_in">DISGUISE</span>(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.<span class="built_in">find</span>(disguised_object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// copy all of the associations that need to be removed.</span></span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            <span class="keyword">for</span> (ObjectAssociationMap::iterator j = refs-&gt;<span class="built_in">begin</span>(), end = refs-&gt;<span class="built_in">end</span>(); j != end; ++j) &#123;</span><br><span class="line">                elements.<span class="built_in">push_back</span>(j-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// remove the secondary table.</span></span><br><span class="line">            <span class="keyword">delete</span> refs;</span><br><span class="line">            associations.<span class="built_in">erase</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the calls to releaseValue() happen outside of the lock.</span></span><br><span class="line">    for_each(elements.<span class="built_in">begin</span>(), elements.<span class="built_in">end</span>(), <span class="built_in">ReleaseValue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实不看代码应该也能够猜出个大概了吧.</p>
<ol>
<li>根据 object地址 找到映射的 refs，遍历 refs，将保存着的 value 保存在 <code>vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements</code></li>
<li>删除 refs， 然后一个个的释放 elements 里面的值</li>
</ol>
</blockquote>
<h3 id="给类对象关联对象"><a href="#给类对象关联对象" class="headerlink" title="#给类对象关联对象"></a>#给类对象关联对象</h3><p>看完源代码后，我们知道实例对象地址与 ObjectAssociationMap map是一一对应的。那么是否可以给类对象添加关联对象呢？<br>答案是<em>可以</em>，因为Class也是一个对象，我们完全可以用同样的方式给类对象添加关联对象，只不过我们一般情况下不会这样做，因为更多时候可以通过 static 变量来实现类级别的变量。</p>
<p>你可以通过下面的代码这样操作</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">AssociatedObject</span>)</span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)associatedObject &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(associatedObject));</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">void</span>)setAssociatedObject:(<span class="built_in">NSString</span> *)associatedObject &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(associatedObject), associatedObject, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>) foo &#123;</span><br><span class="line">    <span class="built_in">NSObject</span>.associatedObject = <span class="string">@&quot;associatedObject&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="何时释放关联对象"><a href="#何时释放关联对象" class="headerlink" title="#何时释放关联对象"></a>#何时释放关联对象</h3><p>在 <a target="_blank" rel="noopener" href="https://kikido.github.io/2019/06/24/%E6%8E%A2%E7%A9%B6ARC%E4%B8%8Bdealloc%E5%AE%9E%E7%8E%B0/">探究ARC下dealloc实现</a> 中我们研究过，当对象引用计数变为0时会调用 dealloc 方法，然后最终调用 <code>objc_destructInstance</code> 方法来执行释放所有<code>__weak</code>修饰的指向该对象的指针，释放关联对象，释放该对象成员变量的操作</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *objc_destructInstance(<span class="type">id</span> obj) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="type">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        <span class="type">bool</span> assoc = !UseGC &amp;&amp; obj-&gt;hasAssociatedObjects();</span><br><span class="line">        <span class="type">bool</span> dealloc = !UseGC;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) object_cxxDestruct(obj);</span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);</span><br><span class="line">        <span class="keyword">if</span> (dealloc) obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _object_remove_assocations(<span class="type">id</span> object) &#123;</span><br><span class="line">    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        <span class="keyword">if</span> (associations.size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            <span class="comment">// copy all of the associations that need to be removed.</span></span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            <span class="keyword">for</span> (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123;</span><br><span class="line">                elements.push_back(j-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// remove the secondary table.</span></span><br><span class="line">            delete refs;</span><br><span class="line">            associations.erase(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the calls to releaseValue() happen outside of the lock.</span></span><br><span class="line">    for_each(elements.begin(), elements.end(), ReleaseValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是有点熟悉呢，在上上节中我们刚刚分析过这个方法。当对象 dealloc 时，会自动调用 <code>objc_removeAssociatedObjects</code> 方法来释放所有的关联对象。</p>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="#总结一下"></a>#总结一下</h3><ul>
<li>类实例跟关联对象(关联的属性)并没有直接的存储关系，关联对象在创建时后存储在一个静态哈希表中，根据类实例的指针映射到该关联对象</li>
<li>当类实例 dealloc 后，会从哈希表中释放该实例的所有的关联对象</li>
<li>关联对象的关联策略跟属性的修饰符非常的相似，要合理使用避免 crash</li>
<li>比起其他解决问题的方法，关联对象应该被视为最后的选择</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="#引用"></a>#引用</h3><ul>
<li><a target="_blank" rel="noopener" href="https://nshipster.cn/associated-objects/">Associated Objects</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-06-27T06:39:18.000Z" title="6/27/2019, 2:39:18 PM">2019-06-27</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">18 分钟读完 (大约2697个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/06/27/%E8%B0%88Objective-C%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/">谈Objective-C类成员变量</a></h1><div class="content"><h3 id="我是前言"><a href="#我是前言" class="headerlink" title="#我是前言"></a>#我是前言</h3><p>Objective-C 是一门动态语言，所以它总是将一些决定工作从编译延迟到运行时，也就是说只有编译器是不够的，还需要一个运行时系统来执行编译后的代码。这就是 runtime 存在的意义，它是 Objective-C 框架的一块基石。<br>runtime 有两个版本：modeen 和 leagcy，我们现在使用的是 modern 版的。<br>本文 runtime 源码为<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">objc4-646.tar.gz版本</a></p>
<p>在老版本的 runtime 中，如果修改了<em>基类</em>的成员变量布局（比如增加成员变量），<em>子类</em>需要重新编译。</p>
<p><img src="https://i.loli.net/2019/06/27/5d1466cdd97f541342.png" alt="父类NSObject，子类MyObject成员变量布局"></p>
<p>如果苹果发布了新的 iOS SDK，NSObject 增加了几个成员变量，那么我们原先的代码将无法运行。因为 MyObject 成员变量布局在编译时就确定了，父类新增的成员变量的地址跟子类成员变量的内存区域重叠了。此时，我们只能重新编译 MyObject 的代码，程序才能在新版本系统上运行。如果 MyObject 存在于别人编写的静态库，那我们只能希望作者快点发布新版本了。</p>
<p><img src="https://i.loli.net/2019/06/27/5d14680dd97fe55738.png" alt="新版本后NSObject，MyObject的成员变量布局"></p>
<p><code>非脆弱[Non-fragile]</code>实例变量是新版 Objective-C 的一个新功能，应用于iPhone和64位Mac上。它们提供给框架开发者更多的灵活性，且不会失去二进制的兼容性</p>
<p><img src="https://i.loli.net/2019/06/27/5d1469a9a290976437.png" alt="非脆弱成员变量"></p>
<h3 id="如何寻址成员变量"><a href="#如何寻址成员变量" class="headerlink" title="#如何寻址成员变量"></a>#如何寻址成员变量</h3><p>点开 runtime 的源码，让我们找到 ivar 的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类实例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">isa_t</span> isa;</span><br><span class="line"><span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">isa_t</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="type">isa_t</span>(<span class="type">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="type">uintptr_t</span> bits;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="type">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="type">class_data_bits_t</span> bits;  </span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_data_bits_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">class_rw_t</span>* <span class="title function_">data</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="type">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">class_ro_t</span> *ro;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="type">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="type">uint32_t</span> instanceSize;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="type">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * name;</span><br><span class="line">    <span class="type">const</span> <span class="type">method_list_t</span> * baseMethods;</span><br><span class="line">    <span class="type">const</span> <span class="type">protocol_list_t</span> * baseProtocols;</span><br><span class="line">    <span class="type">const</span> <span class="type">ivar_list_t</span> * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="type">const</span> <span class="type">property_list_t</span> *baseProperties;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/06/27/5d14b8a1a902a62244.png" alt="image"></p>
<ul>
<li>每个 OC 类实例实际上都是一个内存上指向<code>objc_object</code>结构体的指针，成员变量 isa 有指向<code>objc_class</code>结构体的指针<code>Class cls;</code></li>
<li>在<code>class_ro_t</code>结构体中可以找到成员变量<code> const ivar_list_t * ivars</code>，这个就是存储类所有成员变量的列表</li>
<li>在<code>class_ro_t</code>结构体中成员变量<code>const uint8_t * ivarLayout;</code>和<code>const uint8_t * weakIvarLayout;</code>的作用可以看一下<a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2015/09/13/class-ivar-layout/">孙源的这篇博客</a></li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *_age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>clang -rewrite-objc MyObject.h</code> 将代码转化成 C++ 实现，你可以看到编译后的 MyObject 实例的内存布局：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyObject_IMPL</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> <span class="title">NSObject_IVARS</span>;</span></span><br><span class="line">	NSString *__strong _age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> &#123;</span></span><br><span class="line">	__unsafe_unretained Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><img src="https://i.loli.net/2019/06/27/5d14b9ee7ccf877916.jpg" alt="类实例内存布局"></p>
<p><code>ivar_list_t</code> 结构体的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_list_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> entsize;</span><br><span class="line">    <span class="type">uint32_t</span> count;</span><br><span class="line">    <span class="type">ivar_t</span> first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></span><br><span class="line">    <span class="type">int32_t</span> *offset;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *type;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以看到<code>ivar_t</code>有名为<code>offset</code>的成员变量，这个就是成员变量在对象中的位置偏移量。在应用启动时，如果父类size变大时，runtime 会通过修改 offset，更新成员变量的偏移量，来正确的找到成员变量的地址。</p>
<hr>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *_age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></span><br><span class="line">- (<span class="type">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">self</span> -&gt; _age = <span class="string">@&quot;hhh&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>使用命令行<code>clang -F -cc1 -S -emit-llvm -fblocks MyObject.m</code>，将代码编译成 IR(intermediate representation)。<br>注意要加*-F*，好多人的博客里面都少了这个标志，会报错。在 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/18060469/fatal-error-foundation-foundation-h-no-such-file-or-directory">stackoverflow</a> 找到答案。<br>下面是编译后的代码：</p>
<!--fixme 分析ir代码-->
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@&quot;OBJC_IVAR_$_MyObject._age&quot; = hidden global i64 8, section &quot;__DATA, __objc_ivar&quot;, align 8</span><br><span class="line">// ...</span><br><span class="line">%6 = load i64, i64* @&quot;OBJC_IVAR_$_MyObject._age&quot;, align 8, !invariant.load !8</span><br><span class="line">%7 = bitcast %0* %5 to i8*</span><br><span class="line">%8 = getelementptr inbounds i8, i8* %7, i64 %6</span><br><span class="line">%9 = bitcast i8* %8 to %1**</span><br><span class="line">store %1* bitcast (%struct.__NSConstantString_tag* @_unnamed_cfstring_ to %1*), %1** %9, align 8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以简化成如下的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> g_ivar_MyClass_age = <span class="number">8</span>;  <span class="comment">// 全局变量</span></span><br><span class="line">*(NSString *)((<span class="type">uint8_t</span> *)obj + g_ivar_MyObject_age) = @<span class="string">&quot;hhh&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>编译时，LLVM 为每各类的每一个成员变量定义一个全局变量，用于存储该成员变量的偏移量</li>
<li>根据成员变量的偏移量，可以直接找到成员变量的地址并赋值</li>
</ul>
<p>这也是为什么结构体<code>ivar_t</code>的成员变量<code>offset</code>是<code>int32_t *</code>类型，因为保存的是该全局变量的地址。</p>
<h3 id="Non-Fragile-ivars"><a href="#Non-Fragile-ivars" class="headerlink" title="#Non Fragile ivars"></a>#Non Fragile ivars</h3><p>在前面部分我们已经知道该如何寻址成员变量，那么当基类的size变化时，runtime 是如何更新子类成员变量的offset呢？</p>
<p>在应用程序启动后，main 函数执行之前，runtime 在加载类的时候，会使用<code>static Class realizeClass(Class cls)</code>函数对类进行初始化，分配其读写数据的内存，返回类的真实结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* realizeClass</span></span><br><span class="line"><span class="comment">* Performs first-time initialization on class cls, </span></span><br><span class="line"><span class="comment">* including allocating its read-write data.</span></span><br><span class="line"><span class="comment">* Returns the real class structure for the class. </span></span><br><span class="line"><span class="comment">* Locking: runtimeLock must be write-locked by the caller</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">static</span> Class <span class="title">realizeClass</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">	<span class="type">class_rw_t</span> *rw = cls-&gt;<span class="built_in">data</span>();</span><br><span class="line">	<span class="comment">//...省略</span></span><br><span class="line">	<span class="keyword">if</span> (ro-&gt;instanceStart &lt; super_ro-&gt;instanceSize) &#123;</span><br><span class="line">        <span class="comment">// Superclass has changed size. This class&#x27;s ivars must move.</span></span><br><span class="line">        <span class="comment">// Also slide layout bits in parallel.</span></span><br><span class="line">        <span class="comment">// This code is incapable of compacting the subclass to </span></span><br><span class="line">        <span class="comment">//   compensate for a superclass that shrunk, so don&#x27;t do that.</span></span><br><span class="line">        <span class="type">class_ro_t</span> *ro_w = <span class="built_in">make_ro_writeable</span>(rw);</span><br><span class="line">        ro = rw-&gt;ro;</span><br><span class="line">        <span class="built_in">moveIvars</span>(ro_w, super_ro-&gt;instanceSize, </span><br><span class="line">                  mergeLayouts ? &amp;ivarBitmap : nil, </span><br><span class="line">                  mergeLayouts ? &amp;weakBitmap : nil);</span><br><span class="line">        <span class="built_in">gdb_objc_class_changed</span>(cls, OBJC_CLASS_IVARS_CHANGED, ro-&gt;name);</span><br><span class="line">        layoutsChanged = YES;</span><br><span class="line">    &#125; </span><br><span class="line">	<span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">class_ro_t</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="type">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="type">uint32_t</span> instanceSize;</span><br><span class="line">    <span class="type">const</span> <span class="type">ivar_list_t</span> * ivars;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>rw 是当前类的可读数据，ro 是类的 Ivar Layout，ro 的结构体定义在上面</li>
<li>在初始化类时，如果父类 ro 的<code>instanceSize</code>比子类的<code>instanceStart</code>大的话，那么会调用<code>moveIvars</code>函数更新子类的<code>instanceSize</code>以及子类成员变量的偏移量</li>
</ul>
<p>再让我们看一下 <code>moveIvars</code> 的源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* moveIvars</span></span><br><span class="line"><span class="comment">* Slides a class&#x27;s ivars to accommodate the given superclass size.</span></span><br><span class="line"><span class="comment">* Also slides ivar and weak GC layouts if provided.</span></span><br><span class="line"><span class="comment">* Ivars are NOT compacted to compensate for a superclass that shrunk.</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock must be held by the caller.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">moveIvars</span><span class="params">(<span class="type">class_ro_t</span> *ro, <span class="type">uint32_t</span> superSize, </span></span></span><br><span class="line"><span class="params"><span class="function">                      layout_bitmap *ivarBitmap, layout_bitmap *weakBitmap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">rwlock_assert_writing</span>(&amp;runtimeLock);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> diff;</span><br><span class="line">    <span class="type">uint32_t</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(superSize &gt; ro-&gt;instanceStart);</span><br><span class="line">    diff = superSize - ro-&gt;instanceStart;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ro-&gt;ivars) &#123;</span><br><span class="line">        <span class="comment">// Find maximum alignment in this class&#x27;s ivars</span></span><br><span class="line">        <span class="type">uint32_t</span> maxAlignment = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ro-&gt;ivars-&gt;count; i++) &#123;</span><br><span class="line">            <span class="type">ivar_t</span> *ivar = <span class="built_in">ivar_list_nth</span>(ro-&gt;ivars, i);</span><br><span class="line">            <span class="keyword">if</span> (!ivar-&gt;offset) <span class="keyword">continue</span>;  <span class="comment">// anonymous bitfield</span></span><br><span class="line"></span><br><span class="line">            <span class="type">uint32_t</span> alignment = ivar-&gt;<span class="built_in">alignment</span>();</span><br><span class="line">            <span class="keyword">if</span> (alignment &gt; maxAlignment) maxAlignment = alignment;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compute a slide value that preserves that alignment</span></span><br><span class="line">        <span class="type">uint32_t</span> alignMask = maxAlignment - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (diff &amp; alignMask) diff = (diff + alignMask) &amp; ~alignMask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Slide all of this class&#x27;s ivars en masse</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ro-&gt;ivars-&gt;count; i++) &#123;</span><br><span class="line">            <span class="type">ivar_t</span> *ivar = <span class="built_in">ivar_list_nth</span>(ro-&gt;ivars, i);</span><br><span class="line">            <span class="keyword">if</span> (!ivar-&gt;offset) <span class="keyword">continue</span>;  <span class="comment">// anonymous bitfield</span></span><br><span class="line"></span><br><span class="line">            <span class="type">uint32_t</span> oldOffset = (<span class="type">uint32_t</span>)*ivar-&gt;offset;</span><br><span class="line">            <span class="type">uint32_t</span> newOffset = oldOffset + diff;</span><br><span class="line">            *ivar-&gt;offset = newOffset;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (PrintIvars) &#123;</span><br><span class="line">                _objc_inform(<span class="string">&quot;IVARS:    offset %u -&gt; %u for %s (size %u, align %u)&quot;</span>, </span><br><span class="line">                             oldOffset, newOffset, ivar-&gt;name, </span><br><span class="line">                             ivar-&gt;size, ivar-&gt;<span class="built_in">alignment</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Slide GC layouts</span></span><br><span class="line">        <span class="type">uint32_t</span> oldOffset = ro-&gt;instanceStart;</span><br><span class="line">        <span class="type">uint32_t</span> newOffset = ro-&gt;instanceStart + diff;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ivarBitmap) &#123;</span><br><span class="line">            <span class="built_in">layout_bitmap_slide</span>(ivarBitmap, </span><br><span class="line">                                oldOffset &gt;&gt; WORD_SHIFT, </span><br><span class="line">                                newOffset &gt;&gt; WORD_SHIFT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (weakBitmap) &#123;</span><br><span class="line">            <span class="built_in">layout_bitmap_slide</span>(weakBitmap, </span><br><span class="line">                                oldOffset &gt;&gt; WORD_SHIFT, </span><br><span class="line">                                newOffset &gt;&gt; WORD_SHIFT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(<span class="type">uint32_t</span> *)&amp;ro-&gt;instanceStart += diff;</span><br><span class="line">    *(<span class="type">uint32_t</span> *)&amp;ro-&gt;instanceSize += diff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ro-&gt;ivars) &#123;</span><br><span class="line">        <span class="comment">// No ivars slid, but superclass changed size. </span></span><br><span class="line">        <span class="comment">// Expand bitmap in preparation for layout_bitmap_splat().</span></span><br><span class="line">        <span class="keyword">if</span> (ivarBitmap) <span class="built_in">layout_bitmap_grow</span>(ivarBitmap, ro-&gt;instanceSize &gt;&gt; WORD_SHIFT);</span><br><span class="line">        <span class="keyword">if</span> (weakBitmap) <span class="built_in">layout_bitmap_grow</span>(weakBitmap, ro-&gt;instanceSize &gt;&gt; WORD_SHIFT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先计算 superSize 与 instanceStart 之间的差值 diff</li>
<li>得到结构体中最大的成员变量的size：maxAlignment， 然后赋值：alignMask &#x3D; maxAlignment - 1</li>
<li>比较 diff 和 alignMask，通过算法 <code>if (diff &amp; alignMask) diff = (diff + alignMask) &amp; ~alignMask;</code> 对diff重新赋值</li>
</ul>
<blockquote>
<p>编译器在给结构体开辟空间时，首先找到结构体中最大的基本数据类型，然后寻找内存地址能是该基本数据类型的整倍的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为对齐模数。<br>为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。了解更多可以看这篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27909209/article/details/80814324">博客</a></p>
</blockquote>
<ul>
<li>更新成员变量的 offset，<code>ivar.newOffset = diff + ivar.oldOffset</code></li>
<li>更新子类 ro 的 instanceStart 和 instanceSize，ro.newinstanceStart &#x3D; ro.oldinstanceStart + diff，ro.newinstanceSize &#x3D; ro.oldinstanceSize + diff</li>
<li>当父类变大时会调用该函数来移动子类ivar，当父类变小时则子类ivar不变化</li>
</ul>
<blockquote>
<p>通过这个函数，即使父类size变大了，我们还是可以通过子类的 ro.instanceStart + ivar.offset 访问到成员变量</p>
</blockquote>
<h3 id="不能动态添加成员变量"><a href="#不能动态添加成员变量" class="headerlink" title="#不能动态添加成员变量"></a>#不能动态添加成员变量</h3><p>在 runtime 中有一个函数 <code>class_addIvar()</code>可以为类添加成员变量, 下面是该方法的一部分注释：</p>
<blockquote>
<p>his function may only be called after objc_allocateClassPair and before objc_registerClassPair. Adding an instance variable to an existing class is not supported.<br>The class must not be a metaclass. Adding an instance variable to a metaclass is not supported.</p>
</blockquote>
<p>上面的大致意思是该函数只能在类注册之前使用，且不能为元类添加成员变量。</p>
<p>让我们设想一下如果 OC 允许动态增加成员变量：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Father</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *age;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Son</span> : <span class="title">Father</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *toys;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 当Father初始化之后，instanceStart，instanceSize，offset已经<em>确定</em>。<br> 为 Father 添加新的成员变量 sex，则使用 Son 的实例对象 son 会出错误，因为 son.instanceStart &lt; Father.instanceSize，即 father 成员变量的 sex 的内存区域会跟 son 的一部分重合</p>
<p>我们有时会在类目中动态的为类添加关联对象(添加对象)，为什么可以添加关联对象呢?<br>具体的你可以看一下我的另一篇博客 <a target="_blank" rel="noopener" href="https://kikido.github.io/2019/06/28/%E8%B0%88Objective-C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/">谈Objective-C关联对象</a>。<br>这里我简单解释一下：关联对象被保存在一个静态的 map 中，以类实例的指针地址为映射，而不是保存在类实例的结构体中，不影响对象中成员变量的使用，所以可以在运行时添加成员变量。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="#引用"></a>#引用</h3><p><a target="_blank" rel="noopener" href="http://quotation.github.io/objc/2015/05/21/objc-runtime-ivar-access.html">Objective-C类成员变量深度剖析</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/tags/runtime/page/0/">上一页</a></div><div class="pagination-next"><a href="/tags/runtime/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/tags/runtime/">1</a></li><li><a class="pagination-link" href="/tags/runtime/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="千行"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">千行</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>杭州, 浙江</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">33</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/bug/"><span class="level-start"><span class="level-item">bug</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/cocoapods/"><span class="level-start"><span class="level-item">cocoapods</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS%E6%9D%82/"><span class="level-start"><span class="level-item">iOS杂</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%90%AD%E5%BB%BA/"><span class="level-start"><span class="level-item">搭建</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/EventKit/"><span class="tag">EventKit</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GCD/"><span class="tag">GCD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NSError/"><span class="tag">NSError</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Runloop/"><span class="tag">Runloop</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tagged-Pointer/"><span class="tag">Tagged Pointer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/YTKNetwork/"><span class="tag">YTKNetwork</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/YYModel/"><span class="tag">YYModel</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/block/"><span class="tag">block</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dyld/"><span class="tag">dyld</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mach-o/"><span class="tag">mach-o</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/runtime/"><span class="tag">runtime</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/weak/"><span class="tag">weak</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/"><span class="tag">关联对象</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"><span class="tag">内存分布</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%A1%E6%A0%B8/"><span class="tag">审核</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%A5%E5%85%B7/"><span class="tag">工具</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"><span class="tag">引用计数</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82/"><span class="tag">杂</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%BA%90%E7%A0%81/"><span class="tag">源码</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%94%81/"><span class="tag">锁</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="千行的博客" height="28"></a><p class="is-size-7"><span>&copy; 2022 千行</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>