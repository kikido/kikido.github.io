<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: iOS杂 - 千行的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="千行的博客"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="千行的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="千行的博客"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="千行的博客"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="千行"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"千行的博客","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"千行"},"publisher":{"@type":"Organization","name":"千行的博客","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-0VD5EHM46E" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-0VD5EHM46E');</script><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="千行的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">iOS杂</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-08-12T08:27:27.000Z" title="8/12/2020, 4:27:27 PM">2020-08-12</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">13 分钟读完 (大约1946个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/12/YTKNetwork-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E5%9B%9B-%E4%B9%8B-YTKBatchRequest-%E5%92%8C-YTKChainRequest/">YTKNetwork 源码解读 (四) 之 YTKBatchRequest 和 YTKChainRequest</a></h1><div class="content"><p>这篇是 YTKNetwork 源码阅读的最后一篇，主要讲解的是 YTKBaseRequest(批量请求)，YTKChainRequest(链式请求) 两个部分。</p>
<h2 id="YTKBatchRequest"><a href="#YTKBatchRequest" class="headerlink" title="YTKBatchRequest"></a>YTKBatchRequest</h2><p>YTKBatchRequest 用于完成批量请求的任务。当初始化时，需要指定 YTKBatchRequest 的数目，后续无法再添加新的请求。随后按添加顺序依次发起请求，当其中的一个请求失败时判定为 YTKBatchRequest 请求失败，同时 cancel 其它正在执行的请求</p>
<p><img src="https://i.loli.net/2020/08/06/wgAGbD3QvtMhk1V.jpg"></p>
<p>协议，用于 YTKBatchRequest 请求失败或者成功的回调</p>
<p><img src="https://i.loli.net/2020/08/06/hgMZA6yiQRF8OjW.jpg"></p>
<p>这些是 YTKBatchRequest 的属性，大部分看注释就能理解了。</p>
<p>需要注意的是：</p>
<ol>
<li>代理的执行顺序在 block 之前</li>
<li>tag 需要自己手动赋值来区分 YTKBatchRequest，默认值都是 0</li>
</ol>
<p><img src="https://i.loli.net/2020/08/06/hbnC92FYwM5rJXT.jpg"></p>
<p>初始化方法，在这里你需要指定 YTKRequest 数组。<br>个人觉得最好将其它默认的初始化方法给禁用掉</p>
<p><img src="https://i.loli.net/2020/08/06/Frtwa1VXfBgARd5.jpg"></p>
<p>设置 YTKBatchRequest 请求成功和失败的回调，当请求结束后，会调用 <code>-clearCompletionBlock</code> 将 block 置为 nil</p>
<p><img src="https://i.loli.net/2020/08/06/9dHeIuiD7Jh6nKB.jpg"></p>
<p>YTKRequestAccessory 协议用于执行请求不同阶段的回调</p>
<p><img src="https://i.loli.net/2020/08/06/rnkEDsPpLVCRxSa.jpg"></p>
<p>请求的开启和取消</p>
<p><img src="https://i.loli.net/2020/08/06/PAzdSfveubah4MD.jpg"></p>
<p>请求的数据是否来自于缓存。所有请求中，如果有一个请求的数据来自于缓存，那么这个方法就会返回 YES</p>
<p><img src="https://i.loli.net/2020/08/10/MWZotGTC9cyVxs8.jpg"></p>
<p>初始化方法，将参数 requestArray 赋值给属性 _requestArray，并且会判断里面的元素是否是 YTKRequest 实例，如果不是的话会返回。<br>初始化内部属性 finishedCount，该属性表示已完成请求的数目</p>
<p><img src="https://i.loli.net/2020/08/10/p8XUGsxKnqodMHi.jpg"></p>
<p>方法开头会判断属性 finishedCount 的值是否大于 0，如果 0 的话则返回。这说明当 YTKBatchRequest 实例创建只能调用 <code>start</code> 方法一次，再次调用的话可能会出现重复开启任务的问题，这里个人还是觉得要进行下判断比较好。<br>将 YTKRequest 的 delegate 设置为自己，同时清空 YTKRequest 的 block 回调，以确保只有 YTKBatchRequest 处理请求完成后的回调，最后开启请求</p>
<p><img src="https://i.loli.net/2020/08/10/EaCdM8eAnmGcgoP.jpg" alt="stop"></p>
<p>触发即将停止回调 toggleAccessoriesWillStopCallBack，并调用 clearRequest 方法循环将 YTKRequest 进行停止操作，随后将自己从 YTKBatchRequestAgent 中移除。</p>
<p><img src="https://i.loli.net/2020/08/10/x8hr17BTw4CHyaz.jpg" alt="clearRequest"></p>
<p>循环调用 YTKRequest 的 stop 方法</p>
<p><img src="https://i.loli.net/2020/08/10/EtTJoiqeZpGaRBA.jpg"></p>
<p>设置 YTKBatchRequest 的完成回调，当所有请求都成功调用或者其中一个失败时使用</p>
<p><img src="https://i.loli.net/2020/08/10/pnYCvZ9LAtrzm8R.jpg" alt="isDataFromCache"></p>
<p>可以看到，只要一个请求的数据来自于缓存，那么方法的返回结果就是 NO</p>
<p><img src="https://i.loli.net/2020/08/10/BwSh5TM6FRxCyGE.jpg"></p>
<p>当请求成功后，YTKBatchRequest 在这个方法里面处理数据。</p>
<ol>
<li>_finishedCount 的值 +1</li>
<li>如果 _finishedCount 的值等于请求的个数，说明所有的请求都已请求成功，这种情况表示 YTKBatchRequest 请求成功，执行相应的回调</li>
</ol>
<p><img src="https://i.loli.net/2020/08/10/krLgfPAah8bwUZ6.jpg"></p>
<p>YTKBatchRequest 在这个方法里面处理请求失败的情况。<br>一个请求失败意味着 YTKBatchRequest 的失败，所以也不用接着处理那些完成的请求。在这里会循环取消 YTKRequest 请求<br>接着执行失败回调，并将自己从 YTKBatchRequestAgent 移除。</p>
<p>YTKBatchRequestAgent 是一个单例，作用是强引用 YTKBatchRequest，避免被销毁。当任务执行完毕后，将 YTKBatchRequest 移除</p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>YTKBatchRequest 是一个批量执行请求的类，能够批量执行 YTKRequest 类型的请求。<br>请求的开启顺序按照任务的添加顺序执行，单个 YTKRequest 完成后，不会执行 YTKRequest 自己的回调 block，代理等回调方法。<br>当所有请求成功后，执行 YTKBatchRequest 的代理回调，回调 block; 否则执行 YTKBatchRequest 的失败回调</p>
<h2 id="YTKChainRequest"><a href="#YTKChainRequest" class="headerlink" title="YTKChainRequest"></a>YTKChainRequest</h2><p>YTKChainRequest 也是批量处理请求的类，只不过是当前面的请求完成后再执行下一个请求。</p>
<p><img src="https://i.loli.net/2020/08/10/tyxu5r2jRzsBlWN.jpg"></p>
<p>YTKChainRequest 完成的回调。可以看到在失败回调中多了一个参数 failedBaseRequest</p>
<p><img src="https://i.loli.net/2020/08/10/gcXN2dnmY38oeEQ.jpg"></p>
<p>比较简单，看注释就好了。<br><code>id&lt;YTKRequestAccessory&gt;</code> 是实现了协议 YTKRequestAccessory 的实例，这个协议里面有请求各种状态的方法，例如将要发起请求，将要结束请求</p>
<p><img src="https://i.loli.net/2020/08/10/OlkmZNL6vgs1dVb.jpg"></p>
<p>通过该方法向 YTKChainRequest 里面添加请求，同时设定该请求的完成回调。<br>我们知道 YTKBaseRequest 可以通过设定属性来设置完成回调，但这里为什么还需要这个方法来设定呢？通过属性设定的回调是否会触发呢？这些在后面会讲到的</p>
<p><img src="https://i.loli.net/2020/08/10/jPd6qNIc1yioT8C.jpg"></p>
<p>一些内部用到的属性</p>
<ol>
<li>requestArray：请求数组</li>
<li>requestCallbackArray：请求完成回调数组，有的请求没有设定回调，那么会往数组里面添加一个什么都不做的空回调</li>
<li>nextRequestIndex：下一个执行的请求的序号</li>
<li>emptyCallback：空回调</li>
</ol>
<p><img src="https://i.loli.net/2020/08/10/bBq7KgyMYjSEkcV.jpg"></p>
<p>初始化实例，可以看到 _emptyCallback 其实是一个不执行任何操作的 block</p>
<p><img src="https://i.loli.net/2020/08/10/8buHYgPl34VcACO.jpg"></p>
<p>开启任务后，通过 startNextRequest 方法开启第一个请求，并将 YTKChainRequest 添加到单例 YTKChainRequestAgent 中，防止被销毁</p>
<p><img src="https://i.loli.net/2020/08/10/aTvqonJywNXlQYd.jpg" alt="startNextRequest"></p>
<p>该方法用来开启下一个未执行的请求。<br>_nextRequestIndex 表示该请求在数组中的位置，如果超出了数组范围则返回。<br>通过 _nextRequestIndex 得到该请求，随后将 delegate 设置为自己，并清除其完成回调，随后开启请求，返回 YES; 否则返回 NO</p>
<p><img src="https://i.loli.net/2020/08/10/SJz6RqeaDiowu7F.jpg" alt="stop"></p>
<p>取消 YTKChainRequest，并将 YTKChainRequest 从单例 YTKChainRequestAgent 中移除。<br>通过调用 clearRequest 方法取消当前的请求</p>
<p><img src="https://i.loli.net/2020/08/10/YUa8JQXwyvkVClD.jpg" alt="clearRequest"></p>
<p>获取到当前的 YTKBaseRequest，由于 _nextRequestIndex 表示下一个未执行的请求位置，所以这里要 -1。<br>清空 _requestArray 和 _requestCallbackArray 这两个数组</p>
<p><img src="https://i.loli.net/2020/08/10/MEnRFSX5bNODYJy.jpg"></p>
<p>添加请求及其完成回调。<br>在 startNextRequest 方法中，我们知道，开启单个任务 YTKBaseRequest 之前，会将 YTKBaseRequest 的 delegate 设置为自己，并清除其回调 block。<br>所以，这里我们需要通过 _requestCallbackArray 这种方式来额外添加回调<br>需要注意的是该回调仅在请求成功时被调用</p>
<p><img src="https://i.loli.net/2020/08/10/CLAJBh9KMlGyPza.jpg" alt="requestFinished"></p>
<p>这里是 YTKBaseRequest 的代理方法，当请求成功后调用。<br>从 _requestCallbackArray 数组中获取该请求的完成回调。当所有的请求都获取成功后，执行 YTKChainRequestAgent 的完成回调</p>
<p><img src="https://i.loli.net/2020/08/10/34OZmbANdI7LM1f.jpg" alt="requestFailed"></p>
<p>这里是 YTKBaseRequest 的代理方法，当请求失败后调用。需要注意的是，当单个 YTKBaseRequest 请求失败，判断 YTKChainRequestAgent 请求失败，执行其完成回调<br>如果你想执行 YTKBaseRequest 的失败回调，你可以在代理方法 <code>chainRequestFailed:failedBaseRequest:</code> 中，通过 YTKBaseRequest 得到响应数据，随后执行后续操作</p>
<h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><p>YTKChainRequest 是一个批量同步执行请求的类，能够批量执行 YTKBaseRequest 类型的请求。<br>你可以自定义 YTKChainRequest 的实例方法添加 YTKBaseRequest 和 成功回调。</p>
<p>不同于 YTKBatchRequest，YTKChainRequest 中可添加的 request 类型是 YTKBaseRequest 而不是 YTKRequest</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-08-06T05:58:33.000Z" title="8/6/2020, 1:58:33 PM">2020-08-06</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">22 分钟读完 (大约3329个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/06/YTKNetwork-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E4%B8%89-%E4%B9%8B-YTKNetworkAgent/">YTKNetwork 源码解读 (三) 之 YTKNetworkAgent</a></h1><div class="content"><p>这一篇主要用来介绍 <code>YTKNetworkAgent</code> 这个类。当我们生成一个 <code>YTKBaseRequest</code> 实例，使用 <code>-start</code> 方法来发起请求，底层其实是使用 YTKNetworkAgent 来帮助序列化请求 request，以及请求结果 reponse 的序列化和回调。</p>
<h2 id="YTKNetworkConfig"><a href="#YTKNetworkConfig" class="headerlink" title="YTKNetworkConfig"></a>YTKNetworkConfig</h2><p><img src="https://i.loli.net/2020/08/05/kIElVBOoyNjMRLZ.jpg"></p>
<p>定义了一个叫做 AFURLSessionTaskDidFinishCollectingMetricsBlock 的 block 类型，看过 AF 源码的同学应该知道在 AFURLSessionManager.m 文件中同样定义了这个名字的 block，在同一个文件中 typedef 重复定义貌似不会报错。</p>
<p>NSURLSessionTaskMetrics 是 session 任务指标的封装，每个实例均包含下面几个属性：</p>
<ul>
<li>taskInterval：表示任务从创建到完成花费的总时间，任务的创建时间是任务被实例化时的时间；任务完成时间是任务的内部状态将要变为完成的时间</li>
<li>redirectCount：表示被重定向的次数</li>
<li>transactionMetrics：包含了任务执行过程中每个请求&#x2F;响应事务中收集的指标，指标是 NSURLSessionTaskTransactionMetrics 类型</li>
</ul>
<p>这个 block 用于 <code>NSURLSessionTaskDelegate</code> 协议的回调方法 <code>URLSession:task:didFinishCollectingMetrics:</code>，简单的，你可以在这个方法中统计网络流量</p>
<p><img src="https://i.loli.net/2020/08/05/Gf5ljV3ghY8XDQs.jpg" alt="YTKUrlFilterProtocol"></p>
<p>YTKUrlFilterProtocol 协议里面只有一个方法 <code>- (NSString *)filterUrl:(NSString *)originUrl withRequest:(YTKBaseRequest *)request</code>，该方法在方法 <code>-buildRequestUrl</code> 中被调用，用来加工 <code>requestUrl</code> 返回的字符串 Url。<br>YTKNetworkConfig 可以添加多个实现 YTKUrlFilterProtocol 协议的实例</p>
<p><img src="https://i.loli.net/2020/08/05/R6DfoBIKjP4tsmJ.jpg" alt="YTKCacheDirPathFilterProtocol"></p>
<p>YTKCacheDirPathFilterProtocol 协议里面只有一个方法 <code>- (NSString *)filterCacheDirPath:(NSString *)originPath withRequest:(YTKBaseRequest *)request</code>，用来加工缓存的默认目录 &#x2F;Library&#x2F;LazyRequestCache，YTKNetworkConfig 可以添加多个实现了 YTKCacheDirPathFilterProtocol 的实例</p>
<p><img src="https://i.loli.net/2020/08/05/oirZj9kn2SECWpy.jpg"></p>
<p>NS_UNAVAILABLE 这个宏的作用是你无法使用这个宏修饰的方法，也就是你只能只用 <code>+sharedConfig</code> 方法来生成实例，也就是单例</p>
<p><img src="https://i.loli.net/2020/08/05/bkA8PXwm1JrlILH.jpg"></p>
<ul>
<li>baseUrl: 域名，类似 <code>http://www.yuantiku.com</code>，默认值为 nil</li>
<li>cdnUrl：cdn url，默认值是 nil</li>
<li>urlFilters：只读，你可以使用实例方法 <code>-addUrlFilter：</code> 来添加实现了 YTKUrlFilterProtocol 协议的实例，该协议在上面已经提到过了</li>
<li>cacheDirPathFilters：只读，你可以使用实例方法 <code>-addCacheDirPathFilter：</code> 来添加实现了 YTKCacheDirPathFilterProtocol 协议的实例，该协议在上面已经提到过了</li>
<li>securityPolicy：安全策略，与证书相关</li>
<li>debugLogEnabled：是否开启 debug 模式，开启后可打印 log</li>
<li>sessionConfiguration：session config</li>
<li>collectingMetricsBlock：收集指标后的回调</li>
</ul>
<p><img src="https://i.loli.net/2020/08/05/pMJYnzurIUE7oXA.jpg"></p>
<p>这些就不讲了</p>
<p><img src="https://i.loli.net/2020/08/05/GuTjnysMcBHQXbk.jpg"></p>
<p>对应于 .h 文件中的 urlFilters, cacheDirPathFilters 属性，只是一个为只读，而上面的是成员变量可以直接使用<br><img src="https://i.loli.net/2020/08/05/dDCjnZPbhe16rEJ.jpg"></p>
<p>单例的写法，并在 init 进行初始化。<br>需要注意的是安全策略 securityPolicy 为默认策略，也就是无条件信任服务器的证书</p>
<p><img src="https://i.loli.net/2020/08/05/SnFb17CqAzaUYeJ.jpg"></p>
<p>比较简单就不说了</p>
<hr>
<p>YTKNetworkConfig 是一个单例，你可以用它来：</p>
<ol>
<li>设定域名 baseUrl</li>
<li>设定 cdn Url</li>
<li>设定安全策略</li>
<li>开启 log</li>
<li>对接口 url 进行修改</li>
<li>对缓存路径进行修改</li>
</ol>
<h2 id="YTKNetworkAgent"><a href="#YTKNetworkAgent" class="headerlink" title="YTKNetworkAgent"></a>YTKNetworkAgent</h2><p><img src="https://i.loli.net/2020/08/05/JhQS63NGAkVrzP5.jpg"></p>
<p>跟上面一样</p>
<p><img src="https://i.loli.net/2020/08/05/B5q3aymfGF2ihlp.jpg"></p>
<ul>
<li>addRequest：生成 NSURLSessionDataTask，并开启任务; 通过此方法会添加到一个字典集合中</li>
<li>cancelRequest：取消任务，并从集合中移除</li>
<li>cancelAllRequests：取消所有的任务，并从集合中移除</li>
</ul>
<p><img src="https://i.loli.net/2020/08/05/GN9aRKLEI5AyQFe.jpg" alt="buildRequestUrl"></p>
<p>构建请求的 url 字符串</p>
<p><img src="https://i.loli.net/2020/08/05/418R5InecrWNQz9.jpg"></p>
<p>互斥锁，用来保持线程安全。这里使用宏来简化锁的使用<br>使用方式为：</p>
<ol>
<li>初始化锁：pthread_mutex_init(&amp;_lock, NULL)</li>
<li>上锁：pthread_mutex_lock(&amp;_lock)</li>
<li>解锁：pthread_mutex_unlock(&amp;_lock)</li>
<li>销毁锁，虽然在文件中并没有这步操作：pthread_mutex_destroy(&amp;_lock)</li>
</ol>
<p><img src="https://i.loli.net/2020/08/05/j6l94oPuNxYVBHr.jpg"></p>
<p>这里是一些 YTKNetworkAgent 的私有成员变量</p>
<ol>
<li>_manager：序列化参数，上传的附件，响应结果并发起请求</li>
<li>_config：网络配置，上一节已经讲过了</li>
<li>_jsonResponseSerializer：将响应结果序列化成 json </li>
<li>_xmlParserResponseSerialzier：将响应结果序列化成 xml</li>
<li>_requestsRecord：task 集合，强引用 task，使其在请求过程中不会被释放 </li>
<li>_processingQueue：并行队列，用来分配请求成功时的回调</li>
<li>_lock：互斥锁</li>
<li>_allStatusCodes：状态码集合，用来验证响应结果</li>
</ol>
<p><img src="https://i.loli.net/2020/08/05/FlIMDLvcJHKBmZ7.jpg"></p>
<p>生成 YTKNetworkAgent 实例并初始化，值得注意的是这里的状态码集合范围是 (100， 500)，不同于 AFN 的 (200， 300)</p>
<p><img src="https://i.loli.net/2020/08/05/C8UnNLEmPjzQKIV.jpg"></p>
<p>懒加载 _jsonResponseSerializer、_xmlParserResponseSerialzier 这两个序列化器，它们只有当 responseSerializerType 为 YTKResponseSerializerTypeJSON、YTKResponseSerializerTypeXMLParser 才会被使用</p>
<p><img src="https://i.loli.net/2020/08/05/waucstXMhQOegdS.jpg" alt="buildRequestUrl"></p>
<p>这个方法的作用是构建 request 的 url</p>
<p>先让我们了解一下 URL 的组成，这里举一个例子：<a target="_blank" rel="noopener" href="http://www.example.com/path/to/myfile.html?key1=value1&amp;key2=value2#SomewhereInTheDocument">http://www.example.com:80/path/to/myfile.html?key1=value1&amp;key2=value2#SomewhereInTheDocument</a></p>
<p>其中：</p>
<ul>
<li>scheme：因特网服务类型，这里是 http</li>
<li>domain：因特网域名，在这里是 <a target="_blank" rel="noopener" href="http://www.example.com/">www.example.com</a></li>
<li>port：主机上的端口号，默认端口号是 80</li>
<li>path：服务器上的资源路径，在这里是 &#x2F;path&#x2F;to&#x2F;myfile.html</li>
<li>parameter：提供给服务器的额外参数，在这里是 ?key1&#x3D;value1&amp;key2&#x3D;value2</li>
</ul>
<p>在这个方法中，如果一个 url 存在 host 跟 scheme，那么就会把它当做一个完整的 url，不需要拼接直接返回</p>
<p><img src="https://i.loli.net/2020/08/05/GE1FoKsCgbv7Aqa.jpg"></p>
<p>这个方法的作用是创建一个请求序列化器</p>
<p>① 前面部分是根据 requestSerializerType 类型创建不同的 requestSerializer<br>红色框里面的内容是服务器如果需要 账号&#x2F;密码 验证时，使用 <code>setAuthorizationHeaderFieldWithUsername：password：</code>将这些信息添加到请求头中<br>① 后面部分的内容是设置你自定义的请求头信息</p>
<p><img src="https://i.loli.net/2020/08/05/CVyF3piMaPmfD4L.jpg"></p>
<p>这个方法的作用是创建 NSURLSessionTask task</p>
<ol>
<li>根据参数 YTKBaseRequest 获取到请求 method，url，参数，要上传的文件信息，进度 block以及请求序列化器</li>
<li>获取到上面的信息后，根据 method 选择不同的构建方法创建 NSURLSessionTask</li>
</ol>
<p>当 method 是 GET 时，有两种情况，一种是下载任务，一种是数据任务</p>
<p><img src="https://i.loli.net/2020/08/05/23lydGtx7EuBgOT.jpg" alt="构建下载任务"></p>
<p>这个方法用来构建下载任务。<br>下载任务有断点下载的作用，所以在这里我们需要判断之前是否下载了部分数据，如果是的话则继续下载，否则的话则重头开始下载。</p>
<ol>
<li>首先我们需要构建 request，这部分由 AFN 的请求序列器 requestSerializer 完成，简单点讲就是设置请求头，设置请求体(将参数编码)，创建 NSMutableURLRequest</li>
<li>代码块 1 的作用是确保下载路径是一个文件路径，而不是文件夹路径。下载任务完成后，AFN 使用方法 <code>moveItemAtURL:toURL:error:</code> 将文件移动到指定路径，如果此时该路径下已经有一个文件存在，就会失败，所以 YTK 这里在下载前就先判断是否文件，如果存在的话则移除这个文件</li>
<li>代码块 2 的作用是恢复断点下载<ul>
<li>首先获取到之前下载好的数据，这些数据会被保存在 &#x2F;tmp&#x2F;Incomplete 文件夹下面 </li>
<li>获取这些数据，并进行验证。断点数据被保存时会被当做一个 plist 文件，包含了许多的 key 来记录下载信息，所以 YTK 使用 <code>validateResumeData</code> 方法来对这些数据进行验证</li>
<li>当断点数据存在并且有效时，使用 AFHTTPSessionManager 的实例方法 <code>downloadTaskWithResumeData:progress:destination:completionHandler</code> 方法来创建一个下载任务</li>
<li>到这里如果没有断点下载，则使用 AFHTTPSessionManager 的实例方法 <code>downloadTaskWithRequest:progress:destination:completionHandler</code> 方法重新创建一个下载任务</li>
</ul>
</li>
</ol>
<p><img src="https://i.loli.net/2020/08/05/voG8OhsDYqFUQPI.jpg"></p>
<p>这个方法的作用是创建数据任务，流程大概就是：</p>
<ol>
<li>requestSerializer 生成 NSMutableURLRequest，需要注意的是如果有文件上传的话需要用另一个方法来初始化 request</li>
<li>使用 AFHTTPSessionManager 生成 NSURLSessionDataTask，具体实现还是自己翻 AFN 的代码吧</li>
</ol>
<p><img src="https://i.loli.net/2020/08/05/N7gyvmaUR6VXStZ.jpg"></p>
<p>这个方法的作用是生成任务 task，添加到字典集合中强引用避免被销毁，开启任务</p>
<ol>
<li>代码块 1 的作用是初始化 NSURLSessionTask 实例<ul>
<li>如果我们使用了 <code>-buildCustomUrlRequest</code> 自定义了 NSURLRequest，那么将使用 AFHTTPSessionManager 的方法 <code>dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler</code> 来创建 NSURLSessionTask，你对 YTKBaseRequest 一些属性的设置都将失效</li>
<li>如果没有自定义 NSURLRequest，那么将使用 <code>sessionTaskForRequest:error:</code> 来创建 NSURLSessionTask，这个方法我们在上面已经讲过了</li>
</ul>
</li>
<li>代码块 2 的作用是在创建 NSURLSessionTask 的过程中失败了，则直接执行失败回调</li>
<li>代码块 3 的作用是为 NSURLSessionTask 设置优先级，因为这个属性是 iOS8 之后才有的，所以先用 <code>respondsToSelector:</code> 方法判断了下</li>
<li>当 NSURLSessionTask 创建成功后，使用 <code>-addRequestToRecord:</code> 添加到字典集合 _requestsRecord， key&#x2F;value 对应于 task.taskIdentifier&#x2F;request</li>
<li>由于刚创建的 NSURLSessionTask 处于 suspend 暂停状态，所以需要使用 resume 方法来开启</li>
</ol>
<p><img src="https://i.loli.net/2020/08/05/K8AmFsxLf1whYbR.jpg" alt="cancelRequest"></p>
<p>该方法用来取消 request。</p>
<p>当 task 是下载任务时，且 YTKBaseRequest 的 resumableDownloadPath 属性不为 nil，取消任务会将已经下载好的数据保存在本地文件中，以便于下次下载时不重复下载。需要注意时，这些数据不只是你要下载的文件数据，而是一个 plist 文件，里面有许多键值对，例如 NSURLSessionDownloadURL，NSURLSessionResumeBytesReceived，NSURLSessionResumeCurrentRequest<br>数据保存的文件路径是 <code>/tmp/Incomplete/resumableDownloadPath</code>，其中 resumableDownloadPath 部分是你自己设定的值</p>
<p>取消任务 task 之后，会将 task 从集合 _requestsRecord 中移除</p>
<p><img src="https://i.loli.net/2020/08/06/osnFDKfHPtA8XIO.jpg" alt="cancelAllRequests"></p>
<p>该方法用来取消所有添加到集合中的任务，值得注意的是锁的使用，这里将锁作用在数据的添加和读取上</p>
<p><img src="https://i.loli.net/2020/08/06/BcWmje7frXJAxod.jpg"></p>
<p>该方法用来验证 request 的响应结果，此时请求已经完成，且响应数据已经被序列化赋值给了 YTKBaseRequest 实例。</p>
<ol>
<li>首先验证状态码，有效的状态码范围是 (200，299)，在这个范围内说明请求被服务器接收并处理。如果无效则返回</li>
<li>如果 YTKBaseRequest 的 responseJSONObject 属性和方法 -jsonValidator 返回值不为 nil，则需要验证 JSON，如果 JSON 中相应字段的值不为 nil，则验证成功; 如果失败则返回</li>
</ol>
<p><img src="https://i.loli.net/2020/08/06/D2X4imyep7MP5Kc.jpg"></p>
<p>代码块 1：<br>当我们取消 task 后，底层的 AFN 会立刻调用失败回调，进而调用这个方法。为了防止这种情况，我们在这里做了一个判断，如果 request 为 nil 的时候立即返回</p>
<p>代码块 2：<br>序列化响应结果，根据 responseSerializerType 属性的不同，将数据序列化成不同类型，比如 JSON Object，NSXMLParser。具体实现过程由 AFN 的响应序列化器实现</p>
<ol>
<li>到这一步如果都没有出现 error，则调用方法 <code>-validateResult:error:</code> 验证响应结果，这个方法我们在上面已经讲过</li>
<li>如果验证成功，则调用 <code>-requestDidSucceedWithRequest：</code> 方法处理; 否则，调用 <code>-requestDidFailWithRequest：error:</code> 处理，这两个方法我们随后会讲到</li>
<li>无论验证成功还是失败，最后都要将 request 从集合 _requestsRecord 中移除，并清空自己的 successCompletionBlock、failureCompletionBlock、uploadProgressBlock</li>
</ol>
<p><img src="https://i.loli.net/2020/08/06/2yuE35P7LSMlvNZ.jpg"></p>
<p>请求成功后的处理方法，会依次调用下面几个方法</p>
<ol>
<li>requestCompletePreprocessor：如果使用 cache 的话是在主线程，否则的话在其它线程执行。下面的方法均在主线程执行</li>
<li>requestWillStop</li>
<li>requestCompleteFilter</li>
<li>requestFinished</li>
<li>successCompletionBlock</li>
<li>requestDidStop</li>
</ol>
<p><img src="https://i.loli.net/2020/08/06/Iz4GmoRQcn6xdKZ.jpg"></p>
<p>请求失败的处理方法</p>
<p>代码块 1：<br>如果此时有断点数据且 resumableDownloadPath 属性不为 nil，则将其保存在本地，用于下载任务</p>
<p>代码块 2：<br>对于断点下载的任务，后面恢复下载的任务开启时，responseObject 的值会被赋予断点数据的文件路径。<br>如果下载任务请求失败了，那么将把断点数据读取出来，然后把文件删除，不是很明白为什么把数据读取出来</p>
<p>代码块 3：<br>执行一些失败的回调，执行顺序如下：</p>
<ol>
<li>requestFailedPreprocessor：如果使用 cache 的话是在主线程，否则的话在其它线程执行。下面的方法均在主线程执行</li>
<li>requestWillStop</li>
<li>requestFailedFilter</li>
<li>requestFailed</li>
<li>failureCompletionBlock</li>
<li>requestDidStop</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>YTKNetworkAgent 是 YTK 实现请求的类，它序列化了请求以及响应数据，并且实现了断点下载的功能。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-08-03T07:17:32.000Z" title="8/3/2020, 3:17:32 PM">2020-08-03</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">17 分钟读完 (大约2535个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/03/YTKNetwork-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E4%BA%8C-%E4%B9%8B-YTKRequest/">YTKNetwork 源码解读 (二) 之 YTKRequest</a></h1><div class="content"><h2 id="YTKCacheMetadata"><a href="#YTKCacheMetadata" class="headerlink" title="YTKCacheMetadata"></a>YTKCacheMetadata</h2><p><img src="https://i.loli.net/2020/07/13/vK2cFaYh54MoLsu.jpg"></p>
<p>YTKCacheMetadata 表示缓存元数据，保存了跟缓存相关的一些信息，例如创建时间，创建时的版本号，app 版本号等。<br>通过比较 YTKCacheMetadata，来判断本地缓存是否有效。如果无效的话则重新发起请求，有效的话则从本地缓存加载 reponse 数据</p>
<p>下面几种比较 YTKCacheMetadata 的情况会被认为本地无效：</p>
<ol>
<li>version 不匹配</li>
<li>sensitiveDataString 不匹配。不要被它的名字给误导了，其实它就相当于一个额外的一个标识符，自己可以设定，如果 sensitiveDataString 不相等说明不匹配</li>
<li>creationDate 取创建日期到现在的时间戳，如果超过了设定的缓存有效时间说明缓存无效</li>
<li>appVersionString 不匹配，app 版本号不匹配</li>
</ol>
<p>还有一个属性 <code>NSStringEncoding stringEncoding</code> 用于将本地数据转换成字符串时使用。</p>
<p>另外 YTKCacheMetadata 还支持 NSSecureCoding 协议，协议里的方法就不讲了。</p>
<p><img src="https://i.loli.net/2020/07/13/3AQOFr6ICM5uq9d.jpg"></p>
<p>定义了一些跟缓存相关的一些状态码</p>
<h2 id="YTKRequest"><a href="#YTKRequest" class="headerlink" title="YTKRequest"></a>YTKRequest</h2><!--FIXME：扩展的版本链接-->
<p>YTKRequest 是 YTKBaseRequest 的子类，为 YTKBaseRequest 增加了缓存功能</p>
<p><img src="https://i.loli.net/2020/07/13/pLRehUOCPFoVxMJ.jpg"></p>
<p>response 数据是否保存到本地需要满足两个条件:</p>
<ol>
<li>当前 response 不是来自于缓存，即 response 需要来自于 request</li>
<li>缓存有效时间 cacheTimeInSeconds 需要大于 0</li>
</ol>
<p><img src="https://i.loli.net/2020/07/13/PQLzhDKWxZuTC5l.jpg"></p>
<p><code>-cacheVersion</code>，<code>-cacheSensitiveData</code> 这两个标识符都是自己设定的。<br>保存缓存时，也会将缓存元数据保存在本地，当需要加载缓存时，会先把缓存元数据取出来，比较 cacheVersion，cacheSensitiveData 这两个标识符跟当前的标识符是否相等，如果有不相等说明缓存无效</p>
<p>接下来是 <code>YTKRequest.m</code> 部分</p>
<p><img src="https://i.loli.net/2020/07/15/msUzTJGKSufay2p.jpg"></p>
<p>两个宏 <code>NSFoundationVersionNumber_iOS_8_0</code> 和 <code>NSFoundationVersionNumber_With_QoS_Available</code> 用来处理系统在 iOS8 之前和之后两种情况，不过在 iOS11 之后，我们可以使用 <code>if (@available(iOS 10, macOS 10.12, watchOS 3, tvOS 10, *))</code> 这个关键字来处理系统版本不同的问题</p>
<p>这里创建了一个串行队列，对于 iOS8 之后的系统，还指定了它的队列优先级为 <code>QOS_CLASS_BACKGROUND</code>。需要注意的是 <code>QOS_CLASS_BACKGROUND</code> 的优先级别是最低的，可能是因为不想占用太多系统资源吧。<br>这个队列用来将 response 保存到本地文件中</p>
<p><img src="https://i.loli.net/2020/07/15/2MIDkdoPpyFlJnH.jpg"></p>
<p>上面几种不同类型的缓存对应 YTKResponseSerializerType 的类型</p>
<ol>
<li>cacheData 和 cacheString 对应于 YTKResponseSerializerTypeHTTP</li>
<li>cacheData 和 cacheJSON 对应于 YTKResponseSerializerTypeJSON</li>
<li>cacheData 和 cacheXML 对应于 YTKResponseSerializerTypeXMLParser</li>
</ol>
<p><img src="https://i.loli.net/2020/07/15/59fMuWAXvbqT4oa.jpg"></p>
<p>因为 YTKRequest 是 YTKBaseRequest 的子类，在这里覆写了它的 <code>start</code> 方法。</p>
<p>有三种情况会导致不使用缓存数据：</p>
<ol>
<li>设置 YTKRequest 的属性 ignoreCache 为 YES，这样会忽略缓存直接进行请求</li>
<li>如果当前任务是一个下载任务，此时不会对 response 结果进行缓存，自然也就不会有读取缓存这个过程</li>
<li>加载缓存时出现了问题。例如缓存元数据验证时出现问题，或者是读取缓存文件时出现的问题</li>
</ol>
<p>如果加载缓存成功，会在主队列分发一个异步任务，用来执行请求完成后的一些方法，这些我们在讲 YTKBaseRequest 的时候提到过了<br>需要注意的是下面这行代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YTKRequest *strongSelf = self;</span><br></pre></td></tr></table></figure>

<p>这是为了防止执行异步任务的时候 self 突然被释放了。不过我的理解是，既然 GCD 已经强引用了 self，那么在 block 执行完毕之前，self 都是不会被释放掉的，所以这句代码貌似有点多余了</p>
<p><img src="https://i.loli.net/2020/07/15/ynWUkDuqTzieHlO.jpg"></p>
<p>使用 -loadCacheWithError 方法来加载本地缓存，分这么几步：</p>
<ol>
<li>判断是否设置了缓存有效时间，如果没有的话说明不使用缓存了，直接返回</li>
<li>加载缓存元数据，如果元数据不存在，说明缓存也不存在</li>
<li>验证缓存元数据，判断缓存是否有效</li>
<li>加载本地缓存</li>
</ol>
<p>在这里，我们先讲一下第三步验证缓存元数据的方法，加载缓存元数据和加载缓存后面再讲</p>
<p><img src="https://i.loli.net/2020/07/15/FAirxDa6dfjCETv.jpg" alt="validateCacheWithError"></p>
<ol>
<li>首先比较缓存的有效时间，因为缓存元数据中保存了缓存的创建日期，所以这里比较简单</li>
<li>比较缓存版本号，因为是 long long 类型，所以直接比较就可以</li>
<li>比较 sensitiveDataString 标识符，因为是字符串类型，所以需要使用 <code>isEqualToString</code> 方法比较。值得注意的是，对于符号 <code>||</code>，当前面那个条件满足之后就不会再去比较后面那个条件了，所以我们写代码的时候可以把比较简单的判断条件放在前面，同理还有 <code>&amp;&amp;</code></li>
<li>比较 app 版本号。这里我觉得只需要使用 dispatch_once 进行一次比较就可以了。如果变 app 版本号变更了，则清除缓存，后面就不再需要比较; 如果版本号没有变更，后面也不需要比较了</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 忽略缓存，开启请求</span><br><span class="line">- (void)startWithoutCache &#123;</span><br><span class="line">    // 清空跟缓存相关的属性</span><br><span class="line">    [self clearCacheVariables];</span><br><span class="line">    [super start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不使用缓存，则调用这个方法来开启任务。</p>
<p><img src="https://i.loli.net/2020/07/15/vUlL8gpwIi4mkxa.jpg"></p>
<p>清空跟缓存相关属性的值，需要注意的是，并不会清除本地的缓存文件(如果有)</p>
<p><img src="https://i.loli.net/2020/07/15/R7Sh9anB2bvfKYw.jpg"></p>
<p><code>requestCompletePreprocessor</code> 方法在得到请求结果后调用。由于 YTKRequest 覆写了父类 YTKBaseRequest 的 requestCompletePreprocessor 方法，所以首先需要调用父类的 requestCompletePreprocessor 方法。<br>如果 YTKRequest 的 <code>writeCacheAsynchronously</code> 属性值为 YES，则表示在执行请求回调的线程(一般为主线程)，将请求结果保存在本地文件中; 如果值是 NO，则在私有的串行队列 <code>ytkrequest_cache_writing_queue</code> 添加一个异步任务来处理</p>
<p><img src="https://i.loli.net/2020/08/03/NbsO7IQTnAqhlkp.jpg" alt="saveResponseDataToCacheFile"></p>
<p><code>saveResponseDataToCacheFile</code> 方法的作用是将数据保存到本地。</p>
<ol>
<li>检查数据是否是来自缓存，如果是的话则返回; 否则执行下一步</li>
<li>将数据保存到本地，文件名字根据接口名字、参数、请求方式来生成</li>
<li>生成一个 YTKCacheMetadata 实例，保存缓存元数据，然后使用归档的方式将其保存到本地中，其文件名字为 “缓存名字.metadata”</li>
</ol>
<p><img src="https://i.loli.net/2020/08/03/NmwzDa2IUyQ18bT.jpg"></p>
<p>覆写这些方法，用来控制请求缓存的使用</p>
<ul>
<li>cacheTimeInSeconds：缓存使用时间</li>
<li>cacheVersion：缓存版本，充当一个标记</li>
<li>cacheSensitiveData：也是一个标记</li>
<li>writeCacheAsynchronously：是否异步保存缓存</li>
</ul>
<p><img src="https://i.loli.net/2020/08/03/Z7xt3jHokVRS5EU.jpg"></p>
<p>属性 _dataFromCache 用来标记此时的请求结果是否来自于缓存<br>根据请求格式 responseSerializerType 的不同，缓存将被转换成的对象也不相同，所以这里有很多成员变量 _cacheData&#x2F;_cacheXML&#x2F;_cacheJSON&#x2F;_cacheString</p>
<p><img src="https://i.loli.net/2020/08/03/oBP5jgH3f6T9zM1.jpg" alt="loadCacheMetadata"></p>
<p>加载缓存元数据，使用归档加载，如果加载成功，则该方法返回 YES。<br>这里需要注意的是 YTKLog 这个宏</p>
<p><img src="https://i.loli.net/2020/08/03/uoIxqKkjCOiDvYE.jpg" alt="YTKLog"></p>
<p>展开来其实是一个 C 函数，参数是 format 和可变参数。<br>方法的实现被包含在了一个 #ifdef&#x2F;#endif 里面，这样做的好处是在正式版本环境 RELEASE 时，不会再打印 log，减少系统开销</p>
<p><img src="https://i.loli.net/2020/08/03/6tmJugLQ8fscNPS.jpg" alt="loadCacheData"></p>
<p>这个方法的作用是加载本地缓存</p>
<p>首先判断缓存文件是否存在，存在的话则读取数据 data，随后根据属性 responseSerializerType 的值将 data 转换成不同格式的对象</p>
<p><img src="https://i.loli.net/2020/08/03/pR8CtblTKcOvwDi.jpg" alt="clearCacheVariables"></p>
<p>清除跟缓存相关的几个属性，需要注意的是并没有主动的清除本地缓存</p>
<p><img src="https://i.loli.net/2020/08/03/sL6Q5M2E81Aw7uN.jpg" alt="createBaseDirectoryAtPath"></p>
<p>该方法用来创建文件夹，需要注意的是 createDirectoryAtPath:withIntermediateDirectories:attributes:error:，该方法可以用来创建中间目录。<br>例如我们创建一个名字为 app&#x2F;doc&#x2F;user&#x2F;info 的文件夹，而当前只存在 app 这个文件夹的话，使用该方法会帮我们创建好 doc，user，info 这几个文件夹</p>
<p><img src="https://i.loli.net/2020/08/03/mAFkNIntxwS2CM1.jpg"></p>
<p>根据 path 来查找是否存在该文件夹，如果不存在的话则使用 createBaseDirectoryAtPath 来创建文件夹; 如果存在的话则判断是否是文件，如果是文件的话则移除该文件，然后使用 createBaseDirectoryAtPath 来创建文件夹</p>
<p>可以看到 createBaseDirectoryAtPath，createBaseDirectoryAtPath 两个方法的使用是为了确保生成指定名字的文件夹</p>
<p><img src="https://i.loli.net/2020/08/03/4Q2YEgoDiGX8p93.jpg"></p>
<p>该方法用来创建缓存存放的文件目录</p>
<p>默认的文件夹位置是 &#x2F;Library&#x2F;LazyRequestCache，但是我们可以使用 YTKNetworkConfig 的实例方法 <code>addCacheDirPathFilter</code> 来修改文件夹的名字<br>在确定好文件夹名字之后，使用 createDirectoryIfNeeded 创建该文件夹</p>
<p><img src="https://i.loli.net/2020/08/03/8MXwRHIantJKGiT.jpg"></p>
<p>该方法用来确定缓存文件的名字</p>
<p>得到请求的 url， basicUrl，参数，然后拼接成一个字符串 requestInfo，随后使用 YTKNetworkUtils 的方法 md5StringFromString，从 requestInfo 中提取 md5，将其作为缓存文件的名字</p>
<p><img src="https://i.loli.net/2020/08/03/knBlZpyvgf2wICu.jpg"></p>
<p>得到了文件夹名字和文件名字，我们就可以将其拼接成缓存文件的路径啦</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>YTKRequest 作为 YTKBaseRequest 的子类，为其添加了缓存这个功能。在我们的使用中自定义的 request 子类也是需要直接继承与 YTKRequest 的</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-07-13T03:09:56.000Z" title="7/13/2020, 11:09:56 AM">2020-07-13</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">14 分钟读完 (大约2056个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/13/YTKNetwork-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E4%B8%80-%E4%B9%8B-YTKBaseRequest/">YTKNetwork 源码解读 (一) 之 YTKBaseRequest</a></h1><div class="content"><p>因为 YTKBaseRequest .h&#x2F;.m 里代码数目不多，所以这里将从头开始逐行介绍，有一些直接就写在注释里了，有一些需要注意的地方会特别摘出来讲解的。</p>
<p><img src="https://i.loli.net/2020/07/10/W3mhf6ugSBzDq9I.jpg"></p>
<p>不知道你有没有注意到 <code>NS_ENUM</code> 后面没有跟着指定一个名字，是的，如果你不需要指定一个类型名字的话，可以直接这样子写。<br><code>YTKRequestValidationErrorInvalidStatusCode</code> 值的是 <code>reponse.statusCode</code> 不在 200~299 这个区间内，跟 AFHTTPResponseSerializer 的 <code>acceptableStatusCodes</code> 的范围一致</p>
<p><img src="https://i.loli.net/2020/07/10/YIxNzSZ2gdTma4b.jpg"></p>
<p>常见的请求方法</p>
<p><img src="https://i.loli.net/2020/07/10/fulaMKk6Eys97i2.jpg"></p>
<p>请求的序列化样式，相对于 AFNetworking 少了 AFPropertyListRequestSerializer，可能是因为这种编码方式比较少见吧。</p>
<p>相应的序列化样式，相对于 AFNetworking 少了 AFXMLDocumentResponseSerializer，AFPropertyListResponseSerializer，AFImageResponseSerializer，AFCompoundResponseSerializer 几个类型</p>
<p><img src="https://i.loli.net/2020/07/10/bSkVAmef7QgCLh1.jpg"></p>
<p>对应于 NSURLSessionTask 的 priority 属性，需要在 iOS8 以后的系统中使用，不过一般也不需要再兼容之前的系统了吧。。。</p>
<p><img src="https://i.loli.net/2020/07/10/ZlS7V3w91BXoH4a.jpg"></p>
<p>AFMultipartFormData 在 AFNetworking 用于 <code>Content-Type </code> 为 <code>application/form-data</code> 的请求，将数据添加到请求体中。一般用于 upload task 中。<br>在 AFConstructingBlock 类型的 block 中，你可以将数据添加数据添加到请求体中<br>在 AFURLSessionTaskProgressBlock 的 block 你可以追踪上传的进度</p>
<p><img src="https://i.loli.net/2020/07/10/YV2MJiOnbyE7HwX.jpg"></p>
<p>你可以实现这两个协议，以便在 request 的不同阶段进行相应的处理<br>需要注意的是这些方法的执行顺序不要搞错了</p>
<p><img src="https://i.loli.net/2020/07/10/zrmpbNKCdMojXua.jpg"></p>
<p>接下来介绍 <code>YTKBaseRequest</code> 这个类，它是一个抽象类，提供了构建 requeset 时的许多选项</p>
<p><img src="https://i.loli.net/2020/07/10/ynW2spDa8TO9bAB.jpg"></p>
<p>这里大部分的属性是映射 <code>NSHTTPURLResponse</code>， <code>NSURLRequest</code>，<code>NSURLSessionTask</code> 这几个类的属性的。</p>
<p>需要注意的是 <code>responseObject</code>，如果 <code>resumableDownloadPath</code> 不为空并且 requestTask 是 DownloadTask 类型的，那么这个属性的值就一个文件路径(NSURL)，用来保存下载数据的</p>
<p><img src="https://i.loli.net/2020/07/10/1DZGRTkV3QESAp7.jpg"></p>
<p>tag 可以用来标记 YTKBaseRequest，默认值是 0<br>userInfo 可以用来添加额外信息</p>
<p><img src="https://i.loli.net/2020/07/10/exVL4ChWQlyKb26.jpg"></p>
<p>requestAccessories 是一个数组，可以用来保存<code>多个</code>实现了 <code>YTKRequestAccessory</code> 协议的对象<br>constructingBodyBlock 用来将数据添加到请求体中<br>resumableDownloadPath 是保存下载数据文件的路径，当下载请求失败时，部分的下载数据会自动保存到这个文件中，否则数据会保存到 responseData&#x2F;responseString 中<br>resumableDownloadProgressBlock 可以用来追踪下载进度<br>uploadProgressBlock 可以用来追踪上传进度</p>
<p><img src="https://i.loli.net/2020/07/10/VudFo4c9YDZPC8R.jpg"> </p>
<p><code>-setCompletionBlockWithSuccess:failure:</code> 用来添加请求 成功&#x2F;失败 的回调<br><code>-clearCompletionBlock:</code> 将请求 成功&#x2F;失败 的回调 block 置为 nil，避免循环引用<br><code>-addAccessory:</code> 用来添加实现 YTKRequestAccessory 的对象</p>
<p><img src="https://i.loli.net/2020/07/13/mgYVArZ1p5N6FsE.jpg"></p>
<ol>
<li>-start：开启任务。需要注意是为了让 task 在完成之前不被释放掉，会在这个 task 添加到单例 YTKNetworkAgent 的成员变量 <code>_requestsRecord</code>中</li>
<li>-stop：取消任务。我感觉这个方法叫做 cancle 比较合适，我一开始看到 stop 还以为是 suspend 的意思</li>
<li>-startWithCompletionBlockWithSuccess:failure:，设置请求 失败&#x2F;成功 的回调，并开启任务</li>
</ol>
<p><img src="https://i.loli.net/2020/07/13/d2ovlJ4YtS7mQeF.jpg"></p>
<p>这部分是你实现 YTKBaseRequest 子类时可以覆写的方法</p>
<p>-requestCompletePreprocessor，-requestCompleteFilter，-requestFailedPreprocessor，-requestFailedFilter：这几个方法都是对请求 成功&#x2F;失败 结果的处理，结合之前讲过 <code>YTKRequestDelegate</code>，<code>YTKRequestAccessory</code> 两个协议里面的方法，下面给出这些方法的执行顺序.</p>
<p>请求成功后回调的执行顺序：</p>
<ol>
<li>requestCompletePreprocessor：如果使用 cache 的话是在主线程，否则的话在其它线程执行。下面的方法均在主线程执行</li>
<li>requestWillStop</li>
<li>requestCompleteFilter</li>
<li>requestFinished</li>
<li>successCompletionBlock</li>
<li>requestDidStop</li>
</ol>
<p>请求失败后回调的执行顺序</p>
<ol>
<li>requestFailedPreprocessor：如果使用 cache 的话是在主线程，否则的话在其它线程执行。下面的方法均在主线程执行</li>
<li>requestWillStop</li>
<li>requestFailedFilter</li>
<li>requestFailed</li>
<li>failureCompletionBlock</li>
<li>requestDidStop</li>
</ol>
<p>方法 <code>-cacheFileNameFilterForRequestArgument</code> 用来对请求参数 argument 进行过滤后返回一个新的参数，用在获取缓存文件名字上。</p>
<p>方法 <code>-requestAuthorizationHeaderFieldArray</code>，用于身份验证，在这个方法中你需要返回一个容量为 2 的数组，第一个元素表示账号，第二个元素表示密码。<br>该认证方式使用用户的 账号&#x2F;密码 作为凭证信息，进行 base64 编码添加到请求头 <code>Authorization</code> 中传输到服务器中</p>
<p>方法 <code>buildCustomUrlRequest</code>，在这个方法里面你可以放回一个自定义的 request，而不是使用 AFNetworking 的 AFHTTPRequestSerializer 生成。<br>如果你返回了一个不为 nil 的对象，那么将忽略 <code>requestUrl</code>, <code>requestTimeoutInterval</code>,  <code>requestArgument</code>, <code>allowsCellularAccess</code>, <code>requestMethod</code> and <code>requestSerializerType</code></p>
<p>方法 <code>jsonValidator</code>，在这个方法里面，你可以对 reponse 序列化后的 JSON 对象进行验证。<br>举个例子，我们要向网址 <a target="_blank" rel="noopener" href="http://www.yuantiku.com/iphone/users">http://www.yuantiku.com/iphone/users</a> 发送一个 GET 请求，请求参数是 userId 。我们想获得某一个用户的信息，包括他的昵称和等级，我们需要服务器必须返回昵称（字符串类型）和等级信息（数值类型），则可以覆盖 jsonValidator 方法，实现简单的验证。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (id)jsonValidator &#123;</span><br><span class="line">    return @&#123;</span><br><span class="line">        @&quot;nick&quot;: [NSString class],</span><br><span class="line">        @&quot;level&quot;: [NSNumber class]</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法 <code>statusCodeValidator</code>，我觉得如果是验证状态码的话好得加个状态码的参数啊，不过无所谓啦，反正可以自己获取状态码然后再进行判断。该方法返回一个布尔值，如果返回的是 NO 的话将会报错。</p>
<p>接下来讲 .m 文件</p>
<p><img src="https://i.loli.net/2020/07/13/njUJ93GyN6SertB.jpg"></p>
<p>在 .h 文件中这些属性都是只读的，在 .m 文件中改成可读写，防止外部修改这些属性的值。</p>
<p><img src="https://i.loli.net/2020/07/13/9jCsWPpr6qMcFoa.jpg"></p>
<p>将 <code>NSURLSessionTask</code>，<code>NSURLResponse</code> 的一些属性映射成自己的属性，便于使用</p>
<p><img src="https://i.loli.net/2020/07/13/x5iXczjwIsrBVY4.jpg"></p>
<p>设置请求 成功&#x2F;失败 的回调<br>需要注意的是可以添加多个实现了 YTKRequestAccessory 协议的对象</p>
<p><img src="https://i.loli.net/2020/07/13/HYdDZ5xE18bouSh.jpg"></p>
<p>开启&#x2F;关闭 请求的方法。<br>在 start 方法中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 触发 YTKRequestAccessory 代理</span><br><span class="line">- (void)toggleAccessoriesWillStartCallBack &#123;</span><br><span class="line">    for (id&lt;YTKRequestAccessory&gt; accessory in self.requestAccessories) &#123;</span><br><span class="line">        if ([accessory respondsToSelector:@selector(requestWillStart:)]) &#123;</span><br><span class="line">            [accessory requestWillStart:self];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/07/13/t4ia9CTdyofFMPn.jpg" alt="addRequest方法实现"></p>
<p>在成功创建 task 后，task 将会被添加到 _requestsRecord 属性中避免被释放。随后调用 resume 开启任务<br>如果我们没有覆写方法 buildCustomUrlRequest 返回自定义的 request，系统会根据 YTKBaseRequest 创建 request。这部分在 <code>sessionTaskForRequest:error:</code> 中实现</p>
<p><img src="https://i.loli.net/2020/07/13/D7bwGxekBOVtUNh.jpg"></p>
<p>获取 YTKBaseRequest 实例上各种属性的值，例如方法类型，参数，然后在根据 method 的不同，使用不同的方法创建 task。<br>因为这部分内容都在 YTKNetworkAgent，这里就简单提下。在后面讲解 YTKNetworkAgent 部分的时候再仔细说</p>
<p>在 <code>stop</code> 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 执行代理</span><br><span class="line">[self toggleAccessoriesWillStopCallBack];</span><br><span class="line">// 将 delegate 置为 nil</span><br><span class="line">self.delegate = nil;</span><br><span class="line">// task cancle</span><br><span class="line">[[YTKNetworkAgent sharedAgent] cancelRequest:self];</span><br><span class="line">// 执行代理</span><br><span class="line">[self toggleAccessoriesDidStopCallBack];</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/07/13/pJaWsQxdj1mATEh.jpg"></p>
<p>如果你的请求是下载任务，并且你指定了一个缓存文件名，那么下载好的部分数据将会写入这个临时文件中，在下次恢复下载时使用。<br>当然如果要使用断点下载，还需要满足下面的几个条件：</p>
<ol>
<li>这个资源自你第一次请求后没有改变</li>
<li>这个任务是一个 HTTP 或者 HTTP GET 请求</li>
<li>服务器在 reponse header 提供了 ETag 或者 Last-Modified 字段</li>
<li>服务器支持字节范围请求</li>
<li>本地临时文件没有被删除</li>
</ol>
<p><img src="https://i.loli.net/2020/07/13/z2X8Fqbu6fB5GIe.jpg"></p>
<p>由于 YTKBaseRequest 是一个基类，所以在这些需要子类覆写的方法里面内容不多</p>
<p><img src="https://i.loli.net/2020/07/13/JTaGPn6tEl7fpVq.jpg"></p>
<p>覆写了 -description 方法，方便打印信息</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-05-24T09:34:59.000Z" title="5/24/2020, 5:34:59 PM">2020-05-24</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">1 小时读完 (大约9973个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/05/24/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%AF%BB%E6%87%82-Runloop/"> 从源码读懂 Runloop</a></h1><div class="content"><p>runloop 是和线程密切相关的一个组件，它帮助线程管理需要被处理的事件和消息，例如网络连接，异步回调，定时器…<br>当有事件或消息要处理时唤醒线程处理，否则休眠等待接收 mach 消息。</p></div><a class="article-more button is-small is-size-7" href="/2020/05/24/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%AF%BB%E6%87%82-Runloop/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-05-11T08:04:52.000Z" title="5/11/2020, 4:04:52 PM">2020-05-11</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">1 小时读完 (大约7465个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/05/11/%E6%8E%A2%E7%A9%B6-block-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">探究 block 数据结构及内存管理</a></h1><div class="content"><p>本文首先将介绍一些 block 的基础, 随后着重介绍下面的内容</p>
<ul>
<li>block 的数据结构</li>
<li>block 的内存管理(retain，release)</li>
</ul>
<p>会用到下面这个<br><a target="_blank" rel="noopener" href="https://github.com/LGCooci/objc_debug/tree/master">可编译的源码</a></p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>Block</code> 的语法比较难记, 以至于出现了 <a target="_blank" rel="noopener" href="http://fuckingblocksyntax.com/">fuckingblocksyntax</a> 这样的网站专门用于记录 block 的语法, 摘录如下:</p>
<p>作为变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">returnType (^blockName)(parameterTypes) = ^returnType(parameters) &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>作为属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes);</span><br></pre></td></tr></table></figure>

<p>作为函数声明参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)someMethodThatTakesABlock:(returnType (^nullability)(parameterTypes))blockName;</span><br></pre></td></tr></table></figure>

<p>作为函数调用中的参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[someObject someMethodThatTakesABlock:^returnType (parameters) &#123;...&#125;];</span><br></pre></td></tr></table></figure>

<p>作为 typedef</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef returnType (^TypeName)(parameterTypes);</span><br><span class="line">TypeName blockName = ^returnType(parameters) &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="捕获外部变量"><a href="#捕获外部变量" class="headerlink" title="捕获外部变量"></a>捕获外部变量</h3><p>block 可以捕获来自外部作用域的变量(id 类型, C++类型, 基础数据类型, block), 这是 block 一个很强大的特性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)foo &#123;</span><br><span class="line">    int anInteger = 42;</span><br><span class="line">    void (^testBlock)(void) = ^&#123;</span><br><span class="line">        NSLog(@&quot;Integer is: %i&quot;, anInteger);</span><br><span class="line">    &#125;;</span><br><span class="line">    testBlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下, 捕获的外部变量在 block 里做的修改，在外部是不起作用的。如果想要在外部起作用，需要使用 <code>__block</code> 来声明变量:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int __block anInteger = 42</span><br></pre></td></tr></table></figure>

<p>所以，根据变量是否被 __block 修饰，可以将变量分为两类：</p>
<ul>
<li>by ref： 引用类型。该类的变量被 __block 修饰，在 block 内部对其修改，外部也生效</li>
<li>by copy：拷贝类型。该类的变量不被 __block 修饰，在 block 内部对其修改，外部不生效(全局&#x2F;静态 变量除外)</li>
</ul>
<p>至于原因进阶部分会进行详细的探究</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>运行下面的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^BLK)(void);</span><br><span class="line"></span><br><span class="line">- (void)foo</span><br><span class="line">&#123;</span><br><span class="line">    static int staticInt = 5;</span><br><span class="line">    int ret = 5;</span><br><span class="line">    </span><br><span class="line">    BLK globalBlock = ^&#123;</span><br><span class="line">        int a = staticInt;</span><br><span class="line">    &#125;;</span><br><span class="line">    BLK mallocBlock = ^&#123;</span><br><span class="line">        int a = ret;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;global = %@&quot;, globalBlock);</span><br><span class="line">    NSLog(@&quot;malloc = %@&quot;, mallocBlock);</span><br><span class="line">    NSLog(@&quot;stack = %@&quot;, ^&#123;int a = ret;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">global = &lt;__NSGlobalBlock__: 0x104bb22b0&gt;</span><br><span class="line">malloc = &lt;__NSMallocBlock__: 0x281a21bf0&gt;</span><br><span class="line">stack  = &lt;__NSStackBlock__:  0x16b8266d8&gt;</span><br></pre></td></tr></table></figure>

<p>在 iOS 平台中, 一共有三种类型的 block:</p>
<ul>
<li>_NSConcreteGlobalBlock： 在 .data 区域, block 内部没有访问任何的外部非(静态变量 &amp;&amp; 全局变量)的变量(^{;}同样是该类型)</li>
<li>_NSConcreteMallocBlock： 在堆中创建内存, 使用<code>__strong</code>修饰的 block </li>
<li>_NSConcreteStackBlock：  在栈中创建内存, 使用<code>__weak</code>修饰的 block 或者是匿名 block</li>
</ul>
<p>优先级为 _NSConcreteGlobalBlock &gt; _NSConcreteMallocBlock &#x3D;&#x3D; _NSConcreteStackBlock，即满足 _NSConcreteGlobalBlock 条件的 block 就是 _NSConcreteGlobalBlock 类型的</p>
<p>_NSConcreteGlobalBlock 类型的 block 我不知道初始化的时候是否直接在 .data 区域创建。<br>_NSConcreteMallocBlock 和 _NSConcreteStackBlock类型的 block 在初始化时在栈中创建，随后如果有 __storng 强指针引用的话，<br>则进行 retain 操作，将其内存拷贝到堆中，后续的 retain 操作则只是增加 block 的引用计数</p>
<hr>
<p>使用命令<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-13.0.0 YOUR_FILE_NAME</code>将下面的代码转换成 C++ 实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)foo</span><br><span class="line">&#123;</span><br><span class="line">    static int staticInt = 5;</span><br><span class="line">    NSObject *commonObject = [[NSObject alloc] init];</span><br><span class="line">    __weak NSObject *weakObject = commonObject;</span><br><span class="line">    __block NSObject *byrefObject = [[NSObject alloc] init];</span><br><span class="line">    __block __weak NSObject *byrefWeakObject = commonObject;</span><br><span class="line">    BLK blockObject = ^&#123;</span><br><span class="line">       NSObject *val = commonObject;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">    BLK malocBlock = ^&#123;</span><br><span class="line">        staticInt++;</span><br><span class="line">        NSLog(@&quot;%@&quot;, commonObject);</span><br><span class="line">        NSLog(@&quot;%@&quot;, byrefWeakObject);</span><br><span class="line">        NSLog(@&quot;%@&quot;, weakObject);</span><br><span class="line">        NSLog(@&quot;%@&quot;, byrefObject);</span><br><span class="line">        NSLog(@&quot;%@&quot;, byrefWeakObject);</span><br><span class="line">        NSLog(@&quot;%@&quot;, blockObject);</span><br><span class="line">    &#125;;</span><br><span class="line">    NSLog(@&quot;malloc = %@&quot;, malocBlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换得到的 C++ 实现， 只截取部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">static void __Block_byref_id_object_copy_131(void *dst, void *src) &#123;</span><br><span class="line"> _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);</span><br><span class="line">&#125;</span><br><span class="line">static void __Block_byref_id_object_dispose_131(void *src) &#123;</span><br><span class="line"> _Block_object_dispose(*(void * *) ((char*)src + 40), 131);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct __Block_byref_byrefObject_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_byrefObject_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> void (*__Block_byref_id_object_copy)(void*, void*);</span><br><span class="line"> void (*__Block_byref_id_object_dispose)(void*);</span><br><span class="line"> NSObject *__strong byrefObject;</span><br><span class="line">&#125;;</span><br><span class="line">struct __Block_byref_byrefWeakObject_1 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_byrefWeakObject_1 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> void (*__Block_byref_id_object_copy)(void*, void*);</span><br><span class="line"> void (*__Block_byref_id_object_dispose)(void*);</span><br><span class="line"> NSObject *__weak byrefWeakObject;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __TestObject__foo_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __TestObject__foo_block_desc_0* Desc;</span><br><span class="line">  NSObject *__strong commonObject;</span><br><span class="line">  __TestObject__foo_block_impl_0(void *fp, struct __TestObject__foo_block_desc_0 *desc, NSObject *__strong _commonObject, int flags=0) : commonObject(_commonObject) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __TestObject__foo_block_func_0(struct __TestObject__foo_block_impl_0 *__cself) &#123;</span><br><span class="line">  NSObject *__strong commonObject = __cself-&gt;commonObject; // bound by copy</span><br><span class="line"></span><br><span class="line">       NSObject *val = commonObject;</span><br><span class="line">   &#125;</span><br><span class="line">static void __TestObject__foo_block_copy_0(struct __TestObject__foo_block_impl_0*dst, struct __TestObject__foo_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;commonObject, (void*)src-&gt;commonObject, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __TestObject__foo_block_dispose_0(struct __TestObject__foo_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;commonObject, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static struct __TestObject__foo_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __TestObject__foo_block_impl_0*, struct __TestObject__foo_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __TestObject__foo_block_impl_0*);</span><br><span class="line">&#125; __TestObject__foo_block_desc_0_DATA = &#123; 0, sizeof(struct __TestObject__foo_block_impl_0), __TestObject__foo_block_copy_0, __TestObject__foo_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">struct __TestObject__foo_block_impl_1 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __TestObject__foo_block_desc_1* Desc;</span><br><span class="line">  int *staticInt;</span><br><span class="line">  NSObject *__strong commonObject;</span><br><span class="line">  NSObject *__weak weakObject;</span><br><span class="line">  __strong BLK blockObject;</span><br><span class="line">  __Block_byref_byrefWeakObject_1 *byrefWeakObject; // by ref</span><br><span class="line">  __Block_byref_byrefObject_0 *byrefObject; // by ref</span><br><span class="line">  __TestObject__foo_block_impl_1(void *fp, struct __TestObject__foo_block_desc_1 *desc, int *_staticInt, NSObject *__strong _commonObject, NSObject *__weak _weakObject, __strong BLK _blockObject, __Block_byref_byrefWeakObject_1 *_byrefWeakObject, __Block_byref_byrefObject_0 *_byrefObject, int flags=0) : staticInt(_staticInt), commonObject(_commonObject), weakObject(_weakObject), blockObject(_blockObject), byrefWeakObject(_byrefWeakObject-&gt;__forwarding), byrefObject(_byrefObject-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __TestObject__foo_block_func_1(struct __TestObject__foo_block_impl_1 *__cself) &#123;</span><br><span class="line">  __Block_byref_byrefWeakObject_1 *byrefWeakObject = __cself-&gt;byrefWeakObject; // bound by ref</span><br><span class="line">  __Block_byref_byrefObject_0 *byrefObject = __cself-&gt;byrefObject; // bound by ref</span><br><span class="line">  int *staticInt = __cself-&gt;staticInt; // bound by copy</span><br><span class="line">  NSObject *__strong commonObject = __cself-&gt;commonObject; // bound by copy</span><br><span class="line">  NSObject *__weak weakObject = __cself-&gt;weakObject; // bound by copy</span><br><span class="line">  __strong BLK blockObject = __cself-&gt;blockObject; // bound by copy</span><br><span class="line"></span><br><span class="line">        (*staticInt)++;</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h0_ybj03b8d0mj52n8dx82v2br40000gn_T_TestObject_1a9b07_mi_0, commonObject);</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h0_ybj03b8d0mj52n8dx82v2br40000gn_T_TestObject_1a9b07_mi_1, (byrefWeakObject-&gt;__forwarding-&gt;byrefWeakObject));</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h0_ybj03b8d0mj52n8dx82v2br40000gn_T_TestObject_1a9b07_mi_2, weakObject);</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h0_ybj03b8d0mj52n8dx82v2br40000gn_T_TestObject_1a9b07_mi_3, (byrefObject-&gt;__forwarding-&gt;byrefObject));</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h0_ybj03b8d0mj52n8dx82v2br40000gn_T_TestObject_1a9b07_mi_4, (byrefWeakObject-&gt;__forwarding-&gt;byrefWeakObject));</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h0_ybj03b8d0mj52n8dx82v2br40000gn_T_TestObject_1a9b07_mi_5, blockObject);</span><br><span class="line">    &#125;</span><br><span class="line">static void __TestObject__foo_block_copy_1(struct __TestObject__foo_block_impl_1*dst, struct __TestObject__foo_block_impl_1*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;commonObject, (void*)src-&gt;commonObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_assign((void*)&amp;dst-&gt;byrefWeakObject, (void*)src-&gt;byrefWeakObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;weakObject, (void*)src-&gt;weakObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_assign((void*)&amp;dst-&gt;byrefObject, (void*)src-&gt;byrefObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;blockObject, (void*)src-&gt;blockObject, 7/*BLOCK_FIELD_IS_BLOCK*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __TestObject__foo_block_dispose_1(struct __TestObject__foo_block_impl_1*src) &#123;_Block_object_dispose((void*)src-&gt;commonObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_dispose((void*)src-&gt;byrefWeakObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;weakObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_dispose((void*)src-&gt;byrefObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;blockObject, 7/*BLOCK_FIELD_IS_BLOCK*/);&#125;</span><br><span class="line"></span><br><span class="line">static struct __TestObject__foo_block_desc_1 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __TestObject__foo_block_impl_1*, struct __TestObject__foo_block_impl_1*);</span><br><span class="line">  void (*dispose)(struct __TestObject__foo_block_impl_1*);</span><br><span class="line">&#125; __TestObject__foo_block_desc_1_DATA = &#123; 0, sizeof(struct __TestObject__foo_block_impl_1), __TestObject__foo_block_copy_1, __TestObject__foo_block_dispose_1&#125;;</span><br><span class="line"></span><br><span class="line">static void _I_TestObject_foo(TestObject * self, SEL _cmd) &#123;</span><br><span class="line">    static int staticInt = 5;</span><br><span class="line">    NSObject *commonObject = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));</span><br><span class="line">    __attribute__((objc_ownership(weak))) NSObject *weakObject = commonObject;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_byrefObject_0 byrefObject = &#123;(void*)0,(__Block_byref_byrefObject_0 *)&amp;byrefObject, 33554432, sizeof(__Block_byref_byrefObject_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;))&#125;;</span><br><span class="line">    __attribute__((__blocks__(byref))) __attribute__((objc_ownership(weak))) __Block_byref_byrefWeakObject_1 byrefWeakObject = &#123;(void*)0,(__Block_byref_byrefWeakObject_1 *)&amp;byrefWeakObject, 33554432, sizeof(__Block_byref_byrefWeakObject_1), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, commonObject&#125;;</span><br><span class="line">    BLK blockObject = ((void (*)())&amp;__TestObject__foo_block_impl_0((void *)__TestObject__foo_block_func_0, &amp;__TestObject__foo_block_desc_0_DATA, commonObject, 570425344));</span><br><span class="line"></span><br><span class="line">    BLK malocBlock = ((void (*)())&amp;__TestObject__foo_block_impl_1((void *)__TestObject__foo_block_func_1, &amp;__TestObject__foo_block_desc_1_DATA, &amp;staticInt, commonObject, weakObject, blockObject, (__Block_byref_byrefWeakObject_1 *)&amp;byrefWeakObject, (__Block_byref_byrefObject_0 *)&amp;byrefObject, 570425344));</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h0_ybj03b8d0mj52n8dx82v2br40000gn_T_TestObject_1a9b07_mi_6, malocBlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，上面生成的 C++ 代码中 block 的结构体，并不符合最新版本 objc4-779.1 源码里 block 的结构定义</p>
</blockquote>
<p>在 objc4-779.1 里 block 结构体的定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#define BLOCK_DESCRIPTOR_1 1</span><br><span class="line">struct Block_descriptor_1 &#123;</span><br><span class="line">    uintptr_t reserved;</span><br><span class="line">    uintptr_t size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define BLOCK_DESCRIPTOR_2 1</span><br><span class="line">struct Block_descriptor_2 &#123;</span><br><span class="line">    // requires BLOCK_HAS_COPY_DISPOSE</span><br><span class="line">    void (*copy)(void *dst, const void *src);</span><br><span class="line">    void (*dispose)(const void *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define BLOCK_DESCRIPTOR_3 1</span><br><span class="line">struct Block_descriptor_3 &#123;</span><br><span class="line">    // requires BLOCK_HAS_SIGNATURE</span><br><span class="line">    const char *signature;</span><br><span class="line">    const char *layout;     // contents depend on BLOCK_HAS_EXTENDED_LAYOUT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Block_layout &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    volatile int32_t flags; // contains ref count</span><br><span class="line">    int32_t reserved; </span><br><span class="line">    void (*invoke)(void *, ...);</span><br><span class="line">    struct Block_descriptor_1 *descriptor;</span><br><span class="line">    // imported variables</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不是有三种类型的 BLOCK_DESCRIPTOR 结构体，只是根据功能将其分为三部分，其实是一个整体<br>注意下面两个结构体在内存上是完全一样的，原因是结构体本身并不带有任何额外的附加信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct SampleA &#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">    int c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct SampleB &#123;</span><br><span class="line">    int a;</span><br><span class="line">    struct Part1 &#123;</span><br><span class="line">        int b;</span><br><span class="line">    &#125;;</span><br><span class="line">    struct Part2 &#123;</span><br><span class="line">        int c;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>Block_layout 成员变量介绍:</p>
<ul>
<li>void *isa: isa 指针</li>
<li>int flags: 使用位域来保存信息, 例如引用计数, 是否正在被销毁等信息</li>
<li>int reserved: 保留变量</li>
<li>void (*invoke)(void *, …): 函数指针, 指向 block 实现函数的调用地址</li>
<li>struct Block_descriptor *descriptor: block 的附加描述信息，一般来说都包含 Block_descriptor_1，但是是否包含 Block_descriptor_2 和 Block_descriptor_3 需要根据捕获外部变量的类型来判断</li>
<li>还有一些捕获的外部变量</li>
</ul>
<table>
<thead>
<tr>
<th>位域名</th>
<th>位置</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>BLOCK_DEALLOCATING</td>
<td>0x0001</td>
<td>1 表示正在被销毁</td>
</tr>
<tr>
<td>BLOCK_REFCOUNT_MASK</td>
<td>0xfffe</td>
<td>block 是引用计数</td>
</tr>
<tr>
<td>BLOCK_NEEDS_FREE</td>
<td>1 &lt;&lt; 24</td>
<td>1 表示 block 已拷贝到堆中</td>
</tr>
<tr>
<td>BLOCK_HAS_COPY_DISPOSE</td>
<td>1 &lt;&lt; 25</td>
<td>block 是否有 copy&#x2F;dispos 函数，即 descriptor 是否包含 Block_descriptor_2</td>
</tr>
<tr>
<td>BLOCK_HAS_CTOR</td>
<td>1 &lt;&lt; 26</td>
<td>copy&#x2F;dispose helper 函数里面有 C++代码</td>
</tr>
<tr>
<td>BLOCK_IS_GC</td>
<td>1 &lt;&lt; 27</td>
<td>1 表示使用 GC 管理内存，iOS 平台中不使用 GC</td>
</tr>
<tr>
<td>BLOCK_IS_GLOBAL</td>
<td>1 &lt;&lt; 28</td>
<td>1 表示是个全局 block</td>
</tr>
<tr>
<td>BLOCK_USE_STRET</td>
<td>1 &lt;&lt; 29</td>
<td>arm64 架构下没用，不知道干嘛的</td>
</tr>
<tr>
<td>BLOCK_HAS_SIGNATURE</td>
<td>1 &lt;&lt; 30</td>
<td>是否有函数类型编码</td>
</tr>
<tr>
<td>BLOCK_HAS_EXTENDED_LAYOUT</td>
<td>1 &lt;&lt; 31</td>
<td>GC 下使用</td>
</tr>
</tbody></table>
<p>Block_descriptor 成员变量介绍:</p>
<ul>
<li>unsigned long int reserved: 预留变量</li>
<li>unsigned long int size: block 结构体的 size 大小</li>
<li>void (*copy)(void *dst, void *src): copy 函数，将 block 成员变量 从栈拷贝到堆中。后面会再介绍</li>
<li>void (*dispose)(void *): dispose 函数， 对 block 成员变量内存回收</li>
<li>const char *signature：函数的类型编码</li>
<li>const char *layout: GC 下使用，不知道具体作用</li>
</ul>
<p>让我们对照着 C++ 实现捋一遍，因为实现里的 block 结构体是老版本所以跟上面讲的可能会有出入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __TestObject__foo_block_impl_1 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __TestObject__foo_block_desc_1* Desc;</span><br><span class="line">  int *staticInt;</span><br><span class="line">  NSObject *__strong commonObject;</span><br><span class="line">  NSObject *__weak weakObject;</span><br><span class="line">  __strong BLK blockObject;</span><br><span class="line">  __Block_byref_byrefWeakObject_1 *byrefWeakObject; // by ref</span><br><span class="line">  __Block_byref_byrefObject_0 *byrefObject; // by ref</span><br><span class="line">  __TestObject__foo_block_impl_1(void *fp, struct __TestObject__foo_block_desc_1 *desc, int *_staticInt, NSObject *__strong _commonObject, NSObject *__weak _weakObject, __strong BLK _blockObject, __Block_byref_byrefWeakObject_1 *_byrefWeakObject, __Block_byref_byrefObject_0 *_byrefObject, int flags=0) : staticInt(_staticInt), commonObject(_commonObject), weakObject(_weakObject), blockObject(_blockObject), byrefWeakObject(_byrefWeakObject-&gt;__forwarding), byrefObject(_byrefObject-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>在结构体 __TestObject__foo_block_impl_1 有很多捕获的外部变量充当的成员变量，如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int *staticInt;</span><br><span class="line">NSObject *__strong commonObject;</span><br><span class="line">NSObject *__weak weakObject;</span><br><span class="line">__strong BLK blockObject;</span><br><span class="line">__Block_byref_byrefWeakObject_1 *byrefWeakObject; // by ref</span><br><span class="line">__Block_byref_byrefObject_0 *byrefObject; // by ref</span><br></pre></td></tr></table></figure>

<p>为了尽可能的谈论多的情况，在示例代码中我在 block 加了许多不同类型的外部变量<br>可以看到，全局&#x2F;静态 变量和 __block 变量，都是将变量的地址保存在成员变量中，这样做的目的是为了在内部修改该变量在外部也会生效。<br>而其它非 __block 变量则仅仅拷贝了值，类似于浅拷贝</p>
<p>__Block_byref_byrefWeakObject_1 是 Block_byref 类型的结构体。__block 变量在编译时变成对应的 Block_byref 实例，且实例持有该变量</p>
<p>Block_byref 结构体的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct Block_byref &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    struct Block_byref *forwarding;</span><br><span class="line">    volatile int32_t flags; // contains ref count</span><br><span class="line">    uint32_t size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Block_byref_2 &#123;</span><br><span class="line">    // requires BLOCK_BYREF_HAS_COPY_DISPOSE</span><br><span class="line">    void (*byref_keep)(struct Block_byref *dst, struct Block_byref *src);</span><br><span class="line">    void (*byref_destroy)(struct Block_byref *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Block_byref_3 &#123;</span><br><span class="line">    // requires BLOCK_BYREF_LAYOUT_EXTENDED</span><br><span class="line">    const char *layout;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类似 Block_descriptor，根据功能将其分为三部分<br>成员变量介绍：</p>
<ul>
<li>void *isa：一般指向 0x0，如果该变量还被 __weak 修饰，则指向 _NSConcreteWeakBlockVariable</li>
<li>struct Block_byref *forwarding：指向该结构体。在拷贝到堆的过程中，在堆中新建一个结构体实例，此时栈中的实例并没有被销毁，将栈中实例 forwarding 指向堆中的实例</li>
<li>int flags：引用计数使用的 bit 数目和位置与 block 相同，其它不再介绍</li>
<li>int size：Block_byref 结构体的字节长度</li>
<li>void (*byref_keep)(struct Block_byref *dst, struct Block_byref *src)：Block_byref 的 copy 函数，帮助将实例持有的变量拷贝到堆中</li>
<li>void (*byref_destroy)(struct Block_byref *)：Block_byref 的 dispose 函数，帮助将持有的变量销毁</li>
<li>const char *layout：Block_byref 持有的变量</li>
</ul>
<p>为了方便，后面将 Block_layout 的 copy&#x2F;dispose 函数简称为 Block copy&#x2F;dispose 函数; Block_byref 的 byref_keep&#x2F;byref_destroy 函数简称为 __block copy&#x2F;dispose 函数</p>
<p>在 <code>foo()</code> 函数中我们在 block 捕获了两个 __block 修饰的变量，下面是其中一个的 Block_byref 结构体</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_byrefObject_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_byrefObject_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> void (*__Block_byref_id_object_copy)(void*, void*);</span><br><span class="line"> void (*__Block_byref_id_object_dispose)(void*);</span><br><span class="line"> NSObject *__strong byrefObject;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>编译时，编译器会将 __block 修饰的变量 byrefObject，转换成对应的 Block_byref 结构体 __Block_byref_byrefObject_0 实例，然后让实例持有该变量<code>NSObject *__strong byrefObject;</code></p>
<hr>
<p>block 结构体 __TestObject__foo_block_impl_1 里面还定义了一个初始化方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_TestObject__foo_block_impl_1(void *fp, struct __TestObject__foo_block_desc_1 *desc, int *_staticInt, NSObject *__strong _commonObject, NSObject *__weak _weakObject, __strong BLK _blockObject, __Block_byref_byrefWeakObject_1 *_byrefWeakObject, __Block_byref_byrefObject_0 *_byrefObject, int flags=0) : staticInt(_staticInt), commonObject(_commonObject), weakObject(_weakObject), blockObject(_blockObject), byrefWeakObject(_byrefWeakObject-&gt;__forwarding), byrefObject(_byrefObject-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>其中类似 <code>: commonObject(_commonObject)</code> 的写法是将形参<code>NSObject *__strong _commonObject</code>赋值给成员变量 <code>_commonObject</code></li>
<li>参数 flags 有一个默认值 0, 在本例中传入的值为 570425344, 用二进制表示为 0b00100010000000000000000000000000，即第 30 位(BLOCK_USE_STRET), 第 26 位(BLOCK_HAS_COPY_DISPOSE) bit 的值 1</li>
<li>参数 fp 是函数指针, 在本例中它的实现如下:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void __TestObject__foo_block_func_1(struct __TestObject__foo_block_impl_1 *__cself) &#123;</span><br><span class="line">  __Block_byref_byrefWeakObject_1 *byrefWeakObject = __cself-&gt;byrefWeakObject; // bound by ref</span><br><span class="line">  __Block_byref_byrefObject_0 *byrefObject = __cself-&gt;byrefObject; // bound by ref</span><br><span class="line">  int *staticInt = __cself-&gt;staticInt; // bound by copy</span><br><span class="line">  NSObject *__strong commonObject = __cself-&gt;commonObject; // bound by copy</span><br><span class="line">  NSObject *__weak weakObject = __cself-&gt;weakObject; // bound by copy</span><br><span class="line">  __strong BLK blockObject = __cself-&gt;blockObject; // bound by copy</span><br><span class="line"></span><br><span class="line">        (*staticInt)++;</span><br><span class="line"></span><br><span class="line">       // 省略。。。</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
<p>也就是 block 里面的代码。<br>可以看到非 __block 变量后面都写了注释 <code>bound by copy</code>，__block 变量后面的注释是 <code>bound by ref</code>，__block 变量都会转换成 Block_byref 实例保存在 block 中<br>为了方便，后面将 __block 修饰的变量称为引用变量，否则称为拷贝变量</p>
<ul>
<li>block 初始化参数 desc 的类型是<code>__TestObject__foo_block_desc_1 *</code></li>
</ul>
<p>结构体的定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static struct __TestObject__foo_block_desc_1 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __TestObject__foo_block_impl_1*, struct __TestObject__foo_block_impl_1*);</span><br><span class="line">  void (*dispose)(struct __TestObject__foo_block_impl_1*);</span><br><span class="line">&#125; __TestObject__foo_block_desc_1_DATA = &#123; 0, sizeof(struct __TestObject__foo_block_impl_1), __TestObject__foo_block_copy_1, __TestObject__foo_block_dispose_1&#125;;</span><br></pre></td></tr></table></figure>

<p>并且初始化了一个结构体实例 <code>__TestObject__foo_block_desc_1_DATA</code>，其中 reserved 的值为 0, Block_size 的值为结构体 __TestObject__foo_block_impl_1 的字节长度<br>copy 和 dispose 两个函数指针分别指向函数 __TestObject__foo_block_copy_1 和 __TestObject__foo_block_dispose_1<br>实现如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void __TestObject__foo_block_copy_1(struct __TestObject__foo_block_impl_1*dst, struct __TestObject__foo_block_impl_1*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;commonObject, (void*)src-&gt;commonObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_assign((void*)&amp;dst-&gt;byrefWeakObject, (void*)src-&gt;byrefWeakObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;weakObject, (void*)src-&gt;weakObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_assign((void*)&amp;dst-&gt;byrefObject, (void*)src-&gt;byrefObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;blockObject, (void*)src-&gt;blockObject, 7/*BLOCK_FIELD_IS_BLOCK*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __TestObject__foo_block_dispose_1(struct __TestObject__foo_block_impl_1*src) &#123;_Block_object_dispose((void*)src-&gt;commonObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_dispose((void*)src-&gt;byrefWeakObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;weakObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_dispose((void*)src-&gt;byrefObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;blockObject, 7/*BLOCK_FIELD_IS_BLOCK*/);&#125;</span><br></pre></td></tr></table></figure>

<p>这两个函数很容易看懂，有多少捕获的外部变量，就调用多少次 <code>_Block_object_assign()</code> 和 <code>_Block_object_dispose()</code>  函数。<br>需要注意的是 <code>_Block_object_assign()</code> 的第三个参数，根据变量的类型不同传入不同的标记，后面会详细讲</p>
<p>与其类似的是 Block_byref  的 copy&#x2F;dispose 函数<br>在本例中它们的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void __Block_byref_id_object_copy_131(void *dst, void *src) &#123;</span><br><span class="line"> _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);</span><br><span class="line">&#125;</span><br><span class="line">static void __Block_byref_id_object_dispose_131(void *src) &#123;</span><br><span class="line"> _Block_object_dispose(*(void * *) ((char*)src + 40), 131);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>可以看到，Block_byref 的 copy&#x2F;dispose 函数最终也是调用 _Block_object_assign&#x2F;_Block_object_dispose 函数</p>
<p>至于参数为什么要强转成 char*, 我的理解是这样的：</p>
<p>举个例子，定义一个 int 类型的数组, <code>int a[10]</code>。我们可以使用指针来代替数组的下标, 例如用<code>(int *)a + 1</code>来表示数组的第二个元素, 其距离第一个元素偏移了 4 个字节长度，所以强制转换成 char* 类型是为了每次偏移 1 个字节。上面的代码表示偏移了 40 个字节</p>
<p>而老版本 Block_byref 的定义(因为 C++ 实现符合源码)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Block_byref &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    struct Block_byref *forwarding;</span><br><span class="line">    int flags; /* refcount; */</span><br><span class="line">    int size;</span><br><span class="line">    void (*byref_keep)(struct Block_byref *dst, struct Block_byref *src);</span><br><span class="line">    void (*byref_destroy)(struct Block_byref *);</span><br><span class="line">    /* long shared[0]; */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Block_byref 偏移 40 个字节后的位置刚好是持有变量的首地址，所以在这里传入的参数即是引用变量(被 __block 修饰的变量)<br>至于后面的数字 131 后面再讲</p>
<p>好了，数据结构就分析到这啦。<br>目前我们可以知道的是，block 以及 __block 变量在编译时会生成对应的 Block_layout，Block_byref 结构体，它们都有各自的 copy&#x2F;dispose 函数</p>
<h3 id="验证-block-数据结构"><a href="#验证-block-数据结构" class="headerlink" title="验证 block 数据结构"></a>验证 block 数据结构</h3><p>这一节主要使用 lldb 用来验证 block 的数据结构</p>
<p><img src="https://i.loli.net/2020/05/11/cWBvNK3VRthaqgE.jpg"></p>
<p>打个断点，使用命令 <code>x/8xg ptr</code></p>
<p><img src="https://i.loli.net/2020/05/11/fJgaS9tmeHB7G5V.jpg" alt="block 内部分布"></p>
<p>根据上一节 block 结构体内容，我们可以知道各成员变量的值</p>
<table>
<thead>
<tr>
<th>block 成员变量</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>void *isa</td>
<td>0x00000001ca53c0f0</td>
</tr>
<tr>
<td>volatile int32_t flags</td>
<td>0xc3000002</td>
</tr>
<tr>
<td>int32_t reserved</td>
<td>0x0</td>
</tr>
<tr>
<td>void (*invoke)(void *, …)</td>
<td>0x0000000104bcce80</td>
</tr>
<tr>
<td>struct Block_descriptor_1 *descriptor</td>
<td>0x000000010519e290</td>
</tr>
<tr>
<td>捕获变量 _commonObject</td>
<td>0x0000000281eaac10</td>
</tr>
<tr>
<td>Block_byref * _byrefObject</td>
<td>0x0000000281225170</td>
</tr>
</tbody></table>
<p>验证一下：</p>
<p><img src="https://i.loli.net/2020/05/11/R6xtyLwKA8bg4hc.jpg" alt="isa 验证"></p>
<p>isa 指针指向 __NSMallocBlock__，没问题</p>
<p>flags 用二进制表示为 0b11000011000000000000000000000010，即位域  BLOCK_HAS_SIGNATURE，BLOCK_HAS_EXTENDED_LAYOUT，BLOCK_HAS_COPY_DISPOSE，BLOCK_NEEDS_FREE 为 1 引用计数 BLOCK_REFCOUNT_MASK 为 1</p>
<p><img src="https://i.loli.net/2020/05/11/l3FxiDYJELdte5C.jpg" alt="invoke 验证"><br>可以通过上面的方法打印出函数指针的内容</p>
<p>成员变量 _commonObject 的值于 commonObject 相同，均为 0x0000000281eaac10，说明是浅拷贝</p>
<p>下面来验证 descriptor<br>0x000000010519e290 为 Block_descriptor_1 结构体的首地址</p>
<p><img src="https://i.loli.net/2020/05/11/6TiVct12vSRUbQI.jpg" alt="descriptor 内存分布"></p>
<table>
<thead>
<tr>
<th>Block_descriptor 成员变量</th>
<th>值</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>uintptr_t reserved</td>
<td>0x0</td>
<td>预留字段</td>
</tr>
<tr>
<td>uintptr_t size</td>
<td>0x0000000000000030</td>
<td>十进制为 48，即 block 结构体的字节长度</td>
</tr>
<tr>
<td>void (*copy)(void *dst, const void *src)</td>
<td>0x0000000104bccee8</td>
<td>copy 函数指针</td>
</tr>
<tr>
<td>void (*dispose)(const void *)</td>
<td>0x0000000104bccf54</td>
<td>dispose 函数指针</td>
</tr>
<tr>
<td>const char *signature</td>
<td>0x000000010511847f</td>
<td>函数类型编码</td>
</tr>
<tr>
<td>const char *layout</td>
<td>0x0000000000000110</td>
<td>不知道干嘛的</td>
</tr>
</tbody></table>
<p>打印下 block 函数的类型编码</p>
<p><img src="https://i.loli.net/2020/05/11/cHWtqd6iOk8GzT7.jpg" alt="函数类型编码"></p>
<p>成员变量 const char *layout 应该是在 GC 下使用的，具体作用不明白</p>
<hr>
<p>接下来验证 Block_byref 的结构</p>
<p><img src="https://i.loli.net/2020/05/11/kRQwxf5btaYE97F.jpg" alt="Block_byref 内存分布"></p>
<table>
<thead>
<tr>
<th>Block_byref 成员变量</th>
<th>值</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>void *isa</td>
<td>0x0</td>
<td>isa</td>
</tr>
<tr>
<td>struct Block_byref *forwarding</td>
<td>0x0000000281225170</td>
<td>十进制为 48，即 block 结构体的字节长度</td>
</tr>
<tr>
<td>volatile int32_t flags</td>
<td>0x33000004</td>
<td>标记，二级制表示为 0b00110011000000000000000000000100</td>
</tr>
<tr>
<td>uint32_t size</td>
<td>0x00000030</td>
<td>Block_byref 结构体长度</td>
</tr>
<tr>
<td>byref_keep</td>
<td>0x000000010511847f</td>
<td>__block copy 函数指针</td>
</tr>
<tr>
<td>byref_destroy</td>
<td>0x0000000000000110</td>
<td>__block dispose 函数指针</td>
</tr>
<tr>
<td>const char *layout</td>
<td>0x0000000281eaac50</td>
<td>持有的变量  byrefObject</td>
</tr>
</tbody></table>
<p>flags 表示引用计数为 2，因为初始化有一个，然后 block 有一个。位域 BLOCK_BYREF_LAYOUT_STRONG 为 1，表示该变量是 __strong 类型<br>const char *layout 表示其持有的变量</p>
<h3 id="如何将-block-从栈拷贝到堆中"><a href="#如何将-block-从栈拷贝到堆中" class="headerlink" title="如何将 block 从栈拷贝到堆中"></a>如何将 block 从栈拷贝到堆中</h3><p>现在我们来探究一下 block 是如何从栈中拷贝到堆中的吧。<br>除 global block 类型的 block 均在栈中创建，当被强引用，即 retain block 的话，block 就会从栈拷贝到堆中，如果已经在堆中，则增加其引用计数</p>
<p><img src="https://i.loli.net/2020/05/07/FGZfBguw6mJ4an7.jpg" alt="断点调试"></p>
<p>step into</p>
<p><img src="https://i.loli.net/2020/05/07/OSwbczJdivUKRm8.jpg"></p>
<p>_Block_copy 的函数实现在 <a target="_blank" rel="noopener" href="https://opensource.apple.com/source/clang/clang-800.0.42.1/src/projects/compiler-rt/lib/BlocksRuntime/runtime.c.auto.html">clang-800 源码</a> 中可以看到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void *_Block_copy(const void *arg) &#123;</span><br><span class="line">    return _Block_copy_internal(arg, WANTS_ONE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/05/07/Eb4mvWz5djZIq1c.jpg" alt="_Block_copy_internal 实现"></p>
<p>我们主要看红色框框里面的代码：</p>
<ul>
<li>首先通过 <code>malloc()</code> 在堆中新建一个 block 结构体实例，接着使用<code>memmove()</code>将旧实例的数据拷贝过去</li>
<li>重置新实例成员变量 flags 的 BLOCK_REFCOUNT_MASK(引用计数)部分</li>
<li>将新实例成员变量 flags 的位域 BLOCK_NEEDS_FREE 设置为 1, 表示该 block 在堆中</li>
<li>将新实例的 isa 指向 _NSConcreteMallocBlock</li>
<li>如果存在 Block copy 函数，则调用</li>
</ul>
<p>上一节中已经提到过，这里再贴一下它的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static void __TestObject__foo_block_copy_1(struct __TestObject__foo_block_impl_1*dst, struct __TestObject__foo_block_impl_1*src) </span><br><span class="line">&#123;</span><br><span class="line">_Block_object_assign((void*)&amp;dst-&gt;commonObject, (void*)src-&gt;commonObject, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br><span class="line">_Block_object_assign((void*)&amp;dst-&gt;byrefWeakObject, (void*)src-&gt;byrefWeakObject, 8/*BLOCK_FIELD_IS_BYREF*/);</span><br><span class="line">_Block_object_assign((void*)&amp;dst-&gt;weakObject, (void*)src-&gt;weakObject, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br><span class="line">_Block_object_assign((void*)&amp;dst-&gt;byrefObject, (void*)src-&gt;byrefObject, 8/*BLOCK_FIELD_IS_BYREF*/);</span><br><span class="line">_Block_object_assign((void*)&amp;dst-&gt;blockObject, (void*)src-&gt;blockObject, 7/*BLOCK_FIELD_IS_BLOCK*/);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，如果外部变量是 C++类型，则不会调用 <code>_Block_object_assign()</code>函数，而是其对应的 const 拷贝构造方法。注释如下：<br>In these cases helper functions are synthesized by the compiler for use in Block_copy and Block_release, called the copy and dispose helpers.  The copy helper emits a call to the C++ const copy constructor for C++ stack based objects and for the rest calls into the runtime support function _Block_object_assign.  The dispose helper has a call to the C++ destructor for case 1 and a call into _Block_object_dispose for the rest.</p>
</blockquote>
<p><code>_Block_object_assign</code>函数的实现如下:</p>
<p><img src="https://i.loli.net/2020/05/11/AM2sgQxLlbGeVF9.jpg" alt="_Block_object_assign 函数实现"></p>
<p>参数 flags 有以下几种情况:</p>
<p>由 Block copy 函数调用：</p>
<ul>
<li><pre><code>id                   3       
</code></pre>
<ul>
<li><pre><code>(^Block)             7
</code></pre>
</li>
</ul>
</li>
<li>__block              8     <ul>
<li><pre><code>__weak __block       8+16
</code></pre>
</li>
</ul>
</li>
</ul>
<p>flags 有 4 种可能: 3， 7， 8， (8+16)</p>
<p>由 __block copy 函数调用：</p>
<p>BLOCK_BYREF_CALLER (128)：表示由 __block copy 调用<br>此时, 传入的 flags 有 4 种可能: </p>
<ul>
<li><pre><code>__block id                   128+3       
</code></pre>
<ul>
<li><pre><code>__block (^Block)             128+7
</code></pre>
</li>
</ul>
</li>
<li>__weak __block id           128+3+16     <ul>
<li><pre><code>__weak __block (^Block)      128+7+16
</code></pre>
</li>
</ul>
</li>
</ul>
<p>总共有以上 8 种情况</p>
<blockquote>
<p>需要注意的是，Block copy 调用该函数，第一个参数是指针的地址(void **)，第二个参数传入的是指针的值(void *)<br>而 __block copy 调用该函数，传入的前两个参数均为指针的值(void *)</p>
</blockquote>
<p>下面根据 case 条件分几步来讲解这个函数：</p>
<ul>
<li>代码块 1:</li>
</ul>
<p>Block copy 函数调用，且该变量是 id 类型的</p>
<p>代码<code>_Block_retain_object()</code>最终会调用下面这个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void _Block_retain_object_default(const void *ptr) &#123;</span><br><span class="line">	(void)ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码<code>_Block_assign()</code>最终会调用下面这个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void _Block_assign_default(void *value, void **destptr) &#123;</span><br><span class="line">    *destptr = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不知道调用 _Block_retain_object 函数的目的是什么<br>这一分支仅做了浅拷贝，拷贝指针内容</p>
<ul>
<li>代码块 2:</li>
</ul>
<p>Block copy 函数调用，且该变量也是一个 block</p>
<p>这里首先调用了 <code>_Block_copy_internal()</code> 函数, 先将 block 类型的变量拷贝到堆中<br>然后调用 <code>_Block_assign</code> 将其堆中的地址赋值给 Block 对应的成员变量</p>
<ul>
<li>代码块 3:</li>
</ul>
<p>Block copy 函数调用，且变量被 __block 修饰</p>
<p><img src="https://i.loli.net/2020/05/09/ITPjVSUlEfMoAmZ.jpg" alt="_Block_byref_assign_copy 实现"></p>
<p>这里传入的第一个参数 void *dest 表示的是指针的地址</p>
<p>_Block_byref_assign_copy 实现中代码块 1 的逻辑如下</p>
<ul>
<li>声明一个布尔值 isWeak， 用来表示该变量是否还被 __weak 修饰</li>
<li>_Block_allocator 函数最终调用 <code>malloc()</code> 函数, 在堆上拷贝一份同样内存大小的 Block_byrefs 实例</li>
<li>将旧实例的成员变量 flags 拷贝到新实例中, 并将新实例的引用计数设置为 2。 1 份是因为栈上有一个实例, 1 份是因为堆上也有一个， 1+1 就等于 2 了</li>
<li>将旧实例和新实例的成员变量 forwarding 均赋值为新实例</li>
<li>如果 isWeak 为 true, 则将 Block_byrefs 实例的 isa 指针指向 _NSConcreteWeakBlockVariable</li>
<li>如果实例有 <code>__block copy/dispose helpers</code>(还是调用 _Block_object_assign 函数), 则调用它对实例持有的变量进行拷贝到堆操作; 如果没有的话则将旧实例中 size 后面的成员变量拷贝到新实例的 bit 中</li>
</ul>
<p>函数里面有一行看起来比较让人困扰的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct Block_byref_2 *src2 = (struct Block_byref_2 *)(src+1);</span><br></pre></td></tr></table></figure>

<p>在前面的声明中，src 被声明成了 <code>Block_byref *</code> 类型，所以 <code>src + 1</code> 的意思是从 src 的首地址偏移 sizeof(Block_byref) 个字节，即 Block_byref_2 的首地址<br>结构体拷贝完成后，随后将 Block_byref 持有的变量通过函数 *src2-&gt;byref_keep 也拷贝到堆中<br>_Block_byref_assign_copy 实现中代码块 2 的作用是如果 Block_byref 持有的变量已经拷贝到堆中了, 则增加其引用计数</p>
<ul>
<li>代码块 4:</li>
</ul>
<p>__block copy 函数调用，且持有的变量不被 __weak 修饰</p>
<p>最终会调用下面那个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void _Block_assign_default(void *value, void **destptr) &#123;</span><br><span class="line">    *destptr = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浅拷贝</p>
<ul>
<li>代码块 5:</li>
</ul>
<p>__block copy 函数调用，且持有的变量被 __weak 修饰</p>
<p>最终会调用下面那个函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void _Block_assign_weak_default(const void *ptr, void *dest) &#123;</span><br><span class="line">    *(void **)dest = (void *)ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里讲一下我的理解：<br>void * 是一个指针，里面保存了一个地址，但是我们不能 *(void *) 这样使用它，因为我们不知道它指向的结构是什么类型的。如果要使用的话就需要将其转换成其它类型，例如 int *，所以在这里可以仅仅把它看成是变量，保存了一个地址。<br>而 void **，其表示指向指针的指针，不同于 void *，我们可以 *(void **) 这样使用它，因为我们知道 void ** 指向的内容是一个指针。</p>
<p>在 _Block_assign_weak_default 函数中，我们先将 dest 强转成 void ** 类型，然后就可以对其进行赋值操作啦</p>
<hr>
<p>至此，整个拷贝流程已经讲的差不多了，这里总结一下：</p>
<ul>
<li>一个 block 可能捕获多个外部变量</li>
<li>block 在栈中生成，retain 后，将栈中的内容拷贝到堆中</li>
<li>block 会调用 <code>Block copy</code> 函数，对其捕获的变量也进行拷贝操作<ul>
<li>如果是 C++ 类型，则调用其 const 拷贝构造函数到堆中</li>
<li>如果是 block 类型，则将其拷贝到堆中</li>
<li>如果是 id 类型，因为已经在堆中了，所以进行浅拷贝，仅复制指针值</li>
<li>如果是 __block 修饰的变量，则将其对应的 Block_byref 结构体拷贝到堆中，随后调用 __block copy 函数将其持有的变量也拷贝到堆中</li>
</ul>
</li>
</ul>
<h3 id="如何销毁-block"><a href="#如何销毁-block" class="headerlink" title="如何销毁 block"></a>如何销毁 block</h3><p>这一节我们将探究如何销毁 block</p>
<p>创建一个 malloc block 类型的 block，foo() 结束，block 会被回收。<br>在函数尾巴那里打个断点</p>
<p><img src="https://i.loli.net/2020/05/08/M6XYjobniRguPvk.jpg"></p>
<p>step into</p>
<p><img src="https://i.loli.net/2020/05/08/xjGZJzP2thL7QeR.jpg"></p>
<p>将断点停留在<code>objc_release()</code>函数<br>runtime 通过该函数对 block 进行 release 操作，如果其引用计数变成 0，则销毁</p>
<p>继续 step into</p>
<p><img src="https://i.loli.net/2020/05/08/AqLZp1hWwoRHuDe.jpg"></p>
<p>block 是特殊的类，自己重写了<code>release()</code>函数，所以代码 <code>ISA()-&gt;hasCustomRR()</code> 返回的结果是 true，将执行自己重写的 release() 函数<br>继续 step into</p>
<p><img src="https://i.loli.net/2020/05/08/x2ISisTvBQwLh8k.jpg"></p>
<p>因为没有 block 的 <code>release()</code>源码，通过调用栈发现随后调用了 <code>_Block_release()</code> 函数<br>在<a target="_blank" rel="noopener" href="https://github.com/LGCooci/objc_debug/tree/master">可编译的源码</a>中可以找到该函数的实现(直接在文件夹中搜索)</p>
<p><img src="https://i.loli.net/2020/05/09/85ENFYT9nlZcRiM.jpg" alt="_Block_release 实现"></p>
<p>根据 if 的判断将函数分为三个部分</p>
<ul>
<li>判断条件 1：如果是全局 block 或者其引用计数已经为 0(表示已经在销毁了)， 则返回</li>
<li>判断条件 2：如果使用 GC 管理内存，则执行什么什么操作。因为 iOS 平台不使用 GC，所以略过</li>
<li>判断条件 3：如果 block 已经在堆上了，则将其引用计数减 1，如果减为 0，则调用下面三个函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_Block_call_dispose_helper(aBlock);</span><br><span class="line">_Block_destructInstance(aBlock);</span><br><span class="line">_Block_deallocator(aBlock);</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个函数 <code>_Block_call_dispose_helper</code></li>
</ul>
<p>在同个文件中搜索该函数，其实现如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void _Block_call_dispose_helper(struct Block_layout *aBlock)</span><br><span class="line">&#123;</span><br><span class="line">    struct Block_descriptor_2 *desc = _Block_descriptor_2(aBlock);</span><br><span class="line">    if (!desc) return;</span><br><span class="line"></span><br><span class="line">    (*desc-&gt;dispose)(aBlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果存在 Block dispose 函数，则调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void __TestObject__foo_block_dispose_1(struct __TestObject__foo_block_impl_1*src) </span><br><span class="line">&#123;</span><br><span class="line">_Block_object_dispose((void*)src-&gt;byrefInt, 8/*BLOCK_FIELD_IS_BYREF*/);</span><br><span class="line">_Block_object_dispose((void*)src-&gt;commonObject, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br><span class="line">_Block_object_dispose((void*)src-&gt;byrefWeakObject, 8/*BLOCK_FIELD_IS_BYREF*/);</span><br><span class="line">_Block_object_dispose((void*)src-&gt;weakObject, 3/*BLOCK_FIELD_IS_OBJECT*/);</span><br><span class="line">_Block_object_dispose((void*)src-&gt;byrefObject, 8/*BLOCK_FIELD_IS_BYREF*/);</span><br><span class="line">_Block_object_dispose((void*)src-&gt;blockObject, 7/*BLOCK_FIELD_IS_BLOCK*/);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/05/09/mLH7QEBp2TWxbXP.jpg" alt="_Block_object_dispose 实现"></p>
<p>通过判断条件将 _Block_object_dispose 分为几部分</p>
<ul>
<li>判断条件 1：变量由 __block 修饰</li>
</ul>
<p><img src="https://i.loli.net/2020/05/09/AKTYlozkaOIVFQr.jpg" alt="_Block_byref_release 实现"></p>
<p>代码<code>byref = byref-&gt;forwarding;</code>，因为可能会有 byref 在栈中，而 forwarding 此时却在堆中的情况。随后判断 byref 是否在栈中，如果是的话则立即返回。<br>对 Block_byref 的引用计数减 1 随后判断是否为 0，如果是的话则调用其 byref_destroy 函数(也就是 _Block_object_dispose)，销毁其持有的变量<br>最后将 Block_byref 结构体的内存释放掉</p>
<ul>
<li>判断条件 2：变量是 Block 类型</li>
</ul>
<p><img src="https://i.loli.net/2020/05/09/7XBcIrVYCbO2GRp.jpg" alt="_Block_destroy 实现"></p>
<p>调用 _Block_release 来销毁该 block</p>
<ul>
<li>判断条件 3：变量是 id 类型</li>
</ul>
<p>_Block_release_object 最终调用的函数如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void _Block_release_object_default(const void *ptr) &#123;</span><br><span class="line">	(void)ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等于什么都没做，这是因为 id 类型的对象由 ARC 管理其内存。即不再被强指针引用时引用计数减 1 </p>
<ul>
<li>判断条件 4</li>
</ul>
<p>什么都没做，如果走到走一步说明可能系统有异常</p>
<hr>
<p>接着讲 block 销毁时调用的第二个函数 <code>_Block_destructInstance</code>。<br>调试时，调用栈里也有这个函数</p>
<p><img src="https://i.loli.net/2020/05/09/C1snHLtSfzj2BOY.jpg">  </p>
<p>接着 step into</p>
<p><img src="https://i.loli.net/2020/05/09/deEVtqBWhPQMDwZ.jpg"></p>
<p>使用该函数，主要是为了将在弱引用表中注册的使用 __weak 引用 block 的变量置为 nil，因为 block 已经要被销毁了<br>这里不仔细讲了</p>
<hr>
<p>最后调用 <code>_Block_deallocator()</code> 函数，将 block 结构体的内存销毁</p>
<hr>
<p>这里总结一下 block 的内存销毁流程：</p>
<ul>
<li>先将 block 捕获的外部变量进行销毁</li>
<li>将弱引用 block 的指针置为 nil</li>
<li>将 block 结构体的内存销毁</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-04-23T07:59:59.000Z" title="4/23/2020, 3:59:59 PM">2020-04-23</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">12 分钟读完 (大约1862个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/23/%E6%8E%A2%E7%A9%B6runtime%E7%A2%B0%E5%88%B0%E7%9A%84%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/">探究runtime碰到的类和结构体</a></h1><div class="content"><p>在研究 runtime 时能遇到许多的类和结构体, 因为不可能每篇文章碰到就介绍一遍, 所以在这里统一把这些碰到的类和结构体介绍一下</p>
<h3 id="SideTable"><a href="#SideTable" class="headerlink" title="SideTable"></a>SideTable</h3><p>这个类的作用是存放引用计数表和弱引用表, 并使用自旋锁来防止操作表结构时可能的竞态条件<br>定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct SideTable &#123;</span><br><span class="line">    spinlock_t slock;</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    weak_table_t weak_table;</span><br><span class="line"></span><br><span class="line">    SideTable() &#123;</span><br><span class="line">        memset(&amp;weak_table, 0, sizeof(weak_table));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~SideTable() &#123;</span><br><span class="line">        _objc_fatal(&quot;Do not delete SideTable.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void lock() &#123; slock.lock(); &#125;</span><br><span class="line">    void unlock() &#123; slock.unlock(); &#125;</span><br><span class="line">    void forceReset() &#123; slock.forceReset(); &#125;</span><br><span class="line"></span><br><span class="line">    // Address-ordered lock discipline for a pair of side tables.</span><br><span class="line"></span><br><span class="line">    template&lt;HaveOld, HaveNew&gt;</span><br><span class="line">    static void lockTwo(SideTable *lock1, SideTable *lock2);</span><br><span class="line">    template&lt;HaveOld, HaveNew&gt;</span><br><span class="line">    static void unlockTwo(SideTable *lock1, SideTable *lock2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有下面几个成员变量</p>
<ul>
<li><p>spinlock_t slock: 自旋锁</p>
</li>
<li><p>RefcountMap refcnts: 额外引用计数存储表</p>
</li>
<li><p>weak_table_t weak_table: 弱引用表, 用来存储弱引用者(weak 修饰的变量)</p>
<p>  其中<code>RefcountMap</code>是类型<code>objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,RefcountMapValuePurgeable&gt;</code>的别名</p>
</li>
</ul>
<h3 id="DisguisedPtr"><a href="#DisguisedPtr" class="headerlink" title="DisguisedPtr"></a>DisguisedPtr</h3><p>定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class DisguisedPtr &#123;</span><br><span class="line">    uintptr_t value;</span><br><span class="line"></span><br><span class="line">    static uintptr_t disguise(T* ptr) &#123;</span><br><span class="line">        return -(uintptr_t)ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static T* undisguise(uintptr_t val) &#123;</span><br><span class="line">        return (T*)-val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    DisguisedPtr() &#123; &#125;</span><br><span class="line">    DisguisedPtr(T* ptr) </span><br><span class="line">        : value(disguise(ptr)) &#123; &#125;</span><br><span class="line">    DisguisedPtr(const DisguisedPtr&lt;T&gt;&amp; ptr) </span><br><span class="line">        : value(ptr.value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    DisguisedPtr&lt;T&gt;&amp; operator = (T* rhs) &#123;</span><br><span class="line">        value = disguise(rhs);</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    DisguisedPtr&lt;T&gt;&amp; operator = (const DisguisedPtr&lt;T&gt;&amp; rhs) &#123;</span><br><span class="line">        value = rhs.value;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    operator T* () const &#123;</span><br><span class="line">        return undisguise(value);</span><br><span class="line">    &#125;</span><br><span class="line">    T* operator -&gt; () const &#123; </span><br><span class="line">        return undisguise(value);</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; operator * () const &#123; </span><br><span class="line">        return *undisguise(value);</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; operator [] (size_t i) const &#123;</span><br><span class="line">        return undisguise(value)[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // pointer arithmetic operators omitted </span><br><span class="line">    // because we don&#x27;t currently use them anywhere</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个类的作用是伪装指针, 避免引用计数表和弱引用表里面保存的指针被内存泄漏工具<code>leaks</code>当做是内存泄漏.</p>
<ul>
<li>它的成员变量<code>value</code>存储的是经过函数<code>disguise()</code>处理后的指针.</li>
<li>你可以像操作指针一样操作<code>DisguisedPtr</code>实例. 为了实现这个功能, <code>DisguisedPtr</code>重载了许多的操作符, 例如<code>-&gt;</code>, <code>*</code>, <code>=</code>, <code>==</code>, <code>[]</code>. 不了解的同学可以自己查资料, 关键字 <code>运算符重载operator</code></li>
</ul>
<p><code>DisguisedPtr</code>一般用来充当 Key, 保存在结构体中</p>
<h3 id="RefcountMapValuePurgeable"><a href="#RefcountMapValuePurgeable" class="headerlink" title="RefcountMapValuePurgeable"></a>RefcountMapValuePurgeable</h3><p>定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct RefcountMapValuePurgeable &#123;</span><br><span class="line">    static inline bool isPurgeable(size_t x) &#123;</span><br><span class="line">        return x == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>只有一个内联函数<code>RefcountMapValuePurgeable</code>, 用来判断这个值需要是否析构释放内存</p>
<h3 id="DenseMapInfo"><a href="#DenseMapInfo" class="headerlink" title="DenseMapInfo"></a>DenseMapInfo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct DenseMapInfo&lt;DisguisedPtr&lt;T&gt;&gt; &#123;</span><br><span class="line">  static inline DisguisedPtr&lt;T&gt; getEmptyKey() &#123;</span><br><span class="line">    return DisguisedPtr&lt;T&gt;((T*)(uintptr_t)-1);</span><br><span class="line">  &#125;</span><br><span class="line">  static inline DisguisedPtr&lt;T&gt; getTombstoneKey() &#123;</span><br><span class="line">    return DisguisedPtr&lt;T&gt;((T*)(uintptr_t)-2);</span><br><span class="line">  &#125;</span><br><span class="line">  static unsigned getHashValue(const T *PtrVal) &#123;</span><br><span class="line">      return ptr_hash((uintptr_t)PtrVal);</span><br><span class="line">  &#125;</span><br><span class="line">  static bool isEqual(const DisguisedPtr&lt;T&gt; &amp;LHS, const DisguisedPtr&lt;T&gt; &amp;RHS) &#123;</span><br><span class="line">      return LHS == RHS; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它有两个内联函数:</p>
<ul>
<li>getEmptyKey(): 生成 empty 的标记</li>
<li>getTombstoneKey(): 生成墓碑标记(即代表之前被人使用过但现在已经没人用了)</li>
</ul>
<p>有两个静态函数:</p>
<ul>
<li>getHashValue(): 根据指针返回一个哈希值</li>
<li>isEqual(): 判断两个参数是否相等</li>
</ul>
<p><code>DenseMapInfo</code>常常跟<code>DisguisedPtr</code>一起使用. 它的两个内联函数用来标记存储数据的<code>DenseMapPair</code>实例 bucket 的状态是否是 empty 或者 tombstoneKey. 它的<code>getHashValue</code>函数用来生成一个哈希值来确定 bucket 的序号</p>
<h3 id="detail-DenseMapPair"><a href="#detail-DenseMapPair" class="headerlink" title="detail::DenseMapPair"></a>detail::DenseMapPair</h3><p>部分定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename KeyT, typename ValueT&gt;</span><br><span class="line">struct DenseMapPair : public std::pair&lt;KeyT, ValueT&gt; &#123;</span><br><span class="line"></span><br><span class="line">  // FIXME: Switch to inheriting constructors when we drop support for older</span><br><span class="line">  //        clang versions.</span><br><span class="line">  // NOTE: This default constructor is declared with &#x27;&#123;&#125;&#x27; rather than</span><br><span class="line">  //       &#x27;= default&#x27; to work around a separate bug in clang-3.8. This can</span><br><span class="line">  //       also go when we switch to inheriting constructors.</span><br><span class="line">  DenseMapPair() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的父类<code>std::pair</code>是一个结构体模板, 它将两个数据组合成一个数据, 类似于我们经常用的字典.<br><code>DenseMapPair</code>被用来在引用计数表中保存引用计数. 其中 key 的类型为DisguisedPtr<objc_object></p>
<h3 id="DenseMap"><a href="#DenseMap" class="headerlink" title="DenseMap"></a>DenseMap</h3><p>部分定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename KeyT, typename ValueT,</span><br><span class="line">          typename ValueInfoT = DenseMapValueInfo&lt;ValueT&gt;,</span><br><span class="line">          typename KeyInfoT = DenseMapInfo&lt;KeyT&gt;,</span><br><span class="line">          typename BucketT = detail::DenseMapPair&lt;KeyT, ValueT&gt;&gt;</span><br><span class="line">class DenseMap : public DenseMapBase&lt;DenseMap&lt;KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;,</span><br><span class="line">                                     KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt; &#123;</span><br><span class="line">  friend class DenseMapBase&lt;DenseMap, KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;;</span><br><span class="line"></span><br><span class="line">  // Lift some types from the dependent base class into this class for</span><br><span class="line">  // simplicity of referring to them.</span><br><span class="line">  using BaseT = DenseMapBase&lt;DenseMap, KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;;</span><br><span class="line"></span><br><span class="line">  BucketT *Buckets;</span><br><span class="line">  unsigned NumEntries;</span><br><span class="line">  unsigned NumTombstones;</span><br><span class="line">  unsigned NumBuckets;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  /// Create a DenseMap wth an optional \p InitialReserve that guarantee that</span><br><span class="line">  /// this number of elements can be inserted in the map without grow()</span><br><span class="line">  explicit DenseMap(unsigned InitialReserve = 0) &#123; init(InitialReserve); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类就是之前提到的引用计数表, 它的成员里面有一个存储数组, 用来保存引用计数. 数组的元素类型为 <code>detail::DenseMapPair</code><br>如果一个对象的引用计数曾经溢出保存到表中, 当对象被销毁时, 会将表中对象使用过的存储器 bucket 标记为墓碑状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">friend class DenseMapBase&lt;DenseMap, KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;;</span><br></pre></td></tr></table></figure>
<p>用于声明一个友元类, 这样<code>DenseMapBase</code>就能访问<code>DenseMap</code>里面的私有属性和私有方法了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using BaseT = DenseMapBase&lt;DenseMap, KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;;</span><br></pre></td></tr></table></figure>
<p>为<code>DenseMapBase&lt;DenseMap, KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;</code>添加一个类型别名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explicit DenseMap(unsigned InitialReserve = 0) &#123; init(InitialReserve); &#125;</span><br></pre></td></tr></table></figure>
<p>上面那行代码的作用是显示的声明一个构造方式, 这样这类就不能隐式转换了</p>
<p>成员变量如下:</p>
<ul>
<li>Buckets: 一个 bucket 数组, 用于保存数据. 可扩容</li>
<li>NumEntries: Buckets 数组中已经被使用的数目</li>
<li>NumTombstones: Buckets 数组中 tombstone 的数目</li>
<li>NumBuckets: Buckets 数组的数目</li>
</ul>
<h3 id="weak-table-t"><a href="#weak-table-t" class="headerlink" title="weak_table_t"></a>weak_table_t</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct weak_table_t &#123;</span><br><span class="line">    weak_entry_t *weak_entries;</span><br><span class="line">    size_t    num_entries;</span><br><span class="line">    uintptr_t mask;</span><br><span class="line">    uintptr_t max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个结构体用来存储弱引用条目, 弱引用条目里面保存着对象以及它的弱引用者们.<br>当数组数量超过 1024 且被使用的数量占比小于 1&#x2F;16 时, 数组长度会缩小为原来的 1&#x2F;8</p>
<p>它有 4 个成员变量:</p>
<ul>
<li>weak_entry_t *weak_entries: weak_entry_t 类型的数组. 弱引用条目, 用来保存弱引用者(被 weak 修饰的指针)</li>
<li>size_t num_entries: 已经被使用的条目数量</li>
<li>uintptr_t mask: 条目数组的数量</li>
<li>uintptr_t max_hash_displacement: 用来记录数组中被使用条目的 index 的最大值</li>
</ul>
<h3 id="weak-entry-t"><a href="#weak-entry-t" class="headerlink" title="weak_entry_t"></a>weak_entry_t</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">struct weak_entry_t &#123;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent;</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            weak_referrer_t *referrers;</span><br><span class="line">            uintptr_t        out_of_line_ness : 2;</span><br><span class="line">            uintptr_t        num_refs : PTR_MINUS_2;</span><br><span class="line">            uintptr_t        mask;</span><br><span class="line">            uintptr_t        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        struct &#123;</span><br><span class="line">            // out_of_line_ness field is low bits of inline_referrers[1]</span><br><span class="line">            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    bool out_of_line() &#123;</span><br><span class="line">        return (out_of_line_ness == REFERRERS_OUT_OF_LINE);</span><br><span class="line">    &#125;</span><br><span class="line">    weak_entry_t&amp; operator=(const weak_entry_t&amp; other) &#123;</span><br><span class="line">        memcpy(this, &amp;other, sizeof(other));</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weak_entry_t(objc_object *newReferent, objc_object **newReferrer)</span><br><span class="line">        : referent(newReferent)</span><br><span class="line">    &#123;</span><br><span class="line">        inline_referrers[0] = newReferrer;</span><br><span class="line">        for (int i = 1; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            inline_referrers[i] = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个结构体用来保存引用对象以及它的弱引用者, 属于一对多的关系<br>当弱引用比较少的时候会将弱引用者保存在结构体里面, 当弱引用者数量超过 4 时会保存到外部的数组中</p>
<p>它有两个成员变量, 一个是<code>DisguisedPtr&lt;objc_object&gt; referent;</code>, 另一个是联合体 union.<br>referent 表示引用对象, 当一个弱引用者引用了一个新的对象, 那么我们需要从弱引用条目中(weak_entry_t)移除该弱引用者</p>
<p><code>weak_referrer_t</code> 是 <code>DisguisedPtr&lt;objc_object *&gt;</code> 类型的别名</p>
<p>第二个成员变量 union 里面有两个结构体, 我这里称呼它们为 s1, s2.<br>因为是 union, 所以 s1 里面的 out_of_line_ness 跟 s2 里面的 inline_referrers 的第二个元素的低 2 个 bit 是重合的. 数组 inline_referrers 的元素是 weak_referrer_t 类型. 在 arm64 架构下, 指针 8 字节对齐, 意味着指针低 3 位肯定都是 0, 经过<code>DisguisedPtr</code>的伪装后, 它的低 2 位都是 1, 也就是 s1 的 out_of_line_ness 的值为 0b11.<br>这个特性用来标记是否使用内部数组来保存弱引用者, 当使用外部数组时, 内部数组被清空, 将 out_of_line_ness 赋值为 0b10 来表示使用外部数组</p>
<p>当使用内部数组时</p>
<ul>
<li>s1 的成员变量均没有意义</li>
<li>使用 s2 的 inline_referrers 数组来保存弱引用者.</li>
</ul>
<p>当使用外部数组时</p>
<ul>
<li>s1 的成员变量<code>referrers</code>是指向外部数组的指针; <code>out_of_line_ness</code>为常量 2, 表示使用了外部数组; <code>mask</code>表示外部数组的长度 - 1; <code>num_refs</code>表示外部数组中被使用的数量; <code>max_hash_displacement</code>表示哈希最大偏移量</li>
<li>此时 s2 的成员变量 inline_referrers 被清空</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-04-23T07:16:30.000Z" title="4/23/2020, 3:16:30 PM">2020-04-23</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">24 分钟读完 (大约3634个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/23/iOS-weak%E5%BC%B1%E5%BC%95%E7%94%A8%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/">iOS weak弱引用底层实现</a></h1><div class="content"><p>源码版本：objc4-779.1<br>当然还是推荐使用这个来学习：<a target="_blank" rel="noopener" href="https://github.com/LGCooci/objc_debug/tree/master">可编译的源码</a></p>
<p><code>weak</code>是一个所有权修饰符, 它提供弱引用的功能, 即弱引用者(weak 修饰的变量, 后统称为弱引用者)不能持有引用对象, 当引用对象被释放时, 此弱引用者被置为 nil.<br>此文将探究弱引用在底层是如何实现</p>
<h3 id="弱引用者如何注册到弱引用表"><a href="#弱引用者如何注册到弱引用表" class="headerlink" title="弱引用者如何注册到弱引用表"></a>弱引用者如何注册到弱引用表</h3><p>首先我们研究弱引用者是如何注册到弱引用表中的<br>调试代码如下(代码需要在开头提到的可编译版本里面才能运行, 后面不再解释), 注意里面打了个断点, 运行程序</p>
<p><img src="https://i.loli.net/2020/04/21/9Nwyob2e34ntvIu.jpg"></p>
<p>点击 step into, 会跳转到函数<code>objc_initWeak()</code>中</p>
<p><img src="https://i.loli.net/2020/04/21/4hZcXPHIlN6E8s9.jpg"></p>
<p>这个函数的作用是初始化弱引用者.<br>需要注意的是<code>storeWeak</code>模板里面的两个参数 <code>DontHaveOld</code>, <code>DoHaveNew</code>. 它们分别是<code>HaveOld</code>和<code>HaveNew</code>枚举的变量. 枚举里面变量的含义如下</p>
<ul>
<li><p>DontHaveOld: 表示弱引用者之前没有引用对象, 例如在用<code>__weak id weakPtr = [[NSObject alloc] init];</code>初始化弱引用者</p>
</li>
<li><p>DoHaveOld: 表示弱引用者之前有引用对象. 此时需要将弱引用者从弱引用表中注销</p>
</li>
<li><p>DontHaveNew: 表示弱引用者没有引用一个新的对象</p>
</li>
<li><p>DoHaveNew: 表示弱引用者引用了一个新的对象. 此时需要将弱引用者注册到弱引用表中</p>
</li>
</ul>
<p>继续 step into, 跳转到<code>storeWeak()</code>函数里面</p>
<p><img src="https://i.loli.net/2020/04/22/nRwmhYWQS7ovKVH.jpg"></p>
<p>函数里面代码比较多, 为了方便, 我把它分成了几部分来说明</p>
<p><code>SideTable</code>跟弱引用的实现息息相关, 在<a target="_blank" rel="noopener" href="https://kikido.github.io/2020/04/23/%E6%8E%A2%E7%A9%B6runtime%E7%A2%B0%E5%88%B0%E7%9A%84%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/">这里</a>可以看到对这个类的详细说明.<br>这里我就简单的介绍一下, 它是存放引用计数表和弱引用表的结构. 它有三个成员变量:引用计数表, 弱引用表, 自旋锁. 在我们操作引用计数表或者弱引用表的时候自旋锁会加锁防止竞态条件的出现.</p>
<p>代码块 1 的作用:</p>
<ul>
<li>加锁, 防止在修改哈希表时可能出现的竞态条件. 按锁地址(从低到高)顺序加锁, 防止可能出现的锁的排序问题. </li>
<li>如果弱引用者的引用对象改变了(这是因为如果并发修改弱引用者的引用对象, 在加锁之前, 可能原先的引用对象会改变), 则重复执行<code>retry</code>部分的代码</li>
</ul>
<!--FIXME:class初始化-->
<p>代码块 2 的作:</p>
<ul>
<li>保证引用对象的 isa 指针已经初始化过. 如果未初始化, 则对该对象的非元类 Class 进行初始化.</li>
</ul>
<p>代码块 3 的作:</p>
<ul>
<li>在弱引用表上注销弱引用者, 后面会再来讲这个部分</li>
</ul>
<p>代码块 4 的作用:</p>
<ul>
<li>在弱引用表上注册弱引用者</li>
</ul>
<p>代码块 5 的作用:</p>
<ul>
<li>对象被弱引用者引用了, 则修改对象 isa 指针上位域的信息, 将<code>weakly_referenced</code>置为 YES, 表示该对象被一个弱引用者引用.</li>
</ul>
<blockquote>
<p>需要注意的是, 如果这个对象后续不再被弱引用者引用了, isa 指针上的<code>weakly_referenced</code>值仍旧是 YES</p>
</blockquote>
<p>接着, 我们把断点移动到<code>weak_register_no_lock()</code>函数里面, 同样, 我把它分成几部分来讲解.</p>
<p><img src="https://i.loli.net/2020/04/22/9hwX2HTFZn7dyaM.jpg"></p>
<p><code>referent</code> 表示引用对象, <code>referrer</code> 表示弱引用者</p>
<p>代码块 1 的作用是:</p>
<ul>
<li>保证引用对象是可用的. 如果引用对象正处于被销毁的状态, 那么程序会崩溃</li>
</ul>
<p>代码块 2 的作用是:</p>
<ul>
<li>根据引用对象找到对应的 weak_entry_t 实例(后面统称为为弱条目), 并将该弱引用者保存到弱条目中</li>
</ul>
<p>下面是<code>append_referrer()</code>函数的实现, 写了点注释就不展开讲了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">static void append_referrer(weak_entry_t *entry, objc_object **new_referrer)</span><br><span class="line">&#123;</span><br><span class="line">    if (! entry-&gt;out_of_line()) &#123;</span><br><span class="line">    	 // 使用内部数组来保存弱引用者. 遍历内部数组, 如果有空位则用该空位保存弱引用者并返回</span><br><span class="line">        for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            if (entry-&gt;inline_referrers[i] == nil) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = new_referrer;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		 // 如果执行到这里, 说明内部数组都被使用了. 所以需要扩容, 即创建一个外部数组来保存弱引用者</span><br><span class="line">		 // 先初始化一个跟内部数组长度一样的数组, 并将内部数组的数据转移过去</span><br><span class="line">        weak_referrer_t *new_referrers = (weak_referrer_t *)</span><br><span class="line">            calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t));</span><br><span class="line">        // This constructed table is invalid, but grow_refs_and_insert</span><br><span class="line">        // will fix it and rehash it.</span><br><span class="line">        for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            new_referrers[i] = entry-&gt;inline_referrers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        entry-&gt;referrers = new_referrers;</span><br><span class="line">        entry-&gt;num_refs = WEAK_INLINE_COUNT;</span><br><span class="line">        entry-&gt;out_of_line_ness = REFERRERS_OUT_OF_LINE;</span><br><span class="line">        entry-&gt;mask = WEAK_INLINE_COUNT-1;</span><br><span class="line">        entry-&gt;max_hash_displacement = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ASSERT(entry-&gt;out_of_line());</span><br><span class="line">    // 如果外部数组中有 3/4 的元素都被使用了, 则进行扩容</span><br><span class="line">    if (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * 3/4) &#123;</span><br><span class="line">        // 扩容的长度为原来的 2 倍, 最小值为 8.</span><br><span class="line">        return grow_refs_and_insert(entry, new_referrer);</span><br><span class="line">    &#125;</span><br><span class="line">    // 根据指针的哈希值来计算位置 index</span><br><span class="line">    size_t begin = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    size_t index = begin;</span><br><span class="line">    size_t hash_displacement = 0;</span><br><span class="line">    while (entry-&gt;referrers[index] != nil) &#123;</span><br><span class="line">        // 发生了哈希碰撞, 则增加下标, 查看下一个位置是否为空</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        index = (index+1) &amp; entry-&gt;mask;</span><br><span class="line">        if (index == begin) bad_weak_table(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    // 重新计算 entry 的最大哈希偏移量</span><br><span class="line">    if (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">        entry-&gt;max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将新的弱引用者保存到弱引用条目中</span><br><span class="line">    weak_referrer_t &amp;ref = entry-&gt;referrers[index];</span><br><span class="line">    ref = new_referrer;</span><br><span class="line">    // num_refs + 1</span><br><span class="line">    entry-&gt;num_refs++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码块 3 的作用:</p>
<p>生成一个新的弱引用条目, 将弱引用者保存到弱条目中. 随后将弱条目插入到弱引用表中</p>
<ul>
<li>第一行代码的作用是初始化一个<code>weak_entry_t</code>的实例 new_entry</li>
<li>第二行代码里面函数的作用是, 如果弱引用表的成员变量<code>weak_entries</code>数组里面有 3&#x2F;4 的数量的弱条目被使用了, 则进行扩容. 长度为原来的 2 倍, 最小为 64</li>
<li>第三行代码的作用是将新生成的弱条目插入到弱引用表中</li>
</ul>
<p>至此, 我们已经大致了解了弱引用者是如何注册到弱引用条目的, 这里小总结一下:</p>
<ul>
<li>首先判断引用对象是否处于销毁状态, 否则是的话程序会崩溃</li>
<li>根据引用对象获取到对应的<code>SideTable</code>, 它里面有成员变量弱引用表<code>weak_table_t</code></li>
<li>在弱引用表中根据<code>引用对象</code>来查找对应的弱引用条目, 如果存在则将该弱引用者保存在该条目中. 如果不存在则新生成一个条目, 将弱引用者保存到该条目, 随后将条目插入到弱引用表中</li>
<li>在弱引用表中插入弱条目根据引用对象的哈希值来计算 index, 在弱条目中插入弱引用者根据弱引用者的哈希值来计算 index</li>
<li>在此过程中, 不对任何的弱引用者进行赋值, 即不对 <code>*referrer</code> 进行赋值操作</li>
</ul>
<h3 id="弱引用者如何从弱引用表中注销"><a href="#弱引用者如何从弱引用表中注销" class="headerlink" title="弱引用者如何从弱引用表中注销"></a>弱引用者如何从弱引用表中注销</h3><p>这部分用来探究弱引用者如何从弱引用表中注销<br>实验代码如下</p>
<p><img src="https://i.loli.net/2020/04/23/sw4mBRglLEvuq3f.jpg"></p>
<p>点击<code>step into</code>跳转到<code>objc_storeWeak()</code>函数里面</p>
<p><img src="https://i.loli.net/2020/04/23/1GrBHcT2ZiDCIdu.jpg"></p>
<p>首先弱引用者 w1 引用了对象 o1,  w1 会被注册到 o1 对应的弱引用条目中. 随后我们给它设置了一个新的引用对象 o2, 那么, w1 会先从 o1 的条目中注销, 然后注册到 o2 的条目中.</p>
<p>继续调试, 将断点移动到<code>storeWeak()</code>函数里面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">template &lt;HaveOld haveOld, HaveNew haveNew,</span><br><span class="line">          CrashIfDeallocating crashIfDeallocating&gt;</span><br><span class="line">static id </span><br><span class="line">storeWeak(id *location, objc_object *newObj)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(haveOld  ||  haveNew);</span><br><span class="line">    if (!haveNew) ASSERT(newObj == nil);</span><br><span class="line"></span><br><span class="line">    Class previouslyInitializedClass = nil;</span><br><span class="line">    id oldObj;</span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line"></span><br><span class="line">    // Acquire locks for old and new values.</span><br><span class="line">    // Order by lock address to prevent lock ordering problems. </span><br><span class="line">    // Retry if the old value changes underneath us.</span><br><span class="line"> retry:</span><br><span class="line">    if (haveOld) &#123;</span><br><span class="line">        oldObj = *location;</span><br><span class="line">        oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        oldTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if (haveNew) &#123;</span><br><span class="line">        newTable = &amp;SideTables()[newObj];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        newTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    if (haveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">        SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">        goto retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Prevent a deadlock between the weak reference machinery</span><br><span class="line">    // and the +initialize machinery by ensuring that no </span><br><span class="line">    // weakly-referenced object has an un-+initialized isa.</span><br><span class="line">    if (haveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        Class cls = newObj-&gt;getIsa();</span><br><span class="line">        if (cls != previouslyInitializedClass  &amp;&amp;  </span><br><span class="line">            !((objc_class *)cls)-&gt;isInitialized()) </span><br><span class="line">        &#123;</span><br><span class="line">            SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">            class_initialize(cls, (id)newObj);</span><br><span class="line"></span><br><span class="line">            // If this class is finished with +initialize then we&#x27;re good.</span><br><span class="line">            // If this class is still running +initialize on this thread </span><br><span class="line">            // (i.e. +initialize called storeWeak on an instance of itself)</span><br><span class="line">            // then we may proceed but it will appear initializing and </span><br><span class="line">            // not yet initialized to the check above.</span><br><span class="line">            // Instead set previouslyInitializedClass to recognize it on retry.</span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line"></span><br><span class="line">            goto retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Clean up old value, if any.</span><br><span class="line">    if (haveOld) &#123;</span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Assign new value, if any.</span><br><span class="line">    if (haveNew) &#123;</span><br><span class="line">        newObj = (objc_object *)</span><br><span class="line">            weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br><span class="line">        // weak_register_no_lock returns nil if weak store should be rejected</span><br><span class="line"></span><br><span class="line">        // Set is-weakly-referenced bit in refcount table.</span><br><span class="line">        if (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Do not set *location anywhere else. That would introduce a race.</span><br><span class="line">        *location = (id)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // No new value. The storage is not changed.</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    return (id)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数里面大部分内容已经在上一节中介绍过, 这里就不重复了<br>这里我们要讲解的是<code>weak_unregister_no_lock()</code>函数. 这个函数的作用是将销弱引用者从引用对象对应的弱引用条目中注销. 函数实现如下:</p>
<p><img src="https://i.loli.net/2020/04/23/WjGzV5O27AaMBHo.jpg"></p>
<p><code>referent</code>表示原先的引用对象, <code>referrer</code>表示弱引用者</p>
<p>代码块 1 的作用是根据引用对象查找弱引用条目, 然后存在则将该弱引用者从条目中注销</p>
<p>函数<code>remove_referrer()</code>的实现如下, 写了点注释就不展开讲了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static void remove_referrer(weak_entry_t *entry, objc_object **old_referrer)</span><br><span class="line">&#123;</span><br><span class="line">    if (! entry-&gt;out_of_line()) &#123;</span><br><span class="line">        //使用内部数组保存弱引用者, 此时遍历该数组, 找到对应的弱引用者, 如果找到的话则将其从数组中移除</span><br><span class="line">        for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            if (entry-&gt;inline_referrers[i] == old_referrer) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = nil;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _objc_inform(&quot;Attempted to unregister unknown __weak variable &quot;</span><br><span class="line">                     &quot;at %p. This is probably incorrect use of &quot;</span><br><span class="line">                     &quot;objc_storeWeak() and objc_loadWeak(). &quot;</span><br><span class="line">                     &quot;Break on objc_weak_error to debug.\n&quot;, </span><br><span class="line">                     old_referrer);</span><br><span class="line">        objc_weak_error();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 此时使用外部数组来保存弱引用者</span><br><span class="line">    // 根据弱引用者的哈希值来得到对应元素的 index </span><br><span class="line">    size_t begin = w_hash_pointer(old_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    size_t index = begin;</span><br><span class="line">    size_t hash_displacement = 0;</span><br><span class="line">    while (entry-&gt;referrers[index] != old_referrer) &#123;</span><br><span class="line">        // 如果发生了哈希碰撞, 则偏移+1 往下继续查找该弱引用者.当偏移量超过最大偏移量时程序崩溃</span><br><span class="line">        index = (index+1) &amp; entry-&gt;mask;</span><br><span class="line">        if (index == begin) bad_weak_table(entry);</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        if (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">            _objc_inform(&quot;Attempted to unregister unknown __weak variable &quot;</span><br><span class="line">                         &quot;at %p. This is probably incorrect use of &quot;</span><br><span class="line">                         &quot;objc_storeWeak() and objc_loadWeak(). &quot;</span><br><span class="line">                         &quot;Break on objc_weak_error to debug.\n&quot;, </span><br><span class="line">                         old_referrer);</span><br><span class="line">            objc_weak_error();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 找到对应弱引用则将其从外部数组中移除</span><br><span class="line">    entry-&gt;referrers[index] = nil;</span><br><span class="line">    entry-&gt;num_refs--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码块 2 的作用是判断弱引用条目中注册的弱引用者的数量是否为 0, 如果为 0 则将该弱引用条目从弱引用表中清除.</p>
<p><code>weak_entry_remove()</code>函数的实现如下, 写了点注释就不展开讲了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void weak_entry_remove(weak_table_t *weak_table, weak_entry_t *entry)</span><br><span class="line">&#123;</span><br><span class="line">    // remove entry</span><br><span class="line">    // 如果使用的外部数组, 则将外部数组销毁. 如果使用内部数组, 则会在销毁条目时将内部数组也销毁</span><br><span class="line">    if (entry-&gt;out_of_line()) free(entry-&gt;referrers);</span><br><span class="line">    // 销毁弱引用条目</span><br><span class="line">    bzero(entry, sizeof(*entry));</span><br><span class="line"></span><br><span class="line">    weak_table-&gt;num_entries--;</span><br><span class="line">	 // 当条目数量超过 1024, 并且使用了不到 1/16, 则将条目数量缩小为原来的 1/8</span><br><span class="line">    weak_compact_maybe(weak_table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此, 我们已经大致了解了弱引用者如何从弱引用表中注销的, 我小总结一下:</p>
<ul>
<li>根据旧引用对象获取<code>SideTable</code></li>
<li>根据就引用对象在<code>SideTable</code>的弱引用表中获取对应的弱引用条目</li>
<li>在弱引用条目中查找是否注册了该弱引用者, 如果存在的话则移除</li>
<li>若弱引用者移除后弱引用表中弱引用者的数量为 0, 则将该条目从弱引用表中移除</li>
<li>如条目移除后, 条目的数量超过 1024, 且使用的数量少于 1&#x2F;16, 则将条目的容量缩小为原先的 1&#x2F;8</li>
</ul>
<h3 id="引用对象销毁后弱引用者如何置为-nil"><a href="#引用对象销毁后弱引用者如何置为-nil" class="headerlink" title="引用对象销毁后弱引用者如何置为 nil"></a>引用对象销毁后弱引用者如何置为 nil</h3><p>我们都知道当引用对象被销毁后, 弱引用者会被置为 nil.<br>这部分用来粗略的讲解其实现</p>
<p><img src="https://i.loli.net/2020/04/23/Hve3mRTuJDK8xth.jpg"></p>
<p>添加一个<code>symbolic breakpoint</code>, 在<code>symbol</code>里面输入<code>[NSObject dealloc]</code></p>
<p><img src="https://i.loli.net/2020/04/23/8QNjCHvP9tTeBkM.jpg"></p>
<p>点击 continue program execution, 跳转到<code>dealloc()</code>函数中</p>
<p>对 o1 的引用计数 -1 , o1 的引用计数就变成了 0, 需要销毁. 即调用 NSObject 的 dealloc 方法</p>
<p><img src="https://i.loli.net/2020/04/23/hmsPVcvUInRi3ok.jpg"></p>
<p>随后一直跳转到<code>objc_object::clearDeallocating_slow()</code>函数里面.<br>这个函数的作用是清除该对象在<code>SideTable</code>中存在于引用计数表或者弱引用表中的数据</p>
<p><img src="https://i.loli.net/2020/04/23/bVIg4rULXSHxyu8.jpg"></p>
<p>因为研究的是对弱引用的操作, 所以这边我们只需要关注<code>weak_clear_no_lock()</code>函数.<br>它的实现如下, 写了注释就不展开讲了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">void </span><br><span class="line">weak_clear_no_lock(weak_table_t *weak_table, id referent_id) </span><br><span class="line">&#123;</span><br><span class="line">    // referent 表示引用对象, 即这里要被销毁的对象</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    // 根据引用对象找到对应的弱引用条目</span><br><span class="line">    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class="line">    if (entry == nil) &#123;</span><br><span class="line">        /// XXX shouldn&#x27;t happen, but does with mismatched CF/objc</span><br><span class="line">        //printf(&quot;XXX no entry for clear deallocating %p\n&quot;, referent);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // zero out references</span><br><span class="line">    // 数组指针</span><br><span class="line">    weak_referrer_t *referrers;</span><br><span class="line">    // 数组长度</span><br><span class="line">    size_t count;</span><br><span class="line">    </span><br><span class="line">    if (entry-&gt;out_of_line()) &#123;</span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">        count = TABLE_SIZE(entry);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (size_t i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        if (referrer) &#123;</span><br><span class="line">            // 将弱引用者置为 nil</span><br><span class="line">            if (*referrer == referent) &#123;</span><br><span class="line">                *referrer = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (*referrer) &#123;</span><br><span class="line">                _objc_inform(&quot;__weak variable at %p holds %p instead of %p. &quot;</span><br><span class="line">                             &quot;This is probably incorrect use of &quot;</span><br><span class="line">                             &quot;objc_storeWeak() and objc_loadWeak(). &quot;</span><br><span class="line">                             &quot;Break on objc_weak_error to debug.\n&quot;, </span><br><span class="line">                             referrer, (void*)*referrer, (void*)referent);</span><br><span class="line">                objc_weak_error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将所有弱引用者置为 nil 后, 将该条目从弱引用表中删除</span><br><span class="line">    weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此, 我们已经大致了解了引用对象销毁后弱引用者如何置为 nil 的, 这里小总结一下:</p>
<p>当对象的引用计数为 0 时, 会调用 dealloc 方法用来销毁对象. 如果有弱引用者引用者该对象, 那么会从弱引用表中找到对象的弱引用条目, 将条目中所有注册的弱引用者置为 nil, 随后将该条目从弱引用表中删除.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-04-20T03:02:49.000Z" title="4/20/2020, 11:02:49 AM">2020-04-20</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">7 分钟读完 (大约995个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/20/iOS%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEBugly%E7%AC%A6%E5%8F%B7%E8%A1%A8-2020%E5%B9%B4%E6%9C%89%E6%95%88/">iOS如何配置Bugly符号表(2020年最新)</a></h1><div class="content"><p>本文将粗略的讲解 Bugly 的集成过程, 其中配置符号表部分会说的仔细一点</p>
<p>符号表就是内存地址与函数名, 文件名, 行号的映射表. 通过上传符号表, 我们能将 App 发生 Crash 的程序堆栈进行解析还原.</p>
<p><img src="https://bugly.qq.com/docs/img/symbol-ios/4001.png?v=20200312155538"></p>
<p>Bugly 是我在用的一个崩溃日志收集分析工具. 集成使用简单并且免费.<br>之前一直使用<code>Xcode + sh</code>方式自动配置符号表, 直到有一天看到 crash 堆栈没有被解析, 才知道这个方法已无法上传符号表. 上网找过一些解决方法, 大致就是找到符号表后延迟以后再上传, 但也没什么效果. 随后再上官网查看文档, 使用官方手动配置的方法, 成功的上传了符号表和解析堆栈.</p>
<h3 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h3><p>上 <a target="_blank" rel="noopener" href="https://bugly.qq.com/v2/workbench/myapp">官网</a> 创建产品.<br>创建成功后获取应用的 App ID </p>
<h3 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h3><p>使用<code>Cocoapods</code>集成<br><code>pod &#39;Bugly&#39;</code></p>
<h3 id="初始化-SDK"><a href="#初始化-SDK" class="headerlink" title="初始化 SDK"></a>初始化 SDK</h3><p>在工程<code>AppDelegate.m</code>的<code>application:didFinishLaunchingWithOptions:</code>方法中初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    [Bugly startWithAppId:@&quot;此处替换为你的AppId&quot;];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="手动配置符号表"><a href="#手动配置符号表" class="headerlink" title="手动配置符号表"></a>手动配置符号表</h3><p>下载 <a target="_blank" rel="noopener" href="https://bugly.qq.com/v2/sdk?id=15343657-638a-4569-a220-8689b090be65">最新版</a> 请点击我这个连接去下载, 这个是 3.0.0 版本的.</p>
<p>包里面有几个文件:</p>
<p><img src="https://i.loli.net/2020/04/20/a5KHeFYtcfXhvzi.jpg"></p>
<ul>
<li>buglySymboliOS.jar: 符号表工具JAR包</li>
<li>buglySymboliOS.bat: Windows的脚本</li>
<li>buglySymboliOS.sh: Shell脚本</li>
<li>settings.txt: 默认符号表配置文件</li>
<li>符号表工具iOS版-使用指南</li>
</ul>
<blockquote>
<p> 运行需要<code>Java 运行环境</code> (JRE􏲀JDK􏰅􏱺􏱿􏰎&gt;&#x3D;1.6)<br> 使用脚本时, 请保证脚本和 jar 包在同个目录下!</p>
</blockquote>
<h4 id="获取-dSYM-文件"><a href="#获取-dSYM-文件" class="headerlink" title="获取 dSYM 文件"></a>获取 dSYM 文件</h4><p> iOS 平台中, 􏲜􏲝􏲐􏱓dSYM 文件是指具有调试信息的目标文件, 文件名通常为: dSYM􏰔􏰕􏰫􏰈􏰄􏰳􏲁􏲂􏲃􏲄􏰞􏲅􏲆􏰔􏰕􏱓􏰔􏰕􏲡􏰻􏳋􏱈􏱣xxx.app.dSYM<br> 我使用下面的方式来找到它:</p>
<p> <img src="https://i.loli.net/2020/04/20/Zs9OQXEzhIMjCJ3.jpg"><br> <img src="https://i.loli.net/2020/04/20/Vh7fZrmd9ewpbnW.jpg"><br> <img src="https://i.loli.net/2020/04/20/kVNFOq6KchGES9A.jpg"><br> <img src="https://i.loli.net/2020/04/20/cPuXpiyDk3lAwZU.jpg"></p>
<p> 将最后的 dSYM 文件拷贝出来一份集中备份</p>
<h4 id="dSYM-的符号表生成和上传"><a href="#dSYM-的符号表生成和上传" class="headerlink" title="dSYM 的符号表生成和上传"></a>dSYM 的符号表生成和上传</h4><ul>
<li>生成</li>
</ul>
<p>我使用下面的方式来生成和上传 dSYM 文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /Users/dqh/Desktop/buglySymboliOS3.0.0</span><br><span class="line">java -jar buglySymboliOS.jar -i /Users/AAAA_1.0.15.app.dSYM -u -id 123456 -key 123456-2608-4a57-8af8-ff9c4d481f3e -package com.kikido.youappname -version 1.3.5</span><br></pre></td></tr></table></figure>

<p>你需要更改以下选项信息:</p>
<ul>
<li>i &#x2F;Users&#x2F;AAAA_1.0.15.app.dSYM: 更改为 [i 自己 dSYM 文件存放的地址]</li>
<li>id 123456: 更改为 [id 你自己在 Bugly 申请到的 apple id]</li>
<li>key 123456-2608-4a57-8af8-ff9c4d481f3e: 更改为 [key 你自己在 Bugly 申请到的 apple key]</li>
<li>package com.kikido.youappname: 更改为 [package 你自己 app 的 bundle id]</li>
<li>version 1.3.5: 更改为 [version 你自己 app 的 version]</li>
</ul>
<p>工具选项说明如下</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-i</td>
<td>指定文件路径, 可指定目录(必选)􏰈􏰭􏰔􏰕􏲯􏲰􏱓􏲇􏰈􏰭􏲅􏲒􏱪􏲟􏰡􏱫􏰈􏰭􏰔􏰕􏲯􏲰􏱓􏲇􏰈􏰭􏲅􏲒</td>
</tr>
<tr>
<td>-o</td>
<td>􏲱􏲲􏰞􏰀􏰁􏰂输出的符号表 zip 文件的路径, 必须是 zip 文件</td>
</tr>
<tr>
<td>-d</td>
<td>调试模式开关(默认关闭)</td>
</tr>
<tr>
<td>-s</td>
<td>指定配置文件(默认读取 JAR 目录下的 settings.text 文件)</td>
</tr>
<tr>
<td>-u</td>
<td>上传开关</td>
</tr>
<tr>
<td>-id</td>
<td>app id</td>
</tr>
<tr>
<td>-key</td>
<td>app key</td>
</tr>
<tr>
<td>-package</td>
<td>app 包名</td>
</tr>
<tr>
<td>-version</td>
<td>app 版本</td>
</tr>
<tr>
<td>-symbol</td>
<td>生成 symbol 文件</td>
</tr>
</tbody></table>
<p>更多信息请查看<code>符号表工具iOS版-使用指南.pdf</code></p>
<p>使用上面的命令之后就会在本地生成符号表文件, 并上传到符号表.</p>
<p><img src="https://i.loli.net/2020/04/20/EmPNnc9RQUy8X7W.jpg" alt="上传成功"></p>
<p>下面是 crash 的堆栈解析, 完美<br><img src="https://i.loli.net/2020/04/20/h72tVKX4LQlcYHO.jpg"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-04-16T08:21:05.000Z" title="4/16/2020, 4:21:05 PM">2020-04-16</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">1 小时读完 (大约6745个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/16/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-iOS-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/">深入了解 iOS 引用计数</a></h1><div class="content"><p>iOS 通过引用计数来管理内存，简单的说就是当一个 id 类型的对象引用计数变成 0 的时候就会被销毁，回收内存。<br>本文将通过断点调试来探究引用计数的存储及读取在底层的实现。全程无聊，请配合源码阅读</p>
<p>源码版本：objc4-779.1<br>当然还是推荐使用这个来学习：<a target="_blank" rel="noopener" href="https://github.com/LGCooci/objc_debug/tree/master">可编译的源码</a></p>
<h3 id="引用计数存储在哪"><a href="#引用计数存储在哪" class="headerlink" title="引用计数存储在哪"></a>引用计数存储在哪</h3><p>引用计数只适用于 id 类型的对象</p>
<p>有一种特殊的 id 类型对象，Tagged Pointer，如果不知道的话可以看我另一篇博客 <a target="_blank" rel="noopener" href="https://kikido.github.io/2020/04/02/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Tagged-Pointer/">深入了解Tagged Pointer</a>了解一下</p>
<p>因为 Tagged Pointer 并不是真正的对象，所以它并不通过引用计数来管理其内存。<br>用下面的代码求 n1 的引用计数，输出结果为 9223372036854775807</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 Tagged Pointer 对象</span><br><span class="line">NSNumber *n1 = [NSNumber numberWithInt:1];</span><br><span class="line">NSLog(@&quot;n1 rc = %ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(n1)));</span><br></pre></td></tr></table></figure>

<p>我们知道每个 id 类型对象都有一个 isa 指针，其中只有 33 位用来保存其父类或者元类信息，剩余的31位也不能浪费啊，这其中就会一些 bit 用来保存引用计数。<br>下面是 arm64 架构下的 isa 结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"></span><br><span class="line">    struct &#123;</span><br><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="line">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL</span><br><span class="line">#   define ISA_BITFIELD                                                      \</span><br><span class="line">      uintptr_t nonpointer        : 1;                                       \</span><br><span class="line">      uintptr_t has_assoc         : 1;                                       \</span><br><span class="line">      uintptr_t has_cxx_dtor      : 1;                                       \</span><br><span class="line">      uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \</span><br><span class="line">      uintptr_t magic             : 6;                                       \</span><br><span class="line">      uintptr_t weakly_referenced : 1;                                       \</span><br><span class="line">      uintptr_t deallocating      : 1;                                       \</span><br><span class="line">      uintptr_t has_sidetable_rc  : 1;                                       \</span><br><span class="line">      uintptr_t extra_rc          : 19</span><br><span class="line">#   define RC_ONE   (1ULL&lt;&lt;45)</span><br><span class="line">#   define RC_HALF  (1ULL&lt;&lt;18)</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以发现，isa_t 是一个联合体(union)，几个不同类型的变量 clas 和 bits 及 struct 共用同一段内存。当 isa 指针的第一位<code>nonpointer</code>为 1 时表示它是优化的 isa 指针，即将多余的 bit 用来存储其它信息，从它的名字<code>nonpointer</code>也可以看出它不再是一个纯粹的指针了。当为 1 时，第一个成员变量<code>cls</code>是没有用的，因为 isa 不再使用它来指向父类 cls。下面是 isa 指针各位域的含义</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>nonpointer</td>
<td>表示是否对 isa 指针开启优化 0:纯isa指针，1:存储了额外信息</td>
</tr>
<tr>
<td>has_assoc</td>
<td>表示该对象是否包含 associated object，如果没有，则析构时会更快</td>
</tr>
<tr>
<td>has_cxx_dtor</td>
<td>表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快</td>
</tr>
<tr>
<td>shiftcls</td>
<td>类的指针</td>
</tr>
<tr>
<td>magic</td>
<td>固定值 0x1a, 用于调试器判断当前对象是真的对象还是没有初始化的空间</td>
</tr>
<tr>
<td>weakly_referenced</td>
<td>表示该对象是否有过 weak 对象，如果没有，则析构时更快</td>
</tr>
<tr>
<td>deallocating</td>
<td>表示该对象是否正在析构</td>
</tr>
<tr>
<td>has_sidetable_rc</td>
<td>表示该对象的引用计数值是否过大无法存储在 isa 指针</td>
</tr>
<tr>
<td>extra_rc</td>
<td>存储引用计数值减一后的结果</td>
</tr>
</tbody></table>
<p>在 arm64 下, isa 使用 19 个 bit 用来存储引用计数. 当引用计数超过这个数时，将会把 RC_HALF 数量的引用计数存储在一个全局哈希表中，此时 <code>has_sidetable_rc</code> 变为 1</p>
<h3 id="增加引用计数"><a href="#增加引用计数" class="headerlink" title="增加引用计数"></a>增加引用计数</h3><p>下面让我们通过调试来探究具体的存储过程<br>因为是在模拟器中运行的，isa 最多只能使用 8 个 bit 来存储引用计数, 即在 isa 中只能存储不超过 256 的数目。所以我们只要将对象的引用计数增加到 256 以上，那么系统就会将多余的引用计数存储到哈希表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void foo(void) &#123;</span><br><span class="line">	NSObject *o1 = [[NSObject alloc] init];</span><br><span class="line">	for (int i = 0; i &lt; 500; i++) &#123;</span><br><span class="line">	    _objc_rootRetain(o1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_objc_rootRetain()</code>方法最终会调用<code>objc_object::rootRetain(bool tryRetain, bool handleOverflow)</code>, 这个方法的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE id </span><br><span class="line">objc_object::rootRetain(bool tryRetain, bool handleOverflow)</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line"></span><br><span class="line">    bool sideTableLocked = false;</span><br><span class="line">    bool transcribeToSideTable = false;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">    	 // 是否将引用计数转移到索引表中</span><br><span class="line">        transcribeToSideTable = false;</span><br><span class="line">        // LoadExclusive 的作用是让读取操作原子化</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        // if (slowpath) else ()，表示大概率执行 else 后面的语句，用来提高效率。</span><br><span class="line">        // fastpath 则表示大概率执行 if 后面的语句</span><br><span class="line">        if (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">        	  // arm64 架构下，一般的对象 nonpointer 为YES，但也有特例，例如 block 的 nonpointer 为 False，即不使用 isa 保存额外信息</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            if (rawISA()-&gt;isMetaClass()) return (id)this;</span><br><span class="line">            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            if (tryRetain) return sidetable_tryRetain() ? (id)this : nil;</span><br><span class="line">            else return sidetable_retain();</span><br><span class="line">        &#125;</span><br><span class="line">        // don&#x27;t check newisa.fast_rr; we already called any RR overrides</span><br><span class="line">        if (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        // 用来表示 isa 指针的值是否溢出。因为引用计数存储在指针的高位，当引用计数增加到一定程度，会超过最高位的数字，此时 carry 的值不等于 0，表示溢出</span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        // addc() 是一个内置函数，作用是将 isa 里面的引用计数 + 1 后保存</span><br><span class="line">        newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry);  // extra_rc++</span><br><span class="line"></span><br><span class="line">        if (slowpath(carry)) &#123;</span><br><span class="line">            // newisa.extra_rc++ overflowed</span><br><span class="line">            // 移除的话则需要对多余的引用计数保存到索引表中。</span><br><span class="line">            // 刚开始进入的时候 handleOverflow == false</span><br><span class="line">            if (!handleOverflow) &#123;</span><br><span class="line">                ClearExclusive(&amp;isa.bits);</span><br><span class="line">                return rootRetain_overflow(tryRetain);</span><br><span class="line">            &#125;</span><br><span class="line">            // 加锁</span><br><span class="line">            if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</span><br><span class="line">            // 此时 isa 指针存储的引用计数应该是满的， extra_rc 的 19 位都是 1，将 extra_rc 赋值为原来的一半，也就是将 isa 的最高位赋值为 0，这样做的目的是下次引用计数增加的时候可以直接存储在 isa 中，而不需要调用索引表来存储。将 has_sidetable_rc 赋值为 1，标记有额外的引用计数存储在索引表中</span><br><span class="line">            sideTableLocked = true;</span><br><span class="line">            transcribeToSideTable = true;</span><br><span class="line">            newisa.extra_rc = RC_HALF;</span><br><span class="line">            newisa.has_sidetable_rc = true;</span><br><span class="line">        &#125;</span><br><span class="line">       // StoreExclusive(), 如果&amp;isa.bits和oldisa.bits相等，那么就把newisa.bits的值赋给&amp;isa.bits，并且返回true。</span><br><span class="line">    &#125; while (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    if (slowpath(transcribeToSideTable)) &#123;</span><br><span class="line">        // Copy the other half of the retain counts to the side table.</span><br><span class="line">        // 如果溢出的话，则将 isa 存储的引用计数赋值为最大值的一半，即 RC_HALF，那么减少的一半则转移到索引表中</span><br><span class="line">        sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    if (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</span><br><span class="line">    return (id)this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写了点注释帮助你们理解. 现在我们在<code>sidetable_addExtraRC_nolock(RC_HALF);</code>那一行打个断点，启动程序</p>
<p><img src="https://i.loli.net/2020/05/13/2q6ThJM9igfrKGz.jpg"></p>
<p><code>step into</code>进入这个方法</p>
<p><img src="https://i.loli.net/2020/05/13/cT48MF3VjPEGko6.jpg"></p>
<p>因为用的模拟器，所以 RC_HALF &#x3D;&#x3D; delta_rc &#x3D;&#x3D; 128，符合预期。</p>
<p>代码<code>SideTable&amp; table = SideTables()[this]</code>，通过计算指针值得到哈希值获取到对应的 sidetable<br>让我们点开方法<code>SideTables()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static objc::ExplicitInit&lt;StripedMap&lt;SideTable&gt;&gt; SideTablesMap;</span><br><span class="line"></span><br><span class="line">static StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class="line">    return SideTablesMap.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>class ExplicitInit</code> 的定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Type&gt;</span><br><span class="line">class ExplicitInit &#123;</span><br><span class="line">    alignas(Type) uint8_t _storage[sizeof(Type)];</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    template &lt;typename... Ts&gt;</span><br><span class="line">    void init(Ts &amp;&amp;... Args) &#123;</span><br><span class="line">        new (_storage) Type(std::forward&lt;Ts&gt;(Args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Type &amp;get() &#123;</span><br><span class="line">        return *reinterpret_cast&lt;Type *&gt;(_storage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>ExplicitInit</code>的作用是生成一个模板类型 Type 的实例。<code>alignas(Type) uint8_t _storage[sizeof(Type)];</code>成员变量<code>_storage</code>是一个 sizeof(Type) 长度的 uint8_t 数组，而 uint8_t 占用一个字节，所以实际上<code>_storage</code>的长度跟一个 Type 实例所占用的内存是一样多的。成员函数 <code>Type &amp;get()</code> 将 _storage 数组指针用<code>reinterpret_cast&lt;Type *&gt;</code>强转成了 Type * 类型指针，前面再加一个 *，说明返回的实际上是 Type 实例内存的首地址。而另一个成员函数<code>init</code>用来初始化生成的 Type 实例。</p>
<p>所以<code>static StripedMap&lt;SideTable&gt;&amp; SideTables()</code>函数实际上返回了一个全局静态<code>StripedMap&lt;SideTable&gt;</code>的实例。<br>下面是<code>class StripedMap</code>的部分定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class StripedMap &#123;</span><br><span class="line">#if TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR</span><br><span class="line">    enum &#123; StripeCount = 8 &#125;;</span><br><span class="line">#else</span><br><span class="line">    enum &#123; StripeCount = 64 &#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    struct PaddedT &#123;</span><br><span class="line">        T value alignas(CacheLineSize);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    PaddedT array[StripeCount];</span><br><span class="line"></span><br><span class="line">    static unsigned int indexForPointer(const void *p) &#123;</span><br><span class="line">        uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(p);</span><br><span class="line">        return ((addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)) % StripeCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    T&amp; operator[] (const void *p) &#123; </span><br><span class="line">        return array[indexForPointer(p)].value; </span><br><span class="line">    &#125;</span><br><span class="line">    // ...省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>局部结构体<code>PaddedT</code>的作用是用来内存对齐，常量<code>CacheLineSize</code>是固定值 64。在 arm64 架构下，成员变量<code>array</code>是一个长度为 8，元素类型为 T，每个元素占 64 字节的数组，而在模拟器下是一个长度为 64，每个元素占 64 字节的数组。</li>
<li>成员函数<code>indexForPointer</code>用来根据指针来计算哈希值，确定对应于<code>array</code>里面第几个元素。</li>
<li><code>T&amp; operator[] (const void *p)</code>使用 operator 关键字重载了<code>[]</code>符号。举个例子，StripedMap 有一个实例 sm，有一个 int 类型的变量 a，当执行<code>sm[&amp;a]</code>的代码时，就会跳转到<code>T&amp; operator[] (const void *p)</code>这个方法里面。而在上面的重载<code>[]</code>函数中，传入的参数为指针类型，然后计算出其数组 index，返回对应的元素 T，也就是 <code>SideTable</code>。</li>
</ul>
<p>继续调试，断点此时在<code>SideTable&amp; table = SideTables()[this];</code>这一行。点击 step into</p>
<p><img src="https://i.loli.net/2020/05/13/8KkRmgMFCyporjh.jpg"></p>
<p><code>_storage</code>的数组长度为 4096，也就是 64 * 64，符合预期。继续<code>step into</code>，最终会跳转到下面这里</p>
<p><img src="https://i.loli.net/2020/05/13/gPYtFhH2kpN1KRM.jpg"></p>
<p>跳转到了重载的<code>[]</code>方法里面了。</p>
<p>目前已知道的情报就是，有一个全局的<code>StripedMap</code>条目索引，里面包含了若干个<code>SideTable</code>索引表。在使用时，根据指针得到对应的 sidetable。<code>SideTable</code> 的部分定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct SideTable &#123;</span><br><span class="line">    spinlock_t slock;</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    weak_table_t weak_table;</span><br><span class="line"></span><br><span class="line">    SideTable() &#123;</span><br><span class="line">        memset(&amp;weak_table, 0, sizeof(weak_table));</span><br><span class="line">    &#125;</span><br><span class="line">    void lock() &#123; slock.lock(); &#125;</span><br><span class="line">    void unlock() &#123; slock.unlock(); &#125;</span><br><span class="line">    void forceReset() &#123; slock.forceReset(); &#125;</span><br><span class="line">    // ...省略</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>SideTable 的成员对象里面有一个自旋锁，引用映射表<code>RefcountMap refcnts</code>，弱引用表<code>weak_table_t weak_table</code>。在上面我们提到了每个 sidetable 占用 64 个字节, 那是因为 spinlock_t 占用 4, RefcountMap 占用 24, weak_table_t 占用 32, 加起来就是 64.<br>在这里我们只了解下 RefcountMap, 因为它跟我们引用计数相关.<br><code>RefcountMap</code>是一个类型别名，它的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,RefcountMapValuePurgeable&gt; RefcountMap;</span><br></pre></td></tr></table></figure>

<p>先别急着查看<code>DenseMap</code>的定义，我们先看看<code>DisguisedPtr</code>是个什么类。它的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class DisguisedPtr &#123;</span><br><span class="line">    uintptr_t value;</span><br><span class="line"></span><br><span class="line">    static uintptr_t disguise(T* ptr) &#123;</span><br><span class="line">        return -(uintptr_t)ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static T* undisguise(uintptr_t val) &#123;</span><br><span class="line">        return (T*)-val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">    DisguisedPtr() &#123; &#125;</span><br><span class="line">    DisguisedPtr(T* ptr) </span><br><span class="line">        : value(disguise(ptr)) &#123; &#125;</span><br><span class="line">    DisguisedPtr(const DisguisedPtr&lt;T&gt;&amp; ptr) </span><br><span class="line">        : value(ptr.value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    DisguisedPtr&lt;T&gt;&amp; operator = (T* rhs) &#123;</span><br><span class="line">        value = disguise(rhs);</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    DisguisedPtr&lt;T&gt;&amp; operator = (const DisguisedPtr&lt;T&gt;&amp; rhs) &#123;</span><br><span class="line">        value = rhs.value;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    operator T* () const &#123;</span><br><span class="line">        return undisguise(value);</span><br><span class="line">    &#125;</span><br><span class="line">    T* operator -&gt; () const &#123; </span><br><span class="line">        return undisguise(value);</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; operator * () const &#123; </span><br><span class="line">        return *undisguise(value);</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; operator [] (size_t i) const &#123;</span><br><span class="line">        return undisguise(value)[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>简单的说, 你可以像指针<code>Type *</code>一样的使用<code>DisguisedPtr</code>，但是其成员变量<code>value</code>保存的是伪装后的指针值。伪装函数是<code>disguise()</code>，0 和 0x800…00 经过伪装之后还是本身，但指针值也不可能是这两个值，所以无所谓的。</li>
<li>为了能像指针<code>Type *</code>一样的使用<code>DisguisedPtr</code>，在<code>DisguisedPtr</code>内部，重载了许多符号，例如 [], &#x3D;, *, ()。具体就不分析了。</li>
<li>该类的作用是为了避免直接引用指针, 防止被 leaks 内存检测工具检测出内存泄漏</li>
</ul>
<p><code>class RefcountMapValuePurgeable</code>的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct RefcountMapValuePurgeable &#123;</span><br><span class="line">    static inline bool isPurgeable(size_t x) &#123;</span><br><span class="line">        return x == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它只有一个内联函数，根据 x 是否为 0 返回一个 bool 值。它的作用就是根据参数判断是否需要析构这个实例<br>好了，了解完了<code>DisguisedPtr</code>和<code>RefcountMapValuePurgeable</code>，接下来我们来看<code>DenseMap</code>，它的定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename KeyT, typename ValueT,</span><br><span class="line">          typename ValueInfoT = DenseMapValueInfo&lt;ValueT&gt;,</span><br><span class="line">          typename KeyInfoT = DenseMapInfo&lt;KeyT&gt;,</span><br><span class="line">          typename BucketT = detail::DenseMapPair&lt;KeyT, ValueT&gt;&gt;</span><br><span class="line">class DenseMap : public DenseMapBase&lt;DenseMap&lt;KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;,</span><br><span class="line">                                     KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt; &#123;</span><br><span class="line">  friend class DenseMapBase&lt;DenseMap, KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;;</span><br><span class="line"></span><br><span class="line">  using BaseT = DenseMapBase&lt;DenseMap, KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;;</span><br><span class="line"></span><br><span class="line">  BucketT *Buckets;</span><br><span class="line">  unsigned NumEntries;</span><br><span class="line">  unsigned NumTombstones;</span><br><span class="line">  unsigned NumBuckets;</span><br><span class="line">  </span><br><span class="line">  public:</span><br><span class="line">   explicit DenseMap(unsigned InitialReserve = 0) &#123; init(InitialReserve); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码<code>friend class DenseMapBase</code>的作用是声明一个友元类<code>DenseMapBase</code>，这样<code>DenseMapBase</code>在内存可以直接访问<code>DenseMap</code> private 的成员函数。</li>
<li>代码<code>using BaseT = DenseMapBase</code>的作用是为<code>DenseMapBase</code>指定一个别名<code>BaseT</code></li>
<li>函数<code>explicit DenseMap()</code>, <code>explicit</code>的作用是用来声明类构造函数是显示调用的，而非隐式调用。</li>
</ul>
<p><code>DenseMap</code>里面有 4 个成员变量，Buckets 和 NumEntries，NumTombstones， NumBuckets。</p>
<ul>
<li>Buckets, 存储引用计数的数组, 元素类似于字典, key 为指针, value 为引用计数. 数组可扩容</li>
<li>NumEntries 表示数组中用来存储引用计数的元素有几个</li>
<li>NumTombstones 数组中元素被用来存储一个对象的引用计数, 当这个对象被销毁后, 该元素被标记为墓碑. 该变量用来表示有多少个这种元素</li>
<li>NumBuckets 数组 Buckets 的长度</li>
</ul>
<p>再来看一下模板里的几个类型 <code>DenseMapInfo&lt;KeyT&gt;</code>, <code>detail::DenseMapPair&lt;KeyT, ValueT&gt;</code></p>
<p>DenseMapInfo 有很多的模板定义，可以适用于各种类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct DenseMapInfo&lt;DisguisedPtr&lt;T&gt;&gt; &#123;</span><br><span class="line">  static inline DisguisedPtr&lt;T&gt; getEmptyKey() &#123;</span><br><span class="line">    return DisguisedPtr&lt;T&gt;((T*)(uintptr_t)-1);</span><br><span class="line">  &#125;</span><br><span class="line">  static inline DisguisedPtr&lt;T&gt; getTombstoneKey() &#123;</span><br><span class="line">    return DisguisedPtr&lt;T&gt;((T*)(uintptr_t)-2);</span><br><span class="line">  &#125;</span><br><span class="line">  static unsigned getHashValue(const T *PtrVal) &#123;</span><br><span class="line">      return ptr_hash((uintptr_t)PtrVal);</span><br><span class="line">  &#125;</span><br><span class="line">  static bool isEqual(const DisguisedPtr&lt;T&gt; &amp;LHS, const DisguisedPtr&lt;T&gt; &amp;RHS) &#123;</span><br><span class="line">      return LHS == RHS; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内联函数<code>getEmptyKey</code>和<code>getTombstoneKey</code>均返回一个特征值，用来标记 bucket 的状态 Empty 和 Tombstone。<br>静态函数<code>getHashValue</code>根据指针计算出哈希值。<br><code>ptr_hash()</code>的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static inline uint32_t ptr_hash(uint64_t key)</span><br><span class="line">&#123;</span><br><span class="line">    key ^= key &gt;&gt; 4;</span><br><span class="line">    key *= 0x8a970be7488fda55;</span><br><span class="line">    key ^= __builtin_bswap64(key);</span><br><span class="line">    return (uint32_t)key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看不懂，知道是计算哈希值的就好了。</p>
<p>最后一个静态函数<code>isEqual</code>用来比较两个参数是否相等。</p>
<p>接着看<code>detail::DenseMapPair&lt;KeyT, ValueT&gt;</code> 它的定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename KeyT, typename ValueT&gt;</span><br><span class="line">struct DenseMapPair : public std::pair&lt;KeyT, ValueT&gt; &#123;</span><br><span class="line">  DenseMapPair() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  DenseMapPair(const KeyT &amp;Key, const ValueT &amp;Value)</span><br><span class="line">      : std::pair&lt;KeyT, ValueT&gt;(Key, Value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  DenseMapPair(KeyT &amp;&amp;Key, ValueT &amp;&amp;Value)</span><br><span class="line">      : std::pair&lt;KeyT, ValueT&gt;(std::move(Key), std::move(Value)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  template &lt;typename AltKeyT, typename AltValueT&gt;</span><br><span class="line">  DenseMapPair(AltKeyT &amp;&amp;AltKey, AltValueT &amp;&amp;AltValue,</span><br><span class="line">               typename std::enable_if&lt;</span><br><span class="line">                   std::is_convertible&lt;AltKeyT, KeyT&gt;::value &amp;&amp;</span><br><span class="line">                   std::is_convertible&lt;AltValueT, ValueT&gt;::value&gt;::type * = 0)</span><br><span class="line">      : std::pair&lt;KeyT, ValueT&gt;(std::forward&lt;AltKeyT&gt;(AltKey),</span><br><span class="line">                                std::forward&lt;AltValueT&gt;(AltValue)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  template &lt;typename AltPairT&gt;</span><br><span class="line">  DenseMapPair(AltPairT &amp;&amp;AltPair,</span><br><span class="line">               typename std::enable_if&lt;std::is_convertible&lt;</span><br><span class="line">                   AltPairT, std::pair&lt;KeyT, ValueT&gt;&gt;::value&gt;::type * = 0)</span><br><span class="line">      : std::pair&lt;KeyT, ValueT&gt;(std::forward&lt;AltPairT&gt;(AltPair)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  KeyT &amp;getFirst() &#123; return std::pair&lt;KeyT, ValueT&gt;::first; &#125;</span><br><span class="line">  const KeyT &amp;getFirst() const &#123; return std::pair&lt;KeyT, ValueT&gt;::first; &#125;</span><br><span class="line">  ValueT &amp;getSecond() &#123; return std::pair&lt;KeyT, ValueT&gt;::second; &#125;</span><br><span class="line">  const ValueT &amp;getSecond() const &#123; return std::pair&lt;KeyT, ValueT&gt;::second; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看起来很复杂的样子，但其实只要知道它的父类<code>std::pair</code>是干嘛的就好了。<br><code>std::pair</code>的作用是将两个数据组合成一个数据，两个数据可以是同一类型或者不同类型。它是一个模板结构体，主要的两个成员变量是first和second，这两个变量可以直接使用。<br>再根据注释，可以推测出<code>DenseMapPair</code>作用是将 keyT 和 ValueT 两个类型的值保存在一起</p>
<p>继续之前的调试，在代码<code>size_t&amp; refcntStorage = table.refcnts[this];</code>打个断点，然后点击 continue program execution 跳转过去。</p>
<p>注意这里的<code>size_t&amp;</code>符号不是取内存地址意思，&amp; 在这里表示引用的意思。举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int&amp; b = a;</span><br><span class="line">b = 10;</span><br></pre></td></tr></table></figure>
<p>对 b 赋值 10 后，a 的值也变成了 10。好了，继续</p>
<p><img src="https://i.loli.net/2020/05/13/aY9yrcFwqWZogs6.jpg"></p>
<p>继续 step into</p>
<p><img src="https://i.loli.net/2020/05/13/Xt1gp7hS8LswvdU.jpg"></p>
<p>首先会跳转到类<code>DisguisedPtr</code>的一个初始化方法里面，这里对指针进行伪装并赋值给了成员对象 value。<br>继续 step into</p>
<p><img src="https://i.loli.net/2020/05/13/B76S2Og8qobtRXj.jpg"></p>
<p>跳转到了这里。可以看出来<code>DenseMap</code>的父类<code>DenseMapBase</code>也重载了<code>[]</code>方法。<br>参数类型为<code>KeyT &amp;&amp;</code>，也就是<code>DisguisedPtr&lt;objc_object&gt; &amp;&amp;</code>类型。这里的<code>&amp;&amp;</code>符号以及下面的<code>std::move(Key)</code>函数都是为了确定参数是右值引用，实现移动语义，减少不必要的参数拷贝。</p>
<p>继续 step into，跳转到了下面这里</p>
<p><img src="https://i.loli.net/2020/05/13/6QMiPmD7zAfpxqe.jpg"></p>
<p>之前我们讲<code>DenseMapPair&lt;KeyT, ValueT&gt;</code>的时候说到过，这个类的作用是将两个类型的值的组合成一个整体，类似于我们平常使用的字典。key 对应 first， value 对应 second。在<code>FindAndConstruct</code>方法中，首先会通过<code>LookupBucketFor()</code>查找是否已经有存在的 bucket，如果没有则通过<code>InsertIntoBucket</code>函数生成并返回对应的 bucket。</p>
<p>下面是<code>LookupBucketFor()</code>函数的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename LookupKeyT&gt;</span><br><span class="line">  bool LookupBucketFor(const LookupKeyT &amp;Val,</span><br><span class="line">                       const BucketT *&amp;FoundBucket) const &#123;</span><br><span class="line">    // 返回成员变量 Buckets</span><br><span class="line">    const BucketT *BucketsPtr = getBuckets();</span><br><span class="line">    // 返回成员变量 NumBuckets</span><br><span class="line">    const unsigned NumBuckets = getNumBuckets();</span><br><span class="line"></span><br><span class="line">    if (NumBuckets == 0) &#123;</span><br><span class="line">      FoundBucket = nullptr;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 保存在查找过程中碰到的墓碑</span><br><span class="line">    const BucketT *FoundTombstone = nullptr;</span><br><span class="line">    // DenseMapInfo 的内联函数 getEmptyKey </span><br><span class="line">    const KeyT EmptyKey = getEmptyKey();</span><br><span class="line">    // DenseMapInfo 的内联函数 getTombstoneKey </span><br><span class="line">    const KeyT TombstoneKey = getTombstoneKey();</span><br><span class="line">    assert(!KeyInfoT::isEqual(Val, EmptyKey) &amp;&amp;</span><br><span class="line">           !KeyInfoT::isEqual(Val, TombstoneKey) &amp;&amp;</span><br><span class="line">           &quot;Empty/Tombstone value shouldn&#x27;t be inserted into map!&quot;);</span><br><span class="line"></span><br><span class="line">	 //DenseMapInfo 的静态函数 getHashValue 计算哈希值，并与 NumBuckets-1 进行与运算，得到对应 BucketT 实例的 index</span><br><span class="line">    unsigned BucketNo = getHashValue(Val) &amp; (NumBuckets-1);</span><br><span class="line">    // 查找次数</span><br><span class="line">    unsigned ProbeAmt = 1;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">      const BucketT *ThisBucket = BucketsPtr + BucketNo;</span><br><span class="line">      // Found Val&#x27;s bucket?  If so, return it.</span><br><span class="line">      // 找到了对应的 BucketT 实例</span><br><span class="line">      if (LLVM_LIKELY(KeyInfoT::isEqual(Val, ThisBucket-&gt;getFirst()))) &#123;</span><br><span class="line">        FoundBucket = ThisBucket;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // If we found an empty bucket, the key doesn&#x27;t exist in the set.</span><br><span class="line">      // Insert it and return the default value.</span><br><span class="line">      // 如果对应的 bucket 是空的。如果是第一次查找的话则在这个 bucket 里面插入 key 和 value(在InsertIntoBucket函数中执行)。如果不是第一次并且之前找到了墓碑，则使用墓碑bucket插入key和value</span><br><span class="line">      if (LLVM_LIKELY(KeyInfoT::isEqual(ThisBucket-&gt;getFirst(), EmptyKey))) &#123;</span><br><span class="line">        // If we&#x27;ve already seen a tombstone while probing, fill it in instead</span><br><span class="line">        // of the empty bucket we eventually probed to.</span><br><span class="line">        FoundBucket = FoundTombstone ? FoundTombstone : ThisBucket;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // If this is a tombstone, remember it.  If Val ends up not in the map, we</span><br><span class="line">      // prefer to return it than something that would require more probing.</span><br><span class="line">      // Ditto for zero values.</span><br><span class="line">      // 如果找到一个墓碑，则使用 FoundTombstone  将这个墓碑记录下来</span><br><span class="line">      if (KeyInfoT::isEqual(ThisBucket-&gt;getFirst(), TombstoneKey) &amp;&amp;</span><br><span class="line">          !FoundTombstone)</span><br><span class="line">        FoundTombstone = ThisBucket;  // Remember the first tombstone found.</span><br><span class="line">        // 如果 FoundTombstone 为空并且 对应的 bucket 的 second 是 0，则用FoundTombstone保存下这个bucket</span><br><span class="line">      if (ValueInfoT::isPurgeable(ThisBucket-&gt;getSecond())  &amp;&amp;  !FoundTombstone)</span><br><span class="line">        FoundTombstone = ThisBucket;</span><br><span class="line"></span><br><span class="line">      // Otherwise, it&#x27;s a hash collision or a tombstone, continue quadratic</span><br><span class="line">      // probing.</span><br><span class="line">      // 如果查找次数多余 NumBuckets ，则报错</span><br><span class="line">      if (ProbeAmt &gt; NumBuckets) &#123;</span><br><span class="line">        FatalCorruptHashTables(BucketsPtr, NumBuckets);</span><br><span class="line">      &#125;</span><br><span class="line">      // 重新计算 BucketNo，重新查找</span><br><span class="line">      BucketNo += ProbeAmt++;</span><br><span class="line">      BucketNo &amp;= (NumBuckets-1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码里写了点注释帮助理解。<br>bucket 有两种状态，一种是 Empty，这个表示当前这个 bucket 还没有被使用的标记；另一个状态是 TombstoneKey，当一个 bucket 被使用了，当对象释放后该 bucket 被定义为这种状态</p>
<p>通过<code>FindAndConstruct</code>函数的分析我们知道，如果已经存在 bucket，则返回 YES，并将指针 TheBucket 指向这个 bucket。如果存在一个墓碑或者空的 bucket，则返回 false，并将指针 TheBucket 指向这个 bucket。</p>
<p>接着分析<code>InsertIntoBucket()</code>，下面是它的实现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename KeyArg, typename... ValueArgs&gt;</span><br><span class="line">  BucketT *InsertIntoBucket(BucketT *TheBucket, KeyArg &amp;&amp;Key,</span><br><span class="line">                            ValueArgs &amp;&amp;... Values) &#123;</span><br><span class="line">    TheBucket = InsertIntoBucketImpl(Key, Key, TheBucket);</span><br><span class="line">	</span><br><span class="line">	 // 保存 key 到 bucket 的成员变量 first 中</span><br><span class="line">    TheBucket-&gt;getFirst() = std::forward&lt;KeyArg&gt;(Key);</span><br><span class="line">    // 初始化 ValueT 的实例并保存到 bucket 的成员变量 second 中</span><br><span class="line">    ::new (&amp;TheBucket-&gt;getSecond()) ValueT(std::forward&lt;ValueArgs&gt;(Values)...);</span><br><span class="line">    return TheBucket;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  template &lt;typename LookupKeyT&gt;</span><br><span class="line">  BucketT *InsertIntoBucketImpl(const KeyT &amp;Key, const LookupKeyT &amp;Lookup,</span><br><span class="line">                                BucketT *TheBucket) &#123;</span><br><span class="line">    // If the load of the hash table is more than 3/4, or if fewer than 1/8 of</span><br><span class="line">    // the buckets are empty (meaning that many are filled with tombstones),</span><br><span class="line">    // grow the table.</span><br><span class="line">    //</span><br><span class="line">    // The later case is tricky.  For example, if we had one empty bucket with</span><br><span class="line">    // tons of tombstones, failing lookups (e.g. for insertion) would have to</span><br><span class="line">    // probe almost the entire table until it found the empty bucket.  If the</span><br><span class="line">    // table completely filled with tombstones, no lookup would ever succeed,</span><br><span class="line">    // causing infinite loops in lookup.</span><br><span class="line">    unsigned NewNumEntries = getNumEntries() + 1;</span><br><span class="line">    unsigned NumBuckets = getNumBuckets();</span><br><span class="line">    // 当 buckets 数组已经使用了超过 3/4 或者 空bucket的数量小于 1/8，则增加 buckets 数组的长度。</span><br><span class="line">    if (LLVM_UNLIKELY(NewNumEntries * 4 &gt;= NumBuckets * 3)) &#123;</span><br><span class="line">      // 扩增原来的 NumBuckets，新的 buckets 长度为旧的两倍，长度至少为 4。新的 buckets 生成后将旧数组里面的数据转移过去，并且旧数组删除</span><br><span class="line">      this-&gt;grow(NumBuckets * 2);</span><br><span class="line">      // 因为重新生成了 buckets 数组，所以需要使用LookupBucketFor重新查找对应bucket，并用指针 TheBucket 指向</span><br><span class="line">      LookupBucketFor(Lookup, TheBucket);</span><br><span class="line">      NumBuckets = getNumBuckets();</span><br><span class="line">    &#125; else if (LLVM_UNLIKELY(NumBuckets-(NewNumEntries+getNumTombstones()) &lt;=</span><br><span class="line">                             NumBuckets/8)) &#123;</span><br><span class="line">      this-&gt;grow(NumBuckets);</span><br><span class="line">      LookupBucketFor(Lookup, TheBucket);</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT(TheBucket);</span><br><span class="line"></span><br><span class="line">    // Only update the state after we&#x27;ve grown our bucket space appropriately</span><br><span class="line">    // so that when growing buckets we have self-consistent entry count.</span><br><span class="line">    // If we are writing over a tombstone or zero value, remember this.</span><br><span class="line">    if (KeyInfoT::isEqual(TheBucket-&gt;getFirst(), getEmptyKey())) &#123;</span><br><span class="line">      // Replacing an empty bucket.</span><br><span class="line">      // 使用空bucket，NumEntries + 1 </span><br><span class="line">      incrementNumEntries();</span><br><span class="line">    &#125; else if (KeyInfoT::isEqual(TheBucket-&gt;getFirst(), getTombstoneKey())) &#123;</span><br><span class="line">      // Replacing a tombstone.</span><br><span class="line">      // 使用墓碑 bucket，NumEntries + 1， NumTombstones - 1</span><br><span class="line">      incrementNumEntries();</span><br><span class="line">      decrementNumTombstones();</span><br><span class="line">    &#125; else &#123;      </span><br><span class="line">      // we should be purging a zero. No accounting changes.</span><br><span class="line">      // 如果 second 等于 0，则析构 second</span><br><span class="line">      ASSERT(ValueInfoT::isPurgeable(TheBucket-&gt;getSecond()));</span><br><span class="line">      TheBucket-&gt;getSecond().~ValueT();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return TheBucket;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<p>通过<code>InsertIntoBucket</code>函数我们了解到，当 buckets 数组已经使用了超过 3&#x2F;4 或者 空bucket的数量小于 1&#x2F;8，则会生成一个新的 buckets，长度为原来的2倍（最小为4），并将旧数组的数据转移到新数组中，并重新查找 TheBucket 的 index。最后将伪装后的指针保存到bucket的first中，将引用计数保存到bucket的second中。</p>
<p>理论分析到这里。这几个函数的调试我就不贴出来了，比较长，你们可以自己调试下。</p>
<p>接下来在代码<code>size_t oldRefcnt = refcntStorage;</code>中打个断点，点击 continue program execution 跳转过去。</p>
<p><img src="https://i.loli.net/2020/05/13/9gODFkVRhG1ZYEP.jpg"></p>
<p>让我们回到<code>objc_object::sidetable_addExtraRC_nolock</code>函数中。因为我们刚刚在 sidetable 索引表里面插入了 bucket，所以这里 oldRefcnt 的值 为 0。<br>接下来会对 oldRefcnt 进行校验，这说明 oldRefcnt 并没有把所有的 bit 都用来保存引用计数。</p>
<ul>
<li>低 1 位(从低位往高位数第一位)用来标记是否是弱引用</li>
<li>低 2 位用来标记该变量是否在析构 </li>
<li>高 1 位(从高位往低位数第一位)用来标记保存的引用计数是否已经溢出。</li>
</ul>
<p>下面的代码我们好像看到过了，对，在将引用计数保存在 isa 指针那里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t carry;</span><br><span class="line">size_t newRefcnt = </span><br><span class="line">    addc(oldRefcnt, delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT, 0, &amp;carry);</span><br><span class="line">if (carry) &#123;</span><br><span class="line">    refcntStorage =</span><br><span class="line">        SIDE_TABLE_RC_PINNED | (oldRefcnt &amp; SIDE_TABLE_FLAG_MASK);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    refcntStorage = newRefcnt;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这几句的代码的作用是将  newRefcnt &#x3D; oldRefcnt + delta_rc，如果值太大了溢出了则将 carry 赋值为1，并将 refcntStorage 的高1位赋值为1，并返回true。如果没有溢出的话则将 newRefcnt 赋值到 refcntStorage，并返回 false。</p>
<p>到这里，我们探究了当引用计数增加时，如何保存多余的引用计数。简单的归纳下：</p>
<ul>
<li>有一个静态全局变量 SideTablesMap，实际上是 StripedMap<SideTable> 的实例。以便于在程序初始化的时候就能用到</li>
<li>变量 SideTablesMap 里面有一个长度为 8，类型为 SideTable 的数组成员<code>array</code>，每个元素占用的内存为64(spinlock_t内存4， RefcountMap内存24，weak_table_t内存32)。在保存引用计数的时候，根据指针地址来计算出相应 SideTable 的 index。</li>
<li>获取到相应的 SideTable 后，根据指针地址计算出相应的哈希值，然后查找 bucket。如果 bucket 不存在，则使用空 bucket 或者 墓碑 bucket。如果 bucket 的数量不够则扩容。将指针为 key 和 引用计数 为 value 保存到 bucket 当中。</li>
</ul>
<p>注意：当一个对象创建后它的引用计数为 1，但是 isa 指针里的引用计数还是 0。因为初始化的时候并没有对引用计数进行操作。</p>
<h3 id="减少引用计数"><a href="#减少引用计数" class="headerlink" title="减少引用计数"></a>减少引用计数</h3><p>这里我们只讨论有额外引用计数存储在 sidetable，且 isa 指针里面存储的引用计数为 0 时的临界情况。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void aoo(void) &#123;</span><br><span class="line">    NSObject *o1 = [[NSObject alloc] init];</span><br><span class="line">    for (int i = 0; i &lt; 512; i++) &#123;</span><br><span class="line">        _objc_rootRetain(o1);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; 129; i++) &#123;</span><br><span class="line">        if (i == 128) &#123;</span><br><span class="line">            int a = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        _objc_rootRelease(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在代码<code>int a = 1;</code>处打个断点，此时 isa 保存的引用计数为 0。一直 step over，直到跳转到<code>objc_object::rootRelease(bool performDealloc, bool handleUnderflow)</code>函数。</p>
<p><img src="https://i.loli.net/2020/05/13/turvFcU5IZGkP1b.jpg"><br><img src="https://i.loli.net/2020/05/13/AoLIWTViEd748xq.jpg"></p>
<p>一直点击 step over，直到停在<code>newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry);</code>那一行<br><img src="https://i.loli.net/2020/05/13/Ceoih1Q2jDKfuSs.jpg"></p>
<p>用调试命令打印看一下此时 isa 指针里面的内容</p>
<p><img src="https://i.loli.net/2020/05/13/2iEFlJGR5UpIMQr.jpg"></p>
<p>因为使用的是模拟器，所以 isa 里面只有最高的 8 个bit用来保存引用计数，之前我们减少它的引用计数 128。所以此时它 isa 指针里面保存的引用计数为 0。调试输出结果<code>extra_rc</code>也为0，符合预期(0b是二进制符号)</p>
<p>接下来系统要将引用保存在 isa 指针的引用计数 -1，并判断是否溢流。此刻它的引用计数已经为 0 了，那么对它进行 -1 操作会发生什么呢？我们接着调试，点击 step over</p>
<p><img src="https://i.loli.net/2020/05/13/HbF41O3NWoDEYVj.jpg"><br>可以看到变量<code>carry</code> &#x3D;&#x3D; 1，表示出现溢流。让我们再看一下 isa 指针里面发生了什么。</p>
<p><img src="https://i.loli.net/2020/05/13/paOHdgJVhnSu8wb.jpg"><br>我们可以看到保存引用计数的 8 个 bit 都变成了 1，这其实就是 -1 在无符号整数中的表现形式，不懂的同学可以去了解一下补码。</p>
<p>接着一直 step over，我们可以看到因为溢流所以跳转到了<code>underflow</code>部分。一直 step over 直到跳转到如下的位置</p>
<p><img src="https://i.loli.net/2020/05/13/BgOwLK4MUATkHPW.jpg"></p>
<p><code>rootRelease_underflow</code>最终调用的还是<code>objc_object::rootRelease()</code>函数，只不过参数 handleUnderflow 变成了 YES。<br>进入该函数后，又会执行之前的那些代码，过程也是一样的，就不重复说了。接下来会来到这个位置</p>
<p><img src="https://i.loli.net/2020/05/13/2dtp15ZBOQ6xefN.jpg"></p>
<p>是的，因为没上锁，所以又会回到<code>retry</code>部分的代码。注释里写着是因为</p>
<blockquote>
<p>Need to start over to avoid a race against the nonpointer -&gt; raw pointer transition.</p>
</blockquote>
<p>不是很明白，但是过了。继续 step over</p>
<p><img src="https://i.loli.net/2020/05/13/n6PAYWwuTN9kirV.jpg"></p>
<p>之前引用计数溢出时，我们将<code>RC_HALF</code>数目的引用计数存储到了<code>sidetable</code>当中，此时因为溢流，所以我们从<code>sidetable</code>中取回同样数目的引用计数。 </p>
<p>step into 进入<code>objc_object::sidetable_subExtraRC_nolock()</code>函数</p>
<p><img src="https://i.loli.net/2020/05/13/9H2gtCbzZih6avs.jpg"></p>
<p>在最开始的代码中,我们增加了变量<code>o1</code> 512 的引用计数, 在 isa 指针中保存了 128, 还剩余 384. 但是因为最低两位没有用来保存数据, 所以在 bucket 中存储的数字应该是 384 &lt;&lt; 2, 即 1536, 符合预期</p>
<p>接下来的代码作用就是判断保存在 bucket 中的引用计数是否合理, 如何合理的话则将原有的数据减去<code>RC_HALF</code>并重新保存. 点击 step out 返回之前的函数</p>
<p><img src="https://i.loli.net/2020/05/13/jkhWHiRPa2LTmzX.jpg"></p>
<ul>
<li>代码块1的作用是将从 sidetable 取回了保存着的一部分引用计数, -1 保存到 isa 指针里面</li>
<li>如果代码块1保存失败, 则用代码块2重新保存一次</li>
<li>如果代码块2保存失败了, 则将从 sidetable 取出的引用计数重新放回去. 然后又跳回到 retry 部分</li>
<li>保存成功则解锁, 并返回 false. 返回 true 表示这个对象需要 dealloc 了</li>
</ul>
<p>另一种情况, 如果一个对象 isa 引用计数为 0, 且没有额外的引用计数. 那么它从 sidetable ‘借来的’  borrowed 为 0, 那么会将 isa 的 deallocating 赋值为 1, 并随后对其发送 delloc 消息进行内存消耗</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>以上就是此次对引用计数的探究, 欢迎留言告诉我错的或者不明白的地方~</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/categories/iOS%E6%9D%82/page/0/">上一页</a></div><div class="pagination-next"><a href="/categories/iOS%E6%9D%82/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/categories/iOS%E6%9D%82/">1</a></li><li><a class="pagination-link" href="/categories/iOS%E6%9D%82/page/2/">2</a></li><li><a class="pagination-link" href="/categories/iOS%E6%9D%82/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="千行"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">千行</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>杭州, 浙江</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">33</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/bug/"><span class="level-start"><span class="level-item">bug</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/cocoapods/"><span class="level-start"><span class="level-item">cocoapods</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS%E6%9D%82/"><span class="level-start"><span class="level-item">iOS杂</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%90%AD%E5%BB%BA/"><span class="level-start"><span class="level-item">搭建</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/EventKit/"><span class="tag">EventKit</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GCD/"><span class="tag">GCD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NSError/"><span class="tag">NSError</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Runloop/"><span class="tag">Runloop</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tagged-Pointer/"><span class="tag">Tagged Pointer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/YTKNetwork/"><span class="tag">YTKNetwork</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/YYModel/"><span class="tag">YYModel</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/block/"><span class="tag">block</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dyld/"><span class="tag">dyld</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mach-o/"><span class="tag">mach-o</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/runtime/"><span class="tag">runtime</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/weak/"><span class="tag">weak</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/"><span class="tag">关联对象</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"><span class="tag">内存分布</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%A1%E6%A0%B8/"><span class="tag">审核</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%A5%E5%85%B7/"><span class="tag">工具</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"><span class="tag">引用计数</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82/"><span class="tag">杂</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%BA%90%E7%A0%81/"><span class="tag">源码</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%94%81/"><span class="tag">锁</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="千行的博客" height="28"></a><p class="is-size-7"><span>&copy; 2022 千行</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>