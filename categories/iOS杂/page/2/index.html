<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: iOS杂 - 千行的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="千行的博客"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="千行的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="千行的博客"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="千行的博客"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="千行"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"千行的博客","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"千行"},"publisher":{"@type":"Organization","name":"千行的博客","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-0VD5EHM46E" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-0VD5EHM46E');</script><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="千行的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">iOS杂</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-04-02T13:08:22.000Z" title="4/2/2020, 9:08:22 PM">2020-04-02</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">12 分钟读完 (大约1872个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/02/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Tagged-Pointer/">深入了解Tagged Pointer</a></h1><div class="content"><p><code>objc</code> 源码版本：<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/objc4/">779.1</a><br>当然还是推荐使用这个来学习：<a target="_blank" rel="noopener" href="https://github.com/LGCooci/objc_debug/tree/master">可编译的源码</a></p>
<p>在 2013 年苹果推出了首个使用 64 位架构的双核处理器的手机 iphone 5s。为了节约内存以及提高执行效率，苹果使用了一种叫做 ‘Tagged Pointer’ 的技术，现在跟着我来了解一下它吧。</p>
<h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h3><p>从 5s 开始，iPhone 均使用 arm64 指令集的处理器。在 64 位系统上，一个指针占 8 个字节，而指针指向的实例变量至少需要 16 个字节，并且还需要执行额外的一些操作，例如：申请内存，销毁内存。为了达到优化的目的，苹果将一些存储数据的类，例如 NSString，NSNumber，当它们需要保存的数据不需要占用那么多的字节时，直接将数据保存在“指针”里面。</p>
<p>下面让我们用代码来证实<code>Tagged Pointer</code>的存在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSNumber *a = [NSNumber numberWithInt:1];</span><br></pre></td></tr></table></figure>

<p>然后打个断点，使用 lldb 的命令调试，<code>x/8xg a</code>，该命令的意思是从a的起始地址开始，打印 8 个 16进制的 8字节长度的值<br>输出结果</p>
<p><img src="https://i.loli.net/2020/05/13/UDcHTtGa3iBZ9QM.jpg"></p>
<p>说明指针 a 并不是指向 NSNumber 实例的指针。</p>
<p>或者下面这样更加直观一点</p>
<p><img src="https://i.loli.net/2020/05/13/cEUe3thCQ1L5mlX.jpg"></p>
<p>可以看到 a 并没有 isa 指针，所以它并不是一个 NSNumber 实例指针。</p>
<h3 id="Tagged-Pointer-如何存储数据"><a href="#Tagged-Pointer-如何存储数据" class="headerlink" title="Tagged Pointer 如何存储数据"></a>Tagged Pointer 如何存储数据</h3><p>这里你最好打开源码对照着看。</p>
<h4 id="LSB"><a href="#LSB" class="headerlink" title="LSB"></a>LSB</h4><p>在非 arm64 架构中，将最低位即 LSB 设置为 1，与正常的指针进行区分。<br>这样做的原因是，OC 类在创建实例最终调用的是 C 标准库中的 calloc 函数，它所返回的内存地址是 16 字节对齐的，参考 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/5061392/aligned-memory-management/5061435#5061435">Aligned memory management?</a>。这样的结果就是指针地址低 4 位都是 0，用最低位来表示也合理的</p>
<p><img src="https://image-static.segmentfault.com/181/831/1818316709-5b52534856049_articlex" alt="非 arm64 架构下标记位的设定"></p>
<h4 id="MSB"><a href="#MSB" class="headerlink" title="MSB"></a>MSB</h4><p>在 arm64 架构中，将最高位即 MSB 设置为 1，与正常的指针进行区分。<br>这样做的原因的是因为在 arm64 架构中，指针只用了低位的 48 位，高 16 位都是空着的，原因可以看下这个 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28638698">为什么64位机指针只用48个位?</a></p>
<p>在 <code>objc-internal.h</code> 372 行以及 384 行，我们 我们可以看到掩码 _OBJC_TAG_MASK 的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if OBJC_MSB_TAGGED_POINTERS</span><br><span class="line">#   define _OBJC_TAG_MASK (1UL&lt;&lt;63)</span><br><span class="line">#   define _OBJC_TAG_INDEX_SHIFT 60</span><br><span class="line">#else</span><br><span class="line">#   define _OBJC_TAG_MASK 1UL</span><br><span class="line">#   define _OBJC_TAG_INDEX_SHIFT 1</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h4 id="内置类型和扩展类型"><a href="#内置类型和扩展类型" class="headerlink" title="内置类型和扩展类型"></a>内置类型和扩展类型</h4><p>系统启动时生成两个全局的数组 objc_debug_taggedpointer_classes 和 objc_debug_taggedpointer_ext_classes。一个用来存储系统内置的<code>Tagged Pointer</code>类型，而另一个数组存储扩展的<code>Tagged Pointer</code>类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; &#123; </span><br><span class="line">    extern Class objc_debug_taggedpointer_classes[_OBJC_TAG_SLOT_COUNT];</span><br><span class="line">    extern Class objc_debug_taggedpointer_ext_classes[_OBJC_TAG_EXT_SLOT_COUNT];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>内置类型数组的数目为 8，使用高 2 - 高 4 的 3 个 bit 来存储数据  </li>
<li>扩展类型数组的数目为 256，，使用高 5 - 高 12 的 8 个 bit 来存储数据</li>
</ul>
<p>是否剩余的 bit 都用来保存数据了呢？答案是否定的，拿 NSUmber 举个例子，它属于内置类型，其 tagged pointer 额外使用 低 1 - 低 4 的 5 个 bit 用来保存数字的类型信息，即使用 56 个 bit 来保存数据。</p>
<p>内置类型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">    // 60-bit payloads</span><br><span class="line">    OBJC_TAG_NSAtom            = 0, </span><br><span class="line">    OBJC_TAG_1                 = 1, </span><br><span class="line">    OBJC_TAG_NSString          = 2, </span><br><span class="line">    OBJC_TAG_NSNumber          = 3, </span><br><span class="line">    OBJC_TAG_NSIndexPath       = 4, </span><br><span class="line">    OBJC_TAG_NSManagedObjectID = 5, </span><br><span class="line">    OBJC_TAG_NSDate            = 6,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而当指针的高 1 - 高 4 的 4 个 bit 位均为 1 时，表示这是一个扩展类型。系统自带的扩展类型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">	// ...</span><br><span class="line">	// 52-bit payloads</span><br><span class="line">    OBJC_TAG_Photos_1          = 8,</span><br><span class="line">    OBJC_TAG_Photos_2          = 9,</span><br><span class="line">    OBJC_TAG_Photos_3          = 10,</span><br><span class="line">    OBJC_TAG_Photos_4          = 11,</span><br><span class="line">    OBJC_TAG_XPC_1             = 12,</span><br><span class="line">    OBJC_TAG_XPC_2             = 13,</span><br><span class="line">    OBJC_TAG_XPC_3             = 14,</span><br><span class="line">    OBJC_TAG_XPC_4             = 15,</span><br><span class="line">    OBJC_TAG_NSColor           = 16,</span><br><span class="line">    OBJC_TAG_UIColor           = 17,</span><br><span class="line">    OBJC_TAG_CGColor           = 18,</span><br><span class="line">    OBJC_TAG_NSIndexSet        = 19,</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据混淆"><a href="#数据混淆" class="headerlink" title="数据混淆"></a>数据混淆</h4><p>运行下面的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)boo</span><br><span class="line">&#123;</span><br><span class="line">    NSNumber *a = [NSNumber numberWithInt:1];</span><br><span class="line">    NSNumber *b = [NSNumber numberWithInt:2];</span><br><span class="line">    NSNumber *c = [NSNumber numberWithInt:16];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;pointer a is %lx&quot;, a);</span><br><span class="line">    NSLog(@&quot;pointer b is %lx&quot;, b);</span><br><span class="line">    NSLog(@&quot;pointer c is %lx&quot;, c);</span><br><span class="line">    NSLog(@&quot;pointer d is %lx&quot;, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pointer a is ef59c3d36981ed4b</span><br><span class="line">pointer b is ef59c3d36981ed7b</span><br><span class="line">pointer c is ef59c3d36981ec5b</span><br></pre></td></tr></table></figure>

<p>等等，不是说 <code>Tagged Pointer</code> 最高 4 位用来保存类型信息，剩下的几位都只用来保存数据嘛，为什么输出结果看起来这么复杂呢？<br>原因是从 iOS12 开始，为了系统安全，将数据与一个随机数进行 异或(^) 操作进行混淆，混淆函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static inline void * _Nonnull</span><br><span class="line">_objc_encodeTaggedPointer(uintptr_t ptr)</span><br><span class="line">&#123;</span><br><span class="line">    return (void *)(objc_debug_taggedpointer_obfuscator ^ ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>objc_debug_taggedpointer_obfuscator</code>是一个extern关键字的常量，因为被 extern 声明，所以我们可以用下面的代码来解码，得到真正的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">extern uintptr_t objc_debug_taggedpointer_obfuscator;</span><br><span class="line"></span><br><span class="line">- (void)foo</span><br><span class="line">&#123;</span><br><span class="line">    NSNumber *a = [NSNumber numberWithInt:1];</span><br><span class="line">    NSNumber *b = [NSNumber numberWithInt:2];</span><br><span class="line">    NSNumber *c = [NSNumber numberWithInt:16];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;pointer a real value is %lx&quot;, ((uintptr_t)a ^ objc_debug_taggedpointer_obfuscator));</span><br><span class="line">    NSLog(@&quot;pointer b real value is %lx&quot;, ((uintptr_t)b ^ objc_debug_taggedpointer_obfuscator));</span><br><span class="line">    NSLog(@&quot;pointer c real value is %lx&quot;, ((uintptr_t)c ^ objc_debug_taggedpointer_obfuscator));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pointer a real value is b000000000000012</span><br><span class="line">pointer b real value is b000000000000022</span><br><span class="line">pointer c real value is b000000000000102</span><br></pre></td></tr></table></figure>

<p>从输出结果可以看出，这几个值都是 0Xb 开头，16进制的 b 用 二级制表示为 1011，最高1用来表示这是一个 <code>Tagged Pointer</code>，而剩余 3 位的10进制数为 3，符合之前的定义<code>OBJC_TAG_NSNumber = 3</code>。<br>至于为什么结尾都是 0x2，这个后面再解释。<br>下面让我们测试下 NSNumber 的 Tagged Pointer 使用多少位来保存数据。从之前的探究我们知道内置类型用 60 位来保存数据，而经过上面的实验我们可以看到还有 4 位用来做别的事了，那么是否剩余的 56 位都用来保存数据了呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)foo</span><br><span class="line">&#123;</span><br><span class="line">    NSNumber *d = [NSNumber numberWithLongLong:-0x7FFFFFFFFFFFFF];</span><br><span class="line">    NSLog(@&quot;pointer a real value is %lx&quot;, ((uintptr_t)d ^ objc_debug_taggedpointer_obfuscator));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer d real value is b800000000000013</span><br></pre></td></tr></table></figure>

<p>结果符合预期。至于为什么最高位 b 后面的数字是 8，是因为高位 5 的位置变成了 1，用来表示这个数是负数(0则表示正数), 而 7 的二进制表示为 ob111，高位 5-8 连起来就是 0b1111，也就是16进制的 8 了。<br>还一个值得注意的是低位第一位的数字变成了 3，而不是之前的正整数 2，由此我们可以推测最低位的 4 位是用来表示存储数据类型的数据，例如 int,float,bool 这几个类型生成的 <code>Tagged Pointer</code> 最低4位数字应该是不同的。用下面的代表再来验证下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSNumber *a = [NSNumber numberWithInt:1];</span><br><span class="line">NSNumber *b = [NSNumber numberWithShort:2];</span><br><span class="line">NSNumber *c = [NSNumber numberWithFloat:1.];</span><br><span class="line">NSNumber *d = [NSNumber numberWithLongLong:-0x7FFFFFFFFFFFFF];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;pointer a real value is %lx&quot;, ((uintptr_t)a ^ objc_debug_taggedpointer_obfuscator));</span><br><span class="line">NSLog(@&quot;pointer b real value is %lx&quot;, ((uintptr_t)b ^ objc_debug_taggedpointer_obfuscator));</span><br><span class="line">NSLog(@&quot;pointer c real value is %lx&quot;, ((uintptr_t)c ^ objc_debug_taggedpointer_obfuscator));</span><br><span class="line">NSLog(@&quot;pointer d real value is %lx&quot;, ((uintptr_t)d ^ objc_debug_taggedpointer_obfuscator));</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pointer a real value is b000000000000012</span><br><span class="line">pointer b real value is b000000000000021</span><br><span class="line">pointer c real value is b000000000000014</span><br><span class="line">pointer d real value is b800000000000013</span><br></pre></td></tr></table></figure>

<p>结果符合预期，说明我们的推测是正确的</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34100227/article/details/88772219">NSNumber 与 Tagged Pointer</a><br><a target="_blank" rel="noopener" href="https://toutiao.io/posts/v071dp/preview">深入解构 objc_msgSend 函数的实现</a></p>
<p>希望大家看了有所收获吧。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-08-23T08:13:36.000Z" title="8/23/2019, 4:13:36 PM">2019-08-23</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">1 小时读完 (大约10849个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/08/23/iOS%E7%9A%84%E9%94%81%E4%BB%A5%E5%8F%8AGCD%E7%9B%B8%E5%85%B3/">iOS的锁以及GCD相关</a></h1><div class="content"><p>这段时间的研究内容的是<code>锁</code>，因为实际开发中用到的比较少，文中难免会有错误，希望能够多多指正。<br>这篇博客的第一部分是一些计算机的基础知识，然后介绍一些常见的锁以及它们的工作原理，最后部分是 GCD 相关的一些内容。</p>
<!--补充使用场景-->

<h2 id="一些基础知识"><a href="#一些基础知识" class="headerlink" title="一些基础知识"></a>一些基础知识</h2><p>下面是一些计算机知识，比较枯燥。你可以跳过这一部分，直接看后面的内容，等看到一些不懂的概念的时候再跳回来看这部分内容。</p>
<h3 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h3><p><code>时间片</code>又称为“量子”或者“处理器片”，是分时操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。现代操作系统(例如 Windows，Mac OS X)允许同时运行多个进程。例如，在打开音乐播放器的同时用浏览器浏览网页并下载文件。由于有些计算机只有一个CPU，所以不可能真正地同时运行多个任务。这些进程“看起来像”同时运行，实则是轮番运行，由于时间片通常很短（在Linux上为5ms－800ms），用户不会感觉到。</p>
<p>时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。<br>通常状况下，一个系统所有的进程被分配到的时间片长短并不相等，尽管初始时间片基本相等，系统通过测量进程的<code>阻塞</code>和<code>执行</code>状态的时间长短来计算每个进程的交互性。交互性和每个进程预设的静态优先级(Nice值)的叠加即是动态优先级，动态优先级按比例缩放就是要分配给那个进程时间片的长短。一般的，为了获得较快的响应速度，交互性强的进程(即趋向于IO消耗型)被分配到的时间片要长于交互性弱的进程。</p>
<h3 id="进程基本状态"><a href="#进程基本状态" class="headerlink" title="进程基本状态"></a>进程基本状态</h3><p>进程有以下几种状态：</p>
<ul>
<li>new：创建状态。进程正在被创建，仅仅在堆上分配内存，尚未进入就绪态</li>
<li>ready：就绪态。进程已处于准备运行的状态，即进程已获得除了 CPU 之外的所需资源，一旦分配到 CPU 时间片即可进入运行状态</li>
<li>run：运行态。进程正在运行，占用 CPU 资源，执行代码。任意时间点，处于运行状态的进程(线程)的总数，不会超过 CPU 的总核数</li>
<li>wait：阻塞态。进程处于等待某一事件而放弃 CPU，暂停运行。阻塞状态分3种：<ul>
<li>阻塞在对象等待池：当进程在运行时执行<code>wait()</code>方法，将线程放入等待池</li>
<li>阻塞在对象锁池：当对象在运行时企图获取已经被其它进程占用的同步锁时，会把线程放入锁池</li>
<li>其它阻塞状态：当进程在运行时执行<code>sleep()</code>方法，或调用其它进程的<code>join()</code>方法，或发出I&#x2F;O请求时，进入阻塞状态</li>
</ul>
</li>
<li>dead：死亡态。进程正在被结束，这可能是进程正常结束或其它原因中断运行。进程结束运行前，系统必须置进程为dead态，再处理资源释放和回收等工作</li>
</ul>
<p>在特定的情况下，这三种状态可以相互转换</p>
<ol>
<li>ready -&gt; run: 就绪态的进程获得 CPU 时间片，进入运行态</li>
<li>run -&gt; ready: 运行态的进程在时间片用完后，必须出让 CPU，进入就绪态</li>
<li>run -&gt; wait: 当进程请求资源的使用权或等待事件发生(如I&#x2F;O完成)时，由运行态转换为阻塞态</li>
<li>wait -&gt; ready: 当进程已经获取所需资源的使用权或者等待时间已完成时，中断处理程序必须把相应进程的状态由阻塞态转为就绪态</li>
</ol>
<p><img src="https://i.loli.net/2019/08/20/KhMZ3FiBgp7NxAW.jpg" alt="状态转移"></p>
<h3 id="进程以及线程的关系"><a href="#进程以及线程的关系" class="headerlink" title="进程以及线程的关系"></a>进程以及线程的关系</h3><blockquote>
<p>进程是资源分配的最小单位</p>
</blockquote>
<p><code>进程（Process)</code>是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。<br>每个进程都占用一个<code>进程表项</code>，该表项包含了操作系统对进程进行描述和控制的全部信息，包括程序计数器，堆栈指针，内存分配状况，打开文件的状态，账号和调度信息</p>
<blockquote>
<p>线程是”轻量级的进程“，是 CPU 调度的最小单位</p>
</blockquote>
<p>一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。就绪状态是指线程具备运行的所有条件，逻辑上可以运行，在等待处理机；运行状态是指线程占有处理机正在运行；阻塞状态是指线程在等待一个事件（如某个信号量），逻辑上不可执行。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。<br>线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。</p>
<hr>
<p>进程和线程的区别有以下几点：</p>
<ol>
<li>调度：在多线程os中，线程是调度和分配的基本单位，进程是资源分配的最小单位。在同一进程中，线程的切换不会引起进程的切换。线程上下文切换比进程上下文切换要快很多</li>
<li>资源：进程是拥有资源的一个基本单位，他可以拥有自己的资源，一般地说，线程不拥有系统资源(只有一些必不可少的资源)，但它可以访问其隶属进程的资源</li>
<li>系统开销：在创建和销毁进程时，系统都要为之分配和回收资源，因此，操作系统所付出的开销显著的大于创建或销毁线程的开销</li>
<li>通信：进程间通信IPC，线程间可以直接读写进程数据段(如全局变量)来进行通信</li>
<li>在多线程os中，进程不是一个可执行的实体</li>
</ol>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>数据共享、同步</td>
<td>数据共享复杂，需要用IPC；数据是分开的，同步简单</td>
<td>因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂</td>
</tr>
<tr>
<td>内存、CPU</td>
<td>占用内存多，切换复杂，CPU利用率低</td>
<td>内存占用少，切换简单，CPU利用率高</td>
</tr>
<tr>
<td>创建销毁、切换</td>
<td>创建销毁、切换复杂，速度慢</td>
<td>创建销毁、切换简单，速度很快</td>
</tr>
<tr>
<td>编程、调试</td>
<td>编程简单，调试简单</td>
<td>编程复杂，调试复杂</td>
</tr>
<tr>
<td>可靠性</td>
<td>进程间不会互相影响</td>
<td>线程可能会引起进程异常</td>
</tr>
<tr>
<td>分布式</td>
<td>适用于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td>
<td>适用于多核分布式</td>
</tr>
</tbody></table>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表(Hash table, 也叫散列表)，是根据 key 而直接访问在内存存储位置的数据结构。哈希表本质是一个数组， 通过哈希函数(散列函数)将 key 转换成 index，根据 index 在数组中找到相应的数据。<br>举个例子：为了在电话本中查找某人的号码，可以创建一个按照人名首字母顺序排列的表，在首字母为“W”的表中查找“王”姓的电话号码，显然比直接查找就要快的多。这里使用人名作为 key，“取首字母“就是这个例子中的哈希函数 F()，存放首字母的表对应哈希表。</p>
<p>不管哈希函数设计的如何完美，都可能出现不同的 key 经过哈希函数处理后得到相同的 hash 值。解决哈希冲突的方法，常见的有下面两种：</p>
<ul>
<li>开放定址法：使用两个大小为N的数组(一个存放keys，一个存放values)。使用数组中的空位解决碰撞，当碰撞发生时，直接 hash 值+1，如果此时对应下标的位置仍被占用，则 hash 值继续+1；如果位置为空，则将 key 存放在此位置中。举个例子：<br>将关键字为{89, 18, 49, 48, 69}插入到一个散列表中。假定取关键字除以10的余数为哈希函数法则。</li>
</ul>
<table>
<thead>
<tr>
<th>散列地址</th>
<th>空表</th>
<th>插入89</th>
<th>插入18</th>
<th>插入49</th>
<th>插入58</th>
<th>插入69</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td>49</td>
<td>49</td>
<td>49</td>
</tr>
<tr>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>58</td>
<td>58</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>69</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td></td>
<td></td>
<td>18</td>
<td>18</td>
<td>18</td>
<td>18</td>
</tr>
<tr>
<td>9</td>
<td></td>
<td>89</td>
<td>89</td>
<td>89</td>
<td>89</td>
<td>89</td>
</tr>
</tbody></table>
<p>第一次冲突发生在填装49的时候。地址为9的单元已经填装了89这个关键字，所以取49的哈希值并+1，得到10，也就是0，发现该地址为空，所以将49填装在地址为0的空单元。第二次冲突则发生在58上，取哈希值为8，因为位置9和0都已经占用，往下查找3个单位，将58填装在地址为1的空单元。69同理。</p>
<ul>
<li>拉链法：将哈希表同一个存储位置的所有元素保存在一个链表中。实现时，一种策略是散列表同一位置的所有冲突结果都是用栈存放的，即新元素被插入到链表头中。简单讲就是<code>数组+链表</code></li>
</ul>
<p>iOS 关联对象及 weak 对象均以该方法储存。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子指化学反应中的基本为例，原子在化学反应中不可分割。<br>计算机中所谓原子性是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何的上下文切换(context switch)。</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界区指的是一个访问共享资源的代码片段，并非一种机制或是算法。一个程序可以拥有多个临界区域。<br>当有一个线程在访问临界区，那么其它线程将被挂起。临界区被释放后，其它线程可继续抢占该临界区</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>在计算机科学中，锁是一种同步机制，用于限制多线程环境中对临界区的访问，你可以理解锁是用于排除并发的一种的策略。<br>但如果使用不当，可能会引起死锁，锁封护(lock convoying，多个同优先级的线程重复竞争同一把锁，此时大量虽然被唤醒而得不到锁的线程被迫进行调度切换)等不良影响。</p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁是一种用于多线程编程中，防止两条线程同时对同一公共资源(比如全局变量)进行读写的机制。<br>互斥锁是排它的，当锁被某个线程获取之后，其它访问临界区的线程进入阻塞态。只有当获取了锁的线程释放这个锁，被阻塞的线程才会被唤醒进入运行态。</p>
<p>举个例子：一段代码（甲）正在分步修改一块数据。这时，另一条线程（乙）由于一些原因被唤醒。如果乙此时去读取甲正在修改的数据，而甲碰巧还没有完成整个修改过程，这个时候这块数据的状态就处在极大的不确定状态中，读取到的数据当然也是有问题的。更严重的情况是乙也往这块地方写数据，这样的一来，后果将变得不可收拾。因此，多个线程间共享的数据必须被保护。达到这个目的的方法，就是确保同一时间只有一个临界区域处于运行状态，而其他的临界区域，无论是读是写，都必须被挂起并且不能获得运行机会。</p>
<p>互斥锁在申请锁时，调用了<code>pthread_mutex_lock</code>方法，它在不同的系统上实现各有不同，有时候它的内部是使用信号量来实现，即使不用信号量，也会调用到<code>lll_futex_wait</code>函数，从而导致线程休眠。<br>上文说到如果临界区很短，忙等的效率也许更高，所以在有些版本的实现中，会首先尝试一定次数(比如 1000 次)的 test-and-test，这样可以在错误使用互斥锁时提高性能。<br>另外，由于<code>pthread_mutex</code>有多种类型，可以支持递归锁等，因此在申请加锁时，需要对锁的类型加以判断，这也就是为什么它和信号量的实现类似，但效率略低的原因。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h3><p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@synchronized (obj) &#123;</span><br><span class="line">	// do something...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@synchronized(id obj)</code>关键字锁，使用的时候需要添加一个OC对象。在很多情况下，@synchronized 的可读性更高，使用更方便。<br>开始的时候，我一直不敢用这个锁。因为我不知道 obj 需要什么样子的变量才可以，局部变量有用吗，还是一定需要全局变量什么的？<br>但是看了<a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/">关于 @synchronized，这儿比你想知道的还要多</a>这篇博客之后，理解了它的实现原理，才明白，obj只要是个oc对象就行，当然，在实际使用的时候，你输入的这个对象最好不可以被外界所修改。</p>
<p>现在简单讲解一下<a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/">关于 @synchronized，这儿比你想知道的还要多</a>这篇博客里面 @synchronized 的工作原理：</p>
<p>@synchronized 使用哈希链表的方式存储锁<code>SyncData</code>。SyncData 是链表上的元素，每个<code>SyncData</code>都有一个递归互斥锁<code>recursive_mutex_t mutex</code>，一个<code>id object</code>(传入的obj)，一个<code>int threadCount</code>(使用或等待的线程数量，等于0代表这个锁可以被复用)以及下一个节点<code>struct SyncData* nextData</code>。结构体<code>SyncList</code>的成员变量<code>SyncData *data</code>用来记录链表上的头节点，<code>spinlock_t lock</code>用来防止多线程并发对链表进行修改</p>
<p>当你调用 @synchronized(obj) 时，首先会根据 obj 的内存地址计算出其哈希值，然后在哈希表上找到相应的<code>SyncList</code>实例，接下来根据 obj 来查找有没有未被使用(threadCount &#x3D;&#x3D; 0)的<code>SyncData</code>实例，如果有则使用这个锁；如果没有则新建一个<code>SyncData</code>锁实例，将锁插入到链表的<code>SyncList</code>的头结点中(这样查找会快一点，因为新建的锁往往使用的频繁一点)。上面的查找和新建过程都是加锁的，结束后解锁。</p>
<p>使用时可能有两种特殊情况</p>
<ul>
<li><p>输入 nil<br>此时 @synchronized 不起作用，即锁不生效</p>
</li>
<li><p>输入的 obj 在 @synchronized 的 block 里面被释放掉了<br>对 @synchronized 的使用没有影响。你可以使用<code>clang -rewrite-objc xx.m</code>将代码转换成 C++ 实现</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 代码</span><br><span class="line">- (void)foo &#123;</span><br><span class="line">    NSObject *object = [NSObject new];</span><br><span class="line">    @synchronized (object) &#123;</span><br><span class="line">        NSLog(@&quot;测试@synchronized&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// c++实现</span><br><span class="line">static void _I_MyObject_foo(MyObject * self, SEL _cmd) &#123;</span><br><span class="line">    NSObject *object = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;new&quot;));</span><br><span class="line"></span><br><span class="line">    &#123; id _rethrow = 0; id _sync_obj = (id)object; objc_sync_enter(_sync_obj);</span><br><span class="line">try &#123;</span><br><span class="line">	struct _SYNC_EXIT &#123; _SYNC_EXIT(id arg) : sync_exit(arg) &#123;&#125;</span><br><span class="line">	~_SYNC_EXIT() &#123;objc_sync_exit(sync_exit);&#125;</span><br><span class="line">	id sync_exit;</span><br><span class="line">	&#125; _sync_exit(_sync_obj);</span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h0_ybj03b8d0mj52n8dx82v2br40000gn_T_MyObject_807aa3_mi_1);</span><br><span class="line">    &#125; catch (id e) &#123;_rethrow = e;&#125;</span><br><span class="line">&#123; struct _FIN &#123; _FIN(id reth) : rethrow(reth) &#123;&#125;</span><br><span class="line">	~_FIN() &#123; if (rethrow) objc_exception_throw(rethrow); &#125;</span><br><span class="line">	id rethrow;</span><br><span class="line">	&#125; _fin_force_rethow(_rethrow);&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这几行代码<code>id _rethrow = 0; id _sync_obj = (id)object; objc_sync_enter(_sync_obj);</code>，在内部会将 obj 的值复制一份，所以即使你将 obj 置为 nil，还是能够正常使用。</p>
<h3 id="pthread-mutex"><a href="#pthread-mutex" class="headerlink" title="pthread_mutex"></a>pthread_mutex</h3><p>pthread_mutex 的常见用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_t attr;  </span><br><span class="line">pthread_mutexattr_init(&amp;attr);  </span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_NORMAL);  // 定义锁的属性</span><br><span class="line"></span><br><span class="line">pthread_mutex_t mutex;  </span><br><span class="line">pthread_mutex_init(&amp;mutex, &amp;attr) // 创建锁</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;mutex); // 申请锁  </span><br><span class="line">    // 临界区</span><br><span class="line">pthread_mutex_unlock(&amp;mutex); // 释放锁  </span><br></pre></td></tr></table></figure>

<p>对于 pthread_mutex 来说，它的用法和之前没有太大的改变，比较重要的是锁的类型，可以有<code>PTHREAD_MUTEX_NORMAL</code>、<code>PTHREAD_MUTEX_ERRORCHECK</code>、<code>PTHREAD_MUTEX_RECURSIVE</code>等等，具体的特性就不做解释了，网上有很多相关资料。<br>一般情况下，一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃。假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。<br>然而这种情况经常会发生，比如某个函数申请了锁，在临界区内又递归调用了自己。辛运的是 pthread_mutex 支持递归锁，也就是允许一个线程递归的申请锁，只要把 attr 的类型改成 PTHREAD_MUTEX_RECURSIVE 即可。</p>
<h3 id="NSLock-和-NSRecursiveLock"><a href="#NSLock-和-NSRecursiveLock" class="headerlink" title="NSLock 和 NSRecursiveLock"></a>NSLock 和 NSRecursiveLock</h3><p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)foo &#123;</span><br><span class="line">	NSLock *lock = [NSLock new];</span><br><span class="line">	[lock lock];</span><br><span class="line">	// do something...</span><br><span class="line">	[lock unlock];</span><br><span class="line">    </span><br><span class="line">	NSRecursiveLock *recursiveLock = [NSRecursiveLock new];</span><br><span class="line">	[recursiveLock lock];</span><br><span class="line">	// do something...</span><br><span class="line">	[recursiveLock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NSLock 和 NSRecursiveLock 是 Objective-C 以对象的形式暴露给开发者的一种锁，它们的内部实现都是使用的<code>pthread_mutex</code>，属性为<code>PTHREAD_MUTEX_ERRORCHECK</code>，它会损失一定新能换来错误提示。理论上来说，NSLock 和 pthread_mutex 拥有相同的运行效率，实际由于封装的原因会略慢一点。由于有缓存存在，相差不会很多。</p>
<p>NSRecursiveLock 与 NSLock 的区别在于内部封装的 pthread_mutex_t 对象的类型不同，NSRecursiveLock 的类型为 PTHREAD_MUTEX_RECURSIVE。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁是计算机科学用于多线程同步的一种锁，线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。</p>
<p>自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。因此操作系统的实现在很多地方往往用自旋锁。Windows操作系统提供的轻型读写锁（SRW Lock）内部就用了自旋锁。显然，单核CPU不适于使用自旋锁，这里的单核CPU指的是单核单线程的CPU，因为，在同一时间只有一个线程是处在运行状态，假设运行线程A发现无法获取锁，只能等待解锁，但因为A自身不挂起，所以那个持有锁的线程B没有办法进入运行状态，只能等到操作系统分给A的时间片用完，才能有机会被调度。这种情况下使用自旋锁的代价很高。</p>
<p>获取、释放自旋锁，实际上是读写自旋锁的存储内存或寄存器。因此这种读写操作必须是原子的。通常用test-and-set(TLS 检查并设置)等原子操作来实现。</p>
<h3 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h3><p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;libkern/OSAtomic.h&gt;</span><br><span class="line"></span><br><span class="line">- (void)foo &#123;</span><br><span class="line">     __block OSSpinLock osLock = OS_SPINLOCK_INIT;</span><br><span class="line">    </span><br><span class="line">    // 线程1</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">        NSLog(@&quot;线程1 准备上锁&quot;);</span><br><span class="line">        OSSpinLockLock(&amp;osLock);</span><br><span class="line">        NSLog(@&quot;线程1&quot;);</span><br><span class="line">        OSSpinLockUnlock(&amp;osLock);</span><br><span class="line">        NSLog(@&quot;线程1 解锁完成&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    // 线程2</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), ^&#123;</span><br><span class="line">        NSLog(@&quot;线程2 准备上锁&quot;);</span><br><span class="line">        OSSpinLockLock(&amp;osLock);</span><br><span class="line">        NSLog(@&quot;线程2&quot;);</span><br><span class="line">        OSSpinLockUnlock(&amp;osLock);</span><br><span class="line">        NSLog(@&quot;线程2 解锁完成&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于使用<code>OSSpinLock</code>的使用中可能会出现优先级反转的问题，苹果在 iOS10 发布之后，将 OSSpinLock 比较为了 Deprecated，并且提供了新的 os_unfair_lock 作为代替。</p>
<blockquote>
<p>优先级翻转：有高优先级任务 a，低优先级任务 b，资源 y。b 获得锁并在访问 y，a 在等待。此时由于自旋锁，所以 a 处于忙等状态而占用大量 CPU，此时 b 无法获得时间片，而一直无法完成任务，释放掉锁。详细可以看这篇博客<a target="_blank" rel="noopener" href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/">不再安全的 OSSpinLock</a></p>
</blockquote>
<h3 id="os-unfair-lock"><a href="#os-unfair-lock" class="headerlink" title="os_unfair_lock"></a>os_unfair_lock</h3><p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;os/lock.h&gt;</span><br><span class="line"></span><br><span class="line">// 初始化</span><br><span class="line">os_unfair_lock_t lock;</span><br><span class="line">lock = &amp;(OS_UNFAIR_LOCK_INIT);</span><br><span class="line">// 加锁</span><br><span class="line">os_unfair_lock_lock(lock);</span><br><span class="line">// 临界区</span><br><span class="line">// 解锁</span><br><span class="line">os_unfair_lock_unlock(lock);</span><br></pre></td></tr></table></figure>

<h3 id="自旋锁和互斥锁的对比"><a href="#自旋锁和互斥锁的对比" class="headerlink" title="自旋锁和互斥锁的对比"></a>自旋锁和互斥锁的对比</h3><p>相同点：</p>
<ul>
<li>都能保证同一时间只有一个线程访问共享资源。都能保证线程安全</li>
</ul>
<p>不同点： </p>
<ul>
<li>互斥锁：如果共享数据已经有其他线程加锁了，线程会进入休眠状态等待锁。一旦被访问的资源被解锁，则等待资源的线程会被唤醒</li>
<li>自旋锁：如果共享数据已经有其他线程加锁了，线程会以死循环的方式等待锁，一旦被访问的资源被解锁，则等待资源的线程会立即执行</li>
<li>自旋锁的效率高于互斥锁，因为没有切换线程的消耗</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量（英语：semaphore）又称为信号标，是一个同步对象，用于保持在0至指定最大值之间的一个计数值。当线程完成一次对该 semaphore 对象的等待（wait）时，该计数值减一；当线程完成一次对 semaphore 对象的释放（release）时，计数值加一。当计数值为0，则线程等待该 semaphore 对象不再能成功直至该 semaphore 对象变成 signaled 状态。semaphore 对象的计数值大于0，为 signaled 状态；计数值等于0，为 nonsignaled 状态.</p>
<p>semaphore 对象适用于控制一个仅支持有限个用户的共享资源，是一种不需要使用忙碌等待（busy waiting）的方法。</p>
<p>信号量的概念是由荷兰计算机科学家艾兹赫尔·戴克斯特拉（Edsger W. Dijkstra）发明的，广泛的应用于不同的操作系统中。在系统中，给予每一个进程一个信号量，代表每个进程当前的状态，未得到控制权的进程会在特定地方被强迫停下来，等待可以继续进行的信号到来。如果信号量是一个任意的整数，通常被称为计数信号量（Counting semaphore），或一般信号量（general semaphore）；如果信号量只有二进制的0或1，称为二进制信号量（binary semaphore）。在linux系统中，二进制信号量（binary semaphore）又称互斥锁（Mutex）。</p>
<h3 id="dispatch-semaphore-t"><a href="#dispatch-semaphore-t" class="headerlink" title="dispatch_semaphore_t"></a>dispatch_semaphore_t</h3><p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个信号量5的锁</span><br><span class="line">dispatch_semaphore_t lock = dispatch_semaphore_create(5);</span><br><span class="line">// 如果信号量的值 &gt; 0，就让信号量的值减1，然后继续往下执行代码</span><br><span class="line">// 如果信号量的值 &lt;= 0，就会休眠等待，直到信号量的值变成&gt;0，就让信号量的值减1，然后继续往下执行代码</span><br><span class="line">dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">// 让信号量的值+1</span><br><span class="line">dispatch_semaphore_signal(lock);</span><br></pre></td></tr></table></figure>

<p>注意，正常的使用顺序是先降低(wait)然后再提高(signal)，这两个函数通常成对使用。</p>
<p>信号量是允许并发访问的，也就是说，允许多个线程同时执行多个任务。信号量可以由一个线程获取，然后由不同的线程释放。</p>
<p>在<code>dispatch_semaphore_wait()</code>函数中，第二个参数超时时间我们可以选择<code>DISPATCH_TIME_NOW</code>或者<code>DISPATCH_TIME_FOREVER</code>。根据这个值，信号量最终会表现为互斥或者自旋的方式实现，这也是为什么评测中信号量性能总是优于互斥低于自旋。虽然信号量的性能不是最优，但是这种结合方案保证了它的作用范围更大。</p>
<h3 id="条件锁"><a href="#条件锁" class="headerlink" title="条件锁"></a>条件锁</h3><p>在线程间的同步中，有这样一种情况：<br>线程 A 需要等条件 C 成立,才能继续往下执行.现在这个条件不成立，线程 A 就阻塞等待。而线程 B 在执行过程中，使条件 C 成立了，就唤醒线程 A 继续执行。<br>对于上述情况，可以使用条件变量来操作。</p>
<p>条件变量，类似信号量，提供线程阻塞与信号机制，可以用来阻塞某个线程，等待某个数据就绪后，随后唤醒线程。<br>一个条件变量总是和一个互斥量搭配使用。</p>
<h3 id="NSCodition"><a href="#NSCodition" class="headerlink" title="NSCodition"></a>NSCodition</h3><p>它通常用于表明共享资源是可被访问或者确保一系列任务能按照指定的执行顺序执行。如果一个线程视图访问一个共享资源，而正在访问该资源的线程将其条件设置为不可访问，那么该线程会被阻塞，直到正在访问该资源的线程将访问条件更改为可访问状态或者说给被阻塞的线程发送信号后，被阻塞的线程才能正常访问这个资源。</p>
<p>NSCondition 的底层是通过条件变量(condition variable) pthread_cond_t 来实现的。条件变量有点像信号量，提供了线程阻塞与信号机制，因此可以用来阻塞某个线程，并等待某个数据就绪，随后唤醒线程，比如常见的生产者-消费者模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSCondition *lock;</span><br><span class="line"></span><br><span class="line">- (void)customer &#123;</span><br><span class="line">	[_lock lock];</span><br><span class="line">    while (!data) &#123;</span><br><span class="line">        [lock wait];</span><br><span class="line">    &#125;</span><br><span class="line">    // 消费者消费数据</span><br><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)producer &#123;</span><br><span class="line">	[_lock lock];</span><br><span class="line">	// 生产数据</span><br><span class="line">	[_lock signal];</span><br><span class="line">	[_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NSCodition 可以给每个每个线程加锁，加锁后线程仍旧<code>能够进入临界区</code>。所以 NSCodition 使用 wait 并加锁之后，并不能真正的保证线程安全。当一个 broadcast 操作发出后，如果有两个线程都在做消费者操作，那同时都会消耗掉资源，可能会引发错误。所以我们在方法<code>customer</code>中，使用<code>while (!data)</code>来判断资源是否存在，而不是<code>if (!data)</code>。<br>注意：<code>signal</code>只能唤醒单个 race 竞太，而<code>broadcast</code>是广播，唤醒所有</p>
<h3 id="NSCoditionLock"><a href="#NSCoditionLock" class="headerlink" title="NSCoditionLock"></a>NSCoditionLock</h3><p>NSConditionLock 称为条件锁，只有 condition 参数与初始化时候的 condition 相等，lock 才能正确进行加锁操作。</p>
<p>这里分清两个概念：</p>
<ul>
<li><code>unlockWithCondition:</code> 它是先解锁，再修改 condition 参数的值。 并不是当 condition 符合某个件值去解锁。</li>
<li><code>lockWhenCondition:</code> 它与<code>unlockWithCondition:</code>不一样，不会修改 condition 参数的值，而是符合 condition 的值再上锁。</li>
</ul>
<p>在这里可以利用 NSConditionLock 实现任务之间的依赖.</p>
<h3 id="条件变量和信号量的区别"><a href="#条件变量和信号量的区别" class="headerlink" title="条件变量和信号量的区别"></a>条件变量和信号量的区别</h3><p>每个信号量都有一个与之关联的值，signal 时+1，wait 时-1，任何线程都可以发出一个信号，即使没有线程在等待该信号量的值。<br>可是对于条件变量，例如 signal 发出信号后，没有任何线程阻塞在wait 上，那这个条件变量上的信号会直接丢失掉。条件变量 NSCodition 可以使用方法<code>broadcast</code>唤醒所有阻塞的线程。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。这种锁相对于自旋锁而言，能提高并发性，因为在多处理器系统中，它允许同时有多个读者来访问共享资源，最大可能的读者数为实际的逻辑CPU数。写者是排他性的，一个读写锁同时只能有一个写者或多个读者（与CPU数相关），但不能同时既有读者又有写者。</p>
<h3 id="pthread-rwlock"><a href="#pthread-rwlock" class="headerlink" title="pthread_rwlock"></a>pthread_rwlock</h3><p>使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">//初始化锁</span><br><span class="line">pthread_rwlock_t lock;</span><br><span class="line">pthread_rwlock_init(&amp;lock, NULL);</span><br><span class="line">    </span><br><span class="line">//读加锁</span><br><span class="line">pthread_rwlock_rdlock(&amp;lock);</span><br><span class="line">//读尝试加锁</span><br><span class="line">pthread_rwlock_trywrlock(&amp;lock);</span><br><span class="line">    </span><br><span class="line">//写加锁</span><br><span class="line">pthread_rwlock_wrlock(&amp;lock);</span><br><span class="line">//写尝试加锁</span><br><span class="line">pthread_rwlock_trywrlock(&amp;lock);</span><br><span class="line">    </span><br><span class="line">//解锁</span><br><span class="line">pthread_rwlock_unlock(&amp;lock);</span><br><span class="line">//销毁</span><br><span class="line">pthread_rwlock_destroy(&amp;lock);</span><br></pre></td></tr></table></figure>

<ul>
<li>同一时间，只能有1个线程进行写操作</li>
<li>同一时间，允许多个线程进行读操作</li>
<li>同一时间，不允许同时有读和写操作</li>
</ul>
<p>具体使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;pthread.h&gt;</span><br><span class="line">@property (nonatomic, assign) pthread_rwlock_t lock;</span><br><span class="line"></span><br><span class="line">- (void)foo &#123;</span><br><span class="line">    pthread_rwlock_init(&amp;_lock, NULL);</span><br><span class="line">    dispatch_queue_global_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            [self read];</span><br><span class="line">        &#125;);</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            [self write];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)read &#123;</span><br><span class="line">    pthread_rwlock_rdlock(&amp;_lock);</span><br><span class="line">    sleep(1);</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    pthread_rwlock_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)write &#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;_lock);</span><br><span class="line">    sleep(1);</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    pthread_rwlock_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="barrier"><a href="#barrier" class="headerlink" title="barrier"></a>barrier</h3><p><code>dispatch_barrier_async</code>和<code>dispatch_barrier_sync</code>的共同点：</p>
<ul>
<li>会先完成在它们前面插入的任务，然后再执行自己的任务</li>
<li>执行完自己的任务，再执行后面插入的任务</li>
</ul>
<p>不同点：</p>
<ul>
<li><code>dispatch_barrier_sync</code>会先将自己的任务执行完，在会插入后面的任务</li>
<li><code>dispatch_barrier_sync</code>不会等自己的任务执行完，就会把后面的任务插入队列，然后等待自己的任务结束在执行后面的任务</li>
</ul>
<p>注意：</p>
<ol>
<li><code>dispatch_barrier_async</code>和<code>dispatch_barrier_sync</code>指定的队列必须是自己创建的并发队列，如果是串行队列或者全局并发队列，那么这两个方法的行为就会类似<code>dispatch_async</code>和<code>dispatch_sync</code></li>
<li>dispatch_barrier_sync 如果指定当前队列可能会引起死锁</li>
</ol>
<p>具体使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (void)foo &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_CONCURRENT);    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;test1&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;test2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;test3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt;= 50000000; i++) &#123;</span><br><span class="line">            if (5000 == i) &#123;</span><br><span class="line">                NSLog(@&quot;point1&quot;);</span><br><span class="line">            &#125;else if (6000 == i) &#123;</span><br><span class="line">                NSLog(@&quot;point2&quot;);</span><br><span class="line">            &#125;else if (7000 == i) &#123;</span><br><span class="line">                NSLog(@&quot;point3&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;barrier&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;aaa&quot;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;test4&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;test5&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;test6&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><h3 id="串行和并发队列"><a href="#串行和并发队列" class="headerlink" title="串行和并发队列"></a>串行和并发队列</h3><p><code>dispatch queue</code>分发队列，我喜欢叫它任务分发队列，而任务就是我们在 block 中写的代码。<br>任务队列有两种：</p>
<ul>
<li>串行：当一个任务执行完，才能执行下一个任务。</li>
<li>并行：当一个任务刚提交，不需要等它结束，就开始执行下一个任务。并发队列支持障碍任务（barrier block）</li>
</ul>
<p>这两种队列均遵循 FIFO 原则，即先提交的任务先执行，举个简单的例子：<br>有三个任务，三个任务的输出分别是1，2，3。串行队列输出的结果是1，2，3；而并行队列的输出结果就不一定了。</p>
<p>虽然并行队列可以同时执行多个任务，但还是需要当前系统的状态来。如果当前系统最多只能处理2个任务，那么1、2就会排在前面先执行，等其中一个任务结束了，再执行任务3。</p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>同步和异步针对的是线程。</p>
<p>同步任务：</p>
<ul>
<li>同步任务会阻塞<code>当前线程</code>，必须等待任务执行完毕返回，才能继续执行下一个任务</li>
<li>作为一个优化，可能会在<code>当前线程</code>执行同步任务，因为切换线程需要消耗较多资源。但如果是在主队列中，则该任务会在主线程中执行</li>
<li>在当前队列中执行同步任务会导致死锁。</li>
</ul>
<p>异步任务：</p>
<ul>
<li>提交完任务后就立即返回，不会等待任务执行完毕。不会阻塞当前线程，会开启新的线程</li>
</ul>
<p>这里结合队列举几个例子<br>例子1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)foo &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    NSLog(@&quot;任务0&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        NSLog(@&quot;任务1 %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        sleep(10);</span><br><span class="line">        NSLog(@&quot;任务2 %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;任务3 %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;任务4&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-08-23 11:18:06.165116+0800 190611[6192:1600283] 任务0</span><br><span class="line">2019-08-23 11:18:07.166471+0800 190611[6192:1600283] 任务1 &lt;NSThread: 0x280a95dc0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2019-08-23 11:18:17.167838+0800 190611[6192:1600318] 任务2 &lt;NSThread: 0x280414100&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2019-08-23 11:18:17.168202+0800 190611[6192:1600283] 任务3 &lt;NSThread: 0x280a95dc0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2019-08-23 11:18:17.168329+0800 190611[6192:1600283] 任务4</span><br></pre></td></tr></table></figure>

<p>分析一下代码的执行流程：</p>
<ol>
<li>创建一个串行队列。串行队列里的任务是顺序执行的，且需要当前任务执行返回，才能执行下一个任务</li>
<li>任务1是同步任务，会阻塞当前线程(主线程)。任务1在主线程中执行</li>
<li>等任务1执行后，执行任务2。任务2是一个异步任务，所以在一个新线程中执行。当任务2执行完毕(过了10秒)，执行任务3</li>
<li>任务3是一个同步任务，阻塞当前线程。任务3在主线程中执行</li>
<li>任务3执行完毕后，主线程不再被阻塞，执行任务4</li>
</ol>
<p>通过上面的例子，我们可以得出这样的结论：</p>
<ol>
<li>串行中的任务遵循先提交新执行的原则，且是按顺序一个一个执行的。不管任务是同步的还是异步的</li>
<li>同步任务会在当前线程中执行，并阻塞当前线程。异步任务会在一个新的线程中执行</li>
</ol>
<p>例子2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)foo &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    NSLog(@&quot;任务0&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        NSLog(@&quot;任务1 %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        sleep(10);</span><br><span class="line">        NSLog(@&quot;任务2 %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;任务3 %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;任务4&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-08-23 11:26:58.546591+0800 190611[6206:1601450] 任务0</span><br><span class="line">2019-08-23 11:26:59.547963+0800 190611[6206:1601450] 任务1 &lt;NSThread: 0x280283c40&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2019-08-23 11:26:59.548243+0800 190611[6206:1601450] 任务3 &lt;NSThread: 0x280283c40&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2019-08-23 11:26:59.548320+0800 190611[6206:1601450] 任务4</span><br><span class="line">2019-08-23 11:27:09.553363+0800 190611[6206:1601490] 任务2 &lt;NSThread: 0x280c060c0&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<p>分析一下代码的执行流程：</p>
<ol>
<li>创建一个并行队列。并行队列里的任务也是顺序执行的，但不需要当前任务结束返回就能执行下一个任务</li>
<li>任务1是一个同步任务，会阻塞当前线程(主线程)，并且执行任务(耗时1秒)。结束后，释放线程。执行任务3</li>
<li>任务3也是一个同步任务，会阻塞当前线程(主线程)。结束后，执行任务4</li>
<li>任务2是一个异步任务，虽然这个任务的提交时间跟任务1差不多，但它需要执行(10秒)，所以它是最后才完成的</li>
</ol>
<p>通过上面的例子，我们可以得出这样的结论：</p>
<ol>
<li>并发队列虽然是”并发”，但仍是按照任务提交顺序来执行任务的，只不过它不需要等待任务结束返回就可以开始执行下一个任务，所以表现起来像是并发的。</li>
<li>在上面的例子中，任务1和任务3同样都是同步任务。同步任务会阻塞当前线程，任务1因为先提交所以先执行，然后阻塞主线程。任务3虽然在任务1执行后也跟着执行，但是因为主线程被任务1阻塞了，所以必须等待任务1执行完毕释放线程才能接着执行任务</li>
</ol>
<p>下面我提几个问题，因为我在我好多博客里都看到了错误的结论</p>
<ul>
<li>在主队列中使用同步任务是否会造成死锁？</li>
</ul>
<p>如果你直接在主线程中使用主队列提交一个同步任务是会造成死锁的。但下面这种情况就不会<br>例子3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)foo &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            NSLog(@&quot;任务1&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;任务0&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-08-23 14:35:44.580059+0800 190611[6310:1614276] 任务0</span><br><span class="line">2019-08-23 14:35:44.587546+0800 190611[6310:1614276] 任务1</span><br></pre></td></tr></table></figure>

<p>为什么呢？同步任务往往会阻塞当前线程，任务1在一个异步任务中提交，而异步任务中会创建一个新线程。所以，任务1仅仅是阻塞了这个新的线程。主队列是一个串行队列，任务0是可以算作提交的第一个任务，任务1是后面提交的任务，所以先执行任务1，再执行任务1.</p>
<p>还有很多说在并行队列中同步任务是顺序执行的</p>
<ul>
<li>在并行队列中的同步任务是否是顺序执行的？</li>
</ul>
<p>在上面的例子2中是顺序执行，但下面这个例子里的就不会<br>例子4：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue1 = dispatch_queue_create(NULL, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_queue_t queue2 = dispatch_queue_create(NULL, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue2, ^&#123;</span><br><span class="line">    dispatch_sync(queue1, ^&#123;</span><br><span class="line">        sleep(3);</span><br><span class="line">        NSLog(@&quot;任务1&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(queue1, ^&#123;</span><br><span class="line">    NSLog(@&quot;任务2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;任务0&quot;);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2019-08-23 14:56:55.999218+0800 190611[6346:1617197] 任务2</span><br><span class="line">2019-08-23 14:56:55.999259+0800 190611[6346:1617197] 任务0</span><br><span class="line">2019-08-23 14:56:59.008903+0800 190611[6346:1617213] 任务1</span><br></pre></td></tr></table></figure>

<p>在任务2顺序执行的原因是在第一个同步任务阻塞了当前的线程。但在这个例子中，第一个同步任务，阻塞的是异步任务中创建的新线程，而不是主线程，所以第二个同步任务任务2会率先完成。</p>
<hr>
<p>所以不要去背别人写好的规则，要学会自己去分析。下面是几点总结，类似于数学中的”公理“，能帮助你分析</p>
<ul>
<li>串行和并行队列，都是先执行先提交的任务。串行会等这个任务结束再执行下一个任务，而并行队列不会等它结束就执行下一个任务</li>
<li>同步任务会在当前线程中执行，除了主队列提交的同步任务会在主线程中执行</li>
<li>异步任务中会创建一个新的线程</li>
</ul>
<h3 id="更难的案例分析"><a href="#更难的案例分析" class="headerlink" title="更难的案例分析"></a>更难的案例分析</h3><p>案例1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)foo &#123;</span><br><span class="line">    NSLog(@&quot;任务1&quot;);</span><br><span class="line">    dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">        NSLog(@&quot;任务2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;任务3&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2019-08-23 15:07:03.149869+0800 190611[6361:1618423] 任务1</span><br><span class="line">2019-08-23 15:07:03.149920+0800 190611[6361:1618423] 任务2</span><br><span class="line">2019-08-23 15:07:03.149937+0800 190611[6361:1618423] 任务3</span><br></pre></td></tr></table></figure>

<p>这里谈一下我的理解</p>
<ol>
<li>首先我会将 foo() 这个方法当做在主队列中的第一个同步任务，把它叫做任务0好了</li>
<li>任务0在主线程中执行。任务2是一个同步任务，所以它会阻塞主线程。任务2提交到了一个并发队列中，而不是主队列，所以不会造成死锁。</li>
<li>任务2完成，释放主线程，执行任务3</li>
</ol>
<p>如果把任务2中的队列替换成主队列，就会造成死锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)foo &#123;</span><br><span class="line">    NSLog(@&quot;任务1&quot;);</span><br><span class="line">    dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;任务2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;任务3&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原因是主队列是一个串行队列，任务按顺序执行。所以先要执行任务0，而任务2需要任务0执行完毕才能执行，但是任务2会阻塞主线程，导致两个任务谁都无法完成，造成死锁。</p>
<hr>
<p>案例2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)foo &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    NSLog(@&quot;任务1&quot;); </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;任务2&quot;); </span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            NSLog(@&quot;任务3&quot;); </span><br><span class="line">        &#125;);</span><br><span class="line">        NSLog(@&quot;任务4&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;任务5&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果是 1，5，2 或者是 1，2，5</p>
<p>分析流程：</p>
<ol>
<li>首先执行任务1</li>
<li>创建一个串行队列，并添加一个异步任务。由于异步任务和任务5不知道哪个会先执行，所以输出结果可能是 1，5，2 或者是 1，2，5</li>
<li>在异步任务中，首先执行任务2.然后在当前串行队列中使用了同步任务，造成死锁</li>
</ol>
<p>案例3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)foo &#123;</span><br><span class="line">	dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">		NSLog(@&quot;任务1&quot;); </span><br><span class="line">		dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">		    NSLog(@&quot;任务2&quot;); </span><br><span class="line">		&#125;);</span><br><span class="line">		NSLog(@&quot;任务3&quot;); </span><br><span class="line">	&#125;);</span><br><span class="line">	NSLog(@&quot;任务4&quot;);</span><br><span class="line">	while (1) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	NSLog(@&quot;任务5&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果是 1,4 或者是 4,1<br>分析流程：</p>
<ol>
<li>首先在并行队列中添加一个异步任务，所以不确定任务1跟任务4哪个先执行。所以输出结果是 1,4 或者是 4,1</li>
<li>在异步任务中，先执行任务1。然后碰到一个主队列的同步任务，由于是同步任务，所以会阻塞当前线程。该同步任务会等待主队列中的任务5执行完成然后再执行，但是任务5前面有一个死循环，所以任务5永远不会完成，也就是任务2永远无法完成，于是会一直卡着线程</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写了很多，写的也很杂，但如果你想了解锁，了解多线程的话，这些知识都是少不了的。<br>为了让硬件得到充分利用，我们会使用 GCD 来使用多线程，而为了多线程安全，我们又会使用锁。学习本身也是一个递归的过程，希望大家看完能有所收货~</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-08-15T03:07:00.000Z" title="8/15/2019, 11:07:00 AM">2019-08-15</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">14 分钟读完 (大约2109个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/08/15/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-JYSqlModel/">如何使用 JYSqlModel</a></h1><div class="content"><p><a target="_blank" rel="noopener" href="https://github.com/kikido/JYSqlModel">JYSqlModel</a>是一个高效的 model、sqlite数据的转换工具。在 JYSqlModel，每一条数据库的数据都会被当做一个 model，所以当你对 model 执行相应的增删改查操作时，即对数据库进行着增删改查操作，这意味着你不再需要记得什么字段，什么约束，甚至可以不再使用 sql 语句来操作数据库！<br>JYSqlModel 依赖于库<a target="_blank" rel="noopener" href="https://github.com/ccgus/fmdb">FMDB</a>，使用前请保证你的项目中有这个库。<br>JYSqlModel 的思路来源来自于<a target="_blank" rel="noopener" href="https://github.com/ibireme/YYModel">YYModel</a></p>
<p>使用前请将<code>JYSqlModel</code>和<code>JYClassInfo</code>的 .h 和 .m 文件，放到工程中。</p>
<h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>在 JYSqlModel 中，一个 model 对应于一个表。首先，你需要给这个表确定好一个名字，所以你必须在 model 内重载 JYSqlModel 的类方法<code>+ (nonnull NSString *)tbName;</code>。注意这个名字不能重复重复。<br>系统会在启动的时候，会根据 model 结构创建相应的表。表中字段(column)与 model 属性是一一对应的，在默认情况下，字段名字即是属性名字，当然你也可以使用协议中的方法自定义字段名，这个后面会详细讲。字段的类型会根据属性的类型分成不同的类型，目前只支持下表中的几种类型：</p>
<table>
<thead>
<tr>
<th>字段类型</th>
<th>描述</th>
<th>对应属性类型</th>
</tr>
</thead>
<tbody><tr>
<td>integer</td>
<td>整型数</td>
<td>c的整型，NSNumber</td>
</tr>
<tr>
<td>real</td>
<td>浮点数</td>
<td>c的浮点型，NSDecimalNumber</td>
</tr>
<tr>
<td>text</td>
<td>文本</td>
<td>NSString，NSMutableString，NSURL</td>
</tr>
<tr>
<td>blob</td>
<td>二进制数据</td>
<td>NSData，NSMutableData</td>
</tr>
<tr>
<td>date</td>
<td>日期</td>
<td>NSDate</td>
</tr>
<tr>
<td>bool</td>
<td>布尔值</td>
<td>c的bool</td>
</tr>
<tr>
<td>unknow</td>
<td>除上面所以，会报错</td>
<td>除上面所有</td>
</tr>
</tbody></table>
<p>如果你的类型不是上面支持的几种类型之一，那么就会被归为 unkonw 类型，随即就会报错。这样做的原因一方面是因为自己的知识不够丰富，不知道怎么处理其它的类型，另一方面避免复杂类型引起不可预料的错误。在后期的话可能还会支持 NSArray 等容器类型。</p>
<p>下面是一个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@interface Student : JYSqlModel</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic, copy) NSString *school;</span><br><span class="line">@property (nonatomic, assign) NSInteger age;</span><br><span class="line">@property (nonatomic, assign) CGFloat height;</span><br><span class="line">@property (nonatomic, strong) NSDate *birthDay;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Student</span><br><span class="line">+ (NSString *)tbName</span><br><span class="line">&#123;</span><br><span class="line">    return @&quot;sudent&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>下面是创建相应表的 sql：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table if not exists sudent (school text ,age integer ,birthDay date ,name text ,height real)</span><br></pre></td></tr></table></figure>

<p>是不是很简单，你只需要新建一个<code>JYSqlModel</code>的子类，并给它指定一个表名，就能自动的创建一个表。</p>
<h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>JYSqlModel 提供了以下几种方法来帮助你将 model 写入数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">+ (BOOL)addModel:(nonnull __kindof JYSqlMode *)model;</span><br><span class="line">// 2</span><br><span class="line">+ (BOOL)addModels:(nonnull NSArray&lt;__kindof JYSqlMode *&gt; *)models;</span><br><span class="line">// 3</span><br><span class="line">- (BOOL)addToSql;</span><br></pre></td></tr></table></figure>

<p>方法1和方法2类似，都是使用类方法来添加 model 到数据库中。需要注意的是，model 的类需要跟类一致，否则会添加失败。<br>方法3是实例方法。添加成功会返回 YES，否则返回 NO</p>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>JYSqlModel 提供了以下几种方法来帮助你将 model 从数据库中删除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">+ (BOOL)deleteModelBySql:(nonnull NSString *)sql;</span><br><span class="line">// 2</span><br><span class="line">+ (BOOL)deleteModelByPrimaryKey:(NSString *)primaryKey value:(NSInteger)value;</span><br><span class="line">// 3</span><br><span class="line">+ - (BOOL)deleteFromSql;</span><br></pre></td></tr></table></figure>

<p>方法1的话需要你自己写删除 sql，适用于删除语句比较简单或者批量删除的时候。你可以在子类中，根据这个方法封装一个更简单的方法。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interface Student : JYSqlMode    </span><br><span class="line">+ (BOOL)deleteModeByPKValue:(NSInteger)value;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation JYPerson</span><br><span class="line"> + (BOOL)deleteModeByPKValue:(NSInteger)value &#123;</span><br><span class="line">    NSString *sql = [NSString stringWithFormat:@&quot;delete from tbName where pk = %zd&quot;, value];</span><br><span class="line">    [JYSonModel deleteModelBySql:sql];</span><br><span class="line"> &#125;</span><br><span class="line"> @end</span><br></pre></td></tr></table></figure>
<p>现在你只需要一个pk值就能删除数据库记录了。当然你也可以封装一个实例方法，这样连参数都不需要了。</p>
<p>方法2需要你指定一个主键名字以及主键值来删除相应记录。类似于方法1，你也可以根据该方法封装一个更简便的方法！</p>
<p>方法3不需要你提供什么参数，使用起来更简单，但是如果对应表中没有主键，该删除方法就会失败，因为无法定位到具体到某一条记录。</p>
<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><p>JYSqlModel 提供了以下几种方法来帮助你更新数据库中的记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">+ (BOOL)updateModelBySql:(NSString *)sql;</span><br><span class="line">// 2</span><br><span class="line">+ (BOOL)updateModel:(nonnull __kindof JYSqlMode *)model primaryKey:(NSString *)primaryKey value:(NSInteger)value;</span><br></pre></td></tr></table></figure>

<p>方法1的话需要你自己提供更新 sql，适用于更新字段比较少或者批量更新的时候。</p>
<p>方法2需要你提供一个主键来确定是哪条记录，以便更新相应数据。该方法将更新除主键和autoincrement以外所有的字段，适用于更新字段比较多的情况。</p>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>JYSqlModel 提供了以下几种方法来帮助你查找数据库中的记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">+ (nullable NSArray&lt;__kindof JYSqlMode *&gt; *)findModelsBySql:(nonnull NSString *)sql;</span><br><span class="line">// 2</span><br><span class="line">+ (nullable NSArray&lt;__kindof JYSqlMode *&gt; *)findAllModels;</span><br></pre></td></tr></table></figure>

<p>方法1需要你自己提供查找 sql，返回结果将以 model 数组返回。</p>
<p>方法2将会查找出表中所有的记录，以 model 数组的形式返回。</p>
<h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><p>在项目更新中，如果我们需要增加、删除 model 中的某些属性，或者改变属性的类型要怎么办呢？<br>很简单，你只需要对 model 进行修改，在项目运行时，JYSqlMode 会检测新 model 的结构以及旧表的结构，来判断是否需要进行数据迁移。<br>所谓的<code>数据迁移</code>也就是，将旧表重命名，根据新 model 的结构新建一个表，然后将旧表的数据迁移到新的表中。如此操作之后，新表的结构与新 model 的结构就一一对应了，保证了你在执行增删改查操作时不会出错。</p>
<p>当然，也有一些情况下，可能你做了修改也不会触发数据迁移。例如，如果仅仅是改变了字段的约束条件，那么是不会触发数据迁移的。解决办法最后面会给出。</p>
<h3 id="JYSqlMode"><a href="#JYSqlMode" class="headerlink" title="JYSqlMode"></a>JYSqlMode</h3><p>下面是协议<code>JYSqlMode</code>的可选方法，帮助你执行一些自定义操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">+ (nullable NSDictionary&lt;NSString *, id&gt; *)jyCustomPropertyMapper;</span><br><span class="line">// 2</span><br><span class="line">+ (nullable NSDictionary&lt;NSString *, NSDictionary *&gt; *)jyCustomPropertyConstraint;</span><br></pre></td></tr></table></figure>


<p>方法1帮助你实现自定义 属性 -&gt; 表字段名 的映射。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface Student : JYSqlMode &lt;JYSqlMode&gt;</span><br><span class="line">@property NSString *name;</span><br><span class="line">@property NSString *title;</span><br><span class="line">@property NSInteger age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">implementation Student</span><br><span class="line">+ (nullable NSDictionary&lt;NSString *, id&gt; *)jyCustomPropertyMapper &#123;</span><br><span class="line">return @&#123;</span><br><span class="line">	      @&quot;name&quot;   : @&quot;fName&quot;,</span><br><span class="line">	      @&quot;title&quot;  : @&quot;ftitle&quot;,</span><br><span class="line">	      @&quot;age&quot;    : @&quot;fage&quot;</span><br><span class="line">	     &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>在相应的表中，fName 将会对应属性 name，ftitle 将会对应属性 title，fage 将会对应属性 age</p>
<p>方法2帮助你实现自定义字段的约束条件。目前仅支持以下几种约束类型：</p>
<ul>
<li>JYColumnConstraintKeyNotNull -&gt; not null</li>
<li>JYColumnConstraintKeyDefault -&gt; default</li>
<li>JYColumnConstraintKeyDefaultValue -&gt; 默认值，需要与 JYColumnConstraintKeyDefault 配套使用</li>
<li>JYColumnConstraintKeyUnique -&gt; unique</li>
<li>JYColumnConstraintKeyPrimaryKey -&gt; primary key</li>
<li>JYColumnConstraintKeyAutoIncrement -&gt; autoincrement</li>
</ul>
<p>需要注意的是，JYColumnConstraintKeyDefault 需要配合 JYColumnConstraintKeyDefaultValue 使用，设置一个默认值。<br>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@interface Student : JYSqlModel &lt;JYSqlModel&gt;</span><br><span class="line">@property (nonatomic, assign) NSInteger fid;</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic, copy) NSString *school;</span><br><span class="line">@property (nonatomic, assign) CGFloat height;</span><br><span class="line">@property (nonatomic, strong) NSDate *birthDay;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Student</span><br><span class="line">+ (nullable NSDictionary&lt;NSString *, NSDictionary *&gt; *)jyCustomPropertyConstraint;</span><br><span class="line">&#123;</span><br><span class="line">    return @&#123;</span><br><span class="line">             @&quot;fid&quot; : @&#123;</span><br><span class="line">                     JYColumnConstraintKeyPrimaryKey : @YES,</span><br><span class="line">                     JYColumnConstraintKeyUnique : @YES</span><br><span class="line">                     JYColumnConstraintKeyAutoIncrement : @YES</span><br><span class="line">                     &#125;,</span><br><span class="line">             @&quot;school&quot; : @&#123;</span><br><span class="line">                     JYColumnConstraintKeyDefault : @YES,</span><br><span class="line">                     JYColumnConstraintKeyDefaultValue : @&quot;背背山小学&quot;</span><br><span class="line">                     &#125;</span><br><span class="line">             &#125;;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>这样子，你就定义了一个<code>primary key unique autoincrement</code>的主键 fid，以及一个<code>default &#39;背背山小学&#39;</code>的字段 school。</p>
<h3 id="note"><a href="#note" class="headerlink" title="@note"></a>@note</h3><p>限于个人水平，JYSqlModel 肯定会在一些的问题。也许你会奇怪明明按说明操作了，但没有出现想要的结构。下面我将总结一下使用时需要注意的地方：</p>
<ol>
<li>已存在一个旧表，若只是修改了相应字段的约束条件，这些约束条件是不会立刻生效的。一个解决办法是预留一个字段，当你需要更新表结构的时候修改这个预留字段的名字</li>
<li>已存在一个旧表，如果你为它设置了一个主键，抱歉设置会失败。解决方法参考第1条</li>
<li>NSNumber类型的属性会存储到 integer 类型的字段中，如果想保存成浮点数的话，请将属性类型改为 NSDecimalNumber 或者直接使用 C 的浮点类型 float, double等</li>
<li>如果你在运行时动态的为 model 新增了属性，抱歉，表结构也不会更新</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-07-30T07:57:13.000Z" title="7/30/2019, 3:57:13 PM">2019-07-30</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">32 分钟读完 (大约4794个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/30/YYModel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">YYModel实现原理</a></h1><div class="content"><p>其实很早开始就想写这个了，因为自己一直在用这个库，而且它的代码量也比较少，另外作者<a target="_blank" rel="noopener" href="https://github.com/ibireme">ibireme</a>写的代码质量很高。为了提高自己，拜读大神写的库是一个很好的方式。<br>本文将从头开始分析代码，所以文字可能会比较多。</p>
<h3 id="YYClassMethodInfo"><a href="#YYClassMethodInfo" class="headerlink" title="YYClassMethodInfo"></a>YYClassMethodInfo</h3><p>这个类保存了 Method 的信息(其实后面好像也没怎么用到。。。)。 该类的属性及描述如下：</p>
<table>
<thead>
<tr>
<th>属性名字</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Method method</td>
<td>对应的Method</td>
</tr>
<tr>
<td>NSString *name</td>
<td>方法的名字</td>
</tr>
<tr>
<td>SEL sel</td>
<td>方法选择器</td>
</tr>
<tr>
<td>IMP imp</td>
<td>方法实现</td>
</tr>
<tr>
<td>NSString *typeEncoding</td>
<td>参数及返回值类型的编码</td>
</tr>
<tr>
<td>NSString *returnTypeEncoding</td>
<td>返回值类型的编码</td>
</tr>
<tr>
<td>NSArray&lt;NSString *&gt; *argumentTypeEncodings</td>
<td>参数类型的编码</td>
</tr>
</tbody></table>
<p>想更多的了解类型编码可以去看<a target="_blank" rel="noopener" href="https://nshipster.cn/type-encodings/">Type Encodings</a>这篇博客，主要是runtime加快消息的分发<br>你可以使用<code>@encode</code>将相应类型转换成内部表示的字符串，当然也有一大部分内部使用的类型编码无法用<code>@encode()</code>返回。</p>
<h3 id="YYClassPropertyInfo"><a href="#YYClassPropertyInfo" class="headerlink" title="YYClassPropertyInfo"></a>YYClassPropertyInfo</h3><p>这个类保存了 Property 信息，主要用到等有<code>setter</code>和<code>getter</code>方法，成员变量名称，编码方式(很重要，根据这个来确定属性类型以及其它修饰符)。该类的属性及描述如下：</p>
<table>
<thead>
<tr>
<th>属性名字</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>objc_property_t property</td>
<td>对应的Property</td>
</tr>
<tr>
<td>NSString *name</td>
<td>名字</td>
</tr>
<tr>
<td>YYEncodingType type</td>
<td>类型编码的类型</td>
</tr>
<tr>
<td>NSString *typeEncoding</td>
<td>类型编码</td>
</tr>
<tr>
<td>NSString *ivarName</td>
<td>成员变量名称，加了个_前缀</td>
</tr>
<tr>
<td>Class cls</td>
<td>属性类型</td>
</tr>
<tr>
<td>NSArray&lt;NSString *&gt; *protocols</td>
<td>被包含着的协议，可能为空</td>
</tr>
<tr>
<td>SEL getter</td>
<td>getter方法，不能为空</td>
</tr>
<tr>
<td>SEL setter</td>
<td>setter方法，不能为空</td>
</tr>
</tbody></table>
<p>属性转换成<code>YYClassPropertyInfo</code>的过程比较麻烦，比较复杂的地方在于需要通过解析属性的类型编码，来确定 YYClassPropertyInfo 的<code>YYEncodingType type</code>属性。</p>
<p>YYEncodingType 主要包含了以下几方面的信息：</p>
<ul>
<li>YYEncodingTypeMask： 属性值的类型，例如c的基本数据类型，结构体，id类型，class类型</li>
<li>YYEncodingTypeQualifierMask：不知道怎么形容这个，在<a target="_blank" rel="noopener" href="https://nshipster.cn/type-encodings/">Type Encodings</a>这篇博客里面说是内部使用的类型编码。例如：const，in，out</li>
<li>YYEncodingTypePropertyMask：属性关键词，例如：strong， weak， readonly</li>
</ul>
<h3 id="YYClassIvarInfo"><a href="#YYClassIvarInfo" class="headerlink" title="YYClassIvarInfo"></a>YYClassIvarInfo</h3><p>这个类保存了 Ivar 的信息。貌似不会用到，这里就不展开讲了。</p>
<h3 id="YYClassInfo"><a href="#YYClassInfo" class="headerlink" title="YYClassInfo"></a>YYClassInfo</h3><p>每一个类(包括元类)都有一个对应的 YYClassInfo 实例。非元类对应的实例创建之后会被保存在一个静态字典缓存 classCache 中，元类对应的实例保存在另一个静态字典缓存 metaCache 中，以<code>Class -&gt; YYClassInfo</code>的映射关系保存在缓存中。如果缓存中没有，则重新创建一个。<br>创建时，首先会通过 runtime 的方法得到父类，是否是元类，元类，名字等基本信息，然后按顺序分别将它所有的的 Method，Property，Ivar 生成对应的 YYClassMethodInfo，YYClassPropertyInfo，YYClassIvarInfo实例，添加到 YYClassInfo 中。创建完成之后开始创建父类的 YYClassInfo 实例，一直到根类。</p>
<p>YYClassInfo 保存了 Class 的绝大部分信息，但是 objc 是一门动态的语言，可以在运行时添加方法，属性等信息，这也意味着 YYClassInfo 里面保存的信息可能不是最新的。所以当你对 Class 做了一些修改之后，你需要先获得该 Class 对应的 YYClassInfo实例，然后手动调用<code>- (void)setNeedUpdate;</code>来刷新保存在缓存中的 info 信息。</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Class cls</td>
<td>对应类</td>
</tr>
<tr>
<td>Class superCls</td>
<td>对应类的父类</td>
</tr>
<tr>
<td>Class metaCls</td>
<td>对应类的元类</td>
</tr>
<tr>
<td>BOOL isMeta</td>
<td>对应类是否是元类</td>
</tr>
<tr>
<td>NSString *name</td>
<td>类名</td>
</tr>
<tr>
<td>YYClassInfo *superClassInfo</td>
<td>父类对应的 YYClassInfo 实例</td>
</tr>
<tr>
<td>NSDictionary&lt;NSString *, YYClassIvarInfo *&gt; *ivarInfos</td>
<td>所有成员变量信息</td>
</tr>
<tr>
<td>NSDictionary&lt;NSString *, YYClassMethodInfo *&gt; *methodInfos</td>
<td>所有方法信息</td>
</tr>
<tr>
<td>NSDictionary&lt;NSString *, YYClassPropertyInfo *&gt; *propertyInfos</td>
<td>所有属性信息</td>
</tr>
</tbody></table>
<h3 id="YYModel协议"><a href="#YYModel协议" class="headerlink" title="YYModel协议"></a>YYModel协议</h3><p>如果默认的模型转换不能满足你的需求，那么你可以通过实现 YYModel 协议中的方法达到自定义键值转化的过程。下面，简单介绍一下它的几个方法：</p>
<ul>
<li>+ (nullable NSDictionary&lt;NSString *, id&gt; *)modelCustomPropertyMapper;</li>
</ul>
<p>实现这个方法，你可以自定义<code>mode property -&gt; json key</code>之间的映射关系，你可以定义一个属性映射多个 key。举个注释中的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">json: </span><br><span class="line">    &#123;</span><br><span class="line">        &quot;n&quot;:&quot;Harry Pottery&quot;,</span><br><span class="line">        &quot;p&quot;: 256,</span><br><span class="line">        &quot;ext&quot; : &#123;</span><br><span class="line">            &quot;desc&quot; : &quot;A book written by J.K.Rowling.&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ID&quot; : 100010</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">model:</span><br><span class="line">    @interface YYBook : NSObject &lt;YYModel&gt;</span><br><span class="line">    @property NSString *name;</span><br><span class="line">    @property NSInteger page;</span><br><span class="line">    @property NSString *desc;</span><br><span class="line">    @property NSString *bookID;</span><br><span class="line">    @end</span><br><span class="line">    </span><br><span class="line">    @implementation YYBook</span><br><span class="line">    + (NSDictionary *)modelCustomPropertyMapper &#123;</span><br><span class="line">        return @&#123;@&quot;name&quot;  : @&quot;n&quot;,</span><br><span class="line">                 @&quot;page&quot;  : @&quot;p&quot;,</span><br><span class="line">                 @&quot;desc&quot;  : @&quot;ext.desc&quot;,</span><br><span class="line">                 @&quot;bookID&quot;: @[@&quot;id&quot;, @&quot;ID&quot;, @&quot;book_id&quot;]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    @end</span><br></pre></td></tr></table></figure>

<p>在上面的那个例子中，实现该方法后，字典中 n 对应于属性 name，p 对应于属性 page。。。</p>
<hr>
<ul>
<li>+ (nullable NSDictionary&lt;NSString *, id&gt; *)modelContainerPropertyGenericClass;</li>
</ul>
<p>实现该方法，你可以自定义容器类属性的泛型。例如 NSArray 和 NSDictionary 类的属性，你可以通过该方法你定义它们的元素(数组) value(字典)的类型</p>
<hr>
<ul>
<li>+ (nullable Class)modelCustomClassForDictionary:(NSDictionary *)dictionary;</li>
</ul>
<p>通过该方法，你可以自定义 json&#x2F;字典 在不同的情况转化成不同 Class 的实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@class YYCircle, YYRectangle, YYLine;</span><br><span class="line"> </span><br><span class="line">@implementation YYShape</span><br><span class="line"></span><br><span class="line">+ (Class)modelCustomClassForDictionary:(NSDictionary*)dictionary &#123;</span><br><span class="line">    if (dictionary[@&quot;radius&quot;] != nil) &#123;</span><br><span class="line">        return [YYCircle class];</span><br><span class="line">    &#125; else if (dictionary[@&quot;width&quot;] != nil) &#123;</span><br><span class="line">        return [YYRectangle class];</span><br><span class="line">    &#125; else if (dictionary[@&quot;y2&quot;] != nil) &#123;</span><br><span class="line">        return [YYLine class];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return [self class];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>+ (nullable NSArray&lt;NSString *&gt; *)modelPropertyBlacklist;</li>
</ul>
<p>黑名单，数组中的元素代表的是属性的名字。如果这个方法实现了，那么数组中的属性则不会被赋值。</p>
<hr>
<ul>
<li>+ (nullable NSArray&lt;NSString *&gt; *)modelPropertyWhitelist;</li>
</ul>
<p>白名单，数组的元素代表的是属性的名字。如果这个方法实现，那么不在这个数组中的属性不会被赋值</p>
<hr>
<ul>
<li>- (NSDictionary *)modelCustomWillTransformFromDictionary:(NSDictionary *)dic;</li>
</ul>
<p>在数据模型转换之前，对json字典进行修改。如果实现了这个方法，那么将使用修改后的字典进行mode转换</p>
<hr>
<ul>
<li>- (BOOL)modelCustomTransformFromDictionary:(NSDictionary *)dic;</li>
</ul>
<p>如果你想自定义数据模型转换，那么你可以实现这个方法。在这个方法里你可以生成 mode 的实例，并根据 dic 对实例的属性赋值，记得创建成功后返回 YES</p>
<ul>
<li>- (BOOL)modelCustomTransformToDictionary:(NSMutableDictionary *)dic;</li>
</ul>
<p>fixme 不知道干嘛</p>
<h3 id="YYModelMeta"><a href="#YYModelMeta" class="headerlink" title="_YYModelMeta"></a>_YYModelMeta</h3><p>这是一个内部类，它主要用来保存类的信息，每一个类都有一个对应的 _YYModelMeta 实例。创建好的实例会被保存在一个静态字典缓存中 cache，以<code>clss -&gt; _YYModelMeta</code>的映射关系存储。如果缓存中没有该实例，则重新创建一个。看到这你是不是会觉得很像之前提到的<code>YYClassInfo</code>？简单点说，YYClassInfo 全盘记录了 class 的信息，_YYModelMeta 是对这些信息进行了加工整理。</p>
<p>下面是 _YYModelMeta 的构造函数，代码比较多，可以直接跳到后面看分析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithClass:(Class)cls &#123;</span><br><span class="line">    YYClassInfo *classInfo = [YYClassInfo classInfoWithClass:cls];</span><br><span class="line">    if (!classInfo) return nil;</span><br><span class="line">    self = [super init];</span><br><span class="line">    </span><br><span class="line">    // 得到自定义黑名单</span><br><span class="line">    NSSet *blacklist = nil;</span><br><span class="line">    if ([cls respondsToSelector:@selector(modelPropertyBlacklist)]) &#123;</span><br><span class="line">        NSArray *properties = [(id&lt;YYModel&gt;)cls modelPropertyBlacklist];</span><br><span class="line">        if (properties) &#123;</span><br><span class="line">            blacklist = [NSSet setWithArray:properties];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 得到自定义白名单</span><br><span class="line">    NSSet *whitelist = nil;</span><br><span class="line">    if ([cls respondsToSelector:@selector(modelPropertyWhitelist)]) &#123;</span><br><span class="line">        NSArray *properties = [(id&lt;YYModel&gt;)cls modelPropertyWhitelist];</span><br><span class="line">        if (properties) &#123;</span><br><span class="line">            whitelist = [NSSet setWithArray:properties];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 自定义容器类属性的泛型</span><br><span class="line">    NSDictionary *genericMapper = nil;</span><br><span class="line">    if ([cls respondsToSelector:@selector(modelContainerPropertyGenericClass)]) &#123;</span><br><span class="line">        genericMapper = [(id&lt;YYModel&gt;)cls modelContainerPropertyGenericClass];</span><br><span class="line">        if (genericMapper) &#123;</span><br><span class="line">            NSMutableDictionary *tmp = [NSMutableDictionary new];</span><br><span class="line">            [genericMapper enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</span><br><span class="line">                if (![key isKindOfClass:[NSString class]]) return;</span><br><span class="line">                Class meta = object_getClass(obj);</span><br><span class="line">                if (!meta) return;</span><br><span class="line">                if (class_isMetaClass(meta)) &#123;</span><br><span class="line">                    tmp[key] = obj;</span><br><span class="line">                &#125; else if ([obj isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">                    Class cls = NSClassFromString(obj);</span><br><span class="line">                    if (cls) &#123;</span><br><span class="line">                        tmp[key] = cls;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">            genericMapper = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 创建所有的元属性（不包括根类NSObject和NSProxy等属性）</span><br><span class="line">    NSMutableDictionary *allPropertyMetas = [NSMutableDictionary new];</span><br><span class="line">    YYClassInfo *curClassInfo = classInfo;</span><br><span class="line">    while (curClassInfo &amp;&amp; curClassInfo.superCls != nil) &#123; // recursive parse super class, but ignore root class (NSObject/NSProxy)</span><br><span class="line">        for (YYClassPropertyInfo *propertyInfo in curClassInfo.propertyInfos.allValues) &#123;</span><br><span class="line">            if (!propertyInfo.name) continue;</span><br><span class="line">            if (blacklist &amp;&amp; [blacklist containsObject:propertyInfo.name]) continue;</span><br><span class="line">            if (whitelist &amp;&amp; ![whitelist containsObject:propertyInfo.name]) continue;</span><br><span class="line">            _YYModelPropertyMeta *meta = [_YYModelPropertyMeta metaWithClassInfo:classInfo</span><br><span class="line">                                                                    propertyInfo:propertyInfo</span><br><span class="line">                                                                         generic:genericMapper[propertyInfo.name]];</span><br><span class="line">            if (!meta || !meta-&gt;_name) continue;</span><br><span class="line">            if (!meta-&gt;_getter || !meta-&gt;_setter) continue;</span><br><span class="line">            if (allPropertyMetas[meta-&gt;_name]) continue;</span><br><span class="line">            allPropertyMetas[meta-&gt;_name] = meta;</span><br><span class="line">        &#125;</span><br><span class="line">        curClassInfo = curClassInfo.superClassInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    if (allPropertyMetas.count) _allPropertyMetas = allPropertyMetas.allValues.copy;</span><br><span class="line">    </span><br><span class="line">    NSMutableDictionary *mapper = [NSMutableDictionary new];</span><br><span class="line">    NSMutableArray *keyPathPropertyMetas = [NSMutableArray new];</span><br><span class="line">    NSMutableArray *multiKeysPropertyMetas = [NSMutableArray new];</span><br><span class="line">    </span><br><span class="line">    // 得到自定义数据字典key到mode属性之间的映射关系</span><br><span class="line">    if ([cls respondsToSelector:@selector(modelCustomPropertyMapper)]) &#123;</span><br><span class="line">        NSDictionary *customMapper = [(id &lt;YYModel&gt;)cls modelCustomPropertyMapper];</span><br><span class="line">        [customMapper enumerateKeysAndObjectsUsingBlock:^(NSString *propertyName, NSString *mappedToKey, BOOL *stop) &#123;</span><br><span class="line">            _YYModelPropertyMeta *propertyMeta = allPropertyMetas[propertyName];</span><br><span class="line">            if (!propertyMeta) return;</span><br><span class="line">            [allPropertyMetas removeObjectForKey:propertyName];</span><br><span class="line">            </span><br><span class="line">            if ([mappedToKey isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">                if (mappedToKey.length == 0) return;</span><br><span class="line">                </span><br><span class="line">                propertyMeta-&gt;_mappedToKey = mappedToKey;</span><br><span class="line">                NSArray *keyPath = [mappedToKey componentsSeparatedByString:@&quot;.&quot;];</span><br><span class="line">                for (NSString *onePath in keyPath) &#123;</span><br><span class="line">                    if (onePath.length == 0) &#123;</span><br><span class="line">                        NSMutableArray *tmp = keyPath.mutableCopy;</span><br><span class="line">                        [tmp removeObject:@&quot;&quot;];</span><br><span class="line">                        keyPath = tmp;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (keyPath.count &gt; 1) &#123;</span><br><span class="line">                    propertyMeta-&gt;_mappedToKeyPath = keyPath;</span><br><span class="line">                    [keyPathPropertyMetas addObject:propertyMeta];</span><br><span class="line">                &#125;</span><br><span class="line">                propertyMeta-&gt;_next = mapper[mappedToKey] ?: nil;</span><br><span class="line">                mapper[mappedToKey] = propertyMeta;</span><br><span class="line">                </span><br><span class="line">            &#125; else if ([mappedToKey isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">                </span><br><span class="line">                NSMutableArray *mappedToKeyArray = [NSMutableArray new];</span><br><span class="line">                for (NSString *oneKey in ((NSArray *)mappedToKey)) &#123;</span><br><span class="line">                    if (![oneKey isKindOfClass:[NSString class]]) continue;</span><br><span class="line">                    if (oneKey.length == 0) continue;</span><br><span class="line">                    </span><br><span class="line">                    NSArray *keyPath = [oneKey componentsSeparatedByString:@&quot;.&quot;];</span><br><span class="line">                    if (keyPath.count &gt; 1) &#123;</span><br><span class="line">                        [mappedToKeyArray addObject:keyPath];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        [mappedToKeyArray addObject:oneKey];</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    if (!propertyMeta-&gt;_mappedToKey) &#123;</span><br><span class="line">                        propertyMeta-&gt;_mappedToKey = oneKey;</span><br><span class="line">                        propertyMeta-&gt;_mappedToKeyPath = keyPath.count &gt; 1 ? keyPath : nil;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!propertyMeta-&gt;_mappedToKey) return;</span><br><span class="line">                </span><br><span class="line">                propertyMeta-&gt;_mappedToKeyArray = mappedToKeyArray;</span><br><span class="line">                [multiKeysPropertyMetas addObject:propertyMeta];</span><br><span class="line">                </span><br><span class="line">                propertyMeta-&gt;_next = mapper[mappedToKey] ?: nil;</span><br><span class="line">                mapper[mappedToKey] = propertyMeta;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 对所有的元属性数据进行整理</span><br><span class="line">    [allPropertyMetas enumerateKeysAndObjectsUsingBlock:^(NSString *name, _YYModelPropertyMeta *propertyMeta, BOOL *stop) &#123;</span><br><span class="line">        propertyMeta-&gt;_mappedToKey = name;</span><br><span class="line">        propertyMeta-&gt;_next = mapper[name] ?: nil;</span><br><span class="line">        mapper[name] = propertyMeta;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    // 将整理好的数据赋值给属性</span><br><span class="line">    if (mapper.count) _mapper = mapper;</span><br><span class="line">    if (keyPathPropertyMetas) _keyPathPropertyMetas = keyPathPropertyMetas;</span><br><span class="line">    if (multiKeysPropertyMetas) _multiKeysPropertyMetas = multiKeysPropertyMetas;</span><br><span class="line">    </span><br><span class="line">    _classInfo = classInfo;</span><br><span class="line">    _keyMappedCount = _allPropertyMetas.count;</span><br><span class="line">    _nsType = YYClassGetNSType(cls);</span><br><span class="line">    _hasCustomWillTransformFromDictionary = ([cls instancesRespondToSelector:@selector(modelCustomWillTransformFromDictionary:)]);</span><br><span class="line">    _hasCustomTransformFromDictionary = ([cls instancesRespondToSelector:@selector(modelCustomTransformFromDictionary:)]);</span><br><span class="line">    _hasCustomTransformToDictionary = ([cls instancesRespondToSelector:@selector(modelCustomTransformToDictionary:)]);</span><br><span class="line">    _hasCustomClassFromDictionary = ([cls respondsToSelector:@selector(modelCustomClassForDictionary:)]);</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>创建一个 YYClassInfo 的实例 classInfo</li>
<li>如果实现了协议<YYModel>的方法<code>modelPropertyBlacklist</code>，则得到黑名单列表 blacklist</li>
<li>如果实现了协议<YYModel>的方法<code>modelPropertyWhitelist</code>，则得到白名单列表 whitelist</li>
<li>如果实现了协议<YYModel>的方法<code>modelContainerPropertyGenericClass</code>，则得到容器类的泛型 genericMapper，映射关系为<code>property -&gt; class</code></li>
<li>创建该类以及父类(不包括根类)所有的元属性 _YYModelPropertyMeta<ul>
<li>遍历第一步中得到的 classInfo 的 propertyInfos 属性</li>
<li>如果 blacklist 不为空，并且该属性的名字在里面，则 continue</li>
<li>如果 whitelist 不为空，且该属性的名字不在里面，则 continue</li>
<li>创建 _YYModelPropertyMeta 实例 meta，将 YYClassPropertyInfo 信息赋值给 meta，并添加到字典 allPropertyMetas 中，映射关系为<code>property name -&gt;_YYModelPropertyMeta</code></li>
</ul>
</li>
<li>创建字典 mapper，其映射关系为<code>mappedToKey -&gt; _YYModelPropertyMeta</code>，mappedToKey 即json字典中的key。<ul>
<li>如果实现了协议<YYModel>的方法<code>modelCustomPropertyMapper</code>，得到字典 customMapper，映射关系<code>property name -&gt; json key</code>。为了方便我们把 key 叫做 propertyName， value 叫做 mappedToKey</li>
<li>遍历 customMapper。根据 propertyName 在 allPropertyMetas 中找到对应的 _YYModelPropertyMeta 实例 meta，如果 meta 不为空，则将其移出 allPropertyMetas</li>
<li>如果 mappedToKey 是字符串类型，则将其赋值给 meta 的 _mappedToKey 属性。如果 mappedToKey 的格式使用的 keyPath(类似 @”json.key”)，则将该 mappedToKey 使用 @”.” 分割，将分割后等数组赋值给 mata 的 _mappedToKeyPath 属性，并且将 meta 添加到 keyPathPropertyMetas 数组。最后以<code>mappedToKey -&gt; meta</code>的映射将其添加到字典 mapper 中，</li>
<li>如果 mappedToKey 是数组类型，则说明一个属性可能映射了多个json字典的key。此时需要遍历 mappedToKey，它的每一个元素为 oneKey，使用@”.”分割，来判断是否使用了keyPath，分割后得到数组 keyPath。如果 keyPath 的 count 大于1，则将数组 keyPath 添加到 mappedToKeyArray 数组，如果不是则将 oneKey 添加到 mappedToKeyArray，meta 的 _mappedToKey 取值于遍历时第一个 oneKey。当遍历结束，将 mappedToKeyArray 赋值给 meta 的 mappedToKeyArray。最后以<code>mappedToKey -&gt; meta</code>的映射关系将其添加到字典 mapper，将 meta 添加到数组 multiKeysPropertyMetas 中</li>
<li>遍历第五步中的 allPropertyMetas，为了方便我们将字典中的 key 称为 key，value 称为 meta。 将 key 赋值给对应 meta 的 _mappedToKey，并且以<code>property name -&gt; meta</code>的映射添加到 mapper</li>
<li>当一个json字典的key对应着多个属性时，你可以使用 _YYModelPropertyMeta 的 _next来处理 fixme</li>
</ul>
</li>
<li>最后是为 _YYModelMeta 其它一些属性赋值</li>
</ol>
<p>从这个函数中我们可以看出，_YYModelMeta 处理了好几种情况下的数据模型转换问题</p>
<ol>
<li>当自定义了映射关系，一个属性对应多个 key 时，使用 _multiKeysPropertyMetas 来处理</li>
<li>当自定义了映射关系，一个 key 对应多个属性时，使用 _YYModelPropertyMeta 的 _next 来处理</li>
<li>_mapper 中包含了 key 跟 属性之间的映射关系</li>
<li>默认情况下，key 即为属性名，此时使用 _allPropertyMetas 来处理</li>
<li>通过一些bool值来表明 Class 实现了 》<YYModel>的哪几个方法</li>
</ol>
<p>通过下图的_YYModelPropertyMeta的属性说明，能帮助更好的理解这一点</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>_classInfo</td>
<td>对应YYClassInfo实例</td>
</tr>
<tr>
<td>_mapper</td>
<td>字典，映射关系：json字典key -&gt; 属性。如果一个key对应多个属性时，_mapper数量会小于属性数量</td>
</tr>
<tr>
<td>_allPropertyMetas</td>
<td>所有的_YYModelPropertyMeta实例数组</td>
</tr>
<tr>
<td>_keyPathPropertyMetas</td>
<td>使用了keyPath映射的_YYModelPropertyMeta实例数组</td>
</tr>
<tr>
<td>_multiKeysPropertyMetas</td>
<td>被多个key映射的_YYModelPropertyMeta实例数组</td>
</tr>
<tr>
<td>_keyMappedCount</td>
<td>等同于_mapper的count</td>
</tr>
<tr>
<td>_nsType</td>
<td>是 Founddation 的什么类，可能不是</td>
</tr>
<tr>
<td>_hasCustomWillTransformFromDictionary</td>
<td>是否实现了协议方法modelCustomWillTransformFromDictionary</td>
</tr>
<tr>
<td>_hasCustomTransformFromDictionary</td>
<td>是否实现了协议方法modelCustomTransformFromDictionary</td>
</tr>
<tr>
<td>_hasCustomTransformToDictionary</td>
<td>是否实现了协议方法modelCustomTransformToDictionary</td>
</tr>
<tr>
<td>_hasCustomClassFromDictionary</td>
<td>是否实现了协议方法modelCustomClassForDictionary</td>
</tr>
</tbody></table>
<h3 id="数据模型转换"><a href="#数据模型转换" class="headerlink" title="数据模型转换"></a>数据模型转换</h3><p>通过 _YYModelMeta 生成实例的 modelMeta ，我们可以知道json字典跟属性之间的对应关系。所以，接下来要做的就是数据模型之间转换了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)yy_modelSetWithDictionary:(NSDictionary *)dic &#123;</span><br><span class="line">    if (!dic || dic == (id)kCFNull) return NO;</span><br><span class="line">    if (![dic isKindOfClass:[NSDictionary class]]) return NO;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)];</span><br><span class="line">    if (modelMeta-&gt;_keyMappedCount == 0) return NO;</span><br><span class="line">    </span><br><span class="line">    if (modelMeta-&gt;_hasCustomWillTransformFromDictionary) &#123;</span><br><span class="line">        dic = [((id&lt;YYModel&gt;)self) modelCustomWillTransformFromDictionary:dic];</span><br><span class="line">        if (![dic isKindOfClass:[NSDictionary class]]) return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ModelSetContext context = &#123;0&#125;;</span><br><span class="line">    context.modelMeta = (__bridge void *)(modelMeta);</span><br><span class="line">    context.model = (__bridge void *)(self);</span><br><span class="line">    context.dictionary = (__bridge void *)(dic);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    if (modelMeta-&gt;_keyMappedCount &gt;= CFDictionaryGetCount((CFDictionaryRef)dic)) &#123;</span><br><span class="line">        CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &amp;context);</span><br><span class="line">        if (modelMeta-&gt;_keyPathPropertyMetas) &#123;</span><br><span class="line">            CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas,</span><br><span class="line">                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas)),</span><br><span class="line">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                                 &amp;context);</span><br><span class="line">        &#125;</span><br><span class="line">        if (modelMeta-&gt;_multiKeysPropertyMetas) &#123;</span><br><span class="line">            CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas,</span><br><span class="line">                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas)),</span><br><span class="line">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                                 &amp;context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_allPropertyMetas,</span><br><span class="line">                             CFRangeMake(0, modelMeta-&gt;_keyMappedCount),</span><br><span class="line">                             ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                             &amp;context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (modelMeta-&gt;_hasCustomTransformFromDictionary) &#123;</span><br><span class="line">        return [((id&lt;YYModel&gt;)self) modelCustomTransformFromDictionary:dic];</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先根据 modelMeta 的 _hasCustomClassFromDictionary 来判断是否自定义了mode的类型，如果是，则获得自定的 mode 类型cls，并根据cls得到对应的 _YYModelMeta 实例 modelMeta。根据 modelMeta 的 _hasCustomWillTransformFromDictionary 来判断是否在转换前json字典进行修改，如果修改了则使用修改后的字典来转换mode。随后生成一个结构体 context，用来存储转换时要用到的信息。</p>
<p>比较 modelMeta 的 _keyMappedCount 与 json字典的 count 之间的大小</p>
<ul>
<li>_keyMappedCount 大于等于字典的 count，则首先遍历字典，对里面的键值对调用<code>ModelSetWithDictionaryFunction</code>方法。如果 modelMeta 的 _keyPathPropertyMetas 和 _multiKeysPropertyMetas 不为空，则对里面的每个元素调用<code>ModelSetWithPropertyMetaArrayFunction</code>方法</li>
<li>_keyMappedCount 小于字典的 count，则对 _allPropertyMetas 里面的每个元素调用<code>ModelSetWithPropertyMetaArrayFunction</code>方法</li>
</ul>
<p>(应该是哪个少遍历哪个，减少开销。。。)</p>
<hr>
<p>首先让我们看一下上面提到的第一个方法<code>ModelSetWithDictionaryFunction</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void ModelSetWithDictionaryFunction(const void *_key, const void *_value, void *_context) &#123;</span><br><span class="line">    ModelSetContext *context = _context;</span><br><span class="line">    __unsafe_unretained _YYModelMeta *meta = (__bridge _YYModelMeta *)(context-&gt;modelMeta);</span><br><span class="line">    __unsafe_unretained _YYModelPropertyMeta *propertyMeta = [meta-&gt;_mapper objectForKey:(__bridge id)(_key)];</span><br><span class="line">    __unsafe_unretained id model = (__bridge id)(context-&gt;model);</span><br><span class="line">    while (propertyMeta) &#123;</span><br><span class="line">        if (propertyMeta-&gt;_setter) &#123;</span><br><span class="line">            ModelSetValueForProperty(model, (__bridge __unsafe_unretained id)_value, propertyMeta);</span><br><span class="line">        &#125;</span><br><span class="line">        propertyMeta = propertyMeta-&gt;_next;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法比较简单，根据 key 在 meta 的 _mapper 中找到相应的 _YYModelPropertyMeta 实例，随后调用<code>ModelSetValueForProperty</code>方法为该属性赋值，这个方法稍后再提。因为存在一个 key 对应多个 属性的情况，所以对该属性赋值后，会沿着 _next 继续为其它对应的属性赋值。</p>
<hr>
<p>然后再看一下第二个方法<code>ModelSetWithPropertyMetaArrayFunction</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void ModelSetWithPropertyMetaArrayFunction(const void *_propertyMeta, void *_context) &#123;</span><br><span class="line">    ModelSetContext *context = _context;</span><br><span class="line">    __unsafe_unretained NSDictionary *dictionary = (__bridge NSDictionary *)(context-&gt;dictionary);</span><br><span class="line">    __unsafe_unretained _YYModelPropertyMeta *propertyMeta = (__bridge _YYModelPropertyMeta *)(_propertyMeta);</span><br><span class="line">    if (!propertyMeta-&gt;_setter) return;</span><br><span class="line">    id value = nil;</span><br><span class="line">    </span><br><span class="line">    if (propertyMeta-&gt;_mappedToKeyArray) &#123;</span><br><span class="line">        value = YYValueForMultiKeys(dictionary, propertyMeta-&gt;_mappedToKeyArray);</span><br><span class="line">    &#125; else if (propertyMeta-&gt;_mappedToKeyPath) &#123;</span><br><span class="line">        value = YYValueForKeyPath(dictionary, propertyMeta-&gt;_mappedToKeyPath);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        value = [dictionary objectForKey:propertyMeta-&gt;_mappedToKey];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (value) &#123;</span><br><span class="line">        __unsafe_unretained id model = (__bridge id)(context-&gt;model);</span><br><span class="line">        ModelSetValueForProperty(model, value, propertyMeta);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法里主要做了这么几件事情：</p>
<ul>
<li>找到json字典中的数据</li>
<li>调用<code>ModelSetValueForProperty</code>方法将数据赋值给属性，是的，又是这个方法</li>
</ul>
<h4 id="如何取值"><a href="#如何取值" class="headerlink" title="如何取值"></a>如何取值</h4><p>当调用 ModelSetWithPropertyMetaArrayFunction 方法时，传入了上下文 context(里面包含了我们要用到的json字典<code>context-&gt;dictionary</code>)和元属性<code>_YYModelPropertyMeta *propertyMeta</code>。<br>接下来就是分不同的情况来取值了：</p>
<ol>
<li>如果有多个key对应同一个属性时，那么会取第一个key且相应json字典中value不为空时的value。例如，有一个json @{@”name” : @”11”, @”title” : @”222”}, 如果有 @”age”, @”name”, @”title” 这几个 key 对应同一个属性 name，那么只会取json中 @”name” 对应的值</li>
<li>如果使用了 keyPath 来定义属性的映射，那么在json字典中会逐级获取数据(不知道怎么表达了。。。)，例如有一个json @{@”info” : @{@”name” : @”111”}}, 并且使用@”info.name”来映射属性，那么首先会取得 @”info”对应的字典 dic，然后再在dic中取得@”name”的值</li>
<li>如果没有上述两种情况，则直接根据key在json字典中取值</li>
</ol>
<p>好了，是不是看了感觉还挺简单的，复杂的其实在赋值这一步！</p>
<h4 id="如何赋值"><a href="#如何赋值" class="headerlink" title="如何赋值"></a>如何赋值</h4><p>赋值的过程比较复杂，且代码量比较多, 这里就不贴出来了。在这里我简单的分析一下过程：</p>
<hr>
<p>首先属性是基本数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (meta-&gt;_isCNumber) &#123;</span><br><span class="line">        NSNumber *num = YYNSNumberCreateFromID(value);</span><br><span class="line">        ModelSetNumberToProperty(model, num, meta);</span><br><span class="line">        if (num) [num class]; // hold the number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个比较简单。首先将从json字典得到的value进行处理，得到一个 NSNumber 类型的数据 num。然后将 num 转换成相应类型的数据，通过<code>objc_msgSend</code>消息发送赋值给该属性。由于在赋值的函数中参数的类型是<code>__unsafe_unretained</code>(类似weak)，所以需要在赋值成功前持有该数据，否则程序会因为 num 成为野指针而崩溃，所以在<code>ModelSetNumberToProperty</code>后面还有这样一行代码<code>if (num) [num class];</code>，看似没用，其实还是有点用的。如果你想对<code>__unsafe_unretained</code>了解深一点可以看孙源的<a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2015/01/17/self-in-arc/">这篇博客</a></p>
<hr>
<p>然后时属性属于 Foundation 类型时，会先将 value 转换成属性的类型<code>meta-&gt;_nsType</code>，然后通过<code>objc_msgSend</code>赋值给属性。<br>当属性属于数组（NSArray, NSMutableArray）和字典（NSDictionary, NSMutableDictionary）时复杂一点：</p>
<ul>
<li>数组<ul>
<li>如果没有指定泛型，那么直接把value复制给属性</li>
<li>会遍历数组value，将元素转换成相应的泛型，然后添加到一个新数组value中，最后将该value赋值给属性</li>
</ul>
</li>
<li>字典 <ul>
<li>如果没有指定泛型，那么直接把value复制给属性</li>
<li>会遍历字典values，将value转化成相应的泛型，添加到一个新字典vlues中。最后将该values赋值给属性</li>
</ul>
</li>
</ul>
<hr>
<p>属性属于其它的类型，例如自定义的 objc 类，block，c的结构体，联合，数组等，转换过程跟之前也是差不多的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>写了好几天，终于完成了。希望大家看完后对这个库的使用能够有所帮助。在这里可算是帮我解决了个疑问：<br>在自定义mode中就算为容器类指定了泛型，但转换的时候还是会失败, 原因是我们不能在类型编码中得到泛型的信息…</p>
<p>引用：<a target="_blank" rel="noopener" href="https://github.com/ibireme/YYModel">YYModel</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-07-19T06:02:28.000Z" title="7/19/2019, 2:02:28 PM">2019-07-19</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">32 分钟读完 (大约4753个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/19/iOS%E5%BA%94%E7%94%A8-main-%E6%89%A7%E8%A1%8C%E5%89%8D%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B%E6%83%85/">iOS应用 main 执行前发生的事情</a></h1><div class="content"><p>这篇是对 iOS 应用启动时，main 函数执行前发生的事的一点总结，限于水平，如有错误请指正~</p>
<h3 id="FAT-二进制"><a href="#FAT-二进制" class="headerlink" title="FAT 二进制"></a>FAT 二进制</h3><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fat_binary">FAT 二进制文件</a>，将多种架构的 Mach-O 文件合并而成。它通过 Fat Header 来记录不同架构在文件中的偏移量，Fat Header 占一页(64位16kb，32位4kb)的空间。<br>按分页来存储这些 segement 和 header 会浪费空间，但这有利于虚拟内存的实现。</p>
<p><img src="https://i.loli.net/2019/07/16/5d2d7fbfbad2d16193.png"></p>
<h3 id="Mach-O-文件"><a href="#Mach-O-文件" class="headerlink" title="Mach-O 文件"></a>Mach-O 文件</h3><p><code>Mach-O</code>为 Mach Object 文件格式的缩写，它是一种用于可执行文件，目标代码，动态库，内核转储的文件格式。<br>在 Mac OS X 系统中使用 Mach-O 作为其可执行文件类型。<br>它的组成结构如下图所示：</p>
<p><img src="https://i.loli.net/2019/07/16/5d2d33a11b54759536.png" alt="Mach-O 文件结构"></p>
<p>每个 Mach-O 文件包括一个 Mach-O Header，然后是一系列的载入命令 load commands，再是一个或多个段(segment)，每个段包括0到255个节(section)。Mach-O使用REL再定位格式控制对符号的引用。Mach-O在两级命名空间中将每个符号编码成“对象-符号名”对（所以需要保持 selector 的唯一），在查找符号时则采用线性搜索法。</p>
<p>Mach-O包含了几个 segment，每个 segment 又包含几个 section。segment的名字都是大写的，例如__DATA;section的名字都是小写的, 例如 __text。在 Mach-O 的类型不为<code>MH_OBJECT</code>时，空间大小为页的整数倍。页的大小跟硬件有关，在 arm64 架构一页是16kb，其余为4kb。<br>section 虽然没有整数倍页大小的限制，但是 section 之间不会有重叠。</p>
<h3 id="Mach-O-Header"><a href="#Mach-O-Header" class="headerlink" title="Mach-O Header"></a>Mach-O Header</h3><p>推荐使用<code>MachOView</code>这个软件查看 Mach-O 的文件结构。注意需要<code>手动关闭 processing</code>，不然会闪退。下面是用 MachOView 查看自己的应用结构：<br><img src="https://upload-images.jianshu.io/upload_images/1929756-afb6f9e44e85a834.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用MachOView查看文件结构"></p>
<p>东西有点多就没有截取全部。我们查看一下<code>Mach-O Header</code>部分<br><img src="https://upload-images.jianshu.io/upload_images/1929756-f08a65e6164284a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Header结构"></p>
<p>下面是64位架构下<code>header</code>的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span>	magic;		<span class="comment">/* mach magic number identifier */</span></span><br><span class="line">	<span class="type">cpu_type_t</span>	cputype;	<span class="comment">/* cpu specifier */</span></span><br><span class="line">	<span class="type">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* machine specifier */</span></span><br><span class="line">	<span class="type">uint32_t</span>	filetype;	<span class="comment">/* type of file */</span></span><br><span class="line">	<span class="type">uint32_t</span>	ncmds;		<span class="comment">/* number of load commands */</span></span><br><span class="line">	<span class="type">uint32_t</span>	sizeofcmds;	<span class="comment">/* the size of all the load commands */</span></span><br><span class="line">	<span class="type">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">	<span class="type">uint32_t</span>	reserved;	<span class="comment">/* reserved */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1929756-632845e24fd90afd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>Mach-O 全部的 filetype 和 flags 可以在<code>loader.h</code>中找到。</p>
<hr>
<p>除了<code>MH_OBJECT</code>以外的所有类型，段(Segment)的空间大小均为页的整数倍。页的大小跟硬件有关系，在 arm64 架构下一页为16kb，其它为4kb。</p>
<h3 id="Load-commands"><a href="#Load-commands" class="headerlink" title="Load commands"></a>Load commands</h3><p><code>Load commands</code>紧跟在头部之后, 当加载过 header 之后，会通过解析<code>Load commands</code>来加载剩下的数据，确定其内存的分布。<br>下面是 load commands 的结构定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct load_command &#123;</span><br><span class="line">	uint32_t cmd;		/* 载入命令类型 */</span><br><span class="line">	uint32_t cmdsize;	/* total size of command in bytes */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所有<code>load commands</code>的大小即为 Header-&gt;sizeofcmds, 共有 Header-&gt;ncmds 条<code>load command</code>。<br>load command 以<code>LC</code>开头，不同的加载命令有不同的专有的结构体，cmd 和 cmdsize 是都有的，分别为命令类型（即命令名称），这条命令的长度。这些加载命令告诉系统应该如何处理后面的二进制数据，对系统内核加载器和动态链接器起指导作用。如果当前 LC_SEGMENT 包含 section，那么 section 的结构体紧跟在 LC_SEGMENT 的结构体之后，所占字节数由 SEGMENT 的 cmdsize 字段给出。</p>
<table>
<thead>
<tr>
<th>cmd(命令名称)</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>LC_SEGMENT_64</td>
<td>将对应的段中的数据加载并映射到进程的内存空间去</td>
</tr>
<tr>
<td>LC_SYMTAB</td>
<td>符号表信息</td>
</tr>
<tr>
<td>LC_DYSYMTAB</td>
<td>动态符号表信息</td>
</tr>
<tr>
<td>LC_LOAD_DYLINKER</td>
<td>启动动态加载连接器&#x2F;usr&#x2F;lib&#x2F;dyld程序</td>
</tr>
<tr>
<td>LC_UUID</td>
<td>唯一的 UUID，标示该二进制文件，128bit</td>
</tr>
<tr>
<td>LC_VERSION_MIN_IPHONEOS&#x2F;MACOSX</td>
<td>要求的最低系统版本（Xcode中的Deployment Target）</td>
</tr>
<tr>
<td>LC_MAIN</td>
<td>设置程序主线程的入口地址和栈大小</td>
</tr>
<tr>
<td>LC_ENCRYPTION_INFO</td>
<td>加密信息</td>
</tr>
<tr>
<td>LC_LOAD_DYLIB</td>
<td>加载的动态库，包括动态库地址、名称、版本号等</td>
</tr>
<tr>
<td>LC_FUNCTION_STARTS</td>
<td>函数地址起始表</td>
</tr>
<tr>
<td>LC_CODE_SIGNATURE</td>
<td>代码签名信息</td>
</tr>
</tbody></table>
<p>注意：不同类型的 segment 会使用不同的函数来加载</p>
<h3 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h3><p>Mach-O 文件中由许多个段（Segment），每个段都有不同的功能，每个段包含了许多个小的Section。<code>LC_SEGMENT</code>意味着这部分文件需要映射到进程的地址空间去，几乎所有 Mach-O 都包含这三个段：</p>
<ol>
<li>__TEXT：包含了执行代码和其它只读数据(如C 字符串)。权限：只读(VM_PROT_READ)，可执行(VM_PROT_EXECUTE)</li>
<li>__DATA：程序数据，包含全局变量，静态变量等。权限：可读写(VM_PROT_WRITE&#x2F;READ) 可执行(VM_PROT_EXECUTE)</li>
<li>__LINKEDIT：包含了加载程序的”元数据”，比如函数的名称和地址。权限：只读(VM_PROT_READ)</li>
</ol>
<p>除了上面三个，还有一个常见的 segment：</p>
<ul>
<li>__PAGEZERO：空指针陷阱段，映射到虚拟内存空间的第一页，用于捕捉对 NULL 指针的引用</li>
</ul>
<p><code>LC_SEGMENT_64</code> 的结构定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command_64</span> &#123;</span> <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmd;		<span class="comment">/* LC_SEGMENT_64 */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmdsize;	<span class="comment">/* includes sizeof section_64 structs */</span></span><br><span class="line">	<span class="type">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment name */</span></span><br><span class="line">	<span class="type">uint64_t</span>	vmaddr;		<span class="comment">/* memory address of this segment */</span></span><br><span class="line">	<span class="type">uint64_t</span>	vmsize;		<span class="comment">/* memory size of this segment */</span></span><br><span class="line">	<span class="type">uint64_t</span>	fileoff;	<span class="comment">/* file offset of this segment */</span></span><br><span class="line">	<span class="type">uint64_t</span>	filesize;	<span class="comment">/* amount to map from the file */</span></span><br><span class="line">	<span class="type">vm_prot_t</span>	maxprot;	<span class="comment">/* maximum VM protection */</span></span><br><span class="line">	<span class="type">vm_prot_t</span>	initprot;	<span class="comment">/* initial VM protection */</span></span><br><span class="line">	<span class="type">uint32_t</span>	nsects;		<span class="comment">/* number of sections in segment */</span></span><br><span class="line">	<span class="type">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到这里大部分的成员变量都是帮助内核将 segment 映射到虚拟内存的。<code>nsects</code>即表明该段中包含多少个 section，section是具体数据存放的地方。<code>cmdsize</code>表示当前 segment 结构体以及它所包含的所有 section 结构体的总大小。</p>
<p>文件映射的起始位置由<code>fileoff</code>给出，映射到地址空间的<code>vmaddr</code>处。</p>
<h3 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h3><p>section 的名字均为小写。section 是具体数据存放的地方，它的结构体跟随在 LC_SEGMENT 结构体之后。在64位环境中它的结构定义为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct section_64 &#123; /* for 64-bit architectures */</span><br><span class="line">	char		sectname[16];	/* name of this section */</span><br><span class="line">	char		segname[16];	/* segment this section goes in */</span><br><span class="line">	uint64_t	addr;		/* memory address of this section */</span><br><span class="line">	uint64_t	size;		/* size in bytes of this section */</span><br><span class="line">	uint32_t	offset;		/* file offset of this section */</span><br><span class="line">	uint32_t	align;		/* section alignment (power of 2) */</span><br><span class="line">	uint32_t	reloff;		/* file offset of relocation entries */</span><br><span class="line">	uint32_t	nreloc;		/* number of relocation entries */</span><br><span class="line">	uint32_t	flags;		/* flags (section type and attributes)*/</span><br><span class="line">	uint32_t	reserved1;	/* reserved (for offset or index) */</span><br><span class="line">	uint32_t	reserved2;	/* reserved (for count or sizeof) */</span><br><span class="line">	uint32_t	reserved3;	/* reserved */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>flasg</code>字段储存了两个属性的值：type 和 attributes。type 只能有一个值，而 attributes 的值可以有多个。如果 segment 中任何一个 section 拥有属性 S_ATTR_DEBUG，那么该段所有的 section 都会拥有这个属性。属性详情可以参考<code>loader.h</code></p>
<table>
<thead>
<tr>
<th>section name</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>__text</td>
<td>主程序代码</td>
</tr>
<tr>
<td>__stub_helper</td>
<td>用于动态链接的存根</td>
</tr>
<tr>
<td>__symbolstub1</td>
<td>用于动态链接的存根</td>
</tr>
<tr>
<td>__objc_methname</td>
<td>Objective-C 的方法名</td>
</tr>
<tr>
<td>__objc_classname</td>
<td>Objective-C 的类名</td>
</tr>
<tr>
<td>__cstring</td>
<td>硬编码的字符串</td>
</tr>
<tr>
<td>__lazy_symbol</td>
<td>懒加载，延迟加载节，通过 dyld_stub_binder 辅助链接</td>
</tr>
<tr>
<td>_got</td>
<td>存储引用符号的实际地址，类似于动态符号表</td>
</tr>
<tr>
<td>__nl_symbol_ptr</td>
<td>非延迟加载节</td>
</tr>
<tr>
<td>__mod_init_func</td>
<td>初始化的全局函数地址，在 main 之前被调用</td>
</tr>
<tr>
<td>__mod_term_func</td>
<td>结束函数地址</td>
</tr>
<tr>
<td>__cfstring</td>
<td>Core Foundation 用到的字符串（OC字符串）</td>
</tr>
<tr>
<td>__objc_clsslist</td>
<td>Objective-C 的类列表</td>
</tr>
<tr>
<td>__objc_nlclslist</td>
<td>Objective-C 的 +load 函数列表，比 __mod_init_func 更早执行</td>
</tr>
<tr>
<td>__objc_const</td>
<td>Objective-C 的常量</td>
</tr>
<tr>
<td>__data</td>
<td>初始化的可变的变量</td>
</tr>
<tr>
<td>__bss</td>
<td>未初始化的静态变量</td>
</tr>
</tbody></table>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>在 segment 的结构体中，我们可以看到<code>vmaddr</code>和<code>vmsize</code>两个成员变量，它们分别代表 segment 在虚拟内存中的地址以及大小。</p>
<p><code>虚拟内存</code>就是一层间接寻址（indirection）。软件工程中有句格言就是任何问题都能通过添加一个间接层来解决。虚拟内存解决的是管理所有进程使用物理 RAM 的问题。通过添加间接层来让每个进程使用逻辑地址空间，它可以映射到 RAM 上的某个物理页上。这种映射不是一对一的，逻辑地址可能映射不到 RAM 上，也可能有多个逻辑地址映射到同一个物理 RAM 上。针对第一种情况，当进程要存储逻辑地址内容时会触发 page fault；第二种情况就是多进程共享内存。</p>
<p>对于文件可以不用一次性读入整个文件，可以使用<code>分页映射（mmap()）</code>的方式读取。也就是把文件某个片段映射到进程逻辑内存的某个页上。当某个想要读取的页没有在内存中，就会触发 page fault，内核只会读入那一页，实现文件的懒加载。</p>
<p>也就是说 Mach-O 文件中的<code>__TEXT</code>段可以映射到多个进程，并可以懒加载，且进程之间共享内存。<code>__DATA</code>段是可读写的。这里使用到了<code>Copy-On-Write</code>技术，简称 COW。也就是多个进程共享一页内存空间时，一旦有进程要做写操作，它会先将这页内存内容复制一份出来，然后重新映射逻辑地址到新的 RAM 页上。也就是这个进程自己拥有了那页内存的拷贝。这就涉及到了 clean&#x2F;dirty page 的概念。dirty page 含有进程自己的信息，而 clean page 可以被内核重新生成（重新读磁盘）。所以 dirty page 的代价大于 clean page。</p>
<p>在多个进程加载 Mach-O 文件时<code>__TEXT</code>和<code>__LINKEDIT</code>因为只读，都是可以共享内存的。而<code>__DATA</code>因为可读写，就会产生 dirty page。当 dyld 执行结束后，<code>__LINKEDIT</code>就没用了，对应的内存页会被回收。</p>
<h3 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a>dyld</h3><p><img src="https://i.loli.net/2019/07/18/5d3054bb2f41b84030.jpg" alt="dyld"></p>
<p><em>dyld</em>（the dynamic link editor），Apple 的动态链接器。在内核完成映射进程的工作后会启动<code>dyld</code>，负责加载应用依赖的所有动态链接库，准备好运行所需的一切。<br>在 App 启动的时候，首先会加载 App 的 mach-o 文件，从 load commands 中得到 dyld 的路径，并且运行。随后 dyld 做的事情顺序概括如下：</p>
<ol>
<li>初始化运行环境</li>
<li>加载主程序执行文件 生成 image, 将image添加到一个全局容器中</li>
<li>加载共享缓存</li>
<li>根据依赖链递归加载动态链接库 dylib，如果在缓存中有加载好的 image 则直接拿出来，否则生成一个新的 image，将image添加到一个全局容器中</li>
<li>link 主执行文件</li>
<li>link dylib<ul>
<li>根据依赖链递归修正指针 Rebase</li>
<li>根据依赖链递归符号绑定 Bind</li>
</ul>
</li>
<li>初始化 dylib（runtime 的初始化就在这个时候）</li>
</ol>
<p>在加载完所有的 dylib 之后，它们处于互相独立的状态，所以还需要将它们绑定起来。代码签名让我们不能修改指令，所以不能直接让一个 dylib 调用另一个 dylib，这时需要很多间接层。<br>这个时候需要 dyld 来修正指针(rebasing)和绑定符号(binding)。</p>
<p>详细可以查看 dyld 的<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/dyld/">源码</a>中的<code>_main</code>函数。<br>下面会分析上述的其中几个步骤。</p>
<h3 id="ImageLoader"><a href="#ImageLoader" class="headerlink" title="ImageLoader"></a>ImageLoader</h3><p> <code>ImageLoader</code>是一个将 mach-o 文件里面二进制数据(编译过的代码、符号等)加载到内存的基类，它负责将 mach-o 中的二进制数据映射到内存，它的实例就是我们熟悉的 image。<br> 每一个 mach-o 文件都会有一个对应的 image，实例的类型根据 mach-o 格式的不同也会不同。</p>
<p><img src="https://raw.githubusercontent.com/turingH/BLOGIMAGE/master/png/dyld_macho_load/Butterfly-ImageLoader.png"></p>
<ul>
<li>ImageLoaderMachOClassic: 用于加载<code>__LINKEDIT</code>段为传统格式的 mach-o 文件</li>
<li>ImageLoaderMachOCompressed: 用于加载<code>__LINKEDIT</code>段为压缩格式的 mach-o 文件</li>
</ul>
<p>因为<code>dylib</code>之间有依赖关系，所以系统会沿着依赖链递归加载 image。</p>
<h3 id="Rebasing"><a href="#Rebasing" class="headerlink" title="Rebasing"></a>Rebasing</h3><p><code>dylib</code>的二进制数据会随机的映射到内存的一个随机地址ASLR(Address space layout randomization,)中，这个随机的地址跟代码和数据指向的旧地址(preferred_address)会有一定的偏差，<code>dyld</code>需要修正这个偏差(slide)，做法就是将<code>dylib</code>内部的指针地址都加上这个偏移值，偏移值的计算方法如下：</p>
<p>slide &#x3D; actual_address - preferred_address</p>
<p>随后就是不断的将<code>__DATA</code>段中需要修正的指针加上这个偏移值。<br>注意：每次程序启动后的地址都会变化，所以指针的地址都需要重新修正。</p>
<p>在 mach-o 的一个载入命令<code>LC_DYLD_INFO_ONLY</code>可以查看到<code>rebase</code>, <code>bind</code>, <code>week_bind</code>,<code>lazy_bind</code>的偏移量和大小。</p>
<p><img src="https://i.loli.net/2019/07/17/5d2ec84e3414c16255.png"></p>
<h3 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h3><p><code>binding</code>处理那些指向<code>dylib</code>外部的指针，它们实际上被符号名称(symbol)绑定，也就是个字符串。比如我们 objc 代码中需要使用到 NSObject, 即符号_OBJC_CLASS_$_NSObject，但是这个符号不存在当前的 image 中，而是在系统库 Foundation.framework中，因此就需要binding这个操作将对应关系绑定到一起。</p>
<h3 id="Lazy-Binding"><a href="#Lazy-Binding" class="headerlink" title="Lazy Binding"></a>Lazy Binding</h3><p><code>lazyBinding</code>就是在加载动态库的时候不会立即 binding, 当时当第一次调用这个方法的时候再实施 binding。 做到的方法也很简单： 通过<code>dyld_stub_binder</code>这个符号来做。lazy binding 的方法第一次会调用到 dyld_stub_binder, 然后 dyld_stub_binder负责找到真实的方法，并且将地址bind到桩上，下一次就不用再bind了。<br>多数符号都是 lazy binding 的</p>
<h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><p>每一个<code>dylib</code>都有自己的初始化方法，当相应的 image 被加载到内存后，就会调用初始化方法。当然这不是调用名为<code>initialize</code>方法，而是C++静态对象初始化构造器，<code>__attribute__((constructor))</code>标记的方法以及<code>Initializer</code>方法。你可以在程序中设置环境变量<code>DYLD_PRINT_INITIALIZERS</code>来打印<code>dylib</code>的初始化方法。</p>
<p><img src="https://i.loli.net/2019/07/18/5d2fdcba273bf19458.jpg"></p>
<p><img src="https://i.loli.net/2019/07/18/5d2fdcf3c16be55910.jpg" alt="打印信息"></p>
<p>我们可以看到程序首先调用了<code>libSystem</code>这个dylib的初始化方法。<code>libSystem</code>是很多系统的lib的集合，包括 libdispatch(GCD), libsystem_c(c语言库), libsystem_blocks(block)。<br>在<code>libSystem</code>的源码<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/Libsystem/Libsystem-169.3/init.c">init.c</a>中我们可以看到，它的初始化方法<code>libSystem_initializer</code>会调用<code>libdispatch_init();</code>, 然后逐步调用到<code>_objc_init</code>，也就是 objc 和 runtime 的入口。<br>添加一个符号断点<code>_objc_init</code>，下面是方法调用栈：</p>
<p><img src="https://i.loli.net/2019/07/18/5d300eef8d17d46008.png" alt="断点调试"></p>
<p>注意：runtime 和 objc 属于<code>libobjc</code></p>
<hr>
<p>下面是<code>_objc_init</code>的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void _objc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    // 省略...</span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>map_images</code>不是将 image 添加到内存中的意思，在这个方法被调用的时候，已经完成了 image 的映射以及指针修正，绑定符号的工作了。<br>这个函数实际上是将 image 中 OBJC 相关的信息进行初始化，具体实现可以查看<code>_read_image</code>的源码，因为代码太多所以这里就不贴出来了，下面是具体做的事情：</p>
<ul>
<li>会将所有的 Class 存放在一张映射类名与 Class 的全局表中<code>gdb_objc_realized_classes</code></li>
<li>随后调用<code>readClass</code>函数将 每一个 Class 添加到<code>gdb_objc_realized_classes</code>表中。</li>
<li>确定 selector 是唯一的</li>
<li>read protocols: 读取protocol</li>
<li>realizeClasses：这一步的意义就是动态链接好class, 让class处于可用状态，主要操作如下：<ul>
<li>检查ro是否已经替换为rw,没有就替换一下。</li>
<li>检查类的父类和metaClass是否已经realize,没有就先把它们先realize</li>
<li>重新layout ivar. 因为只有加载好了所有父类，才能确定ivar layout</li>
<li>把一些flags从ro拷贝到rw</li>
<li>链接class的 nextSiblingClass 链表</li>
<li>attach categories: 合并categories的method list、 properties、protocols到 class_rw_t 里面</li>
</ul>
</li>
<li>read categories：读取类目</li>
</ul>
<p>在<code>map_images</code>结束会调用<code>load_images</code>函数。这一步做的事情比较少，就是调用我们熟悉的<code>+(load)</code>函数。父类会先调用，除了 Class，每个类目的<code>+(load)</code>方法也会被调用一次，但顺序就不一定了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这里对 main 函数之前的操作做一个小总结吧：</p>
<ol>
<li>将 App 的 mach-o header 读取到内存中</li>
<li>根据 load commands 获取 dyld 的路径，运行 dyld</li>
<li>初始化运行环境，加载 dylib，如果缓存中存在则从缓存中拿出加载过的 image，否则新建一个 image，加载到内存中</li>
<li>修正指针(rebase)，绑定符号(bind)</li>
<li>初始化 dylib，运行 runtime</li>
<li>runtime 将 image 中有关 OBJC 的数据进行初始化</li>
<li>调用 +(load) 方法</li>
<li>dyld 调用 main 函数</li>
</ol>
<p>花了一周的时间用来研究这部分的内容，终于填完坑了<del>很舒服<br>最大的感受就是学习完后，看 clang 编译后的 C++ 代码能看懂的更多了。比如添加完一个类目之后，会将这个这个类目添加到__DATA的section <code>__objc_catlist</code>中，以前不知道啥意思现在就明白了。也明白 xcode 的许多设置是用来干嘛的，总之好处多多</del><br>学习也是一个递归的过程，加油跳出这个递归吧！</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/">iOS 程序 main 函数之前发生了什么</a><br><a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/#dyld-%E5%8A%A0%E8%BD%BD-dylib-%E6%96%87%E4%BB%B6">优化 App 的启动时间</a><br><a target="_blank" rel="noopener" href="https://turingh.github.io/2016/03/16/dyld%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90load/#0x03_%E5%B0%8F%E7%BB%93">dyld源码分析-动态加载load</a><br><a target="_blank" rel="noopener" href="https://blog.cnbluebox.com/blog/2017/06/20/dyldyu-objc/">dyld与ObjC</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-07-10T07:34:15.000Z" title="7/10/2019, 3:34:15 PM">2019-07-10</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">23 分钟读完 (大约3427个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/10/Objective-C%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/">Objective-C类和对象的内存分布</a></h1><div class="content"><p>之前在别人博客下面看到了一个问题，觉得挺有意思的。但是自己想回答的时候又发现好像有一些知识点还不是很熟悉，觉得有点迷糊，所以准备再研究一下底层再来回答问题。现在把这个坑填上吧。<br><img src="https://i.loli.net/2019/07/10/5d25955c660d280691.png"></p>
<h3 id="OC对象的指针类型"><a href="#OC对象的指针类型" class="headerlink" title="OC对象的指针类型"></a>OC对象的指针类型</h3><p><code>Objective-C </code>是一门动态语言，而动态语言是在运行时确定数据类型，变量使用之前不需要类型声明。但是我们在写代码的时候还是要给对象一个类型或者使用<code>id</code>的，我自己觉得这么做是为了通过编译（例如声明了类型为NSObject的实例sark，却调用了方法foo，那么编译就通不过了）。<br>实际上动态语言的一个特性<code>多态</code>就是这么实现的，即用父类的指针指向子类的实例。</p>
<h3 id="对象的内存分布"><a href="#对象的内存分布" class="headerlink" title="对象的内存分布"></a>对象的内存分布</h3><p>还是举个例子会明白一点。需要注意的是需要在<code>模拟器</code>上调试，在<code>真机</code>调试会有问题的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface Father : NSObject</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)foo &#123;</span><br><span class="line">    Father *father1 = [Father new];</span><br><span class="line">    father1.name = @&quot;001&quot;;</span><br><span class="line">    id father2 = [Father new];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>调试之前，我们要明白几点常识。在计算机中每个字节都是有一个地址的，每个字节有8个bit，每个bit可以存储1或者0，这8个bit就是这个字节的值。在小端系统中，低位的值存储在低地址上。<br>使用 x 命令调试。格式：<code>x/&lt;n/f/u&gt;  &lt;addr&gt;</code></p>
<ul>
<li>x 显示内存</li>
<li>n 正整数，表示需要显示的内存单元的个数</li>
<li>f 表示addr指向的内存内容的输出格式<ul>
<li>s: 对应输出字符串</li>
<li>x: 按十六进制格式显示变量</li>
<li>d: 按十进制格式显示变量</li>
<li>c: 按字符格式显示变量</li>
</ul>
</li>
<li>u 以多少个字节作为一个内存单元<ul>
<li>b: 1 byte</li>
<li>h: 2 bytes</li>
<li>w: 4 bytes</li>
<li>g: 8 bytes</li>
</ul>
</li>
</ul>
<p>打断点，然后输入命令: <code>x/8xg father1</code>, 即：以8个字节为一个单元，从 father1 指针的地址开始起8个单元的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x/8xg father1</span><br><span class="line">0x6000000128f0: 0x000000010be34050(Class) 0x000000010bdcc058(name)                            </span><br><span class="line">0x600000012900: 0x00006000000128a0 0x0000000100000002</span><br><span class="line">0x600000012910: 0x000000010f8f8e58 0x0000000000000000</span><br><span class="line">0x600000012920: 0x0000000000000000 0x0000000000000000</span><br><span class="line"></span><br><span class="line">(lldb) x/8xg father2</span><br><span class="line">0x600000012490: 0x000000010be34050(Class) 0x0000000000000000(name)</span><br><span class="line">0x6000000124a0: 0xbadd2dcdc19dbead 0x00006000000124f0</span><br><span class="line">0x6000000124b0: 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x6000000124c0: 0x00007f8ae3c140c0 0x00006080000092b0</span><br></pre></td></tr></table></figure>

<p>这里我提前将这些地址代表的意思标注好了。<br><code>father2</code>虽然是<code>id</code>类型的，但是它跟<code>father1</code>第一个8字节所存储的地址是相同的，都是<code>0x000000010be34050</code>。其实这个地址就是 <code>Father</code>类的地址。我们可以使用下面的方法验证：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po (Class)0x000000010be34050</span><br><span class="line">Father</span><br></pre></td></tr></table></figure>

<p>所以一个实例对象第一个8字节存储的是这个类的指针，那么后面的字节存储的是什么呢？答案是这个实例的成员变量，在上面的例子中我们给实例<code>father1</code>的成员变量<code>name</code>赋值了<code>001</code>, 现在让我们验证一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po (id)0x000000010bdcc058</span><br><span class="line">001</span><br></pre></td></tr></table></figure>
<p>因为我们没有对<code>father2</code>的成员变量 name 赋值，所以这8个字节的值是空的。</p>
<hr>
<p>打开 <a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">runtime 750版本源码</a>，查看 id 和 Class 的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_class</span> *Class;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_object</span> *id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_object</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">isa_t</span> isa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">isa_t</span> &#123;</span><br><span class="line">    <span class="built_in">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">isa_t</span>(<span class="type">uintptr_t</span> value) : <span class="built_in">bits</span>(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="type">uintptr_t</span> bits;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ISA_BITFIELD)</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        ISA_BITFIELD;  <span class="comment">// defined in isa.h</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_class</span> : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="type">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="type">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">data</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>id的定义很简单，是一个指向 objc_object 的指针，而 objc_object 只有一个私有成员变量 isa。objc_class 继承于 objc_object，所以你也可以用 id 来声明 Class 的变量，例如<code>id foo = [NSObject class];</code>。</li>
<li>isa是一个联合体，里面的 struct 在不同架构的CPU中定义是不同的。在 64 位CPU中，isa 可以用来存储更多的信息，例如引用计数，是否有关联对象等，可以看我的这篇博客<a target="_blank" rel="noopener" href="https://kikido.github.io/2019/07/03/Objective-C%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%8E%9F%E7%90%86/">Objective-C引用计数原理</a></li>
</ol>
<p>使用<code>clang rewrite-objc ViewController.m</code>将代码转化成C++实现，可以看到 Father 这个类变成了如下的结构体</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Father_IMPL &#123;</span><br><span class="line">	struct NSObject_IMPL NSObject_IVARS;</span><br><span class="line">	NSString *_name;</span><br><span class="line">&#125;;</span><br><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">	Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看到这个结构体你是不是就明白了为什么对象的内存分布是下图这个样子的？<br>需要<code>注意</code>的是，NSObject 的实例虽然理论上只有8个字节，但是它的实例实际上有 16 个字节，后面8个字节是空的。</p>
<p><img src="https://i.loli.net/2019/07/10/5d2597437203257924.png" alt="实例内存分布图"></p>
<p>研究到这里，我们就可以回答开头的那个问题了。</p>
<ol>
<li>指针的类型是id类型，而指针指向的类型可以是别的类。因为 OC 是动态语言，变量的类型需要在运行时才能够确定。</li>
<li>指针保存的是对象内存的首地址</li>
<li>64位平台中，对象首地址开始的8个字节存储的是类的指针。也就是通过这个才能确定该类的类型</li>
</ol>
<p>是不是很简单！下面继续让我们研究下 Class 的内存分布问题</p>
<h3 id="Class的内存分布"><a href="#Class的内存分布" class="headerlink" title="Class的内存分布"></a>Class的内存分布</h3><p>让我们继续回到之前的代码调试。上一节中我们已经知道了<code>Father</code>类的地址了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x/16xg 0x000000010be34050</span><br><span class="line">0x10be34050: 0x000000010be34028(meta-class) 0x000000010f8f8e58(superClass)                     </span><br><span class="line">0x10be34060: 0x00006000000972f0(bucket_t *_buckets) 0x0000000200000003(_mask &amp; _occupied )</span><br><span class="line">0x10be34070: 0x0000600000074302 0x000000010f8f8e08</span><br><span class="line">0x10be34080: 0x000000010f8f8e08 0x000000010f548520</span><br><span class="line">0x10be34090: 0x0000000000000000 0x000000010bdd7df0</span><br><span class="line">0x10be340a0: 0x000000010be34078 0x000000010f8f8e58</span><br><span class="line">0x10be340b0: 0x000000010f548520 0x0000000000000000</span><br><span class="line">0x10be340c0: 0x000000010bdd7e38 0x000000010f8f8e08</span><br></pre></td></tr></table></figure>

<p>PS: 注意不要使用<code>真机</code>来调试，因为我调试的时候发现跳不到那个内存地址中，但在<code>模拟器</code>中没这个问题…</p>
<p>配套的我们把 objc_class 的定义放到下面。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_class</span> : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="type">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="type">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">data</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 objc_class 继承于 objc_object，所以 Class 的第一个8字节还是 isa 指针，也就是一个指向元类(meta-Class)的指针。如果你不知道元类是什么意思的话就去百度，我也懒得讲了。第2个8字节储存的是指向父类的指针。先让我们验证一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lldb) po (Class)0x000000010be34028</span><br><span class="line">Father</span><br><span class="line"></span><br><span class="line">(lldb) po (Class)0x000000010f8f8e58</span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure>

<p>结论正确。让我们接着看<code>cache_t</code>的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">    struct bucket_t *_buckets;</span><br><span class="line">    mask_t _mask;</span><br><span class="line">    mask_t _occupied;</span><br><span class="line">&#125;</span><br><span class="line">struct bucket_t &#123;</span><br><span class="line">private:</span><br><span class="line">    // IMP-first is better for arm64e ptrauth and no worse for arm64.</span><br><span class="line">    // SEL-first is better for armv7* and i386 and x86_64.</span><br><span class="line">#if __arm64__</span><br><span class="line">    MethodCacheIMP _imp;</span><br><span class="line">    cache_key_t _key;</span><br><span class="line">#else</span><br><span class="line">    cache_key_t _key;</span><br><span class="line">    MethodCacheIMP _imp;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cache_t</code>关系到方法查找的缓存。当对实例发送消息后，会先到Class的缓存中查找有没有该方法的缓存，如果有则直接调用方法的实现，提高效率。<br> 大致可以看出，<code>bucket_t</code>是一个哈希表，根据<code>_key</code>找到其映射的方法实现<code>_imp</code>，而<code>_key</code>就是 SEL(方法的名字 const char *)。<code>cache_t</code>是中的<code>_mask</code>和<code>_occupied</code>是两个4字节的变量，应该代表的是缓存的数量。所以，Class 第三个8字节存储的是<code>bucket_t *</code>类型的指针，第4个8字节保存的是 _mask 和 _occupied。因为是小端，低位地址存储低位的数据，所以 _mask 的值是<code>0x00000003</code>，而 _occupied 的值是<code>0x00000002</code></p>
<p>接下来看 Class 的第3个成员变量<code>class_data_bits_t bits;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct class_data_bits_t &#123;</span><br><span class="line">    // Values are the FAST_ flags above.</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    </span><br><span class="line">    public:</span><br><span class="line">    class_rw_t* data() &#123;</span><br><span class="line">        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在64位下，uintptr_t 为8个字节。class_data_bits_t 的公共方法有很多，主要是配合掩码进行一些读写操作。<br>继续看<code>class_rw_t</code>的定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    // Be warned that Symbolication knows the layout of this structure.</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    char *demangledName;</span><br><span class="line"></span><br><span class="line">#if SUPPORT_INDEXED_ISA</span><br><span class="line">    uint32_t index;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在结构体中，你可以看到有一个成员变量的类型是<code>class_ro_t</code>，是不是很像<code>class_rw_t</code>。从字面意思上可以猜测，一个是readwriite，一个是readonly。因为 OC 是动态语言，可以在运行时添加方法和成员变量，运行时添加的方法或者成员变量就是添加到<code>class_rw_t</code>上的，而<code>class_ro_t</code>存储的是一些编译后Class的信息。<br>在<code>class_data_bits_t</code>的定义中，我们知道了需要掩码<code>FAST_DATA_MASK</code>才能得到 class_rw_t 的地址。下面是 <code>class_rw_t</code>的内存分布</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 得到class_rw_t的内存地址</span><br><span class="line">0x0000600000074302 &amp; 0x00007ffffffffff8 = 0x600000074300;</span><br><span class="line"></span><br><span class="line">(lldb) x/16xg 0x600000074300</span><br><span class="line">0x600000074300: 0x00000000800a0000(flags &amp; version) 0x000000010bdd7da8(ro)</span><br><span class="line">0x600000074310: 0x000000010bdd7d18(methods) 0x000000010bdd7d90(properties)                          </span><br><span class="line">0x600000074320: 0x0000000000000000(protocols) 0x000000010be33f60(firstSubclass)</span><br><span class="line">0x600000074330: 0x000000010ee88c68(nextSiblingClass) 0x0000000000000000(demangledName)</span><br><span class="line">0x600000074340: 0xbadd2dcdc19dbead 0x0000600000074240</span><br></pre></td></tr></table></figure>

<p>因为在代码中我还声明了一个 Father 的子类 Son，没想到在这里出现，没错，就是这个 firstSubclass。至于如果有多个子类，确定哪个是 firstSubclass 我就不清楚了。。。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po (Class)0x000000010be33f60</span><br><span class="line">Son</span><br></pre></td></tr></table></figure>

<p>再来看一下<code>class_ro_t</code>的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">class_ro_t</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="type">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="type">uint32_t</span> instanceSize;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="type">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * name;</span><br><span class="line">    <span class="type">method_list_t</span> * baseMethodList;</span><br><span class="line">    <span class="type">protocol_list_t</span> * baseProtocols;</span><br><span class="line">    <span class="type">const</span> <span class="type">ivar_list_t</span> * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="type">property_list_t</span> *baseProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是它的内存分布：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x/16xg 0x000000010bdd7da8</span><br><span class="line">0x10bdd7da8: 0x0000000800000184(flags &amp; instanceStart) 0x0000000000000010(instanceSize &amp; reserved)</span><br><span class="line">0x10bdd7db8: 0x000000010bd3ea79(ivarLayout) 0x000000010bd3eafc(name)</span><br><span class="line">0x10bdd7dc8: 0x000000010bdd7d18(baseMethodList) 0x0000000000000000(baseProtocols)</span><br><span class="line">0x10bdd7dd8: 0x000000010bdd7d68(ivars) 0x0000000000000000(weakIvarLayout)</span><br><span class="line">0x10bdd7de8: 0x000000010bdd7d90(baseProperties) 0x0000002800000081</span><br></pre></td></tr></table></figure>
<ol>
<li>可以看到 ro 的成员变量中有<code>instanceStart</code>和<code>instanceSize</code>。这两个值的作用是<code>非脆弱成员变量</code>。即如果基类如果增加了成员变量，不需要重新编译，只需要在初始化系统自动修改<code>instanceStart</code>和<code>instanceSize</code>的值，就能够继续使用子类。具体你可以看我的这篇博客 <a target="_blank" rel="noopener" href="https://kikido.github.io/2019/06/27/%E8%B0%88Objective-C%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/">谈Objective-C类成员变量</a></li>
<li>ivarLayout 记录了那些是 storng 的ivar</li>
<li>name 存储的是这个类的名字，你可以使用<code>po (char *)0x000000010bd3eafc</code>打印该名字</li>
<li>ivars 存储的是该类的成员变量(不包括关联对象)</li>
<li>weakIvarLayout  记录了哪一些是 weak 的ivar</li>
</ol>
<p> 还可以看到 ro 的<code>baseMethodList</code>和rw的<code>methods</code>的地址都是<code>0x000000010bdd7d18</code>，ro 的<code>baseProperties</code>和rw的<code>properties</code>的地址都是<code>0x000000010bdd7d90</code></p>
<blockquote>
<p>实际上 rw 的三个成员变量，<code>methods</code>, <code>properties</code>, <code>protocols</code>的类型都继承于<code>list_array_tt</code>，这个列表可能有以下3中值：1. 空值 2. 指向列表的指针 3. 指向列表的指针的数组。所以这就是为什么Class可以在类目中添加方法和协议，只需要在这个列表数组中再添加一个指向类目中方法和协议列表的指针就好了。<br>因为在这个实例中没有使用类目添加方法，所以rw中methods数组仅有一个值，这个值等于ro的baseMethodList。</p>
</blockquote>
<p> 先来研究<code>methods</code>。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> struct method_t &#123;</span><br><span class="line">    SEL name;</span><br><span class="line">    const char *types;</span><br><span class="line">    MethodListIMP imp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct method_list_t &#123;</span><br><span class="line">	uint32_t entsizeAndFlags;</span><br><span class="line">   uint32_t count;</span><br><span class="line">   method_t first;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">(lldb) x/16xg 0x000000010bdd7d18</span><br><span class="line">0x10bdd7d18: 0x000000030000001a(entsizeAndFlags &amp; count) 0x000000010f547965(name)</span><br><span class="line">0x10bdd7d28: 0x000000010bd41271(types) 0x000000010b7e01e0(imp)</span><br><span class="line">0x10bdd7d38: 0x000000010fd3a28e(name) 0x000000010bd41284(types)</span><br><span class="line">0x10bdd7d48: 0x000000010b7e0180(imp) 0x0000000112f11912(name)</span><br><span class="line">0x10bdd7d58: 0x000000010bd4128c(types) 0x000000010b7e01a0(imp)</span><br><span class="line">0x10bdd7d68: 0x0000000100000020 0x000000010be30c50</span><br><span class="line">0x10bdd7d78: 0x000000010bd19fc8 0x000000010bd4130b</span><br><span class="line">0x10bdd7d88: 0x0000000800000003 0x0000000100000010</span><br></pre></td></tr></table></figure>

<p><code>entsizeAndFlags</code> 第一个4字节保存的是 entsize 和标记, entsize 我的理解好像是method_t的长度。第二个4字节保存的是方法的数量，在上面的例子中我们可以知道一共保存了3个方法。后面保存了3个method_t的实例，每个实例占用了24个字节。每个 method_t 实例，第一个8字节为 sel，即方法名字；第二个8自己保存了方法的参数类型；第3个8字节是方法的函数指针。我们把上面保存的3个方法的信息按顺序打印出来</p>
<ul>
<li>.cxx_destruct  v16@0:8</li>
<li>name @16@0:8</li>
<li>setName: v24@0:8@16</li>
</ul>
<p>第2和第3个方法比较好理解，系统为我们自动生成了属性 name 的 getter 和 setter 方法。<br>第1个方法<code>cxx_destruct</code> 的作用是在delloc时释放该类的成员变量的，具体你可以看这篇博客 <a target="_blank" rel="noopener" href="https://kikido.github.io/2019/06/24/%E6%8E%A2%E7%A9%B6ARC%E4%B8%8Bdealloc%E5%AE%9E%E7%8E%B0/">探究ARC下dealloc实现</a></p>
<p>properties 与 methods 类似，因为继承与同一个结构体。这里简单分析一下，内存分布为 <code>entsizeAndFlags</code>(4字节), count(4字节)，property_t数组。property_t里面有两个成员变量，一个是属性的名字，一个是属性的属性。。。</p>
<hr>
<p>大致上这就是 Class 的内存分布了，下面这张图能够简要的概括了：</p>
<p><img src="https://i.loli.net/2019/07/10/5d25a602083b146585.png" alt="类的内存分布"></p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a target="_blank" rel="noopener" href="http://melonteam.com/posts/objectc_dui_xiang_nei_cun_bu_ju_fen_xi/">ObjectC对象内存布局分析</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-07-03T13:32:56.000Z" title="7/3/2019, 9:32:56 PM">2019-07-03</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">28 分钟读完 (大约4241个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/03/Objective-C%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%8E%9F%E7%90%86/">Objective-C引用计数原理</a></h1><div class="content"><p>在 Objective-C 2.0 中，我们无需手动进行内存管理，因为ARC会自动帮我们在编译的时候，在合适的地方对对象进行<code>retain</code>和<code>release</code>操作。<br>本文将结合<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">runtime 750版本源码</a> 探究 ARC 环境下引用计数的实现原理。</p>
<h3 id="如何存储引用计数"><a href="#如何存储引用计数" class="headerlink" title="如何存储引用计数"></a>如何存储引用计数</h3><p>从 5S 开始，iPhone 都采用了64位架构的处理器，为了节省内存和提高执行效率，苹果提出了Tagged Pointer的概念，专门用来存储小的对象，例如 NSNumber 和 NSDate。这一类变量本身的值需要占用的内存大小常常不需要8字节，拿整数来说，4个字节所能表示的有符号整数可以达到20多亿(2^31&#x3D;2147483648，另外 1 位作为符号位)，基本可以处理大多数情况。所以我们将一个对象的指针(64位下8字节)拆成两部分，一部分用来存储数据，另一部分作为特殊标记，表示这是一个 <code>Tagged Pointer</code>, 不指向任何一个地址。也就是当某些类使用 <code>Tagged Pointer</code> 来存储数据后，它就不是一个对象了，因为它并没有指向任何地址，变成了一个披着对象皮的普通变量而已，而对于这一类的‘对象’，它的内存是分配在<code>栈</code>中，由系统分配以及释放，所以它的引用计数也没有意义了，当然你仍然可以使用<code>CFGetRetainCount</code>方法去获取它的引用计数，返回的是它的指针地址。</p>
<p><img src="https://i.loli.net/2019/07/03/5d1caefd8837b15758.jpeg"></p>
<p>而在某些平台中(比如arm64)，isa 实例的一部分空间也会被用来存储引用计数，当引用计数超过一定值之后，runtime 会使用一张散列表(哈希表)来管理其引用计数；如果不使用 isa 存储引用计数则会直接存储到散列表中。</p>
<h3 id="isa-指针"><a href="#isa-指针" class="headerlink" title="isa 指针"></a>isa 指针</h3><p>用64位(8字节)来存储一个内存地址显然是种浪费，于是可以将一部分的空间用来存储引用计数。当 isa 指针第一位为1时即表示使用优化的 isa 指针，这里列出64位环境下的 isa 结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">isa_t</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="type">isa_t</span>(<span class="type">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="type">uintptr_t</span> bits;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __arm64__</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MASK        0x00000001fffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MAGIC_MASK  0x000003fe00000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MAGIC_VALUE 0x000001a400000001ULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">uintptr_t</span> indexed           : <span class="number">1</span>;</span><br><span class="line">        <span class="type">uintptr_t</span> has_assoc         : <span class="number">1</span>;</span><br><span class="line">        <span class="type">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        <span class="type">uintptr_t</span> shiftcls          : <span class="number">30</span>; <span class="comment">// MACH_VM_MAX_ADDRESS 0x1a0000000</span></span><br><span class="line">        <span class="type">uintptr_t</span> magic             : <span class="number">9</span>;</span><br><span class="line">        <span class="type">uintptr_t</span> weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        <span class="type">uintptr_t</span> deallocating      : <span class="number">1</span>;</span><br><span class="line">        <span class="type">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        <span class="type">uintptr_t</span> extra_rc          : <span class="number">19</span>;</span><br><span class="line"><span class="meta">#       <span class="keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line"><span class="meta">#       <span class="keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// SUPPORT_NONPOINTER_ISA</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>SUPPORT_NONPOINTER_ISA</code>表示是否支持在 isa 指针内添加额外的信息，例如引用计数，析构状态，被__weak变量引用的情况等。目前仅支持 <code>arm64</code>架构的设备支持。</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>indexed</td>
<td>0 表示普通的 isa 指针，1 表示可以存储引用计数</td>
</tr>
<tr>
<td>has_assoc</td>
<td>表示该对象是否包含 associated object(关联对象)</td>
</tr>
<tr>
<td>has_cxx_dtor</td>
<td>表示该对象是否有 C++ 的析构函数</td>
</tr>
<tr>
<td>shiftcls</td>
<td>类的指针</td>
</tr>
<tr>
<td>magic</td>
<td>固定值为 0xd2，用于在调试时分辨对象是否未完成初始化</td>
</tr>
<tr>
<td>weakly_referenced</td>
<td>表示该对象是否有过 weak 对象，如果没有，则析构时更快</td>
</tr>
<tr>
<td>deallocating</td>
<td>表示该对象是否正在析构</td>
</tr>
<tr>
<td>has_sidetable_rc</td>
<td>表示该对象的引用计数值是否过大无法存储在 isa 指针</td>
</tr>
<tr>
<td>extra_rc</td>
<td>存储引用计数值减一后的结果</td>
</tr>
</tbody></table>
<p>在64位环境下，isa 会存储引用计数，当 has_sidetable_rc 的值为1时，那么溢出的引用计数将会存储在一张全局散列表中，也就是<code>引用计数 = isa保存的引用计数 + 哈希表保存的引用计数 + 1</code>。后面会详细讲到。</p>
<h3 id="哈希表-DenseMap"><a href="#哈希表-DenseMap" class="headerlink" title="哈希表 DenseMap"></a>哈希表 DenseMap</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,<span class="type">size_t</span>,<span class="literal">true</span>&gt; RefcountMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> KeyT, <span class="keyword">typename</span> ValueT,</span><br><span class="line">         <span class="type">bool</span> ZeroValuesArePurgeable = <span class="literal">false</span>, </span><br><span class="line">         <span class="keyword">typename</span> KeyInfoT = DenseMapInfo&lt;KeyT&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> DenseMap</span><br><span class="line">    : <span class="keyword">public</span> DenseMapBase&lt;DenseMap&lt;KeyT, ValueT, ZeroValuesArePurgeable, KeyInfoT&gt;,</span><br><span class="line">                          KeyT, ValueT, KeyInfoT, ZeroValuesArePurgeable&gt; </span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br><span class="line">                          </span><br></pre></td></tr></table></figure>

<p>runtime 使用 DenseMap 哈希表(也叫散列表，类似NSDictionary)的别名<code>RefcountMap</code>来存储引用计数。DenseMap 继承于 DenseMapBase 这个 C++ 类，通过观察 DenseMapBase 的内部实现我们可以发现以下几点：</p>
<ul>
<li>键 KeyT 的类型为<code>DisguisedPtr&lt;objc_object&gt;</code>，这个类是对<code>objc_object *</code>指针及其一些操作进行的封装，目的是不受内存泄漏工具<code>leaks</code>的检测 </li>
<li>值 ValueT 的类型为 size_t, size_t在64位环境下等同于 unsigned long。保存的值等于<code>引用计数减一</code></li>
<li>模板的 KeyInfoT 类型为 DenseMapInfo<KeyT>，在这里等同于DenseMapInfo&lt;DisguisedPtr<objc_object>&gt;。DenseMapInfo 封装了比较<code>重要</code>的方法，用于在哈希表中查找 key 映射的内容</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DenseMapInfo</span>&lt;T*&gt; &#123;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">inline</span> T* <span class="title">getEmptyKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uintptr_t</span> Val = <span class="built_in">static_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;T*&gt;(Val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">inline</span> T* <span class="title">getTombstoneKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uintptr_t</span> Val = <span class="built_in">static_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;T*&gt;(Val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="title">getHashValue</span><span class="params">(<span class="type">const</span> T *PtrVal)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">ptr_hash</span>((<span class="type">uintptr_t</span>)PtrVal);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">isEqual</span><span class="params">(<span class="type">const</span> T *LHS, <span class="type">const</span> T *RHS)</span> </span>&#123; <span class="keyword">return</span> LHS == RHS; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>指针哈希算法实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __LP64__</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">ptr_hash</span><span class="params">(<span class="type">uint64_t</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    key ^= key &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    key *= <span class="number">0x8a970be7488fda55</span>;</span><br><span class="line">    key ^= __builtin_bswap64(key);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint32_t</span>)key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>虽然不完美，但是速度很快(注释说的。。。)</p>
<hr>
<blockquote>
<p>简单来讲，DenseMap 通过对象的指针地址来映射其引用计数</p>
</blockquote>
<h3 id="SideTable"><a href="#SideTable" class="headerlink" title="SideTable"></a>SideTable</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SideTable</span> &#123;</span></span><br><span class="line">    <span class="type">spinlock_t</span> slock;</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    <span class="type">weak_table_t</span> weak_table;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>介绍完存储引用计数的哈希表，那么这个哈希表是存储在哪里的呢？<br>答案是保存在一个叫做<code>SideTable</code>的结构体中，通过观察它的结构组成，我们可以可以看到有三个成员变量<code>slock</code>, <code>refcnts</code>和<code>weak_table</code>。</p>
<ul>
<li><code>slock</code>是一个自旋锁，保证线程安全</li>
<li><code>refcnts</code>的类型是 RefcountMap，也就是上一节提到过的 DenseMap 类型的别名。用来保存引用计数</li>
<li><code>weak_table</code>用来保存__weak修饰的指针。当一个对象 delloc 时，通过这个表将这些指向要释放对象的用__weak修饰的指针置为nil，避免野指针的情况出现。</li>
</ul>
<h3 id="StripedMap"><a href="#StripedMap" class="headerlink" title="StripedMap"></a>StripedMap</h3><p>知道引用计数的哈希表是保存在<code>SideTable</code>中，那么<code>SideTable</code>实例保存在哪里呢？<br>答案是在一个全局的<code>StripedMap&lt;SideTable *&gt;</code>类型的静态变量<code>SideTableBuf</code>中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alignas</span>(StripedMap&lt;SideTable&gt;) <span class="type">static</span> <span class="type">uint8_t</span> </span><br><span class="line">    SideTableBuf[<span class="built_in">sizeof</span>(StripedMap&lt;SideTable&gt;)];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">SideTableInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> (SideTableBuf) <span class="built_in">StripedMap</span>&lt;SideTable&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> StripedMap&lt;SideTable&gt;&amp; <span class="title">SideTables</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">reinterpret_cast</span>&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以在初始化时将 SideTableBuf 定义成 uint8_t 是因为方便计算内存大小，在<code>SideTables()</code>方法中我们可以看到<code>SideTableBuf</code>会被强制转换成<code>StripedMap&lt;SideTable&gt;*</code>类型。实际上 SideTableBuf 也是哈希表，根据指针地址映射到相应的<code>SideTable</code>类型的变量。下面是<code>StripedMap</code>这个类的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StripedMap</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">8</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">64</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PaddedT</span> &#123;</span><br><span class="line">        <span class="function">T value <span class="title">alignas</span><span class="params">(CacheLineSize)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    PaddedT array[StripeCount];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">indexForPointer</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p)</span> </span>&#123;</span><br><span class="line">        <span class="type">uintptr_t</span> addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(p);</span><br><span class="line">        <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[] (<span class="type">const</span> <span class="type">void</span> *p) &#123; </span><br><span class="line">        <span class="keyword">return</span> array[<span class="built_in">indexForPointer</span>(p)].value; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>StripedMap</code>中有一个<code>PaddedT</code>类型的数组array，在模拟器中容量为64，在真机中为8。<code>PaddedT</code>结构体大小为64个字节，其成员变量 value 的类型实际是我们之前传入 <code>SideTable</code>。当系统调用<code>SideTable&amp; table = SideTables()[]</code>时首先会执行<code>SideTables()</code>得到SideTableBuf， 然后在StripedMap中执行<code>T&amp; operator[] (const void *p)</code>方法获取相应的SideTable。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T&amp; operator[] (const void *p) &#123; </span><br><span class="line">        return array[indexForPointer(p)].value; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">static unsigned int indexForPointer(const void *p) &#123;</span><br><span class="line">    uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(p);</span><br><span class="line">    return ((addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)) % StripeCount;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在<code>indexForPointer()</code>函数中返回相应 SideTable 的index。<code>(addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)</code>这一步我也不是很懂，应该是类似于产生一个随机数，后面的<code>% StripeCount</code>返回一个 [0, StripeCount)的数，也就是相应 SideTable 的index。所以一个 SideTable 应该是对应许多的对象的。</p>
<hr>
<blockquote>
<p>保存引用计数的哈希表保存在<code>SideTable</code>结构体中，而<code>SideTable</code>保存在一个全局的静态变量<code>StripedMap&lt;SideTable&gt; SideTableBuf</code>中。在真机下，SideTableBuf能够储存8个<code>SideTable</code>实例。<code>StripedMap</code>的方法<code>indexForPointer()</code>通过对象的指针计算出相应 SideTable 的 index。一个 SideTable 对应多个对象</p>
</blockquote>
<h3 id="获取引用计数"><a href="#获取引用计数" class="headerlink" title="获取引用计数"></a>获取引用计数</h3><p>在 ARC 环境下我们可以使用方法<code>CFGetRetainCount</code>得到对象的引用计数。在 runtime 中，通过调用<code>objc_object</code>的<code>rootRetainCount()</code>获取引用计数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uintptr_t</span> </span></span><br><span class="line"><span class="function"><span class="title">objc_object::rootRetainCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span> (<span class="type">uintptr_t</span>)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sidetable_lock</span>();</span><br><span class="line">    <span class="type">isa_t</span> bits = <span class="built_in">LoadExclusive</span>(&amp;isa.bits);</span><br><span class="line">    <span class="built_in">ClearExclusive</span>(&amp;isa.bits);</span><br><span class="line">    <span class="keyword">if</span> (bits.nonpointer) &#123;</span><br><span class="line">        <span class="type">uintptr_t</span> rc = <span class="number">1</span> + bits.extra_rc;</span><br><span class="line">        <span class="keyword">if</span> (bits.has_sidetable_rc) &#123;</span><br><span class="line">            rc += <span class="built_in">sidetable_getExtraRC_nolock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sidetable_unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sidetable_unlock</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sidetable_retainCount</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>isTaggedPointer</code>在前面我们已经分析过了如果是<code>Tagged Pointer</code>类型的对象时是怎么样的。此时对象在栈中分配，由系统自动销毁内存(先进后出）,所以此时对它求引用计数返回其地址。<br>下面让我们重点看一下<code>sidetable_retainCount()</code>这个方法</li>
<li>当 isa 的 nonpointer &#x3D; 1 的情况我们开头也分析过了，此时 isa 指针也用来存储引用计数，如果引用计数溢出则将溢出部分存储在哈希表中</li>
<li>下面让我们研究一下不使用isa优化是怎么从哈希表中获取引用计数的</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">objc_object::sidetable_retainCount()</span><br><span class="line">&#123;</span><br><span class="line">    SideTable&amp; table = SideTables()[this];</span><br><span class="line"></span><br><span class="line">    size_t refcnt_result = 1;</span><br><span class="line">    </span><br><span class="line">    table.lock();</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(this);</span><br><span class="line">    if (it != table.refcnts.end()) &#123;</span><br><span class="line">        // this is valid for SIDE_TABLE_RC_PINNED too</span><br><span class="line">        refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">    return refcnt_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol>
<li>首先得到 SideTable 实例。</li>
<li>成员变量 refcnts 就是之前说的保存引用计数的哈希表，在哈希表中根据指针值查找引用计数。</li>
<li><code>it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT</code> 注意result从第三位才开始保存数据，所以需要将数据向右移动2位才能取到引用计数。第1位用来保存该对象是否被用__weak修饰的变量引用，第2位用来表示该对象是否正在析构</li>
<li>将右移后得到的数+1(refcnt_result)后返回。这也是为什么之前说哈希表保存的引用计数是实际值 -1 之后的值的原因。</li>
</ol>
<h3 id="Retain"><a href="#Retain" class="headerlink" title="Retain"></a>Retain</h3><p>在非 ARC 环境中可以使用<code>retain</code>和<code>release</code>方法对引用计数进行加减操作，在 ARC 环境中我们无需也无法使用这两个方法操作引用计数，但是你可以使用<code>CFRetain()</code>对对象进行 retain 操作。最终会调用 <code>objc_object</code>的<code>rootRetain</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> id </span></span><br><span class="line"><span class="function"><span class="title">objc_object::rootRetain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!UseGC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sidetable_retain</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>类似于上一节中获取引用计数的方法，当对象属于<code>Tagged Pointer</code>时则返回该对象。所以我们接着看<code>sidetable_retain()</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_object::sidetable_retain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    <span class="built_in">assert</span>(!isa.nonpointer);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    SideTable&amp; table = <span class="built_in">SideTables</span>()[<span class="keyword">this</span>];</span><br><span class="line">    </span><br><span class="line">    table.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="type">size_t</span>&amp; refcntStorage = table.refcnts[<span class="keyword">this</span>];</span><br><span class="line">    <span class="keyword">if</span> (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        refcntStorage += SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    table.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先得到 SideTable 实例。从实例中得到存储引用技术的哈希表<code>refcnts</code>，在哈希表中根据对象的地址找到对应的引用计数<code>refcntStorage</code>，判断引用计数的值是否有溢出，如果没有则对引用计数 + 1，返回对象。<br>上一节我们讲过 refcntStorage 中第三位才开始用来存储引用计数，所以读数时需要先往右边移动两位，那为什么这里的代码没有呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIDE_TABLE_DEALLOCATING      (1UL&lt;&lt;1)  <span class="comment">// MSB-ward of weak bit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIDE_TABLE_RC_ONE            (1UL&lt;&lt;2)  <span class="comment">// MSB-ward of deallocating bit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIDE_TABLE_RC_PINNED         (1UL&lt;&lt;(WORD_BITS-1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIDE_TABLE_RC_SHIFT 2</span></span><br></pre></td></tr></table></figure>

<p>注意观察<code>SIDE_TABLE_RC_ONE</code>的定义，是一个8字节的 unsigned long 类型，值为1，向左偏移了两位。<code>refcntStorage += SIDE_TABLE_RC_ONE</code>两者相加的话则直接从第三位开始相加了，所以可以使用 SIDE_TABLE_RC_ONE 对引用计数进行 +1 和 -1 操作。<br>同样的，在上面的代码中, <code>SIDE_TABLE_RC_PINNED</code>用来判断引用计数值是否有溢出。</p>
<h3 id="Release"><a href="#Release" class="headerlink" title="Release"></a>Release</h3><p>release 最终会调用 <code>objc_object</code>的方法<code>rootRelease()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> </span></span><br><span class="line"><span class="function"><span class="title">objc_object::rootRelease</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sidetable_release</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uintptr_t</span> <span class="title">objc_object::sidetable_release</span><span class="params">(<span class="type">bool</span> performDealloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    <span class="built_in">assert</span>(!isa.nonpointer);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    SideTable&amp; table = <span class="built_in">SideTables</span>()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> do_dealloc = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    table.<span class="built_in">lock</span>();</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.<span class="built_in">find</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it == table.refcnts.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        do_dealloc = <span class="literal">true</span>;</span><br><span class="line">        table.refcnts[<span class="keyword">this</span>] = SIDE_TABLE_DEALLOCATING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) &#123;</span><br><span class="line">        <span class="comment">// SIDE_TABLE_WEAKLY_REFERENCED may be set. Don&#x27;t change it.</span></span><br><span class="line">        do_dealloc = <span class="literal">true</span>;</span><br><span class="line">        it-&gt;second |= SIDE_TABLE_DEALLOCATING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        it-&gt;second -= SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    table.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">if</span> (do_dealloc  &amp;&amp;  performDealloc) &#123;</span><br><span class="line">        ((<span class="built_in">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_dealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> do_dealloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法你可以知道为什么哈希表中保存的引用计数是实际值 -1 之后的值。<br><code>it-&gt;second &lt; SIDE_TABLE_DEALLOCATING</code>用来判断保存的引用计数值是否小于1，如果小于1的话则对该值标记为正在析构：<code>it-&gt;second |= SIDE_TABLE_DEALLOCATING;</code>，并且在随后对该对象发送 delloc 消息。<br>举个例子，一个对象 sark，实际的引用计数为1，在哈希表中保存的值为0，当这个对象进行<code>release</code>操作后，sark 的引用计数变成了0，也就是需要进行销毁操作了。而到了该方法中，会判断保存的引用计数的值是否小于1，如果是的话则进行 delloc 操作，并且将哈希表中存储的值标记为<code>正在析构</code>状态。而 sark 原先保存着的引用计数值就是 &#x3D;0，这样设计避免了在哈希表存储的引用计数出现负数的情况。</p>
<h3 id="alloc，new，-copy-和-mutableCopy"><a href="#alloc，new，-copy-和-mutableCopy" class="headerlink" title="alloc，new， copy 和 mutableCopy"></a>alloc，new， copy 和 mutableCopy</h3><p><code>copy</code> 以及 <code>mutableCopy</code>是<code>NSCopying</code>和<code>NSMutableCopying </code>协议上的方法，需要在各类上自己去实现<code>copyWithZone: </code>和<code>mutableCopyWithZone:</code>方法。无论是深拷贝还是浅拷贝都会增加引用计数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (id)new &#123;</span><br><span class="line">    return [callAlloc(self, false/*checkNil*/) init];</span><br><span class="line">&#125;</span><br><span class="line">+ (id)alloc &#123;</span><br><span class="line">    return _objc_rootAlloc(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>[cls alloc]</code>以及<code>[cls allocWithZone:nil]</code>方法最终会调用<code>callAlloc()</code>方法，所以 alloc 和 new 这两个方法后面都会调用<code>callAlloc()</code>这个方法,因为 Objective-C 2.0 忽视垃圾回收和 NSZone，那么后续的调用顺序依次是为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">callAlloc()</span><br><span class="line">class_createInstance()</span><br><span class="line">_class_createInstanceFromZone</span><br><span class="line">calloc()</span><br></pre></td></tr></table></figure>

<p><code>calloc()</code>函数相比于<code>malloc()</code>函数的优点是它将分配的内存区域初始化为0，相当于<code>malloc()</code>后再用<code>memset()</code>方法初始化一遍。</p>
<h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>其实这一节是对上一节内容的补充。<br>记得我刚出来工作的时候，单例是这样写的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Son</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)shareManager</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> Son *son;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        son = [<span class="variable language_">super</span> allocWithZone:<span class="literal">nil</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> son;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> shareManager];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>当时组长问我为什么要这样子写(因为跟他们写的方式不一样)，我也答不上来，因为这种代码都是直接google的。但是看了<code>callAlloc()</code>实现之后我明白为什么了。<br>在上一节我们已经知道了 alloc 和 new 都会接着调用<code>callAlloc()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> ALWAYS_INLINE id</span></span><br><span class="line"><span class="function"><span class="title">callAlloc</span><span class="params">(Class cls, <span class="type">bool</span> checkNil, <span class="type">bool</span> allocWithZone=<span class="literal">false</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(checkNil &amp;&amp; !cls)) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(!cls-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">hasCustomAWZ</span>())) &#123;</span><br><span class="line">        <span class="comment">// No alloc/allocWithZone implementation. Go straight to the allocator.</span></span><br><span class="line">        <span class="comment">// fixme store hasCustomAWZ in the non-meta class and </span></span><br><span class="line">        <span class="comment">// add it to canAllocFast&#x27;s summary</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fastpath</span>(cls-&gt;<span class="built_in">canAllocFast</span>())) &#123;</span><br><span class="line">            <span class="comment">// No ctors, raw isa, etc. Go straight to the metal.</span></span><br><span class="line">            <span class="type">bool</span> dtor = cls-&gt;<span class="built_in">hasCxxDtor</span>();</span><br><span class="line">            id obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, cls-&gt;bits.<span class="built_in">fastInstanceSize</span>());</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!obj)) <span class="keyword">return</span> <span class="built_in">callBadAllocHandler</span>(cls);</span><br><span class="line">            obj-&gt;<span class="built_in">initInstanceIsa</span>(cls, dtor);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Has ctor or raw isa or something. Use the slower path.</span></span><br><span class="line">            id obj = <span class="built_in">class_createInstance</span>(cls, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!obj)) <span class="keyword">return</span> <span class="built_in">callBadAllocHandler</span>(cls);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// No shortcuts available.</span></span><br><span class="line">    <span class="keyword">if</span> (allocWithZone) <span class="keyword">return</span> [cls allocWithZone:nil];</span><br><span class="line">    <span class="keyword">return</span> [cls alloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果类重载了<code>allocWithZone</code>方法，那么<code>cls-&gt;ISA()-&gt;hasCustomAWZ()</code>将会返回YES，也就是说当我们用<code>alloc</code>或者<code>new</code>创建实例的时候，就不会走系统的方法，而会走重载的<code>allocWithZone</code>方法了。我们在重载<code>allocWithZone</code>方法时返回<code>[self shareManager]</code>（注意此时的self代表Son类）, 因为<code>shareManager</code>方法返回的是一个静态变量。</p>
<p>还有一个需要注意的点就是在<code>shareManager</code>中，我们使用<code>son = [super allocWithZone:nil];</code>初始化实例，为什么不使用<code>son = [[super alloc] init];</code>来初始化呢？<br>代码中的<code>[super alloc];</code>在编译后会变成<code>objc_msgSendSuper(objc_super super, @selector(alloc))</code>(大致意思是这样)。其中<code>objc_super</code>是一个结构体，只有两个成员变量<code>id receiver</code>和<code>Class class</code>，receiver 仍是 self（Son类）， class 为 Father类。当我们想通过<code>[super alloc]</code>创建实例的时候，会从 Father类中查找 +alloc 方法，如果没有实现则在 NSObject 中查找 +alloc 方法。而方法里面的参数 self 仍旧为 Son 类而不是 Father 类，所以还是会去调用重载的<code>allocWithZone</code>方法，导致死循环。</p>
<!--### 自动释放池 AutoreleasePool

在 ARC 中，AutoreleasePool 其实是一个已`AutoreleasePoolPage`为节点的双向链表。

- 每一个线程的都有一个相对应的 AutoreleasePool，AutoreleasePoolPage 的成员变量`pthread_t const thread;`即为指向该线程的指针
- AutoreleasePoolPage

```

```-->
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2015/12/06/The-Principle-of-Refenrence-Counting/">Objective-C 引用计数原理</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-06-28T06:10:55.000Z" title="6/28/2019, 2:10:55 PM">2019-06-28</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">16 分钟读完 (大约2351个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/06/28/%E8%B0%88Objective-C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/">谈Objective-C关联对象</a></h1><div class="content"><h3 id="前言"><a href="#前言" class="headerlink" title="#前言"></a>#前言</h3><p>前不久刚写了 <a target="_blank" rel="noopener" href="https://kikido.github.io/2019/06/27/%E8%B0%88Objective-C%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/">谈Objective-C类成员变量</a> ，分析了成员变量的实现原理以及不能动态添加的原因，在这篇文章里我们来根据  <a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">objc4-646.tar.gz版本</a> 源码来谈一下 Objective-C 关联对象的实现原理。</p>
<p>关联对象(Associated Objects)是 Objective-C 2.0运行时的一个特性，起始于OS X Snow Leopard和iOS 4。它允许开发者对已经存在的类在扩展中添加自定义的属性。相关参考可以查看 <code>&lt;objc/runtime.h&gt;</code> 中定义的三个允许你将任何键值在运行时关联到对象上的函数：</p>
<ul>
<li>void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) 用于给对象添加关联属性，传入nil则移除已有的关联对象</li>
<li>id objc_getAssociatedObject(id object, const void *key) 用于获取关联属性</li>
<li>void objc_removeAssociatedObjects(id object) 移除一个对象所有的关联属性，但不建议手动调用这个函数，因为这可能会导致其它人对其添加的属性也被移除了。你可以调用<code>objc_setAssociatedObject</code>方法并传入nil来指定移除某个关联</li>
</ul>
<p>下面分析一下 <code>objc_setAssociatedObject</code> 两个参数 <code>key</code> 和 <code>policy</code></p>
<h3 id="key"><a href="#key" class="headerlink" title="#key"></a>#key</h3><p>通常来说该属性应该是常量、唯一的，在getter和setter方法中都可以访问到。这里有两种常见的添加方式：</p>
<p>第一种是添加 static char 类型的变量，当然更推荐是指针型的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">char</span> kAssociatedObjectKey;</span><br><span class="line">- (<span class="type">void</span>)setMenber:(<span class="built_in">NSString</span> *)menber &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;kAssociatedObjectKey, menber, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然更<em>推荐</em>的是使用更简单的方式实现：用 selector(getter方法)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setMenber:(<span class="built_in">NSString</span> *)menber &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(menber), menber, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关联策略-policy"><a href="#关联策略-policy" class="headerlink" title="#关联策略 policy"></a>#关联策略 policy</h3><p>关联策略跟属性修饰符的使用方法差不多，属性可以根据定义在 objc_AssociationPolicy 上的类型被关联到对象上：</p>
<table>
<thead>
<tr>
<th>关联策略</th>
<th>等价属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>OBJC_ASSOCIATION_ASSIGN</td>
<td>@property (assign)或 @property (unsafe_unretained)</td>
<td>弱引用关联对象</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td>@property (nonatomic, strong)</td>
<td>强引用关联对象，且为非原子操作</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td>@property (nonatomic, copy)</td>
<td>复制关联对象，且为非原子操作</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN</td>
<td>@property (atomic, strong)</td>
<td>强引用关联对象，且为原子操作</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY</td>
<td>@property (atomic, copy)</td>
<td>复制关联对象，且为原子操作</td>
</tr>
</tbody></table>
<h3 id="关联对象实现"><a href="#关联对象实现" class="headerlink" title="#关联对象实现"></a>#关联对象实现</h3><p>下面让我们具体来分析一下这几个函数的具体实现吧！</p>
<h4 id="分析objc-setAssociatedObject实现"><a href="#分析objc-setAssociatedObject实现" class="headerlink" title="分析objc_setAssociatedObject实现"></a>分析objc_setAssociatedObject实现</h4><p>在<code>objc_setAssociatedObject</code>的实现被定义在<code>objc-auto.mm</code>文件 467 行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GC_RESOLVER</span>(objc_setAssociatedObject)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GC_RESOLVER(name)                                       \</span></span><br><span class="line"><span class="meta">    OBJC_EXPORT void *name##_resolver(void) __asm__(<span class="string">&quot;_&quot;</span> #name); \</span></span><br><span class="line"><span class="meta">    void *name##_resolver(void)                                 \</span></span><br><span class="line"><span class="meta">    &#123;                                                           \</span></span><br><span class="line"><span class="meta">        __asm__(<span class="string">&quot;.symbol_resolver _&quot;</span> #name);                    \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (UseGC) return (void*)name##_gc;                     \</span></span><br><span class="line"><span class="meta">        <span class="keyword">else</span> return (void*)name##_non_gc;                       \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>## 符号: 连接宏。举个例子：<code>#define COMMAND(A, B) A##B</code> ， int COMMAND(temp, Int) &#x3D; 10 等同于 int tempInt &#x3D; 10</li>
<li>UseGC 是否使用垃圾回收，在 iPhone 平台上被定义为 NO<br> 所以这个宏展开来为下面的代码</li>
</ul>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GC_RESOLVER</span><span class="params">(name)</span>                                 </span></span><br><span class="line"><span class="function"></span>&#123;                                                           </span><br><span class="line">   <span class="keyword">return</span> (<span class="type">void</span>*)<span class="built_in">objc_setAssociatedObject_non_gc</span>();                       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>objc_setAssociatedObject_non_gc</code>的实现在<code>objc-runtime.m</code>文件，再经过一些跳转，可以发现 objc_setAssociatedObject 最终会调用 <code>_object_set_associative_reference</code>方法 （objc-runtime.m 268行）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _object_set_associative_reference(id object, <span class="type">void</span> *key, id value, <span class="type">uintptr_t</span> policy) &#123;</span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    <span class="function">ObjcAssociation <span class="title">old_association</span><span class="params">(<span class="number">0</span>, nil)</span></span>;</span><br><span class="line">    id new_value = value ? <span class="built_in">acquireValue</span>(value, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.associations())</span></span>;</span><br><span class="line">        <span class="type">disguised_ptr_t</span> disguised_object = <span class="built_in">DISGUISE</span>(object);</span><br><span class="line">        <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">            <span class="comment">// break any existing association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.<span class="built_in">find</span>(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i != associations.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="comment">// secondary table exists</span></span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;<span class="built_in">find</span>(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = <span class="built_in">ObjcAssociation</span>(policy, new_value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    (*refs)[key] = <span class="built_in">ObjcAssociation</span>(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// create the new association (first time).</span></span><br><span class="line">                ObjectAssociationMap *refs = <span class="keyword">new</span> ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = <span class="built_in">ObjcAssociation</span>(policy, new_value);</span><br><span class="line">                object-&gt;<span class="built_in">setHasAssociatedObjects</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// setting the association to nil breaks the association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.<span class="built_in">find</span>(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i !=  associations.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;<span class="built_in">find</span>(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;<span class="built_in">erase</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line">    <span class="keyword">if</span> (old_association.<span class="built_in">hasValue</span>()) <span class="built_in">ReleaseValue</span>()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>AssociationsManager manager;</code>, 会创建一个<code>AssociationsManager</code>结构体的变量 manager，在调用它的构造函数时会上锁，调用析构函数时解锁。结构体内有一个静态变量 <code>AssociationsHashMap</code>, 懒加载该变量。</li>
<li>DISGUISE(object) 用来获取 object 的指针地址</li>
<li><code>AssociationsHashMap</code>是一个无序的哈希表，维护了从对象地址到 ObjectAssociationMap 的映射</li>
<li>ObjectAssociationMap 是一个map，维护了从 key 到 ObjcAssociation 的映射</li>
<li>ObjcAssociation 是一个 C++ 类， 主要包括两个成员变量：uintptr_t _policy(关联策略) id _value(关联对象的值)</li>
</ul>
<p>简单的讲解上面那个函数的流程：</p>
<blockquote>
<ol>
<li>新建一个 AssociationsManager 实例 manager，同时上锁。通过 manager 得到 AssociationsHashMap 关联哈希表 associations，通过 DISGUISE()函数得到 object 的指针 disguised_object。在哈希表 associations 中 根据 disguised_object 查找 ObjectAssociationMap，如果没有则新建一个 refs。</li>
<li>新建一个 ObjcAssociation 实例 new_association，存储在 refs 中</li>
<li>如果传入的value是nil，则在 refs 移除该映射关系</li>
<li>释放掉旧的 old_association</li>
<li>作用域结束释放掉 manager，解锁</li>
</ol>
</blockquote>
<p><img src="https://i.loli.net/2019/06/28/5d15d6bfbe06f14691.png" alt="添加关联对象流程图"></p>
<h4 id="分析objc-getAssociatedObject实现"><a href="#分析objc-getAssociatedObject实现" class="headerlink" title="分析objc_getAssociatedObject实现"></a>分析objc_getAssociatedObject实现</h4><p>按照上一节的流程，我们首先找到 objc_getAssociatedObject 的最终实现源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">id _object_get_associative_reference(id object, <span class="type">void</span> *key) &#123;</span><br><span class="line">    id value = nil;</span><br><span class="line">    <span class="type">uintptr_t</span> policy = OBJC_ASSOCIATION_ASSIGN;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.associations())</span></span>;</span><br><span class="line">        <span class="type">disguised_ptr_t</span> disguised_object = <span class="built_in">DISGUISE</span>(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.<span class="built_in">find</span>(disguised_object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j = refs-&gt;<span class="built_in">find</span>(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs-&gt;<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ObjcAssociation &amp;entry = j-&gt;second;</span><br><span class="line">                value = entry.<span class="built_in">value</span>();</span><br><span class="line">                policy = entry.<span class="built_in">policy</span>();</span><br><span class="line">                <span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((<span class="built_in">id</span>(*)(id, SEL))objc_msgSend)(value, SEL_retain);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span><br><span class="line">        ((<span class="built_in">id</span>(*)(id, SEL))objc_msgSend)(value, SEL_autorelease);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码量比上一节少了还挺多哈，过程也类似，就不讲的很细了</p>
<blockquote>
<ol>
<li>先得到 AssociationsHashMap 实例 associations（静态变量）。根据 object 的指针地址，在 associations 得到映射的 ObjectAssociationMap refs。</li>
<li>在 refs 根据 key 得到映射的 ObjcAssociation 实例 entry，在 entry 中可以得到成员变量 _value，也就是我们所关联属性的值。</li>
<li>根据关联策略 policy 进行相应的操作(autorelease, retain)后返回 value</li>
</ol>
</blockquote>
<h4 id="分析objc-removeAssociatedObjects实现"><a href="#分析objc-removeAssociatedObjects实现" class="headerlink" title="分析objc_removeAssociatedObjects实现"></a>分析objc_removeAssociatedObjects实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _object_remove_assocations(id object) &#123;</span><br><span class="line">    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.associations())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (associations.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">disguised_ptr_t</span> disguised_object = <span class="built_in">DISGUISE</span>(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.<span class="built_in">find</span>(disguised_object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// copy all of the associations that need to be removed.</span></span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            <span class="keyword">for</span> (ObjectAssociationMap::iterator j = refs-&gt;<span class="built_in">begin</span>(), end = refs-&gt;<span class="built_in">end</span>(); j != end; ++j) &#123;</span><br><span class="line">                elements.<span class="built_in">push_back</span>(j-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// remove the secondary table.</span></span><br><span class="line">            <span class="keyword">delete</span> refs;</span><br><span class="line">            associations.<span class="built_in">erase</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the calls to releaseValue() happen outside of the lock.</span></span><br><span class="line">    for_each(elements.<span class="built_in">begin</span>(), elements.<span class="built_in">end</span>(), <span class="built_in">ReleaseValue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实不看代码应该也能够猜出个大概了吧.</p>
<ol>
<li>根据 object地址 找到映射的 refs，遍历 refs，将保存着的 value 保存在 <code>vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements</code></li>
<li>删除 refs， 然后一个个的释放 elements 里面的值</li>
</ol>
</blockquote>
<h3 id="给类对象关联对象"><a href="#给类对象关联对象" class="headerlink" title="#给类对象关联对象"></a>#给类对象关联对象</h3><p>看完源代码后，我们知道实例对象地址与 ObjectAssociationMap map是一一对应的。那么是否可以给类对象添加关联对象呢？<br>答案是<em>可以</em>，因为Class也是一个对象，我们完全可以用同样的方式给类对象添加关联对象，只不过我们一般情况下不会这样做，因为更多时候可以通过 static 变量来实现类级别的变量。</p>
<p>你可以通过下面的代码这样操作</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">AssociatedObject</span>)</span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)associatedObject &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(associatedObject));</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="type">void</span>)setAssociatedObject:(<span class="built_in">NSString</span> *)associatedObject &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(associatedObject), associatedObject, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>) foo &#123;</span><br><span class="line">    <span class="built_in">NSObject</span>.associatedObject = <span class="string">@&quot;associatedObject&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="何时释放关联对象"><a href="#何时释放关联对象" class="headerlink" title="#何时释放关联对象"></a>#何时释放关联对象</h3><p>在 <a target="_blank" rel="noopener" href="https://kikido.github.io/2019/06/24/%E6%8E%A2%E7%A9%B6ARC%E4%B8%8Bdealloc%E5%AE%9E%E7%8E%B0/">探究ARC下dealloc实现</a> 中我们研究过，当对象引用计数变为0时会调用 dealloc 方法，然后最终调用 <code>objc_destructInstance</code> 方法来执行释放所有<code>__weak</code>修饰的指向该对象的指针，释放关联对象，释放该对象成员变量的操作</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *objc_destructInstance(<span class="type">id</span> obj) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="type">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        <span class="type">bool</span> assoc = !UseGC &amp;&amp; obj-&gt;hasAssociatedObjects();</span><br><span class="line">        <span class="type">bool</span> dealloc = !UseGC;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) object_cxxDestruct(obj);</span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);</span><br><span class="line">        <span class="keyword">if</span> (dealloc) obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _object_remove_assocations(<span class="type">id</span> object) &#123;</span><br><span class="line">    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        <span class="keyword">if</span> (associations.size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            <span class="comment">// copy all of the associations that need to be removed.</span></span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            <span class="keyword">for</span> (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123;</span><br><span class="line">                elements.push_back(j-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// remove the secondary table.</span></span><br><span class="line">            delete refs;</span><br><span class="line">            associations.erase(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the calls to releaseValue() happen outside of the lock.</span></span><br><span class="line">    for_each(elements.begin(), elements.end(), ReleaseValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是有点熟悉呢，在上上节中我们刚刚分析过这个方法。当对象 dealloc 时，会自动调用 <code>objc_removeAssociatedObjects</code> 方法来释放所有的关联对象。</p>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="#总结一下"></a>#总结一下</h3><ul>
<li>类实例跟关联对象(关联的属性)并没有直接的存储关系，关联对象在创建时后存储在一个静态哈希表中，根据类实例的指针映射到该关联对象</li>
<li>当类实例 dealloc 后，会从哈希表中释放该实例的所有的关联对象</li>
<li>关联对象的关联策略跟属性的修饰符非常的相似，要合理使用避免 crash</li>
<li>比起其他解决问题的方法，关联对象应该被视为最后的选择</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="#引用"></a>#引用</h3><ul>
<li><a target="_blank" rel="noopener" href="https://nshipster.cn/associated-objects/">Associated Objects</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-06-27T06:39:18.000Z" title="6/27/2019, 2:39:18 PM">2019-06-27</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">18 分钟读完 (大约2697个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/06/27/%E8%B0%88Objective-C%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/">谈Objective-C类成员变量</a></h1><div class="content"><h3 id="我是前言"><a href="#我是前言" class="headerlink" title="#我是前言"></a>#我是前言</h3><p>Objective-C 是一门动态语言，所以它总是将一些决定工作从编译延迟到运行时，也就是说只有编译器是不够的，还需要一个运行时系统来执行编译后的代码。这就是 runtime 存在的意义，它是 Objective-C 框架的一块基石。<br>runtime 有两个版本：modeen 和 leagcy，我们现在使用的是 modern 版的。<br>本文 runtime 源码为<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">objc4-646.tar.gz版本</a></p>
<p>在老版本的 runtime 中，如果修改了<em>基类</em>的成员变量布局（比如增加成员变量），<em>子类</em>需要重新编译。</p>
<p><img src="https://i.loli.net/2019/06/27/5d1466cdd97f541342.png" alt="父类NSObject，子类MyObject成员变量布局"></p>
<p>如果苹果发布了新的 iOS SDK，NSObject 增加了几个成员变量，那么我们原先的代码将无法运行。因为 MyObject 成员变量布局在编译时就确定了，父类新增的成员变量的地址跟子类成员变量的内存区域重叠了。此时，我们只能重新编译 MyObject 的代码，程序才能在新版本系统上运行。如果 MyObject 存在于别人编写的静态库，那我们只能希望作者快点发布新版本了。</p>
<p><img src="https://i.loli.net/2019/06/27/5d14680dd97fe55738.png" alt="新版本后NSObject，MyObject的成员变量布局"></p>
<p><code>非脆弱[Non-fragile]</code>实例变量是新版 Objective-C 的一个新功能，应用于iPhone和64位Mac上。它们提供给框架开发者更多的灵活性，且不会失去二进制的兼容性</p>
<p><img src="https://i.loli.net/2019/06/27/5d1469a9a290976437.png" alt="非脆弱成员变量"></p>
<h3 id="如何寻址成员变量"><a href="#如何寻址成员变量" class="headerlink" title="#如何寻址成员变量"></a>#如何寻址成员变量</h3><p>点开 runtime 的源码，让我们找到 ivar 的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类实例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">isa_t</span> isa;</span><br><span class="line"><span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">isa_t</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="type">isa_t</span>(<span class="type">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="type">uintptr_t</span> bits;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="type">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="type">class_data_bits_t</span> bits;  </span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_data_bits_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">class_rw_t</span>* <span class="title function_">data</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="type">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">class_ro_t</span> *ro;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="type">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="type">uint32_t</span> instanceSize;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="type">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * name;</span><br><span class="line">    <span class="type">const</span> <span class="type">method_list_t</span> * baseMethods;</span><br><span class="line">    <span class="type">const</span> <span class="type">protocol_list_t</span> * baseProtocols;</span><br><span class="line">    <span class="type">const</span> <span class="type">ivar_list_t</span> * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="type">const</span> <span class="type">property_list_t</span> *baseProperties;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/06/27/5d14b8a1a902a62244.png" alt="image"></p>
<ul>
<li>每个 OC 类实例实际上都是一个内存上指向<code>objc_object</code>结构体的指针，成员变量 isa 有指向<code>objc_class</code>结构体的指针<code>Class cls;</code></li>
<li>在<code>class_ro_t</code>结构体中可以找到成员变量<code> const ivar_list_t * ivars</code>，这个就是存储类所有成员变量的列表</li>
<li>在<code>class_ro_t</code>结构体中成员变量<code>const uint8_t * ivarLayout;</code>和<code>const uint8_t * weakIvarLayout;</code>的作用可以看一下<a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2015/09/13/class-ivar-layout/">孙源的这篇博客</a></li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *_age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>clang -rewrite-objc MyObject.h</code> 将代码转化成 C++ 实现，你可以看到编译后的 MyObject 实例的内存布局：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyObject_IMPL</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> <span class="title">NSObject_IVARS</span>;</span></span><br><span class="line">	NSString *__strong _age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> &#123;</span></span><br><span class="line">	__unsafe_unretained Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><img src="https://i.loli.net/2019/06/27/5d14b9ee7ccf877916.jpg" alt="类实例内存布局"></p>
<p><code>ivar_list_t</code> 结构体的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_list_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> entsize;</span><br><span class="line">    <span class="type">uint32_t</span> count;</span><br><span class="line">    <span class="type">ivar_t</span> first;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></span><br><span class="line">    <span class="type">int32_t</span> *offset;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *type;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以看到<code>ivar_t</code>有名为<code>offset</code>的成员变量，这个就是成员变量在对象中的位置偏移量。在应用启动时，如果父类size变大时，runtime 会通过修改 offset，更新成员变量的偏移量，来正确的找到成员变量的地址。</p>
<hr>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *_age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></span><br><span class="line">- (<span class="type">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">self</span> -&gt; _age = <span class="string">@&quot;hhh&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>使用命令行<code>clang -F -cc1 -S -emit-llvm -fblocks MyObject.m</code>，将代码编译成 IR(intermediate representation)。<br>注意要加*-F*，好多人的博客里面都少了这个标志，会报错。在 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/18060469/fatal-error-foundation-foundation-h-no-such-file-or-directory">stackoverflow</a> 找到答案。<br>下面是编译后的代码：</p>
<!--fixme 分析ir代码-->
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@&quot;OBJC_IVAR_$_MyObject._age&quot; = hidden global i64 8, section &quot;__DATA, __objc_ivar&quot;, align 8</span><br><span class="line">// ...</span><br><span class="line">%6 = load i64, i64* @&quot;OBJC_IVAR_$_MyObject._age&quot;, align 8, !invariant.load !8</span><br><span class="line">%7 = bitcast %0* %5 to i8*</span><br><span class="line">%8 = getelementptr inbounds i8, i8* %7, i64 %6</span><br><span class="line">%9 = bitcast i8* %8 to %1**</span><br><span class="line">store %1* bitcast (%struct.__NSConstantString_tag* @_unnamed_cfstring_ to %1*), %1** %9, align 8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以简化成如下的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> g_ivar_MyClass_age = <span class="number">8</span>;  <span class="comment">// 全局变量</span></span><br><span class="line">*(NSString *)((<span class="type">uint8_t</span> *)obj + g_ivar_MyObject_age) = @<span class="string">&quot;hhh&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>编译时，LLVM 为每各类的每一个成员变量定义一个全局变量，用于存储该成员变量的偏移量</li>
<li>根据成员变量的偏移量，可以直接找到成员变量的地址并赋值</li>
</ul>
<p>这也是为什么结构体<code>ivar_t</code>的成员变量<code>offset</code>是<code>int32_t *</code>类型，因为保存的是该全局变量的地址。</p>
<h3 id="Non-Fragile-ivars"><a href="#Non-Fragile-ivars" class="headerlink" title="#Non Fragile ivars"></a>#Non Fragile ivars</h3><p>在前面部分我们已经知道该如何寻址成员变量，那么当基类的size变化时，runtime 是如何更新子类成员变量的offset呢？</p>
<p>在应用程序启动后，main 函数执行之前，runtime 在加载类的时候，会使用<code>static Class realizeClass(Class cls)</code>函数对类进行初始化，分配其读写数据的内存，返回类的真实结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* realizeClass</span></span><br><span class="line"><span class="comment">* Performs first-time initialization on class cls, </span></span><br><span class="line"><span class="comment">* including allocating its read-write data.</span></span><br><span class="line"><span class="comment">* Returns the real class structure for the class. </span></span><br><span class="line"><span class="comment">* Locking: runtimeLock must be write-locked by the caller</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">static</span> Class <span class="title">realizeClass</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">	<span class="type">class_rw_t</span> *rw = cls-&gt;<span class="built_in">data</span>();</span><br><span class="line">	<span class="comment">//...省略</span></span><br><span class="line">	<span class="keyword">if</span> (ro-&gt;instanceStart &lt; super_ro-&gt;instanceSize) &#123;</span><br><span class="line">        <span class="comment">// Superclass has changed size. This class&#x27;s ivars must move.</span></span><br><span class="line">        <span class="comment">// Also slide layout bits in parallel.</span></span><br><span class="line">        <span class="comment">// This code is incapable of compacting the subclass to </span></span><br><span class="line">        <span class="comment">//   compensate for a superclass that shrunk, so don&#x27;t do that.</span></span><br><span class="line">        <span class="type">class_ro_t</span> *ro_w = <span class="built_in">make_ro_writeable</span>(rw);</span><br><span class="line">        ro = rw-&gt;ro;</span><br><span class="line">        <span class="built_in">moveIvars</span>(ro_w, super_ro-&gt;instanceSize, </span><br><span class="line">                  mergeLayouts ? &amp;ivarBitmap : nil, </span><br><span class="line">                  mergeLayouts ? &amp;weakBitmap : nil);</span><br><span class="line">        <span class="built_in">gdb_objc_class_changed</span>(cls, OBJC_CLASS_IVARS_CHANGED, ro-&gt;name);</span><br><span class="line">        layoutsChanged = YES;</span><br><span class="line">    &#125; </span><br><span class="line">	<span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">class_ro_t</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="type">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="type">uint32_t</span> instanceSize;</span><br><span class="line">    <span class="type">const</span> <span class="type">ivar_list_t</span> * ivars;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>rw 是当前类的可读数据，ro 是类的 Ivar Layout，ro 的结构体定义在上面</li>
<li>在初始化类时，如果父类 ro 的<code>instanceSize</code>比子类的<code>instanceStart</code>大的话，那么会调用<code>moveIvars</code>函数更新子类的<code>instanceSize</code>以及子类成员变量的偏移量</li>
</ul>
<p>再让我们看一下 <code>moveIvars</code> 的源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* moveIvars</span></span><br><span class="line"><span class="comment">* Slides a class&#x27;s ivars to accommodate the given superclass size.</span></span><br><span class="line"><span class="comment">* Also slides ivar and weak GC layouts if provided.</span></span><br><span class="line"><span class="comment">* Ivars are NOT compacted to compensate for a superclass that shrunk.</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock must be held by the caller.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">moveIvars</span><span class="params">(<span class="type">class_ro_t</span> *ro, <span class="type">uint32_t</span> superSize, </span></span></span><br><span class="line"><span class="params"><span class="function">                      layout_bitmap *ivarBitmap, layout_bitmap *weakBitmap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">rwlock_assert_writing</span>(&amp;runtimeLock);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> diff;</span><br><span class="line">    <span class="type">uint32_t</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(superSize &gt; ro-&gt;instanceStart);</span><br><span class="line">    diff = superSize - ro-&gt;instanceStart;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ro-&gt;ivars) &#123;</span><br><span class="line">        <span class="comment">// Find maximum alignment in this class&#x27;s ivars</span></span><br><span class="line">        <span class="type">uint32_t</span> maxAlignment = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ro-&gt;ivars-&gt;count; i++) &#123;</span><br><span class="line">            <span class="type">ivar_t</span> *ivar = <span class="built_in">ivar_list_nth</span>(ro-&gt;ivars, i);</span><br><span class="line">            <span class="keyword">if</span> (!ivar-&gt;offset) <span class="keyword">continue</span>;  <span class="comment">// anonymous bitfield</span></span><br><span class="line"></span><br><span class="line">            <span class="type">uint32_t</span> alignment = ivar-&gt;<span class="built_in">alignment</span>();</span><br><span class="line">            <span class="keyword">if</span> (alignment &gt; maxAlignment) maxAlignment = alignment;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compute a slide value that preserves that alignment</span></span><br><span class="line">        <span class="type">uint32_t</span> alignMask = maxAlignment - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (diff &amp; alignMask) diff = (diff + alignMask) &amp; ~alignMask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Slide all of this class&#x27;s ivars en masse</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ro-&gt;ivars-&gt;count; i++) &#123;</span><br><span class="line">            <span class="type">ivar_t</span> *ivar = <span class="built_in">ivar_list_nth</span>(ro-&gt;ivars, i);</span><br><span class="line">            <span class="keyword">if</span> (!ivar-&gt;offset) <span class="keyword">continue</span>;  <span class="comment">// anonymous bitfield</span></span><br><span class="line"></span><br><span class="line">            <span class="type">uint32_t</span> oldOffset = (<span class="type">uint32_t</span>)*ivar-&gt;offset;</span><br><span class="line">            <span class="type">uint32_t</span> newOffset = oldOffset + diff;</span><br><span class="line">            *ivar-&gt;offset = newOffset;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (PrintIvars) &#123;</span><br><span class="line">                _objc_inform(<span class="string">&quot;IVARS:    offset %u -&gt; %u for %s (size %u, align %u)&quot;</span>, </span><br><span class="line">                             oldOffset, newOffset, ivar-&gt;name, </span><br><span class="line">                             ivar-&gt;size, ivar-&gt;<span class="built_in">alignment</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Slide GC layouts</span></span><br><span class="line">        <span class="type">uint32_t</span> oldOffset = ro-&gt;instanceStart;</span><br><span class="line">        <span class="type">uint32_t</span> newOffset = ro-&gt;instanceStart + diff;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ivarBitmap) &#123;</span><br><span class="line">            <span class="built_in">layout_bitmap_slide</span>(ivarBitmap, </span><br><span class="line">                                oldOffset &gt;&gt; WORD_SHIFT, </span><br><span class="line">                                newOffset &gt;&gt; WORD_SHIFT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (weakBitmap) &#123;</span><br><span class="line">            <span class="built_in">layout_bitmap_slide</span>(weakBitmap, </span><br><span class="line">                                oldOffset &gt;&gt; WORD_SHIFT, </span><br><span class="line">                                newOffset &gt;&gt; WORD_SHIFT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(<span class="type">uint32_t</span> *)&amp;ro-&gt;instanceStart += diff;</span><br><span class="line">    *(<span class="type">uint32_t</span> *)&amp;ro-&gt;instanceSize += diff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ro-&gt;ivars) &#123;</span><br><span class="line">        <span class="comment">// No ivars slid, but superclass changed size. </span></span><br><span class="line">        <span class="comment">// Expand bitmap in preparation for layout_bitmap_splat().</span></span><br><span class="line">        <span class="keyword">if</span> (ivarBitmap) <span class="built_in">layout_bitmap_grow</span>(ivarBitmap, ro-&gt;instanceSize &gt;&gt; WORD_SHIFT);</span><br><span class="line">        <span class="keyword">if</span> (weakBitmap) <span class="built_in">layout_bitmap_grow</span>(weakBitmap, ro-&gt;instanceSize &gt;&gt; WORD_SHIFT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先计算 superSize 与 instanceStart 之间的差值 diff</li>
<li>得到结构体中最大的成员变量的size：maxAlignment， 然后赋值：alignMask &#x3D; maxAlignment - 1</li>
<li>比较 diff 和 alignMask，通过算法 <code>if (diff &amp; alignMask) diff = (diff + alignMask) &amp; ~alignMask;</code> 对diff重新赋值</li>
</ul>
<blockquote>
<p>编译器在给结构体开辟空间时，首先找到结构体中最大的基本数据类型，然后寻找内存地址能是该基本数据类型的整倍的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为对齐模数。<br>为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。了解更多可以看这篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27909209/article/details/80814324">博客</a></p>
</blockquote>
<ul>
<li>更新成员变量的 offset，<code>ivar.newOffset = diff + ivar.oldOffset</code></li>
<li>更新子类 ro 的 instanceStart 和 instanceSize，ro.newinstanceStart &#x3D; ro.oldinstanceStart + diff，ro.newinstanceSize &#x3D; ro.oldinstanceSize + diff</li>
<li>当父类变大时会调用该函数来移动子类ivar，当父类变小时则子类ivar不变化</li>
</ul>
<blockquote>
<p>通过这个函数，即使父类size变大了，我们还是可以通过子类的 ro.instanceStart + ivar.offset 访问到成员变量</p>
</blockquote>
<h3 id="不能动态添加成员变量"><a href="#不能动态添加成员变量" class="headerlink" title="#不能动态添加成员变量"></a>#不能动态添加成员变量</h3><p>在 runtime 中有一个函数 <code>class_addIvar()</code>可以为类添加成员变量, 下面是该方法的一部分注释：</p>
<blockquote>
<p>his function may only be called after objc_allocateClassPair and before objc_registerClassPair. Adding an instance variable to an existing class is not supported.<br>The class must not be a metaclass. Adding an instance variable to a metaclass is not supported.</p>
</blockquote>
<p>上面的大致意思是该函数只能在类注册之前使用，且不能为元类添加成员变量。</p>
<p>让我们设想一下如果 OC 允许动态增加成员变量：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Father</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *age;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Son</span> : <span class="title">Father</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *toys;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 当Father初始化之后，instanceStart，instanceSize，offset已经<em>确定</em>。<br> 为 Father 添加新的成员变量 sex，则使用 Son 的实例对象 son 会出错误，因为 son.instanceStart &lt; Father.instanceSize，即 father 成员变量的 sex 的内存区域会跟 son 的一部分重合</p>
<p>我们有时会在类目中动态的为类添加关联对象(添加对象)，为什么可以添加关联对象呢?<br>具体的你可以看一下我的另一篇博客 <a target="_blank" rel="noopener" href="https://kikido.github.io/2019/06/28/%E8%B0%88Objective-C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/">谈Objective-C关联对象</a>。<br>这里我简单解释一下：关联对象被保存在一个静态的 map 中，以类实例的指针地址为映射，而不是保存在类实例的结构体中，不影响对象中成员变量的使用，所以可以在运行时添加成员变量。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="#引用"></a>#引用</h3><p><a target="_blank" rel="noopener" href="http://quotation.github.io/objc/2015/05/21/objc-runtime-ivar-access.html">Objective-C类成员变量深度剖析</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-06-24T03:11:35.000Z" title="6/24/2019, 11:11:35 AM">2019-06-24</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">19 分钟读完 (大约2884个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/06/24/%E6%8E%A2%E7%A9%B6ARC%E4%B8%8Bdealloc%E5%AE%9E%E7%8E%B0/">探究ARC下dealloc实现</a></h1><div class="content"><h3 id="我是前言"><a href="#我是前言" class="headerlink" title="我是前言"></a>我是前言</h3><p>目前正在看 oc 底层的东西，看了许多大牛的博客，发现有一些小问题：</p>
<ul>
<li>runtime 的版本可能跟作者当时写的版本不一致</li>
<li>许多方法一笔带过，因为基础知识的薄弱看不懂。。。</li>
<li>没有标明苹果文档的出处</li>
</ul>
<p>所以我打算解决上面的一些问题，然后重新发一版，当然大部分的内容还是<a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/">原作者</a>写的 。<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">runtime</a> 的源码为 <code>objc4-646.tar.gz</code>版本</p>
<h3 id="进入正题"><a href="#进入正题" class="headerlink" title="进入正题"></a>进入正题</h3><p>在 ARC 环境下，我们不需要主动的调用系统的析构函数 dealloc 就能够完成将对象以及父类的成员变量内存释放掉的操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ... //</span></span><br><span class="line">    <span class="comment">// 非Objc对象内存的释放，如CFRelease(...)</span></span><br><span class="line">    <span class="comment">// ... //</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>问题来了：</p>
<ol>
<li>这个对象成员变量（ivars）的释放操作去哪儿了？</li>
<li>没有主动调用 [super dealloc]，那么是什么时候调用这个方法的？</li>
</ol>
<h3 id="ARC文档中对dealloc过程的解释"><a href="#ARC文档中对dealloc过程的解释" class="headerlink" title="ARC文档中对dealloc过程的解释"></a>ARC文档中对dealloc过程的解释</h3><p>clang <a href="%5Bhttp://clang.llvm.org/docs/AutomaticReferenceCounting.html#dealloc%5D(http://clang.llvm.org/docs/AutomaticReferenceCounting.html#dealloc">ARC文档</a></p>
<blockquote>
<p>A class may provide a method definition for an instance method named dealloc. This method will be called after the final release of the object but before it is deallocated or any of its instance variables are destroyed. The superclass’s implementation of dealloc will be called automatically when the method returns.</p>
</blockquote>
<p>大概意思是：dealloc 方法在最后一次 release 后被调用，但此时实例变量（ivars）并未释放，父类的dealloc的方法将在子类dealloc方法返回后自动调用</p>
<blockquote>
<p>The instance variables for an ARC-compiled class will be destroyed at some point after control enters the dealloc method for the root class of the class. The ordering of the destruction of instance variables is unspecified, both within a single class and between subclasses and superclasses.</p>
</blockquote>
<p>ARC下对象的实例变量在根类 [NSObject dealloc] 中释放（通常root class都是NSObject），变量释放顺序各种不确定（一个类内的不确定，子类和父类间也不确定，也就是说不用care释放顺序）</p>
<hr>
<p>所以，我们不需要主动调用 [super dealloc] ，系统会自动调用，后面我们再讲这是怎么实现的。接下来我们来探究在根类 NSObject 析构时发生了什么</p>
<h3 id="NSObject的析构过程"><a href="#NSObject的析构过程" class="headerlink" title="NSObject的析构过程"></a>NSObject的析构过程</h3><p>通过 runtime 源码，我们可以发现 NSObject 调用 dealloc 时会调用 <code>_objc_rootDealloc</code>(NSObject.mm 2071行) 继而调用<code>object_dispose</code>(objc-object.h 301行) 随后调用<code>objc_destructInstance</code>(objc-runtime-new.mm 6838行), 下面讲一下<code>rootDealloc </code>和<code>objc_destructInstance</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">objc_object::rootDealloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!UseGC);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isa.indexed  &amp;&amp;  </span><br><span class="line">        !isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">        !isa.has_assoc  &amp;&amp;  </span><br><span class="line">        !isa.has_cxx_dtor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(!<span class="built_in">sidetable_present</span>());</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">object_dispose</span>((id)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>64位下，isa 指针的结构:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">struct &#123;</span><br><span class="line">        uintptr_t indexed           : 1;</span><br><span class="line">        uintptr_t has_assoc         : 1;</span><br><span class="line">        uintptr_t has_cxx_dtor      : 1;</span><br><span class="line">        uintptr_t shiftcls          : 30; // MACH_VM_MAX_ADDRESS 0x1a0000000</span><br><span class="line">        uintptr_t magic             : 9;</span><br><span class="line">        uintptr_t weakly_referenced : 1;</span><br><span class="line">        uintptr_t deallocating      : 1;</span><br><span class="line">        uintptr_t has_sidetable_rc  : 1;</span><br><span class="line">        uintptr_t extra_rc          : 19;</span><br><span class="line">#       define RC_ONE   (1ULL&lt;&lt;45)</span><br><span class="line">#       define RC_HALF  (1ULL&lt;&lt;18)</span><br><span class="line">    &#125;;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>

<ul>
<li>indexed(1 bit)	0 表示普通的 isa 指针，1 表示使用优化，即Tagged Pointer存储引用计数</li>
<li>has_assoc(1 bit) 表示该对象是否包含 associated object，如果没有，则析构(释放内存)时会更快</li>
<li>has_cxx_dtor(1 bit)	表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构（释放内存）时更快</li>
<li>shiftcls(30 bits) 类的指针</li>
<li>magic(9 bits) 固定值为 0xd2，用于在调试时分辨对象是否未完成初始化。</li>
<li>weakly_referenced(1 bit)	表示该对象是否有过 weak 对象，如果没有，则析构（释放内存）时更快</li>
<li>deallocating(1 bit) 表示该对象是否正在析构</li>
<li>has_sidetable_rc(1 bit)	表示该对象的引用计数值是否过大无法存储在 isa 指针</li>
<li>extra_jc(19 bits) 表示引用计数值减一后的结果。例如，如果对象引用计数为4，则extra_jc为3</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">objc_destructInstance</span><span class="params">(id obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="type">bool</span> cxx = obj-&gt;<span class="built_in">hasCxxDtor</span>();</span><br><span class="line">        <span class="type">bool</span> assoc = !UseGC &amp;&amp; obj-&gt;<span class="built_in">hasAssociatedObjects</span>();</span><br><span class="line">        <span class="type">bool</span> dealloc = !UseGC;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) <span class="built_in">object_cxxDestruct</span>(obj);</span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);</span><br><span class="line">        <span class="keyword">if</span> (dealloc) obj-&gt;<span class="built_in">clearDeallocating</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>objc_destructInstance</code>干了三件事情：</p>
<ol>
<li>执行了一个 <code>object_cxxDestruct</code> 函数</li>
<li>执行<code>_object_remove_assocations</code>函数去除和这个对象 assocate 的对象（常用于类目中添加的属性 ）</li>
<li>执行<code>clearDeallocating</code>， 清空引用计数并清除弱引用表，将所有使用__weak修饰的指向该对象的变量置为nil</li>
</ol>
<p>所以，ARC 自动释放实例变量的地方就在 <code>object_cxxDestruct</code> 这个方法里面没跑了。</p>
<h3 id="探究-object-cxxDestruct"><a href="#探究-object-cxxDestruct" class="headerlink" title="探究 object_cxxDestruct"></a>探究 object_cxxDestruct</h3><p>上面找到的名为<code>object_cxxDestruct</code>的方法最终成为下面的调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">object_cxxDestructFromClass</span><span class="params">(id obj, Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*dtor)(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call cls&#x27;s dtor first, then superclasses&#x27;s dtors.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; cls != <span class="literal">NULL</span>; cls = _class_getSuperclass(cls)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_class_hasCxxStructors(cls)) <span class="keyword">return</span>;</span><br><span class="line">        dtor = (<span class="built_in">void</span>(*)(id))</span><br><span class="line">            <span class="built_in">lookupMethodInClassAndLoadCache</span>(cls, SEL_cxx_destruct);</span><br><span class="line">        <span class="keyword">if</span> (dtor != (<span class="built_in">void</span>(*)(id))_objc_msgForward_internal) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PrintCxxCtors) &#123;</span><br><span class="line">                _objc_inform(<span class="string">&quot;CXX: calling C++ destructors for class %s&quot;</span>,</span><br><span class="line">                             _class_getName(cls));</span><br><span class="line">            &#125;</span><br><span class="line">            (*dtor)(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码的大致意思是通过继承链(isa)向上递归调用 <code>SEL_cxx_destruct</code>这个函数的函数实现<br>从<a target="_blank" rel="noopener" href="https://my.safaribooksonline.com/book/programming/objective-c/9780132908641/3dot-memory-management/ch03">这篇文章</a>提到：</p>
<blockquote>
<p>ARC actually creates a -.cxx_destruct method to handle freeing instance variables. This method was originally created for calling C++ destructors automatically when an object was destroyed.</p>
</blockquote>
<p>和《Effective Objective-C 2.0》中的：</p>
<blockquote>
<p>When the compiler saw that an object contained C++ objects, it would generate a method called .cxx_destruct. ARC piggybacks on this method and emits the required cleanup code within it.</p>
</blockquote>
<p>可以了解到<code>cxx_destruct</code>方法原本是为了 C++ 对象析构的，ARC 借用了这个方法插入代码实现了自动释放的工作。</p>
<h3 id="通过实验找出-cxx-destruct"><a href="#通过实验找出-cxx-destruct" class="headerlink" title="通过实验找出 .cxx_destruct"></a>通过实验找出 .cxx_destruct</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Father</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Son</span> : <span class="title">Father</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *toys;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>只有两个简单的属性，找个地方写简单的测试代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// before new</span></span><br><span class="line">    Son *son = [Son new];</span><br><span class="line">    son.name = <span class="string">@&quot;sark&quot;</span>;</span><br><span class="line">    son.toys = @[<span class="string">@&quot;sunny&quot;</span>, <span class="string">@&quot;xx&quot;</span>];</span><br><span class="line">    <span class="comment">// after new</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gone</span></span><br></pre></td></tr></table></figure>
<p>当过了大括号的作用域，son 对象就会被释放。所以在after new这行son对象初始化完成，在gone这行son对象被dealloc。</p>
<p>本次实验使用 <a target="_blank" rel="noopener" href="https://github.com/delebedev/DLIntrospection">NSObject+DLIntrospection</a> 这个扩展来作用调试工具，通过它可以轻松打出一个类的方法，成员变量等。<br>将这个扩展引入工程，在 after new 处设置一个断点，在这里打印出 Son 类所有的方法名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">po [[Son class] instanceMethods]</span><br><span class="line">&lt;__NSArrayI 0x280982520&gt;(</span><br><span class="line">- (void)setToys:(id)arg0 ,</span><br><span class="line">- (id)toys,</span><br><span class="line">- (void).cxx_destruct</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发现出现了<code>.cxx_destruct</code>这个方法，经过几次实验，发现：</p>
<ol>
<li>只有在ARC下这个方法才会出现（试验代码的情况下）</li>
<li>只有当前类拥有实例变量时（不论是不是用property）这个方法才会出现，且父类的实例变量不会导致子类拥有这个方法</li>
<li>出现这个方法和变量是否被赋值，赋值成什么没有关系</li>
</ol>
<h3 id="使用-watchpoint-定位内存释放时刻"><a href="#使用-watchpoint-定位内存释放时刻" class="headerlink" title="使用 watchpoint 定位内存释放时刻"></a>使用 watchpoint 定位内存释放时刻</h3><p>依然在 after new 断点处，输入 lldb 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">watchpoint set variable son-&gt;_name</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将<code>name</code>的变量加入watchpoint，当这个变量被修改时会触发trigger：<br>从中可以看出，在这个时刻，_name 从 0x0000000104ac5048 变成了0x0000000000000000，也就是nil，赶紧看下调用栈：<br>发现果然跟到了<code>.cxx_destruct</code>方法，而且是在<code>objc_storeStrong</code>方法中释放</p>
<p><img src="https://i.loli.net/2019/06/24/5d1038e8c739981387.jpg"></p>
<h3 id="刨根问底-cxx-destruct"><a href="#刨根问底-cxx-destruct" class="headerlink" title="刨根问底.cxx_destruct"></a>刨根问底.cxx_destruct</h3><p>知道了ARC环境下，对象实例变量的释放过程在 .cxx_destruct 内完成，但这个函数内部发生了什么，是如何调用 objc_storeStrong 释放变量的呢？<br>从上面的探究中知道，.cxx_destruct 是编译器生成的代码，那它很可能在clang前端编译时完成，这让我联想到clang的Code Generation，因为之前曾经使用clang -rewrite-objc xxx.m时查看过官方文档留下了些印象，于是google：<br><code>.cxx_destruct site:clang.llvm.org</code></p>
<p>结果发现clang的 doxygen 文档中 CodeGenModule 模块正是这部分的实现代码，cxx相关的代码生成部分源码在<br><a target="_blank" rel="noopener" href="http://clang.llvm.org/doxygen/CodeGenModule_8cpp-source.html">http://clang.llvm.org/doxygen/CodeGenModule_8cpp-source.html</a><br>位于1827行，删减掉离题部分如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// EmitObjCIvarInitializations - Emit information for ivar initialization</span></span><br><span class="line"><span class="comment">/// for an implementation.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CodeGenModule::EmitObjCIvarInitializations</span><span class="params">(ObjCImplementationDecl *D)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DeclContext* DC = <span class="built_in">const_cast</span>&lt;DeclContext*&gt;(<span class="built_in">dyn_cast</span>&lt;DeclContext&gt;(D));</span><br><span class="line">    <span class="built_in">assert</span>(DC &amp;&amp; <span class="string">&quot;EmitObjCIvarInitializations - null DeclContext&quot;</span>);</span><br><span class="line">    IdentifierInfo *II = &amp;<span class="built_in">getContext</span>().Idents.<span class="built_in">get</span>(<span class="string">&quot;.cxx_destruct&quot;</span>);</span><br><span class="line">    Selector cxxSelector = <span class="built_in">getContext</span>().Selectors.<span class="built_in">getSelector</span>(<span class="number">0</span>, &amp;II);</span><br><span class="line">    ObjCMethodDecl *DTORMethod = ObjCMethodDecl::<span class="built_in">Create</span>(<span class="built_in">getContext</span>(),</span><br><span class="line">                                                        D-&gt;<span class="built_in">getLocation</span>(),</span><br><span class="line">                                                        D-&gt;<span class="built_in">getLocation</span>(), cxxSelector,</span><br><span class="line">                                                        <span class="built_in">getContext</span>().VoidTy, <span class="number">0</span>,</span><br><span class="line">                                                        DC, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>,</span><br><span class="line">                                                        ObjCMethodDecl::Required);</span><br><span class="line">   D-&gt;<span class="built_in">addInstanceMethod</span>(DTORMethod);</span><br><span class="line">   <span class="built_in">CodeGenFunction</span>(*<span class="keyword">this</span>).<span class="built_in">GenerateObjCCtorDtorMethod</span>(D, DTORMethod, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数大概作用是：获取到 .cxx_destruct 的selector，创建 Method，然后加入到这个类的方法列表中，最后一行的调用才是真的创建这个方法的实现。这个方法位于<a target="_blank" rel="noopener" href="http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html">http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html</a> 1354行，包含了构造和析构的 cxx 方法，继续跟随 .cxx_destruct，最终调用 <code>emitCXXDestructMethod</code> 函数，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">emitCXXDestructMethod</span><span class="params">(CodeGenFunction &amp;CGF, ObjCImplementationDecl *impl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">CodeGenFunction::RunCleanupsScope <span class="title">scope</span><span class="params">(CGF)</span></span>;</span><br><span class="line"></span><br><span class="line">   llvm::Value *self = CGF.<span class="built_in">LoadObjCSelf</span>();</span><br><span class="line"></span><br><span class="line">   <span class="type">const</span> ObjCInterfaceDecl *iface = impl-&gt;<span class="built_in">getClassInterface</span>();</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">const</span> ObjCIvarDecl *ivar = iface-&gt;<span class="built_in">all_declared_ivar_begin</span>(); ivar; ivar = ivar-&gt;<span class="built_in">getNextIvar</span>())</span><br><span class="line">   &#123;</span><br><span class="line">     QualType type = ivar-&gt;<span class="built_in">getType</span>();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Check whether the ivar is a destructible type.</span></span><br><span class="line">     QualType::DestructionKind dtorKind = type.<span class="built_in">isDestructedType</span>();</span><br><span class="line">     <span class="keyword">if</span> (!dtorKind) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">     CodeGenFunction::Destroyer *destroyer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Use a call to objc_storeStrong to destroy strong ivars, for the</span></span><br><span class="line">     <span class="comment">// general benefit of the tools.</span></span><br><span class="line">     <span class="keyword">if</span> (dtorKind == QualType::DK_objc_strong_lifetime) &#123;</span><br><span class="line">       destroyer = destroyARCStrongWithStore;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Otherwise use the default for the destruction kind.</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       destroyer = CGF.<span class="built_in">getDestroyer</span>(dtorKind);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     CleanupKind cleanupKind = CGF.<span class="built_in">getCleanupKind</span>(dtorKind);</span><br><span class="line">     CGF.EHStack.<span class="built_in">pushCleanup</span>&lt;DestroyIvar&gt;(cleanupKind, self, ivar, destroyer,</span><br><span class="line">                                          cleanupKind &amp; EHCleanup);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">assert</span>(scope.<span class="built_in">requiresCleanups</span>() &amp;&amp; <span class="string">&quot;nothing to do in .cxx_destruct?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析这段代码以及其中调用后发现：它遍历当前对象所有的实例变量（Ivars)，调用<code>objc_storeStrong</code>，从clang的<a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#void-objc-storestrong-id-object-id-value">ARC文档</a>上可以找到 objc_storeStrong 的示意代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">objc_storeStrong</span><span class="params">(id *object, id value)</span> </span>&#123;</span><br><span class="line">  id oldValue = *object;</span><br><span class="line">  value = [value retain];</span><br><span class="line">  *object = value;</span><br><span class="line">  [oldValue release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 .cxx_destruct 进行形如 objc_storeStrong(&amp;ivar, null) 的调用后，这个实例变量就被release和设置成nil了</p>
<h3 id="自动调用-super-dealloc-的实现"><a href="#自动调用-super-dealloc-的实现" class="headerlink" title="自动调用[super dealloc]的实现"></a>自动调用[super dealloc]的实现</h3><p>按照上面的思路，自动调用 <code>[super dealloc]</code> 也一定是 <code>CodeGen</code> 的工作了，位于<a target="_blank" rel="noopener" href="http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html">http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html</a> 492行 <code>StartObjCMethod</code> 方法中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (ident-&gt;isStr(&quot;dealloc&quot;))</span><br><span class="line">   EHStack.pushCleanup&lt;FinishARCDealloc&gt;(getARCCleanupKind());</span><br></pre></td></tr></table></figure>

<p>上面代码可以得知在调用<code>dealloc</code>方法时被插入了代码，由<code>FinishARCDealloc</code>结构定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FinishARCDealloc</span> : EHScopeStack::Cleanup &#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Emit</span><span class="params">(CodeGenFunction &amp;CGF, Flags flags)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">     <span class="type">const</span> ObjCMethodDecl *method = <span class="built_in">cast</span>&lt;ObjCMethodDecl&gt;(CGF.CurCodeDecl);</span><br><span class="line"></span><br><span class="line">     <span class="type">const</span> ObjCImplDecl *impl = <span class="built_in">cast</span>&lt;ObjCImplDecl&gt;(method-&gt;<span class="built_in">getDeclContext</span>());</span><br><span class="line">     <span class="type">const</span> ObjCInterfaceDecl *iface = impl-&gt;<span class="built_in">getClassInterface</span>();</span><br><span class="line">     <span class="keyword">if</span> (!iface-&gt;<span class="built_in">getSuperClass</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">     <span class="type">bool</span> isCategory = <span class="built_in">isa</span>&lt;ObjCCategoryImplDecl&gt;(impl);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Call [super dealloc] if we have a superclass.</span></span><br><span class="line">     llvm::Value *self = CGF.<span class="built_in">LoadObjCSelf</span>();</span><br><span class="line"></span><br><span class="line">     CallArgList args;</span><br><span class="line">     CGF.CGM.<span class="built_in">getObjCRuntime</span>().<span class="built_in">GenerateMessageSendSuper</span>(CGF, <span class="built_in">ReturnValueSlot</span>(),</span><br><span class="line">                                                       CGF.<span class="built_in">getContext</span>().VoidTy,</span><br><span class="line">                                                       method-&gt;<span class="built_in">getSelector</span>(),</span><br><span class="line">                                                       iface,</span><br><span class="line">                                                       isCategory,</span><br><span class="line">                                                       self,</span><br><span class="line">                                                       <span class="comment">/*is class msg*/</span> <span class="literal">false</span>,</span><br><span class="line">                                                       args,</span><br><span class="line">                                                       method);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码基本上就是向父类转发dealloc的调用，实现了自动调用[super dealloc]方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>ARC下对象的成员变量在编译器插入的<code>.cxx_desctruct</code>方法自动释放</li>
<li>ARC下[super dealloc]方法也由编译器自动插入</li>
<li>所谓编译器插入代码过程需要进一步了解，还不清楚其运作方式</li>
</ul>
<hr>
<ul>
<li>ARC环境，对象的实例变量将在根类 NSObject 的 dealloc 方法中释放内存</li>
<li>Father 的实例变量(如果有)将在它的 <code>.cxx_desctruct</code>方法中被释放，而 Son 的实例变量(如果有)将在它的 <code>.cxx_desctruct</code>方法中被释放</li>
<li>子类在调用 dealloc 方法时会被插入代码，自动调用父类的 dealloc 方法</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/">ARC下dealloc过程及.cxx_destruct的探究</a><br><a target="_blank" rel="noopener" href="https://luoanhao.github.io/2016/03/29/Memory-Manage-2-MRC/">iOS内存管理之二</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/iOS%E6%9D%82/">上一页</a></div><div class="pagination-next"><a href="/categories/iOS%E6%9D%82/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/iOS%E6%9D%82/">1</a></li><li><a class="pagination-link is-current" href="/categories/iOS%E6%9D%82/page/2/">2</a></li><li><a class="pagination-link" href="/categories/iOS%E6%9D%82/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="千行"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">千行</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>杭州, 浙江</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">33</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/bug/"><span class="level-start"><span class="level-item">bug</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/cocoapods/"><span class="level-start"><span class="level-item">cocoapods</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS%E6%9D%82/"><span class="level-start"><span class="level-item">iOS杂</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%90%AD%E5%BB%BA/"><span class="level-start"><span class="level-item">搭建</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/EventKit/"><span class="tag">EventKit</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GCD/"><span class="tag">GCD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NSError/"><span class="tag">NSError</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Runloop/"><span class="tag">Runloop</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tagged-Pointer/"><span class="tag">Tagged Pointer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/YTKNetwork/"><span class="tag">YTKNetwork</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/YYModel/"><span class="tag">YYModel</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/block/"><span class="tag">block</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dyld/"><span class="tag">dyld</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mach-o/"><span class="tag">mach-o</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/runtime/"><span class="tag">runtime</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/weak/"><span class="tag">weak</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/"><span class="tag">关联对象</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"><span class="tag">内存分布</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%A1%E6%A0%B8/"><span class="tag">审核</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%A5%E5%85%B7/"><span class="tag">工具</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"><span class="tag">引用计数</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82/"><span class="tag">杂</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%BA%90%E7%A0%81/"><span class="tag">源码</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%94%81/"><span class="tag">锁</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="千行的博客" height="28"></a><p class="is-size-7"><span>&copy; 2022 千行</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>