<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: iOS杂 - 千行的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="千行的博客"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="千行的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="千行的博客"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="千行的博客"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="千行"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"千行的博客","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"千行"},"publisher":{"@type":"Organization","name":"千行的博客","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-0VD5EHM46E" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-0VD5EHM46E');</script><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="千行的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">iOS杂</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-06-20T13:02:04.000Z" title="6/20/2019, 9:02:04 PM">2019-06-20</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">1 分钟读完 (大约129个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/06/20/iOS%E6%A3%80%E6%B5%8B%E7%A7%81%E6%9C%89Api%E7%9A%84%E6%96%B9%E6%B3%95/">iOS检测私有Api的方法</a></h1><div class="content"><ol>
<li>首先你有个可以提交审核的ipa，可以先将项目 archive, 在<code>window-&gt;organizer</code>中，选择<code>distribute app -&gt; ios app store -&gt; export</code>，将ipa导出到本地中</li>
<li>将ipa解压，会有两个文件夹Payload、Symbols</li>
<li>cd到Payload里面的app   </li>
<li>有两种方式可以检测打包文件是否包含字符串          <ul>
<li>strings - -a -arch armv7 “AAAA” | grep 你想搜的方法名             </li>
<li>strings - -a -arch armv7 “AAAA” &gt; test.txt</li>
</ul>
</li>
</ol>
<p>   </p>
<p> 第二种可以自己去生成的test.text文件中搜索相应方法名字</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-06-20T12:56:31.000Z" title="6/20/2019, 8:56:31 PM">2019-06-20</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">1 小时读完 (大约8044个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/06/20/%E8%B0%88block%E3%80%81-weak%E5%92%8C-strong/">谈block、__weak和__strong</a></h1><div class="content"><p>最近在”翻新”公司的老项目的时候，发现一个奇怪的问题：</p>
<blockquote>
<p>在一个 block 中，我使用了 RAC 为了避免 block 循环引用而定义的两个宏: <code>@weakify</code>和<code>@strongify</code>，但是如果在 block 内部使用下划线属性(成员变量)，还是会导致循环引用。</p>
</blockquote>
<p>很多人都知道怎么处理这个问题，在使用了<code>@weakify</code>和<code>@strongify</code>的情况下，在 block 内部像<code>self -&gt; ivar</code>这样使用成员变量就可以避免循环引用了，但是为什么这样用就没问题呢？使用了<code>@weakify</code>和<code>@strongify</code>两个宏之后发生了什么呢？带着你在使用 block 时出现过的疑问，在后面的内容中你可能会得到答案。</p>
<h3 id="block是什么"><a href="#block是什么" class="headerlink" title="block是什么"></a>block是什么</h3><p>block 是用于创建匿名函数的 C 语言扩展。用户使用 block 指针与 block 对象进行交互并传输 block 对象，block 指针表示为普通指针。block 可以从局部变量中捕获值;发生这种情况时，必须动态分配内存。初始分配在栈上完成，但 runtime 提供了一个Block_copy函数，给定一个 block 指针，将底层 block 对象复制到堆中，将其引用计数设置为1并返回新的 block 指针，或者（如果 block 对象已经在堆上）将其引用计数增加1.配对函数是Block_release，它将引用计数减少1并在计数达到零并且在堆上时销毁对象。翻译自<a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#background">苹果文档</a></p>
<p>上面的翻译来自于 谷歌翻译~。我对于 block 的理解就是一个指针，指向一个带有函数指针 (用于执行block内的代码) 的结构体，该结构体内有许多捕获的成员变量。在 ARC 环境下 block 会从 栈中自动复制到堆中，方便 runtime 管理内存生命周期；如果内部有全局变量则复制到数据区，生命周期为程序创建到程序结束。</p>
<p>[站外图片上传中…(image-1d1a52-1561035272667)]</p>
<h3 id="block的数据结构"><a href="#block的数据结构" class="headerlink" title="block的数据结构"></a>block的数据结构</h3><p>block 的数据结构定义如下<br>[站外图片上传中…(image-f5b34b-1561035272667)]</p>
<p>结构体定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct Block_layout &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    int flags;</span><br><span class="line">    int reserved;</span><br><span class="line">    void (*invoke)(void *, ...);</span><br><span class="line">    struct Block_descriptor *descriptor;</span><br><span class="line">    /* Imported variables. */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Block_descriptor &#123;</span><br><span class="line">    unsigned long int reserved;</span><br><span class="line">    unsigned long int size;// sizeof(struct Block_layout)</span><br><span class="line">    void (*copy)(void *dst, void *src);</span><br><span class="line">    void (*dispose)(void *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过它的数据结构，我们知道一个 block 实际上是由5部分组成的</p>
<ol>
<li>isa 指针，所有对象都有该指针，用于实现对象相关的功能</li>
<li>flags，用于按 bit 位表示一些 block 的附加信息</li>
<li>reserved，保留变量</li>
<li>invoke，函数指针，指向具体的 block 实现的函数调用地址</li>
<li>descriptor， 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针</li>
</ol>
<h3 id="block的几种的类型"><a href="#block的几种的类型" class="headerlink" title="block的几种的类型"></a>block的几种的类型</h3><blockquote>
<p>常见的 block 有下面三种，不用类型的 block 存放不同的区域，在 ARC 环境下只有<code>_NSConcreteGlobalBlock</code>和<code>_NSConcreteMallocBlock</code>两种类型的 block</p>
</blockquote>
<ul>
<li>_NSConcreteGlobalBlock 全局的静态 block，不会访问任何外部变量。</li>
<li>_NSConcreteStackBlock 保存在栈中的 block，当函数返回时会被销毁。</li>
<li>_NSConcreteMallocBlock 保存在堆中的 block，当引用计数为 0 时会被销毁。</li>
</ul>
<blockquote>
<p>下面是详细的介绍</p>
</blockquote>
<h4 id="NSConcreteStackBlock"><a href="#NSConcreteStackBlock" class="headerlink" title="_NSConcreteStackBlock"></a>_NSConcreteStackBlock</h4><p>该类型的 block 仅存在在 MRC 环境中，数据存放在栈区，当函数返回时会被销毁。在 ARC 环境中，不存在<code>_NSConcreteStackBlock</code>类型，只存在<code>_NSConcreteGlobalBlock</code>和<code>_NSConcreteMallocBlock</code> 两个类型。在下面的例子中， block 的类型的打印结果是<code>__NSMallocBlock__</code>。原因可能是因为c语言的结构体中，编译器不能很好地管理初始化和销毁，这样对内存管理来说很不方便，所以就将 block 放到堆上，使用 runtime 来管理它们的生命周期。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int val = 1;</span><br><span class="line">    </span><br><span class="line">void(^textBlock)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;[block] val&lt;%p&gt;: %d&quot;, &amp;val, val);</span><br><span class="line">    NSLog(@&quot;val: %d&quot;, val);</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@&quot;val&lt;%p&gt;: %d&quot;, &amp;val, val);</span><br><span class="line">textBlock();</span><br><span class="line">NSLog(@&quot;textBlock: %@&quot;, textBlock);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val&lt;0x16b523d1c&gt;: 1</span><br><span class="line">[block] val&lt;0x280a9fcb0&gt;: 1</span><br><span class="line">textBlock: &lt;__NSMallocBlock__: 0x28076a4c0&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面使用 <code>clang -rewrite-objc filename</code> 将代码转换成 C++ 的实现, 下面是关键部分的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct __MyObject__test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __MyObject__test_block_desc_0* Desc;</span><br><span class="line">  int val;</span><br><span class="line">  __MyObject__test_block_impl_0(void *fp, struct __MyObject__test_block_desc_0 *desc, int _val, int flags=0) : val(_val) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __MyObject__test_block_func_0(struct __MyObject__test_block_impl_0 *__cself) &#123;</span><br><span class="line">  int val = __cself-&gt;val; // bound by copy</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static struct __MyObject__test_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __MyObject__test_block_desc_0_DATA = &#123; 0, sizeof(struct __MyObject__test_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">static void _I_MyObject_test(MyObject * self, SEL _cmd) &#123;</span><br><span class="line">    static int static_v = 1;</span><br><span class="line">    int val = 1;</span><br><span class="line"></span><br><span class="line">    void(*textBlock)(void) = ((void (*)())&amp;__MyObject__test_block_impl_0((void *)__MyObject__test_block_func_0, &amp;__MyObject__test_block_desc_0_DATA, val));</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)textBlock)-&gt;FuncPtr)((__block_impl *)textBlock);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>其中<code>__MyObject__test_block_impl_0 </code>是 block 的结构体类型</li>
<li><code>__MyObject__test_block_func_0 </code> 是 block 实现的函数，在 <code>__MyObject__test_block_impl_0</code>内有一个指针<code>FuncPtr </code>指向该函数</li>
<li><code>__MyObject__test_block_desc_0 </code> 是 block 附件描述信息的结构体，包含着 block 结构体大小， copy 和 dispose 函数指针(这两个函数后面后讲到)等的描述信息，在 <code>__MyObject__test_block_impl_0</code>内有一个指针<code>Desc </code>指向该结构体</li>
<li>在<code>_I_MyObject_test </code>函数内可以看到 block 的初始化，<code>void(*textBlock)(void) </code>说明 textBlock 是一个指向该 block 结构体的指针</li>
</ul>
<hr>
<p>首先观察这个<code>__MyObject__test_block_impl_0</code>的结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct __MyObject__test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __MyObject__test_block_desc_0* Desc;</span><br><span class="line">  int val;</span><br><span class="line">  __MyObject__test_block_impl_0(void *fp, struct __MyObject__test_block_desc_0 *desc, int _val, int flags=0) : val(_val) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用 clang 转换过的实现是 MRC 环境的，所以 isa 指针指向 _NSConcreteStackBlock 类型</li>
<li>在这个结构体中可以看到一个成员变量<code>int val; </code>，没错，它就是 block 捕获的局部变量，从构造函数 <code>  __MyObject__test_block_impl_0(void *fp, struct __MyObject__test_block_desc_0 *desc, int _val, int flags=0) : val(_val)</code> 中可以看到，block 仅仅捕获了该变量的值</li>
<li><code>__MyObject__test_block_impl_0</code>中由于增加了一个变量 val，所以结构体的大小变大了，结构体大小被写在了<code>__MyObject__test_block_desc_0</code>中</li>
<li>block 捕获外部变量仅仅只 block 闭包里面会用到的值，其他用不到的值，它并不会去捕获。</li>
</ul>
<hr>
<p>再看一下<code>__MyObject__test_block_func_0</code>这个函数的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void __MyObject__test_block_func_0(struct __MyObject__test_block_impl_0 *__cself) &#123;</span><br><span class="line">  int val = __cself-&gt;val; // bound by copy</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以发现，系统自动给我们加上的注释，bound by copy，自动变量 val 虽然被捕获进来了，但是是用 __cself-&gt;val 来访问的。block 仅仅捕获了 val 的值，并没有捕获 val 的内存地址。所以在__MyObject__test_block_func_0 这个函数中即使我们重写这个自动变量 val 的值，依旧没法去改变block外面变量 val 的值。</p>
<blockquote>
<p>小结一下:<br>基本数据类型的变量是以值传递方式传递到 block 的构造函数里面去的。block 只捕获 block 中会用到的变量。由于只捕获了自动变量的值，并非内存地址，所以 block 内部不能改变变量的值。</p>
</blockquote>
<h4 id="NSConcreteMallocBlock"><a href="#NSConcreteMallocBlock" class="headerlink" title="_NSConcreteMallocBlock"></a>_NSConcreteMallocBlock</h4><p>修改一下上面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> __block int val = 1;</span><br><span class="line">void(^textBlock)(void) = ^&#123;</span><br><span class="line">    val++;</span><br><span class="line">    NSLog(@&quot;[block] val&lt;%p&gt;: %d&quot;, &amp;val, val);</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@&quot;val&lt;%p&gt;: %d&quot;, &amp;val, val);</span><br><span class="line">textBlock();</span><br><span class="line">NSLog(@&quot;val&lt;%p&gt;: %d&quot;, &amp;val, val);</span><br><span class="line">NSLog(@&quot;textBlock: %@&quot;, textBlock);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val&lt;0x282db0858&gt;: 1</span><br><span class="line">[block] val&lt;0x282db0858&gt;: 2</span><br><span class="line">val&lt;0x282db0858&gt;: 2</span><br><span class="line">textBlock: &lt;__NSMallocBlock__: 0x2823d3450&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重新用 clang 生成的c++实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_val_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_val_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __MyObject__test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __MyObject__test_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_val_0 *val; // by ref</span><br><span class="line">  __MyObject__test_block_impl_0(void *fp, struct __MyObject__test_block_desc_0 *desc, __Block_byref_val_0 *_val, int flags=0) : val(_val-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __MyObject__test_block_func_0(struct __MyObject__test_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_val_0 *val = __cself-&gt;val; // bound by ref</span><br><span class="line"></span><br><span class="line">        (val-&gt;__forwarding-&gt;val)++;</span><br><span class="line">    &#125;</span><br><span class="line">static void __MyObject__test_block_copy_0(struct __MyObject__test_block_impl_0*dst, struct __MyObject__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;val, (void*)src-&gt;val, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __MyObject__test_block_dispose_0(struct __MyObject__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;val, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</span><br><span class="line"></span><br><span class="line">static struct __MyObject__test_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __MyObject__test_block_impl_0*, struct __MyObject__test_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __MyObject__test_block_impl_0*);</span><br><span class="line">&#125; __MyObject__test_block_desc_0_DATA = &#123; 0, sizeof(struct __MyObject__test_block_impl_0), __MyObject__test_block_copy_0, __MyObject__test_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">static void _I_MyObject_test(MyObject * self, SEL _cmd) &#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;(void*)0,(__Block_byref_val_0 *)&amp;val, 0, sizeof(__Block_byref_val_0), 1&#125;;</span><br><span class="line">    void(*textBlock)(void) = ((void (*)())&amp;__MyObject__test_block_impl_0((void *)__MyObject__test_block_func_0, &amp;__MyObject__test_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, 570425344));</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)textBlock)-&gt;FuncPtr)((__block_impl *)textBlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在重新生成的代码中，我们看到新增了一个名为<code>__Block_byref_val_0</code>的结构体，它是用来替代我们<code>__block</code>修饰的变量 val 的。</p>
<ul>
<li>它的第一个指针是 isa，说明它也是一个对象。</li>
<li>第二个指针是指向自身类的指针<code>__forwarding</code></li>
<li>第三个是一个标记 flag</li>
<li>第四个是结构体的大小</li>
<li>第五个是变量 val 的值</li>
</ul>
<p>在函数<code>static void _I_MyObject_test(MyObject * self, SEL _cmd)</code>我们可以看到该结构体的初始化代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;(void*)0,(__Block_byref_val_0 *)&amp;val, 0, sizeof(__Block_byref_val_0), 1&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>在初始化时， isa 指向了一个空指针</li>
<li><code>__forwarding</code>指向了自己的地址</li>
<li>1是变量 val 的值。</li>
</ul>
<blockquote>
<p>使用 __block修饰的变量，无论是基本数据类型还是 OC 的类，在编译之后都是转换成一个新的结构体，该结构体的<code>__forwarding</code>指针会指向自己的地址，而成员变量 val 则为编译前的类型和值。至于这样的目的是什么，可以接着看下面。</p>
</blockquote>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static struct __MyObject__test_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __MyObject__test_block_impl_0*, struct __MyObject__test_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __MyObject__test_block_impl_0*);</span><br><span class="line">&#125; __MyObject__test_block_desc_0_DATA = &#123; 0, sizeof(struct __MyObject__test_block_impl_0), __MyObject__test_block_copy_0, __MyObject__test_block_dispose_0&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>__MyObject__test_block_desc_0 </code>这个结构体中，我们发现比之前的代码多了一个 <code>copy</code> 和 <code>dispose</code> 的函数指针。在c语言的结构体中，编译器没有很好地进行初始化和销毁，这样对内存管理来说很不方便，所以就在增加了这两个函数指针，方便进行内存管理。copy函数把block从栈上拷贝到堆上，dispose函数是把堆上的函数在废弃的时候销毁掉。</p>
<ul>
<li><code>copy</code> 和 <code>dispose</code>这两个函数指针对应的两个函数实现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void __MyObject__test_block_copy_0(struct __MyObject__test_block_impl_0*dst, struct __MyObject__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;val, (void*)src-&gt;val, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __MyObject__test_block_dispose_0(struct __MyObject__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;val, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>__MyObject__test_block_copy_0</code>函数实现中出现了方法<code>_Block_object_assign</code>, </li>
<li><code>__MyObject__test_block_dispose_0</code>函数实现中出现了方法<code>_Block_object_dispose</code>。</li>
</ul>
<p>下面是这两个方法的申明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#define Block_copy(...) ((__typeof(__VA_ARGS__))_Block_copy((const void *)(__VA_ARGS__)))</span><br><span class="line">#define Block_release(...) _Block_release((const void *)(__VA_ARGS__))</span><br><span class="line"></span><br><span class="line">// Create a heap based copy of a Block or simply add a reference to an existing one.</span><br><span class="line">// This must be paired with Block_release to recover memory, even when running</span><br><span class="line">// under Objective-C Garbage Collection.</span><br><span class="line">BLOCK_EXPORT void *_Block_copy(const void *aBlock)</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br><span class="line"></span><br><span class="line">// Lose the reference, and if heap based and last reference, recover the memory</span><br><span class="line">BLOCK_EXPORT void _Block_release(const void *aBlock)</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br><span class="line"></span><br><span class="line">// Used by the compiler. Do not call this function yourself.</span><br><span class="line">BLOCK_EXPORT void _Block_object_assign(void *, const void *, const int)</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br><span class="line"></span><br><span class="line">// Used by the compiler. Do not call this function yourself.</span><br><span class="line">BLOCK_EXPORT void _Block_object_dispose(const void *, const int)</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面是这两个方法的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">static void *_Block_copy_internal(const void *arg, const int flags) &#123;</span><br><span class="line">    struct Block_layout *aBlock;</span><br><span class="line">    const bool wantsOne = (WANTS_ONE &amp; flags) == WANTS_ONE;</span><br><span class="line">    </span><br><span class="line">    // 1</span><br><span class="line">    if (!arg) return NULL;</span><br><span class="line">    </span><br><span class="line">    // 2</span><br><span class="line">    aBlock = (struct Block_layout *)arg;</span><br><span class="line">    </span><br><span class="line">    // 3</span><br><span class="line">    if (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) &#123;</span><br><span class="line">        // latches on high</span><br><span class="line">        latching_incr_int(&amp;aBlock-&gt;flags);</span><br><span class="line">        return aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 4</span><br><span class="line">    else if (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) &#123;</span><br><span class="line">        return aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 5</span><br><span class="line">    struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);</span><br><span class="line">    if (!result) return (void *)0;</span><br><span class="line">    </span><br><span class="line">    // 6</span><br><span class="line">    memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first</span><br><span class="line">    </span><br><span class="line">    // 7</span><br><span class="line">    result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed</span><br><span class="line">    result-&gt;flags |= BLOCK_NEEDS_FREE | 1;</span><br><span class="line">    </span><br><span class="line">    // 8</span><br><span class="line">    result-&gt;isa = _NSConcreteMallocBlock;</span><br><span class="line">    </span><br><span class="line">    // 9</span><br><span class="line">    if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">        (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void _Block_release(void *arg) &#123;</span><br><span class="line">    // 1</span><br><span class="line">    struct Block_layout *aBlock = (struct Block_layout *)arg;</span><br><span class="line">    if (!aBlock) return;</span><br><span class="line">    </span><br><span class="line">    // 2</span><br><span class="line">    int32_t newCount;</span><br><span class="line">    newCount = latching_decr_int(&amp;aBlock-&gt;flags) &amp; BLOCK_REFCOUNT_MASK;</span><br><span class="line">    </span><br><span class="line">    // 3</span><br><span class="line">    if (newCount &gt; 0) return;</span><br><span class="line">    </span><br><span class="line">    // 4</span><br><span class="line">    if (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) &#123;</span><br><span class="line">        if (aBlock-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE)(*aBlock-&gt;descriptor-&gt;dispose)(aBlock);</span><br><span class="line">        _Block_deallocator(aBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 5</span><br><span class="line">    else if (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 6</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;Block_release called upon a stack Block: %p, ignored\n&quot;, (void *)aBlock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>_Block_copy_internal</code>是<code>Block_copy</code>的一个实现，实现了从_NSConcreteStackBlock复制到_NSConcreteMallocBlock的过程，有9个步骤。</p>
<ul>
<li>在第8步中我们可以看到 isa 指针指向了<code>_NSConcreteMallocBlock </code></li>
</ul>
</li>
<li><p><code>_Block_release</code>是<code>Block_release</code>的一个实现，实现了一个block释放的过程，有6个步骤</p>
</li>
</ul>
<hr>
<p>扯的有点远了，现在让我们总结一下 <code>__block</code> 修饰的变量在block内发生了什么。</p>
<ul>
<li>block 会在栈中被创建，然后通过<code>Block_copy</code>函数复制到堆中。由 runtime 管理它的生命周期</li>
<li>使用 __block 修饰的变量，在编译后会变成一个新的对象。在初始化时，成员变量<code>__forwarding </code>会指向栈中该变量的地址，val 为该变量原本的值。当 block 的成员变量 <code>__Block_byref_val_0 </code>从栈中复制到堆中时，成员变量 <code>__Block_byref_val_0</code>的地址可能改变了，但是 <code>__forwarding </code>指针指向的结构体是不会变的，仍然在栈中。</li>
<li>block 的实现函数<code>__MyObject__test_block_func_0</code>，block 通过 <code>__Block_byref_val_0 *val = __cself-&gt;val;(val-&gt;__forwarding-&gt;val)++</code> 变量的地址修改 val，所以在 block 内部修改变量 val 是会影响到 block 外部的变量。</li>
<li>这就是为什么 block 内部和外部 val 的地址不同的原因(一个在栈上，一个在堆上)。因为他们<code>__forwarding</code>指向的结构体是一样的，所以在 block 内部修改变量会影响到外部，</li>
</ul>
<h4 id="NSConcreteGlobalBlock"><a href="#NSConcreteGlobalBlock" class="headerlink" title="_NSConcreteGlobalBlock"></a>_NSConcreteGlobalBlock</h4><p>block 内部只用到全局变量，包括<code>全局变量</code>，<code>静态全局变量</code>，<code>静态变量</code>，以及上述 block 的 copy 版本。数据存放在数据区，生命周期从应用创建到应用结束。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int global_v = 1;</span><br><span class="line">static int static_global_v = 1;</span><br><span class="line"></span><br><span class="line">@implementation MyObject</span><br><span class="line"></span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">    static int static_v = 1;</span><br><span class="line">        </span><br><span class="line">    NSLog(@&quot;val&lt;%p&gt;: %d&quot;, &amp;static_v, static_v);</span><br><span class="line">    NSLog(@&quot;global_v&lt;%p&gt;: %d&quot;, &amp;global_v, global_v);</span><br><span class="line">    NSLog(@&quot;static_global_v&lt;%p&gt;: %d&quot;, &amp;static_global_v, static_global_v);</span><br><span class="line">    </span><br><span class="line">    void(^textBlock)(void) = ^&#123;</span><br><span class="line">        static_v++;</span><br><span class="line">        global_v++;</span><br><span class="line">        static_global_v++;</span><br><span class="line">        NSLog(@&quot;[block] val&lt;%p&gt;: %d&quot;, &amp;static_v, static_v);</span><br><span class="line">        NSLog(@&quot;[block] global_v&lt;%p&gt;: %d&quot;, &amp;global_v, global_v);</span><br><span class="line">        NSLog(@&quot;[block] static_global_v&lt;%p&gt;: %d&quot;, &amp;static_global_v, static_global_v);</span><br><span class="line">    &#125;;</span><br><span class="line">    textBlock();</span><br><span class="line">    NSLog(@&quot;textBlock: %@&quot;, textBlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打印信息为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val&lt;0x1034b8114&gt;: 1</span><br><span class="line">global_v&lt;0x1034b8110&gt;: 1</span><br><span class="line">static_global_v&lt;0x1034b8118&gt;: 1</span><br><span class="line"></span><br><span class="line">[block] val&lt;0x1034b8114&gt;: 2</span><br><span class="line">[block] global_v&lt;0x1034b8110&gt;: 2</span><br><span class="line">[block] static_global_v&lt;0x1034b8118&gt;: 2</span><br><span class="line"></span><br><span class="line">textBlock: &lt;__NSGlobalBlock__: 0x10343da40&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>clang 之后 C++ 实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int global_v = 1;</span><br><span class="line">static int static_global_v = 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct __MyObject__test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __MyObject__test_block_desc_0* Desc;</span><br><span class="line">  int *static_v;</span><br><span class="line">  __MyObject__test_block_impl_0(void *fp, struct __MyObject__test_block_desc_0 *desc, int *_static_v, int flags=0) : static_v(_static_v) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __MyObject__test_block_func_0(struct __MyObject__test_block_impl_0 *__cself) &#123;</span><br><span class="line">  int *static_v = __cself-&gt;static_v; // bound by copy</span><br><span class="line"></span><br><span class="line">        (*static_v)++;</span><br><span class="line">        global_v++;</span><br><span class="line">        static_global_v++;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static struct __MyObject__test_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __MyObject__test_block_desc_0_DATA = &#123; 0, sizeof(struct __MyObject__test_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">static void _I_MyObject_test(MyObject * self, SEL _cmd) &#123;</span><br><span class="line">    static int static_v = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>block 仅仅捕获了静态变量 static_v 的地址作为自己的成员变量，因此在内部修改该变量可以影响到 block 外部。block 内部和外部该变量的地址相等</li>
<li>全局变量 global_v 和全局静态变量 static_global_v 并没有被 block 捕获，因为他们已经被保存在数据区中，可以直接使用</li>
</ul>
<blockquote>
<p>由于 clang 改写的方式跟 LLVM 不太一样，在这里并没有开启ARC，所以这里我们看到 isa 指向的还是 _NSConcreteStackBlock，但在开启ARC的时候，block 应该是 _NSConcreteGlobalBlock 类型。</p>
</blockquote>
<h3 id="block-与-self"><a href="#block-与-self" class="headerlink" title="block 与 self"></a>block 与 self</h3><p>在前面的部分，我们已经分析过 局部变量，静态变量，全局变量，全局静态变量在 block 时的情况，那么，还有一种特殊的变量 self，它在 block 内部时又是怎么样运行的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@interface MyObject () &#123;</span><br><span class="line">    NSString *_age;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyObject</span><br><span class="line"></span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    self.name = @&quot;n&quot;;</span><br><span class="line">    _age = @&quot;10&quot;;</span><br><span class="line">    NSLog(@&quot;self: %@&quot;, self);</span><br><span class="line"></span><br><span class="line">    void(^textBlock)(void) = ^&#123;</span><br><span class="line">        self.name = @&quot;a&quot;;</span><br><span class="line">        _age = @&quot;11&quot;;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;[block] self: %@&quot;, self);</span><br><span class="line">        NSLog(@&quot;[block] name&lt;%p&gt;: %@&quot;, self.name, self.name);</span><br><span class="line">        NSLog(@&quot;[block] age&lt;%p&gt;: %@&quot;, _age, _age);</span><br><span class="line">    &#125;;</span><br><span class="line">    NSLog(@&quot;name&lt;%p&gt;: %@&quot;, self.name, self.name);</span><br><span class="line">    NSLog(@&quot;age&lt;%p&gt;: %@&quot;, _age, _age);</span><br><span class="line">    textBlock();</span><br><span class="line">    NSLog(@&quot;name&lt;%p&gt;: %@&quot;, self.name, self.name);</span><br><span class="line">    NSLog(@&quot;age&lt;%p&gt;: %@&quot;, _age, _age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name&lt;0x102804818&gt;: n</span><br><span class="line">age&lt;0x102804838&gt;: 10</span><br><span class="line">[block] name&lt;0x102804858&gt;: a</span><br><span class="line">[block] age&lt;0x102804878&gt;: 11</span><br><span class="line">name&lt;0x102804858&gt;: a</span><br><span class="line">age&lt;0x102804878&gt;: 11</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>clang之后的C++实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct __MyObject__test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __MyObject__test_block_desc_0* Desc;</span><br><span class="line">  MyObject *self;</span><br><span class="line">  __MyObject__test_block_impl_0(void *fp, struct __MyObject__test_block_desc_0 *desc, MyObject *_self, int flags=0) : self(_self) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __MyObject__test_block_func_0(struct __MyObject__test_block_impl_0 *__cself) &#123;</span><br><span class="line">  MyObject *self = __cself-&gt;self; // bound by copy</span><br><span class="line"></span><br><span class="line">        ((void (*)(id, SEL, NSString *))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setName:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_xy_nncr8hn96cd0_rdymw2f0qcw0000gn_T_MyObject_2519b6_mi_2);</span><br><span class="line">        (*(NSString **)((char *)self + OBJC_IVAR_$_MyObject$_age)) = (NSString *)&amp;__NSConstantStringImpl__var_folders_xy_nncr8hn96cd0_rdymw2f0qcw0000gn_T_MyObject_2519b6_mi_3;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">static void __MyObject__test_block_copy_0(struct __MyObject__test_block_impl_0*dst, struct __MyObject__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;self, (void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __MyObject__test_block_dispose_0(struct __MyObject__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static struct __MyObject__test_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __MyObject__test_block_impl_0*, struct __MyObject__test_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __MyObject__test_block_impl_0*);</span><br><span class="line">&#125; __MyObject__test_block_desc_0_DATA = &#123; 0, sizeof(struct __MyObject__test_block_impl_0), __MyObject__test_block_copy_0, __MyObject__test_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">static void _I_MyObject_test(MyObject * self, SEL _cmd) &#123;</span><br><span class="line"></span><br><span class="line">    ((void (*)(id, SEL, NSString *))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setName:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_xy_nncr8hn96cd0_rdymw2f0qcw0000gn_T_MyObject_2519b6_mi_0);</span><br><span class="line">    (*(NSString **)((char *)self + OBJC_IVAR_$_MyObject$_age)) = (NSString *)&amp;__NSConstantStringImpl__var_folders_xy_nncr8hn96cd0_rdymw2f0qcw0000gn_T_MyObject_2519b6_mi_1;</span><br><span class="line"></span><br><span class="line">    void(*textBlock)(void) = ((void (*)())&amp;__MyObject__test_block_impl_0((void *)__MyObject__test_block_func_0, &amp;__MyObject__test_block_desc_0_DATA, self, 570425344));</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)textBlock)-&gt;FuncPtr)((__block_impl *)textBlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>__MyObject__test_block_impl_0</code>中我们可以看到<code>self</code>也被 block 捕获成了成员变量</li>
<li>在<code>__MyObject__test_block_impl_0</code>的构造函数中我们可以看到 self 被当做参数被传入，而不是 self 的地址</li>
<li>因为 block 在内部和外部 self 指向的是相同的 MyObject 结构体，所以在 block 内部对 self 成员变量进行修改会影响到 block 外部</li>
<li>block 的结构体会强引用 self，所以需要小心使用，否则会引起循环应用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void __MyObject__test_block_func_0(struct __MyObject__test_block_impl_0 *__cself) &#123;</span><br><span class="line">  MyObject *self = __cself-&gt;self; // bound by copy</span><br><span class="line"></span><br><span class="line">((void (*)(id, SEL, NSString *))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setName:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_xy_nncr8hn96cd0_rdymw2f0qcw0000gn_T_MyObject_2519b6_mi_2);</span><br><span class="line">(*(NSString **)((char *)self + OBJC_IVAR_$_MyObject$_age)) = (NSString *)&amp;__NSConstantStringImpl__var_folders_xy_nncr8hn96cd0_rdymw2f0qcw0000gn_T_MyObject_2519b6_mi_3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>block 内部使用属性和成员变量是不一样的。直接使用属性时，走的是 obj_msgSend 消息发送(具体可以研究这篇<a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/">博客</a>)，而在使用成员变量时，应该是先通过 self 得到结构体的首地址，然后通过成员变量的偏移量然直接使用这个成员变量(其实我也没很理解。。。)</p>
<blockquote>
<p>小结一下：</p>
<ul>
<li>block 内部使用 self 时的情况跟使用局部变量的情况是比较类似的，block 会捕获 self 的值而不是地址当做成员变量</li>
<li>在 block 内部使用属性和成员变量的情况是不一样的</li>
</ul>
</blockquote>
<h3 id="weak与-strong"><a href="#weak与-strong" class="headerlink" title="__weak与__strong"></a>__weak与__strong</h3><p>我们都知道使用__weak和__strong修饰符可以避免在block的使用中出现循环引用的问题，这是为什么呢？先让我们了解一下这两个修饰符吧！</p>
<p>ARC 环境下，OC的对象面前都需要加上所有权的修饰符，所有的修饰符有以下4种</p>
<ul>
<li>__strong修饰符</li>
<li>__weak修饰符</li>
<li>__unsafe_unretained修饰符</li>
<li>__autoreleasing修饰符</li>
</ul>
<p>默认的修饰符是__strong。  </p>
<blockquote>
<p>ARC下，self既不是strong也不是weak，而是unsafe_unretained的，也就是说，入参的self被表示为：（init系列方法的self除外）来源：<a href="%5Bhttp://blog.sunnyxx.com/2015/01/17/self-in-arc/%5D(http://blog.sunnyxx.com/2015/01/17/self-in-arc/)">博客</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)start &#123;</span><br><span class="line">   const __unsafe_unretained MyObject *self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>想要弄清__weak与__strong的实现原理，需要研究一下clang中关于ARC的<a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html">文档</a>，有兴趣可以点进去仔细看看。</p>
<h4 id="strong"><a href="#strong" class="headerlink" title="__strong"></a>__strong</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id __strong object = [[NSObject alloc] init];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在终端使用命令<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 MyObject.m</code>转换成 C++ 的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id __attribute__((objc_ownership(strong))) object = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&#x3D; 右边的代码意思应该是对 NSObject 这个类发送 alloc 消息，然后再对生成的对象发送 init 消息，这两个方法的实现可以在 runtime 中找到，代码我也贴到下面了<br>&#x3D; 左边的代码，我不大理解<code>objc_ownership</code>这个函数，查了下搜不到是啥意思，看字面意思应该是两个对象间的持有关系，也就是自己持有自己的意思。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ alloc</span><br><span class="line">&#123;</span><br><span class="line">	return (*_zoneAlloc)((Class)self, 0, malloc_default_zone()); </span><br><span class="line">&#125;</span><br><span class="line">- init</span><br><span class="line">&#123;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id __strong object = [[NSObject alloc] init];</span><br><span class="line">id __weak weakSelf = object;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在终端使用命令<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 MyObject.m</code>转换成 C++ 实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id __attribute__((objc_ownership(strong))) object = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));</span><br><span class="line">id __attribute__((objc_ownership(weak))) weakSelf = object;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>相应的会调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objc_initWeak(&amp;weakSelf,object);</span><br><span class="line">objc_destoryWeak(&amp;weakSelf);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>objc_initWeak</code>方法的文档说明<br>Precondition: object is a valid pointer which has not been registered as a __weak object. value is null or a pointer to a valid object.<br> If value is a null pointer or the object to which it points has begun deallocation, object is zero-initialized. Otherwise, object is registered as a __weak object pointing to value. Equivalent to the following code:</p>
<p>id objc_initWeak(id *object, id value) {<br>  *object &#x3D; nil;<br>  return objc_storeWeak(object, value);<br> }</p>
</blockquote>
<p>这个函数会把传入的 object 置为nil，然后执行<code>objc_storeWeak</code>函数。</p>
<hr>
<p>那么<code>objc_storeWeak</code>函数是干什么的呢？下面是这个方法的说明</p>
<blockquote>
<p>Precondition: object is a valid pointer which either contains a null pointer or has been registered as a __weak object. value is null or a pointer to a valid object.<br>If value is a null pointer or the object to which it points has begun deallocation, object is assigned null and unregistered as a __weak object. Otherwise, object is registered as a __weak object or has its registration updated to point to value.<br>Returns the value of object after the call.</p>
</blockquote>
<p>objc_storeWeak函数的用途就很明显了。由于weak表也是用Hash table实现的，所以objc_storeWeak函数就把第一个入参的变量地址注册到weak表中，然后根据第二个入参来决定是否移除。如果第二个参数为0，那么就把__weak变量从weak表中删除记录，并从引用计数表中删除对应的键值记录</p>
<p>所以如果__weak引用的原对象如果被释放了，那么对应的__weak对象就会被指为nil。原来就是通过objc_storeWeak函数这些函数来实现的。</p>
<hr>
<p>接下来是 <code>objc_destoryWeak</code> 函数的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void objc_destroyWeak(id *object) &#123; </span><br><span class="line">    objc_storeWeak(object, nil);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还是调用上面的<code>objc_storeWeak</code>函数，因为传入的value为nil，所以object将从weak表中删除并且置为nil</p>
<h3 id="weak与-strong的作用"><a href="#weak与-strong的作用" class="headerlink" title="__weak与__strong的作用"></a>__weak与__strong的作用</h3><p>终于讲到这两个所有权修饰符的作用了。</p>
<hr>
<p>首先是不使用这两个修饰符时的情况。在上面我们已经讲到过 block 存在 self 的一种情况了，下面我们要讲一下 block 存在 self 并且 self 强应用 block 时的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@interface MyObject ()</span><br><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line">@property (nonatomic, copy) void(^textBlock)(void);</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyObject</span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">    self.textBlock = ^&#123;</span><br><span class="line">        self.name = @&quot;n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation OneViewController </span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    self.object = [[MyObject alloc] init];</span><br><span class="line">    [self.object test]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于 MyObject 来说是造成了循环引用的，因为它强引用了 block，而 block 内部也强引用着 self，所以 MyObject 是不能被dealloc的，但奇怪的是，将 MyObject 当做属性的 OneViewController 竟然可以dealloc，这估计是另一个问题了，等我有空再去研究一下这个。。。</p>
</blockquote>
<p>使用 clang 得到的C++实现，这边只截取了block结构体和初始化block部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct __MyObject__test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __MyObject__test_block_desc_0* Desc;</span><br><span class="line">  MyObject *self;</span><br><span class="line">  __MyObject__test_block_impl_0(void *fp, struct __MyObject__test_block_desc_0 *desc, MyObject *_self, int flags=0) : self(_self) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 初始化</span><br><span class="line">((void (*)())&amp;__MyObject__test_block_impl_0((void *)__MyObject__test_block_func_0, &amp;__MyObject__test_block_desc_0_DATA, self, 570425344)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个部分中可以看到 block 将 self(MyObject *指针)捕获成了自己的成员变量了(强引用), 而self指针的成员变量又包含block，造成循环引用。</p>
<hr>
<p>仅仅使用__weak</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line">@property (nonatomic, copy) void(^textBlock)(void);</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyObject</span><br><span class="line"></span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    self.textBlock = ^&#123;</span><br><span class="line">        weakSelf.name = @&quot;n&quot;;</span><br><span class="line">        NSLog(@&quot;hh&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    self.textBlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 MyObject.m</code>得到C++实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">struct __MyObject__test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __MyObject__test_block_desc_0* Desc;</span><br><span class="line">  MyObject *const __weak weakSelf;</span><br><span class="line">  __MyObject__test_block_impl_0(void *fp, struct __MyObject__test_block_desc_0 *desc, MyObject *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __MyObject__test_block_func_0(struct __MyObject__test_block_impl_0 *__cself) &#123;</span><br><span class="line">  MyObject *const __weak weakSelf = __cself-&gt;weakSelf; // bound by copy</span><br><span class="line"></span><br><span class="line">        ((void (*)(id, SEL, NSString *))(void *)objc_msgSend)((id)weakSelf, sel_registerName(&quot;setName:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_xy_nncr8hn96cd0_rdymw2f0qcw0000gn_T_MyObject_970d18_mi_0);</span><br><span class="line">    &#125;</span><br><span class="line">static void __MyObject__test_block_copy_0(struct __MyObject__test_block_impl_0*dst, struct __MyObject__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;weakSelf, (void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __MyObject__test_block_dispose_0(struct __MyObject__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static struct __MyObject__test_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __MyObject__test_block_impl_0*, struct __MyObject__test_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __MyObject__test_block_impl_0*);</span><br><span class="line">&#125; __MyObject__test_block_desc_0_DATA = &#123; 0, sizeof(struct __MyObject__test_block_impl_0), __MyObject__test_block_copy_0, __MyObject__test_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">static void _I_MyObject_test(MyObject * self, SEL _cmd) &#123;</span><br><span class="line"></span><br><span class="line">    __attribute__((objc_ownership(weak))) typeof(self) weakSelf = self;</span><br><span class="line">    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setTextBlock:&quot;), ((void (*)())&amp;__MyObject__test_block_impl_0((void *)__MyObject__test_block_func_0, &amp;__MyObject__test_block_desc_0_DATA, weakSelf, 570425344)));</span><br><span class="line">    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(&quot;textBlock&quot;))();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>苹果使用一个全局的 weak 表来保存所有的 weak 引用。并将对象作为键，weak_entry_t 作为值。weak_entry_t 中保存了所有指向该对象的 weak 指针。当被指向的对象执行 dealloc 时候，将所有指向该对象的 weak 指针的设置为nil。</p>
<ul>
<li>block 将 __weak 修饰的 self 捕获为成员变量</li>
<li>当 self 执行dealloc时，block 内的 self 置为nil，从而打破循环引用</li>
<li>当 self delloac 之后，在调用 block 的函数指针，block 内部的self置为nil。</li>
</ul>
<hr>
<p>同时使用__weak与__strong</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface MyObject ()</span><br><span class="line">//&#123;</span><br><span class="line">//    NSString *_age;</span><br><span class="line">//&#125;</span><br><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line">@property (nonatomic, copy) void(^textBlock)(void);</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyObject</span><br><span class="line"></span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    self.textBlock = ^&#123;</span><br><span class="line">        __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">        strongSelf.name = @&quot;n&quot;;</span><br><span class="line">        NSLog(@&quot;hh&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    self.textBlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 MyObject.m</code>得到C++实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">struct __MyObject__test_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __MyObject__test_block_desc_0* Desc;</span><br><span class="line">  MyObject *const __weak weakSelf;</span><br><span class="line">  __MyObject__test_block_impl_0(void *fp, struct __MyObject__test_block_desc_0 *desc, MyObject *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __MyObject__test_block_func_0(struct __MyObject__test_block_impl_0 *__cself) &#123;</span><br><span class="line">  MyObject *const __weak weakSelf = __cself-&gt;weakSelf; // bound by copy</span><br><span class="line"></span><br><span class="line">        __attribute__((objc_ownership(strong))) typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">        ((void (*)(id, SEL, NSString *))(void *)objc_msgSend)((id)strongSelf, sel_registerName(&quot;setName:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_xy_nncr8hn96cd0_rdymw2f0qcw0000gn_T_MyObject_0010b9_mi_0);</span><br><span class="line">    &#125;</span><br><span class="line">static void __MyObject__test_block_copy_0(struct __MyObject__test_block_impl_0*dst, struct __MyObject__test_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;weakSelf, (void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __MyObject__test_block_dispose_0(struct __MyObject__test_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static struct __MyObject__test_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __MyObject__test_block_impl_0*, struct __MyObject__test_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __MyObject__test_block_impl_0*);</span><br><span class="line">&#125; __MyObject__test_block_desc_0_DATA = &#123; 0, sizeof(struct __MyObject__test_block_impl_0), __MyObject__test_block_copy_0, __MyObject__test_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">static void _I_MyObject_test(MyObject * self, SEL _cmd) &#123;</span><br><span class="line"></span><br><span class="line">    __attribute__((objc_ownership(weak))) typeof(self) weakSelf = self;</span><br><span class="line">    ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setTextBlock:&quot;), ((void (*)())&amp;__MyObject__test_block_impl_0((void *)__MyObject__test_block_func_0, &amp;__MyObject__test_block_desc_0_DATA, weakSelf, 570425344)));</span><br><span class="line">    ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(&quot;textBlock&quot;))();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>__MyObject__test_block_impl_0</code> block 仍然是将 __weak 修饰的 self 捕获为成员变量</li>
<li>当 self 执行dealloc时，block 内的 self 会被置为nil，从而打破循环引用</li>
<li>block 内的代码在<code>__MyObject__test_block_func_0</code>函数内，当使用<code>strongSelf</code>时，会先取出__weak修饰的成员变量self：<code>MyObject *const __weak weakSelf = __cself-&gt;weakSelf;</code>, 然后再生成一个__strong修饰的局部变量<code>__attribute__((objc_ownership(strong))) typeof(weakSelf) strongSelf = weakSelf;</code>，self 的引用计数 +1。这样的目的是在 block 内的代码块执行完之前避免 self 被dealloc掉。当 block 执行完毕之后，局部变量 strongSelf 被释放，self 的引用计数 -1。</li>
</ul>
<h3 id="weakify-和-strongify"><a href="#weakify-和-strongify" class="headerlink" title="@weakify 和 @strongify"></a>@weakify 和 @strongify</h3><p>这两个是RAC中避免Block循环引用而开发的2个宏，实现过程很牛，值得我们学习。限于篇幅，我就不分析了，想了解可以点开这篇<a href="%5Bhttps://halfrost.com/ios_block_retain_circle/%5D(https://halfrost.com/ios_block_retain_circle/)">博客</a>。<br>这两个宏展开下来就相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self) = @autoreleasepool&#123;&#125; __weak __typeof__ (self) self_weak_ = self;</span><br><span class="line">@strongify(self) = @autoreleasepool&#123;&#125; __strong __typeof__(self) self = self_weak_;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="回到开头"><a href="#回到开头" class="headerlink" title="回到开头"></a>回到开头</h3><p>好了，不知道你看了这么多头晕了没有。。。下面让我们回到开头我碰到的那个问题，为什么我使用了 @weakify 和 @strongify，然后直接使用下划线的成员变量还是会造成循环引用。原因就是<code>_ivar</code>直接使用成员变量，self 跟 weakSelf会同时被 block 捕获成 block 的成员变量，注意：self 还是会被 block 捕获的(前面好像没写例子，不过你可以自己写写看)，导致 block 还是强引用着 self，导致循环引用。解决办法就是 <code>strongSelf -&gt; ivar</code>这样使用成员变量</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>block 会捕捉 block 内部的变量</p>
<ul>
<li>当变量类型是局部变量(基本数据类型时或 oc 类)，仅捕获该变量的值，所以 block 内部和外部这两个变量的地址是不一样的，在block 内部修改变量的值也不会影响 block 外部的变量</li>
<li>当变量是 self 时的情况跟 局部变量时是差不多的</li>
<li>当变量类型是__block修饰的布局变量(基本数据类型或者 oc 类)，会新构建一个结构体，其中成员变量<code>__forwarding</code>会指向栈中该变量的地址，因此在 block 内部修改该变量会影响 block 外部的变量</li>
<li>当变量是全局变量或者全局静态变量时，block 不会捕获该变量，因为变量已经存在在数据区，可以直接调用。此时 block 也保存在数据区</li>
<li>当变量是静态变量时，block 会捕获该变量的地址，因此在 block 内部修改该变量会影响 block 外部的变量</li>
</ul>
</li>
<li><p>block 结构体中的成员变量 <code>descriptor</code> 包含着 <code>copy</code> 和 <code>dispose</code> 两个函数指针。copy 函数把 block 从栈上拷贝到堆上，dispose函数是把堆上的函数在废弃的时候销毁掉。</p>
</li>
<li><p>苹果使用一个全局的 weak 表来保存所有的 weak 引用。并将对象作为键，weak_entry_t 作为值。weak_entry_t 中保存了所有指向该对象的 weak 指针。当被指向的对象执行 dealloc 时候，将所有指向该对象的 weak 指针的设置为nil。</p>
</li>
<li><p>在 block 外部使用 __weak 的原因是，让 block 将这个 __weak修饰的变量捕获成自己的成员变量，这样当外面的变量被 dealloc 后，block 内的该成员变量也将置为 nil，避免循环引用</p>
</li>
<li><p>在 block 里面使用的 __strong 修饰的 weakSelf 是为了在函数生命周期中防止 self 提前释放。strongSelf是一个局部变量，当block内的代码执行完毕就会释放，不会对 self 进行一直进行强引用。</p>
</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="%5Bhttp://blog.sunnyxx.com/2015/01/17/self-in-arc/%5D(http://blog.sunnyxx.com/2015/01/17/self-in-arc/)">ARC对self的内存管理</a><br><a href="%5Bhttps://halfrost.com/ios_block/%5D(https://halfrost.com/ios_block/)">深入研究 Block 捕获外部变量和 __block 实现原理</a><br><a href="%5Bhttps://halfrost.com/ios_block_retain_circle/%5D(https://halfrost.com/ios_block_retain_circle/)">深入研究 Block 用 weakSelf、strongSelf、@weakify、@strongify 解决循环引用</a><br> <a target="_blank" rel="noopener" href="https://blog.devtang.com/2013/07/28/a-look-inside-blocks/" title="谈Objective-C block的实现">谈Objective-C block的实现</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-06-13T11:24:54.000Z" title="6/13/2019, 7:24:54 PM">2019-06-13</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">5 分钟读完 (大约705个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/06/13/self-class-%E5%92%8C-super-class/">[self class]和[super class]</a></h1><div class="content"><p>今天在学习runtime的时候，碰到一个有意思的题目，相信很多人都曾经看到过：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@implementation Son : Father</span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>输出为<code>Son和Son</code>，为什么呢？当我们使用 <code>clang -rewrite-objc Son.m</code>文件，可以看到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_xy_nncr8hn96cd0_rdymw2f0qcw0000gn_T_MyObject_bf216e_mi_1, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(&quot;class&quot;))));</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_xy_nncr8hn96cd0_rdymw2f0qcw0000gn_T_MyObject_bf216e_mi_2, NSStringFromClass(((Class (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(&quot;Son&quot;))&#125;, sel_registerName(&quot;class&quot;))));</span><br></pre></td></tr></table></figure>

<p>这里需要明白以下几个概念：</p>
<h4 id="方法中的隐藏参数-self"><a href="#方法中的隐藏参数-self" class="headerlink" title="方法中的隐藏参数 self"></a>方法中的隐藏参数 self</h4><p>我们经常在方法中使用self关键字来引用实例本身，但从没有想过为什么self就能取到调用当前方法的对象吧。其实self的内容是在方法运行时被偷偷的动态传入的。当<code>objc_msgSend</code>找到方法对应的实现时，它将直接调用该方法实现，并将消息中所有的参数都传递给方法实现,同时,它还将传递两个隐藏的参数:</p>
<ul>
<li>接收消息的对象（也就是self指向的内容）</li>
<li>方法选择器（_cmd指向的内容）<br>之所以说它们是隐藏的是因为在源代码方法的定义中并没有声明这两个参数。它们是在代码被编译时被插入实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static void _I_MyObject_test(MyObject * self, SEL _cmd) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 clang 将代码转换成C++实现，我们可以看到方法的两个隐藏参数 self 和 _cmd</p>
<h4 id="objc-msgSend-和-objc-msgSendSuper的定义"><a href="#objc-msgSend-和-objc-msgSendSuper的定义" class="headerlink" title="objc_msgSend 和 objc_msgSendSuper的定义"></a>objc_msgSend 和 objc_msgSendSuper的定义</h4><p>先给出 objc_msgSend 和 objc_msgSendSuper的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSend(id self, SEL op, ...)</span><br><span class="line">id objc_msgSendSuper(struct objc_super *super, SEL op, ...)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而 ‘objc_super’的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct objc_super &#123;</span><br><span class="line">  __unsafe_unretained id receiver;</span><br><span class="line">  __unsafe_unretained Class super_class;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Class-class-方法的实现"><a href="#Class-class-方法的实现" class="headerlink" title="- (Class)class 方法的实现"></a>- (Class)class 方法的实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (Class)class &#123;</span><br><span class="line">    return object_getClass(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>现在再让我们看一下调用 <code>[super class]</code> 会发生什么</p>
<ul>
<li>当我们对 super 关键字发送消息时，编译器会创建一个 objc_super 的结构体，其中 receiver 仍旧为 self，而super_class为父类</li>
<li>调用 objc_msgSendSuper()方法，会去 Father 的实例方法列表中寻找 class 这个方法，找不到，去 NSObject 中查找</li>
<li>调用 NSObject 的 - (Class)class 方法，因为隐藏参数 self 为 son的实例，所以返回 Son</li>
</ul>
<p>所以当我们调用 [self class] 和 [super class] 方法返回的都是 Son。</p>
<p>加入我们在Father中重载 -(Class)class 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (Class)class &#123;</span><br><span class="line">   return NSClassFromString(@&quot;Father&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么得到的输出将变成 Son 和 Father！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-05-16T07:30:04.000Z" title="5/16/2019, 3:30:04 PM">2019-05-16</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">23 分钟读完 (大约3489个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/05/16/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8JTForm/">如何使用JTForm</a></h1><div class="content"><p><img src="https://img.shields.io/badge/plateform-iOS9.0%2B-orange.svg"><br><img src="https://img.shields.io/badge/language-OC-orange.svg"></p>
<p><img src="https://img.shields.io/badge/pod-0.0.1-blue.svg"><br><img src="https://img.shields.io/badge/license-MIT-green.svg"></p>
<p><code>JTForm</code>是一个能简单快速的搭建流畅复杂表单的库，灵感来自于<a target="_blank" rel="noopener" href="https://github.com/xmartlabs/XLForm">XLForm</a>与<a target="_blank" rel="noopener" href="https://github.com/TextureGroup/Texture">Texture</a>。JTForm能帮助你像html一样创建表单。不同于<code>XLForm</code>是一个<code>UIViewController</code>的子类，<code>JTForm</code>是<code>UIView</code>的子类，也就是说，你可以像使用UIView一样使用JTForm，应用范围更广，更方便。JTForm也可以用来创建列表，而不仅仅是表单。</p>
<p>JTForm使用<code>Texture</code>完成视图的布局与加载，所以集成了Texture的优点：异步渲染，极度流畅。使用JTForm，你可以忘记许多原生控件时需要注意的东西：高度设置，单元行复用等。为了避免<code>ASTableNode</code>重载时图片闪烁的问题，自定义了<code>JTNetworkImageNode</code>代替<code>ASNetworkImageNode</code>。</p>
<p>下面是demo运行在公司老旧设备5s的截图，可以看到fps基本保持在60左右。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g325b2cv3cg30a00dce84.gif" alt="fps基本保持在60"><br><img src="https://i.loli.net/2019/05/15/5cdbdf7c76a0541205.gif" alt="text输入表单"></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>测试一下</p>
<ul>
<li>使用cocoapods：<code>pod &#39;JTForm&#39;, &#39;~&gt; 0.0.1&#39;</code></li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>如果库自带的单元行满足不了需求，需要自定义单元行的时候，需要了解<a target="_blank" rel="noopener" href="https://github.com/TextureGroup/Texture">Texture</a>的相关知识。</li>
<li>如果你的项目中有类似<code>‎IQKeyboardManager</code>的第三方，请在使用JTForm的时候禁用他们，不然会跟库的键盘弹起相冲突。如果你想禁用JTForm的键盘弹起，你可以设置<code>JTForm</code>的属性<code>showInputAccessoryView</code>为NO</li>
</ul>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p><img src="https://i.loli.net/2019/05/15/5cdbdf7c76a0541205.gif" alt="简单的表单1"></p>
<p>下面是构建该表单一部分的代码以及注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">// 构建表描述</span><br><span class="line">JTFormDescriptor *formDescriptor = [JTFormDescriptor formDescriptor];</span><br><span class="line">// 是否在必填行的title前面添加一个红色的*</span><br><span class="line">formDescriptor.addAsteriskToRequiredRowsTitle = YES;</span><br><span class="line">JTSectionDescriptor *section = nil;</span><br><span class="line">JTRowDescriptor *row = nil;</span><br><span class="line">       </span><br><span class="line">#pragma mark - float text</span><br><span class="line">// 创建节描述    </span><br><span class="line">section = [JTSectionDescriptor formSection];</span><br><span class="line">// 为section创建header title，目前需要手动输入header view的height</span><br><span class="line">section.headerAttributedString = [NSAttributedString attributedStringWithString:@&quot;float text&quot; font:nil color:nil firstWordColor:nil];</span><br><span class="line">// 目前需要手动输入header view的height，不然是默认值，可能会出现排版显示问题</span><br><span class="line">section.headerHeight = 30.;</span><br><span class="line">// 将节描述添加到表描述中</span><br><span class="line">[formDescriptor addFormSection:section];</span><br><span class="line">    </span><br><span class="line">// 创建行描述，rowType为必填项，创建单元行时根据rowType来选择创建不同的单元行    </span><br><span class="line">row = [JTRowDescriptor formRowDescriptorWithTag:JTFormRowTypeFloatText rowType:JTFormRowTypeFloatText title:@&quot;测试&quot;];</span><br><span class="line">// 是否必填</span><br><span class="line">row.required = YES;</span><br><span class="line">// 将行描述添加到表描述中</span><br><span class="line">[section addFormRow:row];</span><br><span class="line">    </span><br><span class="line">#pragma mark - formatter</span><br><span class="line">    </span><br><span class="line">row = [JTRowDescriptor formRowDescriptorWithTag:@&quot;20&quot; rowType:JTFormRowTypeNumber title:@&quot;百分比&quot;];</span><br><span class="line">NSNumberFormatter *numberFormatter = [NSNumberFormatter new];</span><br><span class="line">numberFormatter.numberStyle = NSNumberFormatterPercentStyle;</span><br><span class="line">// 添加valueFormatter，是NSFormatter的子类，能将value转换成不同的文本。常用的有nsdateformatter</span><br><span class="line">// 这里valueFormatter的作用是将数字转换成百分数，例如10-&gt;1000%</span><br><span class="line">row.valueFormatter = numberFormatter;</span><br><span class="line">row.value = @(100);</span><br><span class="line">row.required = YES;</span><br><span class="line">// 在title前面添加图片</span><br><span class="line">row.image = [UIImage imageNamed:@&quot;jt_money&quot;];</span><br><span class="line">[section addFormRow:row];</span><br><span class="line">    </span><br><span class="line">row = [JTRowDescriptor formRowDescriptorWithTag:@&quot;21&quot; rowType:JTFormRowTypeNumber title:@&quot;人民币&quot;];</span><br><span class="line">NSNumberFormatter *numberFormatter1 = [NSNumberFormatter new];</span><br><span class="line">numberFormatter1.numberStyle = NSNumberFormatterCurrencyStyle;</span><br><span class="line">// 这里valueFormatter的作用是将数字转换成货币，例如10-&gt;￥10</span><br><span class="line">row.valueFormatter = numberFormatter1;</span><br><span class="line">row.value = @(100);</span><br><span class="line">row.required = YES;</span><br><span class="line">row.image = [UIImage imageNamed:@&quot;jt_money&quot;];</span><br><span class="line">[section addFormRow:row];</span><br><span class="line">       </span><br><span class="line">#pragma mark - common</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">row = [JTRowDescriptor formRowDescriptorWithTag:JTFormRowTypeName rowType:JTFormRowTypeName title:@&quot;JTFormRowTypeName&quot;];</span><br><span class="line">// 占位符</span><br><span class="line">row.placeHolder = @&quot;请输入姓名...&quot;;</span><br><span class="line">// 赋值</span><br><span class="line">row.value = @&quot;djdjd&quot;;</span><br><span class="line">row.required = YES;</span><br><span class="line">[section addFormRow:row];</span><br><span class="line"></span><br><span class="line">// 创建JTForm，formDescriptor不能为空</span><br><span class="line">JTForm *form = [[JTForm alloc] initWithFormDescriptor:formDescriptor];</span><br><span class="line">form.frame = CGRectMake(0, 0, kJTScreenWidth, kJTScreenHeight-64.);</span><br><span class="line">[self.view addSubview:form];</span><br><span class="line">self.form = form;</span><br></pre></td></tr></table></figure>
<h3 id="行描述-JTRowDescriptor"><a href="#行描述-JTRowDescriptor" class="headerlink" title="行描述 JTRowDescriptor"></a>行描述 JTRowDescriptor</h3><p>行描述<code>JTRowDescriptor</code>是单元行的数据源，我们通过修改行描述来控制着单元行的行为，例如：是否显示，是否可编辑，高度。<br>下面是JTRowDescriptor的主要属性和常用方法</p>
<h4 id="configMode"><a href="#configMode" class="headerlink" title="configMode"></a>configMode</h4><p>配置模型。</p>
<ul>
<li>titleColor：标题颜色</li>
<li>contentColor：详情颜色</li>
<li>placeHolderColor：占位符颜色</li>
<li>disabledTitleColor：禁用时标题颜色</li>
<li>disabledContentColor：禁用时详情颜色</li>
<li>bgColor：控件背景颜色</li>
<li>titleFont：标题字体 </li>
<li>contentFont：详情字体</li>
<li>placeHlderFont：占位符字体</li>
<li>disabledTitleFont：禁用时标题字体</li>
<li>disabledContentFont：禁用时详情字体</li>
</ul>
<p><code>JTSectionDescriptor</code>和<code>JTFormDescriptor</code>同样具有这些属性，作用也类似。优先级JTRowDescriptor &gt; JTSectionDescriptor &gt; JTFormDescriptor</p>
<h4 id="image-amp-imageUrl"><a href="#image-amp-imageUrl" class="headerlink" title="image &amp; imageUrl"></a>image &amp; imageUrl</h4><p>用于加载图片，样式类似于UITableViewCell的imageView。image应用于静态图片，imageUrl用于加载网络图片。</p>
<h4 id="rowType"><a href="#rowType" class="headerlink" title="rowType"></a>rowType</h4><p>创建表单时，根据<code>rowType</code>来创建不同类型的单元行。目前库自带的<code>rowType</code>都已经添加到了<code>[JTForm cellClassesForRowTypes]</code>字典中，其中<code>rowType</code>为key，单元行类型Class为value。在创建时单元行时，你就可以通过字典根据<code>rowType</code>得到相应单元行的Class。</p>
<p>所以当你自定义单元行时，你需要在<code>+ (void)load</code>中，将相应的rowType以及对应的Class添加到<code>[JTForm cellClassesForRowTypes]</code>字典中。</p>
<h4 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h4><p>nullable，若不为空，表单将其添加到字典中，其中key为tag，value为<code>JTRowDescriptor</code>实例。所以如果创建表单时有多个行描述tag值一样的话，字典中将只会保存最后添加进去的JTRowDescriptor。</p>
<p>你可以在表单中，根据tag值找到相对应的行描述。且在获取整个表单值的时候也会派上用场。</p>
<h4 id="height"><a href="#height" class="headerlink" title="height"></a>height</h4><p>该属性控制着单元行高度。默认值为<code>JTFormUnspecifiedCellHeight</code>，即不指定高度(自动调节高度)。</p>
<p>单元行高度的优先级：</p>
<ul>
<li>JTRowDescriptor的height属性</li>
<li>JTBaseCellDelegate的方法<code>+ (CGFloat)formCellHeightForRowDescriptor:(JTRowDescriptor *)row;</code></li>
<li>自动调节高度</li>
</ul>
<h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><p>响应事件，目前仅用于点击单元行。如果单元行上有多个控件有响应事件时，建议使用<code>- (JTBaseCell *)cellInForm;</code>得到当前的单元行cell，然后用<code>[cell.button addTarget:self action:action forControlEvents:UIControlEvents]</code>添加响应事件。</p>
<h4 id="hidden-amp-disabled"><a href="#hidden-amp-disabled" class="headerlink" title="hidden &amp; disabled"></a>hidden &amp; disabled</h4><p>hidden：bool值，控制隐藏或者显示当前单元行<br>disabled：bool值，控制当前单元行是否接受响应事件</p>
<p><code>JTSectionDescriptor</code>和<code>JTFormDescriptor</code>同样具有这些属性，作用也类似。优先级JTRowDescriptor &gt; JTSectionDescriptor &gt; JTFormDescriptor</p>
<h4 id="cellConfigAfterUpdate-amp-cellConfigWhenDisabled-amp-cellConfigAtConfigure-amp-cellDataDictionary"><a href="#cellConfigAfterUpdate-amp-cellConfigWhenDisabled-amp-cellConfigAtConfigure-amp-cellDataDictionary" class="headerlink" title="cellConfigAfterUpdate &amp; cellConfigWhenDisabled &amp; cellConfigAtConfigure &amp; cellDataDictionary"></a>cellConfigAfterUpdate &amp; cellConfigWhenDisabled &amp; cellConfigAtConfigure &amp; cellDataDictionary</h4><ul>
<li>cellConfigAfterUpdate：配置cell，在‘update’方法后使用</li>
<li>cellConfigWhenDisabled：配置cell，当’update’方法后，且disabled属性为Yes时被使用</li>
<li>cellConfigAtConfigure：配置cell，当cell调用config之后，update方法之前调用</li>
<li>cellDataDictionary：预留，你可以选择使用时机</li>
</ul>
<h4 id="text"><a href="#text" class="headerlink" title="text"></a>text</h4><p>文本方面的，属性比较多，统一放到这里讲</p>
<ul>
<li>valueFormatter：文本格式转换，可以将数据格式化为一种易读的格式。‘NSFormatter’是一个抽象类，我们只使用它的子类，类似’NSDateFormatter’和‘NSNumberFormatter’</li>
<li>placeHolder：占位符，当value为空时显示该内容</li>
<li>maxNumberOfCharacters：文本类单元行能输入最大字符数</li>
<li><code>- (nullable NSString *)displayContentValue;</code>:在未编辑状态时，详情的显示内容</li>
<li><code>- (nullable NSString *)editTextValue;</code>：在编辑状态时，详情的显示内容</li>
</ul>
<h4 id="验证器"><a href="#验证器" class="headerlink" title="验证器"></a>验证器</h4><p>你可以通过<code>- (void)addValidator:(nonnull id&lt;JTFormValidateProtocol&gt;)validator;</code>添加一个或多个验证器，验证器的作用是对单元行的值进行验证，来判断是否符合你的要求，例如：身份证格式，密码的复杂程度，字数长度等。</p>
<p>当然，除了库自带的验证器外，你可以自定义自己的验证器，注意需要实现代理<code>JTFormValidateProtocol</code>。</p>
<h3 id="单元行类型"><a href="#单元行类型" class="headerlink" title="单元行类型"></a>单元行类型</h3><h4 id="文本类"><a href="#文本类" class="headerlink" title="文本类"></a>文本类</h4><ul>
<li>JTFormRowTypeFloatText</li>
<li>JTFormRowTypeText</li>
<li>JTFormRowTypeName</li>
<li>JTFormRowTypeEmail</li>
<li>JTFormRowTypeNumber</li>
<li>JTFormRowTypeInteger</li>
<li>JTFormRowTypeDecimal</li>
<li>JTFormRowTypePassword</li>
<li>JTFormRowTypePhone</li>
<li>JTFormRowTypeURL</li>
<li>JTFormRowTypeTextView</li>
<li>JTFormRowTypeInfo</li>
</ul>
<p>主要的区别是键盘不同，需要注意的是：<code>JTFormRowTypeTextView</code>和<code>JTFormRowTypeInfo</code>是<code>textview</code>，而其它几种是<code>textfield</code>。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g338qy6tc3g30a00dckjl.gif" alt="text"></p>
<h4 id="select类"><a href="#select类" class="headerlink" title="select类"></a>select类</h4><ul>
<li>JTFormRowTypePushSelect</li>
</ul>
<p>push到另一个vc中，仅可选择一个</p>
<ul>
<li>JTFormRowTypeMultipleSelect</li>
</ul>
<p>push到另一个vc中，可选择多个</p>
<ul>
<li>JTFormRowTypeSheetSelect</li>
</ul>
<p>UIAlertController，样式为UIAlertControllerStyleActionSheet</p>
<ul>
<li>JTFormRowTypeAlertSelect</li>
</ul>
<p>UIAlertController，样式为UIAlertControllerStyleAlert</p>
<ul>
<li>JTFormRowTypePickerSelect</li>
</ul>
<p>类似于弹出键盘，inputview为UIPickeraaa</p>
<p>选择项通常会拥有一个展示文本，一个是代表value的id。例如你在选择汽车型号的时候，展示给你的是不同汽车的型号的文本，当你选中之后传给后台的是代表该型号的文本。</p>
<p>在选择类的单元行中，我们使用的选择项类型是<code>JTOptionObject</code>，主要由两个属性<code>formDisplayText</code>和<code>formValue</code>，含义顾名思义。选择项可以通过<code>selectorOptions</code>赋值得到，在单元行选中之后，单元行的value也是<code>JTOptionObject</code>类型(单选)或者为<code>NSArray&lt;JTOptionObject *&gt; *</code>类型(多选)，你可以使用NSObject类目方法<code>- (id)cellValue;</code>得到value。</p>
<h4 id="date类"><a href="#date类" class="headerlink" title="date类"></a>date类</h4><ul>
<li>JTFormRowTypeDate</li>
<li>JTFormRowTypeTime</li>
<li>JTFormRowTypeDateTime</li>
<li>JTFormRowTypeCountDownTimer</li>
<li>JTFormRowTypeDateInline</li>
</ul>
<p>除了<code>JTFormRowTypeDateInline</code>，其余集中的区别只是<code>UIDatePicker</code>中<code>timeStyle</code>和<code>timeStyle</code>的区别。<code>JTFormRowTypeDateInline</code>的效果如下：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g339l0w8gdg30a00dcwph.gif" alt="JTFormRowTypeDateInline"></p>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul>
<li>JTFormRowTypeSwitch</li>
<li>JTFormRowTypeCheck</li>
<li>JTFormRowTypeStepCounter</li>
<li>JTFormRowTypeSegmentedControl</li>
<li>JTFormRowTypeSlider</li>
</ul>
<p>具体样式可以看demo</p>
<h3 id="JTBaseCell"><a href="#JTBaseCell" class="headerlink" title="JTBaseCell"></a>JTBaseCell</h3><p>单元行的基类，如果你需要自定义单元行的话需要继承它。<code>JTBaseCell</code>里面的属性和方法都比较简单，需要注意的是<code>JTBaseCellDelegate</code>，下面来我来说明一下它的几个方法：</p>
<h4 id="config"><a href="#config" class="headerlink" title="config"></a>config</h4><p>required。初始化控件，在这个方法里只需要创建需要的控件，但不需要为控件添加内容，因为这个时候并没有添加进去数据源<code>JTRowDescriptor</code>。在生命周期内该方法只会被调用一次，除非调用<code>JTRowDescriptor</code>的方法<code>reloadCell</code>，该方法会重新创建单元行。</p>
<p>子类中实现时需要调用<code>[super config]</code></p>
<h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><p>required。更新视图内容，在生命周期中会被多次调用。在这个方法中，我们可以为已经创建好的内容添加内容。</p>
<p>子类中实现时需要调用<code>[super update]</code></p>
<h4 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h4><blockquote>
<p>剩下的几个方法都是@optional</p>
</blockquote>
<ul>
<li><code>+ (CGFloat)formCellHeightForRowDescriptor:(JTRowDescriptor *)row</code></li>
</ul>
<p>指定单元行的高度</p>
<ul>
<li><code>- (BOOL)formCellCanBecomeFirstResponder</code></li>
</ul>
<p>指示单元行是否能够成为第一响应者, 默认返回NO</p>
<ul>
<li><code>- (BOOL)formCellBecomeFirstResponder</code></li>
</ul>
<p>单元行成为第一响应者</p>
<ul>
<li><code>- (BOOL)formCellResignFirstResponder</code></li>
</ul>
<p>单元行放弃第一响应者</p>
<ul>
<li><code>- (void)formCellDidSelected</code></li>
</ul>
<p>当前的单元行被选中了</p>
<ul>
<li><code>- (NSString *)formDescriptorHttpParameterName</code></li>
</ul>
<p>为单元行设置一个参数名称。若不为空，当调用<code>JTFormDescriptor</code>的方法<code>httpParameters</code>返回的表单字典中，key为该参数名称，value为JTRowDescriptor的value。</p>
<ul>
<li><code>- (void)formCellHighlight</code></li>
</ul>
<p>单元行高亮</p>
<ul>
<li><code>- (void)formCellUnhighlight</code></li>
</ul>
<p>单元行不高亮</p>
<h3 id="自定义单元行"><a href="#自定义单元行" class="headerlink" title="自定义单元行"></a>自定义单元行</h3><p>以demo中我自定义的单元行<code>IGCell</code>为例。</p>
<h4 id="void-load"><a href="#void-load" class="headerlink" title="+ (void)load"></a>+ (void)load</h4><p>首先，你需要一个rowType来代表该行。然后在<code>+ (void)load</code>方法中<code>[[JTForm cellClassesForRowTypes] setObject:self forKey:JTFormRowTypeIGCell];</code>将rowType与单元行关联起来。</p>
<h4 id="config-1"><a href="#config-1" class="headerlink" title="config"></a>config</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)config</span><br><span class="line">&#123;</span><br><span class="line">  [super config];  </span><br><span class="line">  // 你的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里你可以创建好控件，但不需要为控件添加内容。注意需要调用<code>[super config];</code>。</p>
<h4 id="update-1"><a href="#update-1" class="headerlink" title="update"></a>update</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)update</span><br><span class="line">&#123;</span><br><span class="line">  [super update];  </span><br><span class="line">  // 你的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，我们可以为已经创建好的内容添加内容。。注意需要调用<code>[super update];</code></p>
<h4 id="layoutSpecThatFits"><a href="#layoutSpecThatFits" class="headerlink" title="layoutSpecThatFits"></a>layoutSpecThatFits</h4><p><code>- (ASLayoutSpec *)layoutSpecThatFits:(ASSizeRange)constrainedSize</code>。在这个方法中，你需要创建好布局。对此，你需要额外学习<code>Texture</code>(原AsyncDisplayKit)的布局系统。</p>
<h3 id="表单行为控制"><a href="#表单行为控制" class="headerlink" title="表单行为控制"></a>表单行为控制</h3><h4 id="hidden"><a href="#hidden" class="headerlink" title="hidden"></a>hidden</h4><p>当表单完成之后，你可以通过改变<code>JTRowDescriptor</code>,<code>JTSectionDescriptor</code>,<code>JTFormDescriptor</code> hidden的值来隐藏或者显示相应的单元行，单元节，表单。</p>
<h4 id="disabled"><a href="#disabled" class="headerlink" title="disabled"></a>disabled</h4><p>你可以通过改变<code>JTRowDescriptor</code>,<code>JTSectionDescriptor</code>,<code>JTFormDescriptor</code> disabled的值来决定相应的单元行，单元节，表单是否可以被编辑。</p>
<h4 id="delete-row"><a href="#delete-row" class="headerlink" title="delete row"></a>delete row</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JTSectionDescriptor *section = [JTSectionDescriptor formSection];</span><br><span class="line">section.sectionOptions = JTFormSectionOptionCanDelete;</span><br></pre></td></tr></table></figure>
<p>你可以这样创建节描述，就可以让单元节具有删除单元行功能。</p>
<h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h4 id="如何给section自定义-header-x2F-footer"><a href="#如何给section自定义-header-x2F-footer" class="headerlink" title="如何给section自定义 header&#x2F;footer"></a>如何给section自定义 header&#x2F;footer</h4><p>你也可以通过设置<code>JTSectionDescriptor</code>的<code>headerHieght</code>和<code>headerView</code>或者<code>footerHieght</code>和<code>footerView</code>属性来自定义header&#x2F;footer。目前需要手动设置高度…</p>
<h4 id="如何拿到表单的值"><a href="#如何拿到表单的值" class="headerlink" title="如何拿到表单的值"></a>如何拿到表单的值</h4><p>你可以通过<code>JTForm</code>的<code>- (NSDictionary *)formValues</code>获取表单值。如果设置了验证器或者有必填项，可以先调用<code>- (NSArray&lt;NSError *&gt; *)formValidationErrors</code>来获取错误集合，再获取表单值进行其它操作。</p>
<h4 id="如何给日期行设置最大，最小日期"><a href="#如何给日期行设置最大，最小日期" class="headerlink" title="如何给日期行设置最大，最小日期"></a>如何给日期行设置最大，最小日期</h4><p>你可以通过下面的代码这样设置，虽然丑陋，但是能用…</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[row.cellConfigAtConfigure setObject:[NSDate date] forKey:@&quot;minimumDate&quot;];</span><br><span class="line">[row.cellConfigAtConfigure setObject:[NSDate dateWithTimeIntervalSinceNow:(60*60*24*3)] forKey:@&quot;maximumDate&quot;];</span><br></pre></td></tr></table></figure>

<h4 id="如何改变cell的高度"><a href="#如何改变cell的高度" class="headerlink" title="如何改变cell的高度"></a>如何改变cell的高度</h4><p>单元行高度的优先级：</p>
<ul>
<li>JTRowDescriptor的height属性</li>
<li>JTBaseCellDelegate的方法<code>+ (CGFloat)formCellHeightForRowDescriptor:(JTRowDescriptor *)row;</code></li>
<li>根据布局来生成高度</li>
</ul>
<h4 id="如何自定义类似于JTFormRowTypeDateInline的内联行"><a href="#如何自定义类似于JTFormRowTypeDateInline的内联行" class="headerlink" title="如何自定义类似于JTFormRowTypeDateInline的内联行"></a>如何自定义类似于JTFormRowTypeDateInline的内联行</h4><p>如果你想要创建类似<code>JTFormRowTypeDateInline</code>的内联行，就意味着你需要自定义两种单元行。拿JTFormRowTypeDateInline举个例子，A：JTFormDateCell，B：JTFormDateInlineCell。当你选中A时，B显示出来，再选中A，B消失。</p>
<ul>
<li>首先，创建两种单元行A, B</li>
<li>B在<code>load</code>方法中，还需要额外添加<code>[[JTForm inlineRowTypesForRowTypes] setObject: A.rowType forKey:B.rowType]</code></li>
<li>剩下的操作为以下代码，你可以照着写。这里简单说明以下，当你选择A时，会调用<code>formCellCanBecomeFirstResponder</code>和<code>formCellBecomeFirstResponder</code>方法。随后调用<code>canBecomeFirstResponder</code>和<code>becomeFirstResponder</code>，注意这里必须调用super的方法，不然当前单元行无法成为第一响应者。在<code>becomeFirstResponder</code>中，我们创建B，并且添加到A后面。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)formCellCanBecomeFirstResponder</span><br><span class="line">&#123;</span><br><span class="line">    return [self canBecomeFirstResponder];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)formCellBecomeFirstResponder</span><br><span class="line">&#123;</span><br><span class="line">    if ([self isFirstResponder]) &#123;</span><br><span class="line">        return [self resignFirstResponder];</span><br><span class="line">    &#125;</span><br><span class="line">    return [self becomeFirstResponder];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)canBecomeFirstResponder</span><br><span class="line">&#123;</span><br><span class="line">    [super canBecomeFirstResponder];</span><br><span class="line">    return !self.rowDescriptor.disabled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)becomeFirstResponder</span><br><span class="line">&#123;</span><br><span class="line">    [super becomeFirstResponder];</span><br><span class="line"></span><br><span class="line">    NSIndexPath *currentIndexPath = [self.rowDescriptor.sectionDescriptor.formDescriptor indexPathForRowDescriptor:self.rowDescriptor];</span><br><span class="line">    JTSectionDescriptor *section = [self.rowDescriptor.sectionDescriptor.formDescriptor.formSections objectAtIndex:currentIndexPath.section];</span><br><span class="line">    JTRowDescriptor *inlineRow = [JTRowDescriptor formRowDescriptorWithTag:nil rowType:JTFormRowTypeInlineDatePicker title:nil];</span><br><span class="line">    JTFormDateInlineCell *inlineCell = (JTFormDateInlineCell *)[inlineRow cellInForm];</span><br><span class="line"></span><br><span class="line">    NSAssert([inlineCell conformsToProtocol:@protocol(JTFormInlineCellDelegate)], @&quot;inline cell must conform to protocol &#x27;JTFormInlineCellDelegate&#x27;&quot;);</span><br><span class="line">    inlineCell.connectedRowDescriptor = self.rowDescriptor;</span><br><span class="line"></span><br><span class="line">    [section addFormRow:inlineRow afterRow:self.rowDescriptor];</span><br><span class="line">    [self.findForm ensureRowIsVisible:inlineRow];</span><br><span class="line"></span><br><span class="line">    BOOL result = [super becomeFirstResponder];</span><br><span class="line">    if (result) &#123;</span><br><span class="line">        [self.findForm beginEditing:self.rowDescriptor];</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)canResignFirstResponder</span><br><span class="line">&#123;</span><br><span class="line">    BOOL result = [super canResignFirstResponder];</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)resignFirstResponder</span><br><span class="line">&#123;</span><br><span class="line">    BOOL result = [super resignFirstResponder];</span><br><span class="line">    if ([self.rowDescriptor.rowType isEqualToString:JTFormRowTypeDateInline]) &#123;</span><br><span class="line">        NSIndexPath *currentIndexPath = [self.rowDescriptor.sectionDescriptor.formDescriptor indexPathForRowDescriptor:self.rowDescriptor];</span><br><span class="line">        NSIndexPath *nextRowPath = [NSIndexPath indexPathForRow:currentIndexPath.row + 1 inSection:currentIndexPath.section];</span><br><span class="line">        JTRowDescriptor *inlineRow = [self.rowDescriptor.sectionDescriptor.formDescriptor formRowAtIndex:nextRowPath];</span><br><span class="line">        if ([inlineRow.rowType isEqualToString:JTFormRowTypeInlineDatePicker]) &#123;</span><br><span class="line">            [self.rowDescriptor.sectionDescriptor removeFormRow:inlineRow];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-05-14T01:52:13.000Z" title="5/14/2019, 9:52:13 AM">2019-05-14</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">3 分钟读完 (大约408个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/05/14/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8Bundle%E8%B5%84%E6%BA%90%E5%8C%85/">如何创建和使用Bundle资源包</a></h1><div class="content"><p>说来惭愧，虽然已经创建过好几次了，但是偶尔还是会忘记步骤，所以在这里记录一下子，方便查阅。</p>
<blockquote>
<p>简单来说，bundle就是一个文件，里面包含很多资源子文件，例如图片，音频，视频等。这些子文件是静态的，不参与编译。</p>
</blockquote>
<h3 id="创建及设置"><a href="#创建及设置" class="headerlink" title="创建及设置"></a>创建及设置</h3><p> 创建bundle</p>
<p><img src="https://i.loli.net/2019/05/14/5cda23f2f305b25735.jpg" alt="创建bundle项目"></p>
<p> 将<code>base sdk</code>改成<code>iOS</code>样式，默认是<code>macOS</code>样式</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g30ky46kufj31dq0dkwfu.jpg" alt="设置平台版本"></p>
<p> 将<code>COMBINE_HIDPI_IMAGES</code>设置为NO，否则打包完成之后的png图片将变为tiff格式<br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g30ky46kufj31dq0dkwfu.jpg" alt="设置COMBINE_HIDPI_IMAGES为NO"></p>
<h3 id="添加多语言"><a href="#添加多语言" class="headerlink" title="添加多语言"></a>添加多语言</h3><ol>
<li><p>添加文字文件，文件名字为<code>Localizable.strings</code><br><img src="https://i.loli.net/2019/05/14/5cda24eee695c52262.jpg" alt="添加多语言文件"></p>
</li>
<li><p>文件本地化，点击按钮后选择english<br><img src="https://i.loli.net/2019/05/14/5cda25052088487962.jpg" alt="文件本地化"></p>
</li>
<li><p>添加其他语言类型，例如<code>chinese-simplified</code><br><img src="https://i.loli.net/2019/05/14/5cda251577f7497943.jpg" alt="添加其他语言类型"></p>
</li>
</ol>
<h3 id="添加图片等文件资源"><a href="#添加图片等文件资源" class="headerlink" title="添加图片等文件资源"></a>添加图片等文件资源</h3><p>目前我的操作是将这些文件直接拖到项目中</p>
<h3 id="如何调用bundle里面的资源"><a href="#如何调用bundle里面的资源" class="headerlink" title="如何调用bundle里面的资源"></a>如何调用bundle里面的资源</h3><p>将bundle拖到项目中，并且添加到<code>build phases</code>的<code>Copy Bundle Resource</code>中</p>
<h4 id="图片类资源"><a href="#图片类资源" class="headerlink" title="图片类资源"></a>图片类资源</h4><p><code>UIImage *image = [UIImage imageNamed:@&quot;bundleName/picName&quot;]</code></p>
<p>bundleName: 包名<br>picName: 图片名</p>
<h4 id="语言本地化"><a href="#语言本地化" class="headerlink" title="语言本地化"></a>语言本地化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;bundleName&quot; withExtension:@&quot;bundle&quot;];</span><br><span class="line">NSBundle *bundle = [NSBundle bundleWithURL:url];</span><br><span class="line">NSString *language = [NSLocale preferredLanguages].firstObject;</span><br><span class="line">bundle = [NSBundle bundleWithPath:[bundle pathForResource:language ofType:@&quot;lproj&quot;]];</span><br><span class="line">NSString *value = [bundle localizedStringForKey:key value:key table:nil];</span><br></pre></td></tr></table></figure>
<p>bundleName：包名</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-03-13T02:46:13.000Z" title="3/13/2019, 10:46:13 AM">2019-03-13</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">7 分钟读完 (大约1074个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/03/13/NSError%E4%BA%86%E8%A7%A3%E4%B8%80%E5%93%88/">NSError了解一哈</a></h1><div class="content"><p> 说来惭愧，工作以来一直没有好好了解<code>NSError</code>这个类。这次的话因为一些需求，准备系统的学习一下子，下面就是我大致的总结。</p>
<h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p>OC中通常使用<code>NSError</code>对象来发出错误信号，提供错误类型以及任何潜在原因的额外信息。</p>
<p><code>Foundation</code>和其它<code>Cocoa</code>框架产生的错误通常归属于<code>NSCocoaErrorDomain</code>错误域。<code>NSCocoaErrorDomain</code>中的错误状态码都是在<code>Foundation</code>定义好的常量。</p>
<p>在子类中，可以通过覆写<code>localizedDescription</code>方法来提供更好的本地错误描述。</p>
<p><code>NSError</code>是<code>CFError</code>的无缝转换对象。</p>
<p>每个<code>NSError</code>对象主要提供三部分的信息：</p>
<ul>
<li>code 状态码</li>
<li>domain 对应的特定错误域</li>
<li>userInfo 额外的信息</li>
</ul>
<h3 id="code和domain"><a href="#code和domain" class="headerlink" title="code和domain"></a>code和domain</h3><p><code>code</code>状态码表示问题的本质，这些状态码都在一个特定的错误域中，以防重叠和混淆。</p>
<p>例如在<code>NSCocoaErrorDomain</code>中，<code>NSFileManager</code>访问一个不存在的文件产生的错误代码是4。而在<code>NSPOSIXErrorDomain</code>中，4代表<code>中断函数</code>错误。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0u9ptklmyj30l90cidg2.jpg" alt="系统错误域"></p>
<h3 id="userInfo及一些属性"><a href="#userInfo及一些属性" class="headerlink" title="userInfo及一些属性"></a>userInfo及一些属性</h3><p>作为<code>Cocoa</code>的惯例，<code>userInfo</code>是一个可以包含任意键值对的字典，无论是为了继承或降低耦合的目的, 它都不适合拿来填满各种杂七杂八的属性。在<code>NSError</code>这个例子中，有一些特定的键值对应着只读属性。一下是标准<code>NSError</code>的<code>userInfo</code>的键列表</p>
<ul>
<li>NSLocalizedDescriptionKey</li>
<li>NSLocalizedFailureReasonErrorKey</li>
<li>NSLocalizedRecoverySuggestionErrorKey</li>
<li>NSLocalizedRecoveryOptionsErrorKey</li>
<li>NSFilePathErrorKey</li>
<li>NSStringEncodingErrorKey</li>
<li>NSUnderlyingErrorKey</li>
<li>NSRecoveryAttempterErrorKey</li>
<li>NSHelpAnchorErrorKey</li>
</ul>
<blockquote>
<p>下面是常见的几个键：</p>
</blockquote>
<h4 id="localizedDescription"><a href="#localizedDescription" class="headerlink" title="localizedDescription"></a>localizedDescription</h4><blockquote>
<p>NSLocalizedDescriptionKey的对应值，即userInfo[NSLocalizedDescriptionKey]，下同<br>一段本地化的错误描述。错误的主要可呈现信息。例如<code>NSFileReadNoPermissionError</code>：”文件XX无法打开，因为你并没有查看它的权限”。理想状况下，这个信息会指出失败的原因以及失败原因。这个值来自于<code>NSLocalizedDescriptionKey</code>或者是<code>NSLocalizedFailureErrorKey + NSLocalizedFailureReasonErrorKey</code>或者是<code>NSLocalizedFailureErrorKey</code>。构建描述信息的步骤如下：</p>
</blockquote>
<ul>
<li>在<code>userInfo</code>中查找<code>NSLocalizedDescriptionKey</code>，如果存在则使用</li>
<li>在<code>userInfo</code>中查找<code>NSLocalizedFailureErrorKey</code>，如果存在，则使用，与<code>NSLocalizedFailureReasonErrorKey</code>的值组合使用(如果存在)</li>
<li>在<code>userInfoValueProvider</code>中查找<code>NSLocalizedDescriptionKey</code>，如果存在则使用</li>
<li>在<code>userInfoValueProvider</code>中查找<code>NSLocalizedFailureErrorKey</code>，如果存在则使用，与<code>NSLocalizedFailureReasonErrorKey</code>的值组合使用(如果存在)</li>
<li>在<code>userInfo</code>或者<code>userInfoValueProvider</code>查找<code>NSLocalizedFailureErrorKey</code>，如果存在则使用</li>
</ul>
<blockquote>
<p>上文中提到的<code>userInfoValueProvider</code>我也不知道是什么东西，我猜测可能是NSError的类方法<code>+ (id  _Nullable (^)(NSError * _Nonnull, NSErrorUserInfoKey _Nonnull))userInfoValueProviderForDomain:(NSErrorDomain)errorDomain; </code>中的返回值</p>
</blockquote>
<h4 id="localizedRecoverySuggestion"><a href="#localizedRecoverySuggestion" class="headerlink" title="localizedRecoverySuggestion"></a>localizedRecoverySuggestion</h4><blockquote>
<p>NSLocalizedRecoverySuggestionErrorKey的对应值，即userInfo[NSLocalizedRecoverySuggestionErrorKey]，一段该错误的恢复建议，适合在<code>alert</code>中显示为辅助消息。</p>
</blockquote>
<h4 id="localizedFailureReason"><a href="#localizedFailureReason" class="headerlink" title="localizedFailureReason"></a>localizedFailureReason</h4><blockquote>
<p>localizedFailureReason的对应值，即userInfo[localizedFailureReason]，一段本地化的错误解释</p>
</blockquote>
<h3 id="如何使用调用系统API时返回的NSError"><a href="#如何使用调用系统API时返回的NSError" class="headerlink" title="如何使用调用系统API时返回的NSError"></a>如何使用调用系统API时返回的NSError</h3><p>了解过上面的知识之后，那我们要怎样更好的使用系统返回给我们的<code>NSError</code>呢，下面是我自己使用的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)showErrorDetail:(NSError *)error viewController:(UIViewController *)viewController</span><br><span class="line">&#123;</span><br><span class="line">    if (![viewController isKindOfClass:[UIViewController class]]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (![error isKindOfClass:[NSError class]] || !error) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:error.localizedDescription message:error.localizedRecoverySuggestion preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">    [alertController addAction:[UIAlertAction actionWithTitle:NSLocalizedString(@&quot;确定&quot;, nil) style:UIAlertActionStyleDefault handler:nil]];</span><br><span class="line">    [viewController presentViewController:alertController animated:YES completion:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何创建一个NSError"><a href="#如何创建一个NSError" class="headerlink" title="如何创建一个NSError"></a>如何创建一个NSError</h3><p>作为开发者，我们需要怎么样使用<code>NSError</code>，才能更好的传递错误信息呢？首先，我们可以按<code>Foundation</code>库中很多类那个样子，在一个自定义方法中定义<code>NSError **</code>类型的形参。然后，我们也可以定义属于自己的错误域、错误代码常量和userInfo中的Key。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 自定义Domain</span><br><span class="line">NSString *const JYCustomErrorDomain = @&quot;JYCustomErrorDomain&quot;;</span><br><span class="line">// 自定义key</span><br><span class="line">NSString *const JYValidationStatusErrorKey = @&quot;JYValidationStatusErrorKey&quot;;</span><br><span class="line">// 自定义错误码</span><br><span class="line">typedef NS_ENUM(NSInteger, JYCustomErrorCode)</span><br><span class="line">&#123;</span><br><span class="line">    JYCustomErrorCodeGen = -999,</span><br><span class="line">    JYCustomErrorCodeRequired = -1000</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用userInfo字典来创建一个NSError"><a href="#使用userInfo字典来创建一个NSError" class="headerlink" title="使用userInfo字典来创建一个NSError"></a>使用userInfo字典来创建一个NSError</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *userInfo = @&#123;</span><br><span class="line">  NSLocalizedDescriptionKey: NSLocalizedString(@&quot;Operation was unsuccessful.&quot;, nil),</span><br><span class="line">  NSLocalizedFailureReasonErrorKey: NSLocalizedString(@&quot;The operation timed out.&quot;, nil),</span><br><span class="line">  NSLocalizedRecoverySuggestionErrorKey: NSLocalizedString(@&quot;Have you tried turning it off and on again?&quot;, nil)</span><br><span class="line">                          &#125;;</span><br><span class="line">NSError *error = [NSError errorWithDomain:JYCustomErrorDomain</span><br><span class="line">                                     code:JYCustomErrorCodeGen</span><br><span class="line">                                 userInfo:userInfo];</span><br></pre></td></tr></table></figure>

<p>将错误信息包装在<code>NSError</code>对象中，很容易在不同对象或者上下文中进行传递。</p>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>参考来源：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://nshipster.cn/nserror/">NSError</a></li>
<li>苹果文档</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-03-13T02:45:56.000Z" title="3/13/2019, 10:45:56 AM">2019-03-13</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">8 分钟读完 (大约1207个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/03/13/JYAuthorization%E7%9A%84%E8%AF%B4%E6%98%8E%E4%BD%BF%E7%94%A8/">JYAuthorization的说明使用</a></h1><div class="content"><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p>在iOS开发中，我们总会用到许多iOS的隐私功能，例如<code>定位</code>，<code>相机</code>，<code>麦克风</code>等。在编写这些功能代码的时候，我们都要先判断是否拥有权限，然后根据有无代码执行不同的操作，功能一多的话就会显得繁琐。为了解决这个问题，我自己编写了<a target="_blank" rel="noopener" href="https://github.com/EchoZuo/ECAuthorizationTools">JYAuthorization</a>这一个框架，旨在快速获取以及查询iOS的功能权限，将更多的精力放在业务上。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g10wx1k625g30a00dcb29.gif" alt="快速的获取及查询功能权限"></p>
<h3 id="支持的类型及要求"><a href="#支持的类型及要求" class="headerlink" title="支持的类型及要求"></a>支持的类型及要求</h3><ul>
<li>ARC</li>
<li>iOS 8.0+</li>
<li>OC</li>
</ul>
<p>目前支持的隐私类型(如果有需要，后面会继续添加)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, JYServiceType)&#123;</span><br><span class="line">    JYServiceTypeNone,</span><br><span class="line">    ///|&lt; 定位-使用应用期间</span><br><span class="line">    JYServiceTypeLocationWhenInUse,</span><br><span class="line">    ///|&lt; 定位-使用使用</span><br><span class="line">    JYServiceTypeLocationAlways,</span><br><span class="line">    ///|&lt; 通讯录</span><br><span class="line">    JYServiceTypeAddressBook,</span><br><span class="line">    ///|&lt; 日历</span><br><span class="line">    JYServiceTypeCalendar,</span><br><span class="line">    ///|&lt; 提醒</span><br><span class="line">    JYServiceTypeReminder,</span><br><span class="line">    ///|&lt; 相册</span><br><span class="line">    JYServiceTypePhoto,</span><br><span class="line">    ///|&lt; 麦克风</span><br><span class="line">    JYServiceTypeMicroPhone,</span><br><span class="line">    ///|&lt; 相机</span><br><span class="line">    JYServiceTypeCamera,</span><br><span class="line">    ///|&lt; 语音识别</span><br><span class="line">    JYServiceTypeSpeechRecognition,</span><br><span class="line">    ///|&lt; 健康</span><br><span class="line">    JYServiceTypeHealth</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="JYAuthorizationManager"><a href="#JYAuthorizationManager" class="headerlink" title="JYAuthorizationManager"></a>JYAuthorizationManager</h3><p><code>JYAuthorizationManager</code>是一个单例，负责查询以及保存功能权限的数据。</p>
<ol>
<li>你可以通过类方法<code>shareManager</code>来创建实例</li>
<li>通过实例方法<code>- (void)requestAccessToServiceType:(JYServiceType)authType completion:(void(^)(BOOL granted, NSError *error))completion</code>可以快速的查询功能权限。error的使用下面会有说明</li>
<li>查询过的权限结果(除JYAuthorizationErrorNotDetermined)，将被保存在私有属性<code>authDict</code>中。因为<code>iOS</code>的隐私功能权限，如果被修改过了，那么当前应用是会被强制退出的，所以当前的查询结果可以保存起来，避免重复查询</li>
<li>如果想要显示查询的Error，你可以调用实例方法<code>jy_showErrorDetail:(NSError *)error viewController:(UIViewController *)viewController</code>，效果就跟上面的gif图中的效果一样</li>
<li><code>JYAuthorization</code>支持多语言，你可以在<code>JYAuthorization.bundle</code>里面的<code>Localizable.strings</code>的文件中修改不同的提示语。<br><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g10xt1g94rj31ks0p878h.jpg" alt="语言国际化"></li>
</ol>
<h4 id="NSError的使用"><a href="#NSError的使用" class="headerlink" title="NSError的使用"></a>NSError的使用</h4><p><code>NSError</code>如果有不明白的可以看我的另一篇博客<a target="_blank" rel="noopener" href="https://kikido.github.io/2019/03/13/NSError%E4%BA%86%E8%A7%A3%E4%B8%80%E5%93%88/">NSError</a>，在这里简单说明下：</p>
<ul>
<li>error.domain为自定义的错误域<code>JYAuthErrorDomain</code></li>
<li>error.code为自定义的值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, JYAuthorizationStatus)&#123;</span><br><span class="line">    JYAuthorizationErrorNone = 0,</span><br><span class="line">    ///|&lt; 已授权</span><br><span class="line">    JYAuthorizationErrorGranted = 1,</span><br><span class="line">    ///|&lt; 未授权</span><br><span class="line">    JYAuthorizationErrorNotDetermined = -100,</span><br><span class="line">    ///|&lt; 无授权，切用户无法改变这个状态。例如，家长控制</span><br><span class="line">    JYAuthorizationErrorRestricted = -101,</span><br><span class="line">    ///|&lt; 授权被拒绝</span><br><span class="line">    JYAuthorizationErrorDenied = -102,</span><br><span class="line">    ///|&lt; 尚未启用该服务</span><br><span class="line">    JYAuthorizationErrorUnServiced = -1000,</span><br><span class="line">    ///|&lt; 版本过低，不支持该服务</span><br><span class="line">    JYAuthorizationErrorLowVersion = -2000</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>error.localizedDescription：错误描述，具体信息你可以在<code>Localizable.strings</code>中修改</li>
<li>error.localizedRecoverySuggestion：错误恢复建议，具体信息你可以在<code>Localizable.strings</code>中修改</li>
<li>如果error.userInfo[JYAuthOpenSettingKey]有值，那么在提示错误时，您可以选择点击<code>前往</code>，前往设置界面</li>
</ul>
<h4 id="accessIfNotDetermined属性"><a href="#accessIfNotDetermined属性" class="headerlink" title="accessIfNotDetermined属性"></a>accessIfNotDetermined属性</h4><p>这是一个BOOL类型的值，默认为YES。值为YES的时候，当你调用<code>- (void)requestAccessToServiceType:(JYServiceType)authType completion:(void(^)(BOOL granted, NSError *error))completion</code>时，如果权限是<code>JYAuthorizationErrorNotDetermined</code>(未授权)，则会直接调用方法请求权限。</p>
<h4 id="dontAlertIfNotDetermined属性"><a href="#dontAlertIfNotDetermined属性" class="headerlink" title="dontAlertIfNotDetermined属性"></a>dontAlertIfNotDetermined属性</h4><p>这是一个BOOL类型的值，默认为YES。值为YES的时候，当你调用<code>- (void)jy_showErrorDetail:(NSError *)error viewController:(UIViewController *)viewController</code>时，如果erroe的code(错误码)是<code>JYAuthorizationErrorNotDetermined</code>(-100)的话，则不会显示错误提示。</p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>假设我们有一个需求：调用iOS的定位服务。那么我们可以像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)startLocationService</span><br><span class="line">&#123;</span><br><span class="line">    JYAuthorizationManager *authManager = [JYAuthorizationManager shareManager];</span><br><span class="line">    [authManager requestAccessToServiceType:JYServiceTypeLocationWhenInUse completion:^(BOOL granted, NSError * _Nonnull error) &#123;</span><br><span class="line">        if (granted) &#123;</span><br><span class="line">            // 有权限的话</span><br><span class="line">            self.locationManager = [[CLLocationManager alloc] init];</span><br><span class="line">            self.locationManager.delegate = self;</span><br><span class="line">            self.locationManager.distanceFilter = 50;</span><br><span class="line">            self.locationManager.desiredAccuracy = kCLLocationAccuracyNearestTenMeters;</span><br><span class="line">            [self.locationManager startUpdatingLocation];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 没有权限</span><br><span class="line">            [authManager jy_showErrorDetail:error viewController:self];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>JYAuthorization</code>，你不需要考虑有没有权限，是否未决定权限。在上面的例子中，如果尚未决定权限，并且<code>error.code</code>是<code>JYAuthorizationErrorNotDetermined</code>的话，会自动帮你请求权限，并且在获取权限之后，执行completion里面的回调。</p>
<blockquote>
<p>当然，现在的很多应用，为了能够获取客户的权限，都会在申请权限之前，跳出一个弹框提示，说明获取权限的重要性，那么使用<code>JYAuthorization</code>也能够很方便的实现这个权限。示例如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)startLocationService</span><br><span class="line">&#123;</span><br><span class="line">    JYAuthorizationManager *authManager = [JYAuthorizationManager shareManager];</span><br><span class="line">    authManager.accessIfNotDetermined = false;</span><br><span class="line">    [authManager requestAccessToServiceType:JYServiceTypeLocationWhenInUse completion:^(BOOL granted, NSError * _Nonnull error) &#123;</span><br><span class="line">        if (granted) &#123;</span><br><span class="line">            // 有权限的话</span><br><span class="line">            // todo...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (error.code == JYAuthorizationErrorNotDetermined) &#123;</span><br><span class="line">                // 如果尚未决定权限，跳出自己的提示页面</span><br><span class="line">                // 1.客户在自己的提示页面点击确定之后，修改`accessIfNotDetermined`为YES，且再次调用`- (void)requestAccessToServiceType:(JYServiceType)authType completion:(void(^)(BOOL granted, NSError *error))completion`这个方法</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                [authManager jy_showErrorDetail:error viewController:self];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>好了，说明就到此为止了。如果有错误的话，欢迎指出~</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-03-01T06:40:14.000Z" title="3/1/2019, 2:40:14 PM">2019-03-01</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">16 分钟读完 (大约2472个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/03/01/iOS-EventKit%E6%97%A5%E5%8E%86%E6%8F%90%E9%86%92/">iOS EventKit日历提醒</a></h1><div class="content"><h3 id="EKEventStore"><a href="#EKEventStore" class="headerlink" title="EKEventStore"></a>EKEventStore</h3><blockquote>
<p><code>EKEventStore</code>用于应用访问日历或者提醒事件，在iOS中，创建好实例之后，必须使用<code>requestAccessToEntityType：completion：</code>方法访问实体类型。</p>
<p>与一个<code>EKEventStore</code>实例相关联的事件，提醒，日历数据无法在另一个<code>EKEventStore</code>实例中使用，所以你最好创建一个常驻的实例，例如创建一个单例。</p>
</blockquote>
<blockquote>
<p>在iOS10.0或者之后的版本，你必须在info.plist文件中添加权限请求，否则应用将会崩溃。提醒和日历分别是<code>NSRemindersUsageDescription</code>和<code>NSCalendarsUsageDescription</code>。</p>
</blockquote>
<blockquote>
<p>在macOS中，使用<code>initWithAccessToEntityTypes:</code>代替默认初始化方法，可以接受的实体类型是<code>EKEntityMaskEvent</code>和<code>EKEntityMaskReminder</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 创建实例</span><br><span class="line">EKEventStore *eventStore = [[EKEventStore alloc] init];</span><br><span class="line">self.eventStore = eventStore;</span><br><span class="line"></span><br><span class="line">// 获取数据</span><br><span class="line">[self.eventStore requestAccessToEntityType:EKEntityTypeEvent completion:^(BOOL granted, NSError * _Nullable error) &#123;</span><br><span class="line">    if (granted) &#123;</span><br><span class="line">        NSLog(@&quot;授权通过&quot;);        </span><br><span class="line">        // 下一步操作...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;授权没有通过&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h4 id="获取授权状态"><a href="#获取授权状态" class="headerlink" title="获取授权状态"></a>获取授权状态</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 获取授权状态</span><br><span class="line">EKAuthorizationStatus eventStatus = [EKEventStore authorizationStatusForEntityType:EKEntityTypeEvent];</span><br><span class="line">switch (eventStatus) &#123;</span><br><span class="line">    case EKAuthorizationStatusNotDetermined:// 未进行选择</span><br><span class="line">    &#123;</span><br><span class="line">        // 弹框 提示授权</span><br><span class="line">        @weakify(self)</span><br><span class="line">        [self.eventStore requestAccessToEntityType:EKEntityTypeEvent completion:^(BOOL granted, NSError * _Nullable error) &#123;</span><br><span class="line">            @strongify(self)</span><br><span class="line">            if (granted) &#123;</span><br><span class="line">        			NSLog(@&quot;授权通过&quot;);        </span><br><span class="line">        			// 下一步操作...</span><br><span class="line">    			&#125; else &#123;</span><br><span class="line">        			NSLog(@&quot;授权没有通过&quot;);</span><br><span class="line">    			&#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;break;</span><br><span class="line">    case EKAuthorizationStatusRestricted:// 未授权</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;未授权&quot;);</span><br><span class="line">    &#125;break;</span><br><span class="line">    case EKAuthorizationStatusDenied:// 拒绝</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;拒绝&quot;);</span><br><span class="line">    &#125;break;</span><br><span class="line">    case EKAuthorizationStatusAuthorized:// 已授权</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;已授权&quot;);</span><br><span class="line">    &#125;break;</span><br><span class="line">    default:break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EKSource-日历源"><a href="#EKSource-日历源" class="headerlink" title="EKSource 日历源"></a>EKSource 日历源</h3><blockquote>
<p>你不需要创建此类的实例; 相反，你从<code>EKEventStore</code>实例中获取<code>EKSource</code>对象。 使用<code>sources</code>属性获取事件存储的所有<code>EKSource</code>对象，并使用此类中的实例方法访问该对象。</p>
</blockquote>
<blockquote>
<p><code>EKSource</code>为日历所属的集合的抽象超类。一个<code>EKEventStore</code>可以包含多个<code>EKSource</code>，一个日历源可以包含多个日历对象。</p>
</blockquote>
<p>日历的类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, EKSourceType) &#123;</span><br><span class="line">    EKSourceTypeLocal,</span><br><span class="line">    EKSourceTypeExchange,</span><br><span class="line">    EKSourceTypeCalDAV,//Represents a CalDAV or iCloud source</span><br><span class="line">    EKSourceTypeMobileMe,</span><br><span class="line">    EKSourceTypeSubscribed,</span><br><span class="line">    EKSourceTypeBirthdays</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0nbqnuzoxj30i80x610r.jpg" alt="真机中的日历源"></p>
<h4 id="获取指定的日历源"><a href="#获取指定的日历源" class="headerlink" title="获取指定的日历源"></a>获取指定的日历源</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSArray *sources = self.eventStore.sources;</span><br><span class="line">    for (EKSource *source in sources) &#123;</span><br><span class="line">        if (source.sourceType == EKSourceTypeCalDAV) &#123;     </span><br><span class="line">        		// 当前source的类型为EKSourceTypeCalDAV，你还可以使用title属性进行筛选                         </span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="EKCalendar-日历"><a href="#EKCalendar-日历" class="headerlink" title="EKCalendar 日历"></a>EKCalendar 日历</h3><ul>
<li><code>type</code> 这个属性跟所属于的<code>EKSource</code>实例的type对应</li>
<li><code>calendarIdentifier</code>，我们可以根据这个属性，使用<code>EKEventStore</code>的实例方法来获取指定的<code>EKCalendar</code>对象。需要注意的是，当发生了<code>完全同步</code>之后，这个值是会变化的。</li>
</ul>
<p>会发生<code>完全同步</code>的几种情况：</p>
<ul>
<li>在iPhone上，用户手动修改了日历的名字，添加&#x2F;编辑&#x2F;删除事件</li>
<li>用户在mac上对iCloud日历进行了一些修改，iOS设备会通知iCloud日历已更改，从而发生同步</li>
<li>第三方应用程序收到日历通知，iOS在后台启动，应用根据通知创建一些日历事件</li>
</ul>
<p>也就是说，<code>完全同步</code>事件可以随时发生。当发生<code>完全同步</code>时，你可以通过下面的代码获得通知</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                         selector:@selector(storeChanged:)</span><br><span class="line">                                             name:EKEventStoreChangedNotification</span><br><span class="line">                                           object:eventStore];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果需要的话，收到通知之后，重新创建<code>EKCalendar</code>实例是有意义的。</p>
<h4 id="创建添加日历"><a href="#创建添加日历" class="headerlink" title="创建添加日历"></a>创建添加日历</h4><p>创建日历之前，我们先要找到它所属于的日历源(当然这取决与你想把它放在哪个日历源)。创建时，我们先要判断是否已经有相同名字的日历存在，如果没有的话，则继续创建。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (void)checkJYCalendar</span><br><span class="line">&#123;</span><br><span class="line">    NSArray *sources = self.eventStore.sources;</span><br><span class="line">    for (EKSource *source in sources) &#123;</span><br><span class="line">        if (source.sourceType == EKSourceTypeCalDAV) &#123;</span><br><span class="line">            </span><br><span class="line">            NSSet *calendars = [source calendarsForEntityType:EKEntityTypeEvent];</span><br><span class="line">            BOOL needAdd = true;</span><br><span class="line">            </span><br><span class="line">            for (EKCalendar *calendar in calendars) &#123;</span><br><span class="line">                if ([calendar.title isEqualToString:@&quot;测试日历&quot;]) &#123;</span><br><span class="line">                    needAdd = false;</span><br><span class="line">                    _calendar = calendar;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 如果没找到日历，则创建一个</span><br><span class="line">            if (needAdd) &#123;</span><br><span class="line">                EKCalendar *calendar = [EKCalendar calendarForEntityType:EKEntityTypeEvent eventStore:self.eventStore];</span><br><span class="line">                calendar.source = source;</span><br><span class="line">                calendar.title = @&quot;测试日历&quot;;</span><br><span class="line">                calendar.CGColor = [UIColor greenColor].CGColor;</span><br><span class="line">                NSError *error;</span><br><span class="line">                [self.eventStore saveCalendar:calendar commit:YES error:&amp;error];</span><br><span class="line">                </span><br><span class="line">                if (error) &#123;</span><br><span class="line">                    JYLog(@&quot;创建日历失败 error:%@&quot;,error);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    JYLog(@&quot;创建日历成功&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                _calendar = calendar;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取日历集"><a href="#获取日历集" class="headerlink" title="获取日历集"></a>获取日历集</h4><p>可以用下面两种实例方法获取日历数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// EKEventStore的实例方法</span><br><span class="line">- (NSArray&lt;EKCalendar *&gt; *)calendarsForEntityType:(EKEntityType)entityType NS_AVAILABLE(10_8, 6_0);</span><br><span class="line"></span><br><span class="line">// EKSource的实例方法</span><br><span class="line">- (NSSet&lt;EKCalendar *&gt; *)calendarsForEntityType:(EKEntityType)entityType NS_AVAILABLE(10_8, 6_0);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="EkEvent-日历事件"><a href="#EkEvent-日历事件" class="headerlink" title="EkEvent 日历事件"></a>EkEvent 日历事件</h3><blockquote>
<p>代表添加到日历中的事件。使用类方法<code>eventWithEventStore:</code>来创建实例</p>
</blockquote>
<h4 id="属性说明"><a href="#属性说明" class="headerlink" title="属性说明"></a>属性说明</h4><ul>
<li><code>eventIdentifier</code>：您可以使用此标识符使用<code>EKEventStore</code>方法<code>eventWithIdentifier：</code>查找事件。<br>  如果事件的日历发生更改，则其标识符很可能也会更改。</li>
<li><code>allDay</code>：设置是否是全天时间</li>
<li><code>startDate</code>：事件开始时间</li>
<li><code>endDate</code>：事件结束时间</li>
<li><code>structuredLocation</code>：往事件里添加地理信息位置，get方法仅返回地理位置的名称</li>
</ul>
<blockquote>
<p>如果你创建了一个日历事件，并且设置了重复规则：从2019-01-01开始，连续10天，每天9：00-9：30。这就就相当于你创建了<em>10个</em>日历事件！对每天的日历事件来说，9：00即·startDate·，9：30即·endDate·，也不是说2019-01-10 9：30是·endDate·！</p>
</blockquote>
<h4 id="事件修改"><a href="#事件修改" class="headerlink" title="事件修改"></a>事件修改</h4><p>当你对<code>EKEvent</code>的属性修改完成之后，可以用<code>EKEventStore</code>的方法<code>- (BOOL)saveEvent:(EKEvent *)event span:(EKSpan)span commit:(BOOL)commit error:(NSError **)error</code>进行保存</p>
<ul>
<li>EKSpan有两种类型，EKSpanThisEvent和EKSpanFutureEvents</li>
</ul>
<blockquote>
<p>举个例子，你创建了一个·EkEvent·对象，并且添加到了日历中了。它的规则为：连续10天，每天的早上9：00- 9：30。当你使用·EKEventStore·的方法·eventsMatchingPredicate：·查找时间时，就会得到<em>10个</em>·EKEventStore·对象，如果是事件发生顺序的快慢来编号（1-10），那么对于第一个·EkEvent·对象讲，·EKSpanThisEvent·指的是自己，而·EKSpanFutureEvents·指的是编号为（1-10）的几个对象；对于第二个·EkEvent·对象讲，·EKSpanThisEvent·指的是自己，而·EKSpanFutureEvents·指的是编号为（2-10）的几个对象。总之，最好自己尝试一下看看这到底是什么。</p>
</blockquote>
<h4 id="事件刷新"><a href="#事件刷新" class="headerlink" title="事件刷新"></a>事件刷新</h4><p>当在其它地方对事件进行了修改之后，你可以收到<code>EKEventStoreChangedNotification</code>的通知，这个时候你可以选择使用实例方法<code>refresh</code>，更新事件的数据</p>
<h4 id="在日历中添加事件"><a href="#在日历中添加事件" class="headerlink" title="在日历中添加事件"></a>在日历中添加事件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 添加事件到日历中</span><br><span class="line"> */</span><br><span class="line">- (BOOL)addEventToCalendarWithTitle:(NSString *)title</span><br><span class="line">                           location:(NSString *)location</span><br><span class="line">                          startDate:(NSDate *)start</span><br><span class="line">                            endDate:(NSDate *)end</span><br><span class="line">                         alarmArray:(NSArray *)alarmArray</span><br><span class="line">&#123;</span><br><span class="line">    EKEvent *newEvent = [EKEvent eventWithEventStore:self.eventStore];</span><br><span class="line">    </span><br><span class="line">    newEvent.title = title;</span><br><span class="line">    newEvent.startDate = start;</span><br><span class="line">    newEvent.endDate = end;</span><br><span class="line">    newEvent.location = location;</span><br><span class="line">    newEvent.notes = @&quot;这是备注&quot;;</span><br><span class="line">    newEvent.allDay = false;</span><br><span class="line">    // 重复规则, 具体代码在下面会讲到</span><br><span class="line">    EKRecurrenceRule *rule = [self getRecurrenceRule];</span><br><span class="line">    // 设置提醒，具体代码在下面会讲到</span><br><span class="line">    [newEvent addAlarm:[self getAlarm]];</span><br><span class="line">    newEvent.calendar = self.calendar;</span><br><span class="line">    </span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    [self.eventStore saveEvent:newEvent span:EKSpanThisEvent commit:YES error:&amp;error];</span><br><span class="line">    </span><br><span class="line">    if (isNull(error)) &#123;</span><br><span class="line">        JYLog(@&quot;添加Event成功&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        JYLog(@&quot;添加Event失败 error:%@&quot;, error);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EKRecurrenceRule重复周期"><a href="#EKRecurrenceRule重复周期" class="headerlink" title="EKRecurrenceRule重复周期"></a>EKRecurrenceRule重复周期</h3><blockquote>
<p>目前无法直接修改EKRecurrenceRule或其任何属性。 通过创建新的EKRecurrenceRule并设置事件或提醒以使用新创建的重复规则。</p>
</blockquote>
<p>一般使用方法下面的方法来创建实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initRecurrenceWithFrequency:(EKRecurrenceFrequency)type</span><br><span class="line">                         interval:(NSInteger)interval </span><br><span class="line">                    daysOfTheWeek:(nullable NSArray&lt;EKRecurrenceDayOfWeek *&gt; *)days</span><br><span class="line">                   daysOfTheMonth:(nullable NSArray&lt;NSNumber *&gt; *)monthDays</span><br><span class="line">                  monthsOfTheYear:(nullable NSArray&lt;NSNumber *&gt; *)months</span><br><span class="line">                   weeksOfTheYear:(nullable NSArray&lt;NSNumber *&gt; *)weeksOfTheYear</span><br><span class="line">                    daysOfTheYear:(nullable NSArray&lt;NSNumber *&gt; *)daysOfTheYear</span><br><span class="line">                     setPositions:(nullable NSArray&lt;NSNumber *&gt; *)setPositions</span><br><span class="line">                              end:(nullable EKRecurrenceEnd *)end;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>type</code>: 重复规则的频率，可以是每天，每周，每周和每年</li>
<li><code>interval</code>: 周期间隔，必须大于0</li>
<li><code>days</code>: 事件发生在一周的哪几天，是一个包含了<code>EKRecurrenceDayOfWeek</code>对象的数组</li>
<li><code>monthDays</code>: 事件发生在一月的哪几天，值必须在1<del>31或者-1</del>-31之间，当为-1时，即代表这个月的倒数第一天，这个参数仅当<code>type</code>为<code>EKRecurrenceFrequencyMonthly</code>有效</li>
<li><code>months</code>: 事件发生在一年的哪几月，值必须在1<del>12或者-1</del>-12之间，当为-1时，即代表这年的倒数第一个月，这个参数仅当<code>type</code>为<code>EKRecurrenceFrequencyYearly</code>有效</li>
<li><code>weeksOfTheYear</code>: 事件发生在一年的哪几周，值必须在1<del>53或者-1</del>-53之间，当为-1时，即代表这年的倒数第一周，这个参数仅当<code>type</code>为<code>EKRecurrenceFrequencyYearly</code>有效</li>
<li><code>daysOfTheYear</code>: 事件发生在一年的哪几天，值必须在1<del>366或者-1</del>-366之间，当为-1时，即代表这年的倒数第一天，这个参数仅当<code>type</code>为<code>EKRecurrenceFrequencyYearly</code>有效</li>
<li><code>setPositions</code>: 额外的重复条件</li>
<li><code>end</code>: 结束规则，为空时即代表永久重复</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">EKRecurrenceRule *rule = nil;</span><br><span class="line">    </span><br><span class="line">    // 每两天执行一次</span><br><span class="line">    rule = [[EKRecurrenceRule alloc] initRecurrenceWithFrequency:EKRecurrenceFrequencyDaily interval:2 end:nil];</span><br><span class="line">    </span><br><span class="line">    // 工作日都执行</span><br><span class="line">    rule = [[EKRecurrenceRule alloc] initRecurrenceWithFrequency:EKRecurrenceFrequencyWeekly interval:1 daysOfTheWeek:@[[EKRecurrenceDayOfWeek dayOfWeek:2], [EKRecurrenceDayOfWeek dayOfWeek:3], [EKRecurrenceDayOfWeek dayOfWeek:4], [EKRecurrenceDayOfWeek dayOfWeek:5], [EKRecurrenceDayOfWeek dayOfWeek:6]] daysOfTheMonth:nil monthsOfTheYear:nil weeksOfTheYear:nil daysOfTheYear:nil setPositions:nil end:nil];</span><br><span class="line">    </span><br><span class="line">    // 每两周的周1执行</span><br><span class="line">    rule = [[EKRecurrenceRule alloc] initRecurrenceWithFrequency:EKRecurrenceFrequencyWeekly interval:2 daysOfTheWeek:@[[EKRecurrenceDayOfWeek dayOfWeek:2]] daysOfTheMonth:nil monthsOfTheYear:nil weeksOfTheYear:nil daysOfTheYear:nil setPositions:nil end:nil];</span><br><span class="line">    </span><br><span class="line">    // 在每年的第二周以及最后一周的工作执行</span><br><span class="line">    rule = [[EKRecurrenceRule alloc] initRecurrenceWithFrequency:EKRecurrenceFrequencyYearly interval:1 daysOfTheWeek:@[[EKRecurrenceDayOfWeek dayOfWeek:2], [EKRecurrenceDayOfWeek dayOfWeek:3], [EKRecurrenceDayOfWeek dayOfWeek:4], [EKRecurrenceDayOfWeek dayOfWeek:5], [EKRecurrenceDayOfWeek dayOfWeek:6]] daysOfTheMonth:nil monthsOfTheYear:nil weeksOfTheYear:nil daysOfTheYear:nil setPositions:@[@2, @-1] end:nil];</span><br><span class="line">    </span><br><span class="line">    EKEvent *event = [[EKEvent alloc] init];</span><br><span class="line">    [event addRecurrenceRule:rule];</span><br></pre></td></tr></table></figure>

<h3 id="EKAlarm创建提醒"><a href="#EKAlarm创建提醒" class="headerlink" title="EKAlarm创建提醒"></a>EKAlarm创建提醒</h3><p><code>EKAlarm</code>在<code>Event Kit</code>中代表警告。你可以使用<code>alarmWithAbsoluteDate</code>和<code>alarmWithAbsoluteDate</code>来创建实例。</p>
<p>可以用下面的方法来创建实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 设置绝对时间</span><br><span class="line">+ (EKAlarm *)alarmWithAbsoluteDate:(NSDate *)date; </span><br><span class="line">// 设置相对时间（相对event的start date），单位是秒，设置负值表示事件前提醒，设置正值是事件发生后提醒</span><br><span class="line">+ (EKAlarm *)alarmWithRelativeOffset:(NSTimeInterval)offset; </span><br></pre></td></tr></table></figure>

<p>设置了提醒后,我们打开iOS系统自带的日历App,会发现只会显示2个提醒,看不到多余的提醒.但是实际测试发现全部提醒都可以工作,而且我们可以在Mac的日历程序中看到所有的提醒。</p>
<p>属性说明：</p>
<ul>
<li><code>structuredLocation</code>：与<code>proximity</code>配合使用，简单来说，就是当你进入或者离开某个范围时，就可以发出提醒</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EKAlarm *alarm = nil;</span><br><span class="line">    </span><br><span class="line">// 事件前5分钟提醒</span><br><span class="line">alarm = [EKAlarm alarmWithRelativeOffset:-60. * 5];</span><br></pre></td></tr></table></figure>


<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>目前我对系统的日历讲解就到这啦，受限于个人的技术水平以及没有深度的使用，可能会有点错误的地方，希望指正，以后我发现错误之后也会及时来更新的！</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/iOS%E6%9D%82/page/2/">上一页</a></div><div class="pagination-next is-invisible is-hidden-mobile"><a href="/categories/iOS%E6%9D%82/page/4/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/iOS%E6%9D%82/">1</a></li><li><a class="pagination-link" href="/categories/iOS%E6%9D%82/page/2/">2</a></li><li><a class="pagination-link is-current" href="/categories/iOS%E6%9D%82/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="千行"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">千行</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>杭州, 浙江</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">33</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/bug/"><span class="level-start"><span class="level-item">bug</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/cocoapods/"><span class="level-start"><span class="level-item">cocoapods</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS%E6%9D%82/"><span class="level-start"><span class="level-item">iOS杂</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%90%AD%E5%BB%BA/"><span class="level-start"><span class="level-item">搭建</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/EventKit/"><span class="tag">EventKit</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GCD/"><span class="tag">GCD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NSError/"><span class="tag">NSError</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Runloop/"><span class="tag">Runloop</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tagged-Pointer/"><span class="tag">Tagged Pointer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/YTKNetwork/"><span class="tag">YTKNetwork</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/YYModel/"><span class="tag">YYModel</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/block/"><span class="tag">block</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dyld/"><span class="tag">dyld</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mach-o/"><span class="tag">mach-o</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/runtime/"><span class="tag">runtime</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/weak/"><span class="tag">weak</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/"><span class="tag">关联对象</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"><span class="tag">内存分布</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%A1%E6%A0%B8/"><span class="tag">审核</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%A5%E5%85%B7/"><span class="tag">工具</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"><span class="tag">引用计数</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82/"><span class="tag">杂</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%BA%90%E7%A0%81/"><span class="tag">源码</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%94%81/"><span class="tag">锁</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="千行的博客" height="28"></a><p class="is-size-7"><span>&copy; 2022 千行</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>