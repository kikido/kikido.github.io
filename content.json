{"posts":[{"title":"Command &#x2F;usr&#x2F;bin&#x2F;codesign failed with exit code 1 解决办法","text":"苹果开发者账号好像今天就过期了，虽然昨天续费了，但是在真机测试的时候，遇到了一下的错误： 1Command /usr/bin/codesign failed with exit code 1 以往对于这种证书签名错误，xcode会弹出提示框，然后点fix来解决，但这次没有弹框，网上查了一下，如下方法可以解决。点击xcode偏好设置-&gt;Locations-&gt;Derived Data，点击箭头定位到目标文件夹，将此文件夹清空并清空回收站，然后重启下电脑即可。 参考：https://segmentfault.com/a/1190000000712103","link":"/2018/12/13/Command-usr-bin-codesign-failed-with-exit-code-1-%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"title":"JYAuthorization的说明使用","text":"综述在iOS开发中，我们总会用到许多iOS的隐私功能，例如定位，相机，麦克风等。在编写这些功能代码的时候，我们都要先判断是否拥有权限，然后根据有无代码执行不同的操作，功能一多的话就会显得繁琐。为了解决这个问题，我自己编写了JYAuthorization这一个框架，旨在快速获取以及查询iOS的功能权限，将更多的精力放在业务上。 支持的类型及要求 ARC iOS 8.0+ OC 目前支持的隐私类型(如果有需要，后面会继续添加)： 1234567891011121314151617181920212223typedef NS_ENUM(NSUInteger, JYServiceType){ JYServiceTypeNone, ///|&lt; 定位-使用应用期间 JYServiceTypeLocationWhenInUse, ///|&lt; 定位-使用使用 JYServiceTypeLocationAlways, ///|&lt; 通讯录 JYServiceTypeAddressBook, ///|&lt; 日历 JYServiceTypeCalendar, ///|&lt; 提醒 JYServiceTypeReminder, ///|&lt; 相册 JYServiceTypePhoto, ///|&lt; 麦克风 JYServiceTypeMicroPhone, ///|&lt; 相机 JYServiceTypeCamera, ///|&lt; 语音识别 JYServiceTypeSpeechRecognition, ///|&lt; 健康 JYServiceTypeHealth}; JYAuthorizationManagerJYAuthorizationManager是一个单例，负责查询以及保存功能权限的数据。 你可以通过类方法shareManager来创建实例 通过实例方法- (void)requestAccessToServiceType:(JYServiceType)authType completion:(void(^)(BOOL granted, NSError *error))completion可以快速的查询功能权限。error的使用下面会有说明 查询过的权限结果(除JYAuthorizationErrorNotDetermined)，将被保存在私有属性authDict中。因为iOS的隐私功能权限，如果被修改过了，那么当前应用是会被强制退出的，所以当前的查询结果可以保存起来，避免重复查询 如果想要显示查询的Error，你可以调用实例方法jy_showErrorDetail:(NSError *)error viewController:(UIViewController *)viewController，效果就跟上面的gif图中的效果一样 JYAuthorization支持多语言，你可以在JYAuthorization.bundle里面的Localizable.strings的文件中修改不同的提示语。 NSError的使用NSError如果有不明白的可以看我的另一篇博客NSError，在这里简单说明下： error.domain为自定义的错误域JYAuthErrorDomain error.code为自定义的值123456789101112131415typedef NS_ENUM(NSInteger, JYAuthorizationStatus){ JYAuthorizationErrorNone = 0, ///|&lt; 已授权 JYAuthorizationErrorGranted = 1, ///|&lt; 未授权 JYAuthorizationErrorNotDetermined = -100, ///|&lt; 无授权，切用户无法改变这个状态。例如，家长控制 JYAuthorizationErrorRestricted = -101, ///|&lt; 授权被拒绝 JYAuthorizationErrorDenied = -102, ///|&lt; 尚未启用该服务 JYAuthorizationErrorUnServiced = -1000, ///|&lt; 版本过低，不支持该服务 JYAuthorizationErrorLowVersion = -2000}; error.localizedDescription：错误描述，具体信息你可以在Localizable.strings中修改 error.localizedRecoverySuggestion：错误恢复建议，具体信息你可以在Localizable.strings中修改 如果error.userInfo[JYAuthOpenSettingKey]有值，那么在提示错误时，您可以选择点击前往，前往设置界面 accessIfNotDetermined属性这是一个BOOL类型的值，默认为YES。值为YES的时候，当你调用- (void)requestAccessToServiceType:(JYServiceType)authType completion:(void(^)(BOOL granted, NSError *error))completion时，如果权限是JYAuthorizationErrorNotDetermined(未授权)，则会直接调用方法请求权限。 dontAlertIfNotDetermined属性这是一个BOOL类型的值，默认为YES。值为YES的时候，当你调用- (void)jy_showErrorDetail:(NSError *)error viewController:(UIViewController *)viewController时，如果erroe的code(错误码)是JYAuthorizationErrorNotDetermined(-100)的话，则不会显示错误提示。 如何使用假设我们有一个需求：调用iOS的定位服务。那么我们可以像下面这样： 1234567891011121314151617- (void)startLocationService{ JYAuthorizationManager *authManager = [JYAuthorizationManager shareManager]; [authManager requestAccessToServiceType:JYServiceTypeLocationWhenInUse completion:^(BOOL granted, NSError * _Nonnull error) { if (granted) { // 有权限的话 self.locationManager = [[CLLocationManager alloc] init]; self.locationManager.delegate = self; self.locationManager.distanceFilter = 50; self.locationManager.desiredAccuracy = kCLLocationAccuracyNearestTenMeters; [self.locationManager startUpdatingLocation]; } else { // 没有权限 [authManager jy_showErrorDetail:error viewController:self]; } }];} 使用JYAuthorization，你不需要考虑有没有权限，是否未决定权限。在上面的例子中，如果尚未决定权限，并且error.code是JYAuthorizationErrorNotDetermined的话，会自动帮你请求权限，并且在获取权限之后，执行completion里面的回调。 当然，现在的很多应用，为了能够获取客户的权限，都会在申请权限之前，跳出一个弹框提示，说明获取权限的重要性，那么使用JYAuthorization也能够很方便的实现这个权限。示例如下： 123456789101112131415161718- (void)startLocationService{ JYAuthorizationManager *authManager = [JYAuthorizationManager shareManager]; authManager.accessIfNotDetermined = false; [authManager requestAccessToServiceType:JYServiceTypeLocationWhenInUse completion:^(BOOL granted, NSError * _Nonnull error) { if (granted) { // 有权限的话 // todo... } else { if (error.code == JYAuthorizationErrorNotDetermined) { // 如果尚未决定权限，跳出自己的提示页面 // 1.客户在自己的提示页面点击确定之后，修改`accessIfNotDetermined`为YES，且再次调用`- (void)requestAccessToServiceType:(JYServiceType)authType completion:(void(^)(BOOL granted, NSError *error))completion`这个方法 } else { [authManager jy_showErrorDetail:error viewController:self]; } } }];} 结束好了，说明就到此为止了。如果有错误的话，欢迎指出~","link":"/2019/03/13/JYAuthorization%E7%9A%84%E8%AF%B4%E6%98%8E%E4%BD%BF%E7%94%A8/"},{"title":"NSError了解一哈","text":"说来惭愧，工作以来一直没有好好了解NSError这个类。这次的话因为一些需求，准备系统的学习一下子，下面就是我大致的总结。 综述OC中通常使用NSError对象来发出错误信号，提供错误类型以及任何潜在原因的额外信息。 Foundation和其它Cocoa框架产生的错误通常归属于NSCocoaErrorDomain错误域。NSCocoaErrorDomain中的错误状态码都是在Foundation定义好的常量。 在子类中，可以通过覆写localizedDescription方法来提供更好的本地错误描述。 NSError是CFError的无缝转换对象。 每个NSError对象主要提供三部分的信息： code 状态码 domain 对应的特定错误域 userInfo 额外的信息 code和domaincode状态码表示问题的本质，这些状态码都在一个特定的错误域中，以防重叠和混淆。 例如在NSCocoaErrorDomain中，NSFileManager访问一个不存在的文件产生的错误代码是4。而在NSPOSIXErrorDomain中，4代表中断函数错误。 userInfo及一些属性作为Cocoa的惯例，userInfo是一个可以包含任意键值对的字典，无论是为了继承或降低耦合的目的, 它都不适合拿来填满各种杂七杂八的属性。在NSError这个例子中，有一些特定的键值对应着只读属性。一下是标准NSError的userInfo的键列表 NSLocalizedDescriptionKey NSLocalizedFailureReasonErrorKey NSLocalizedRecoverySuggestionErrorKey NSLocalizedRecoveryOptionsErrorKey NSFilePathErrorKey NSStringEncodingErrorKey NSUnderlyingErrorKey NSRecoveryAttempterErrorKey NSHelpAnchorErrorKey 下面是常见的几个键： localizedDescription NSLocalizedDescriptionKey的对应值，即userInfo[NSLocalizedDescriptionKey]，下同一段本地化的错误描述。错误的主要可呈现信息。例如NSFileReadNoPermissionError：”文件XX无法打开，因为你并没有查看它的权限”。理想状况下，这个信息会指出失败的原因以及失败原因。这个值来自于NSLocalizedDescriptionKey或者是NSLocalizedFailureErrorKey + NSLocalizedFailureReasonErrorKey或者是NSLocalizedFailureErrorKey。构建描述信息的步骤如下： 在userInfo中查找NSLocalizedDescriptionKey，如果存在则使用 在userInfo中查找NSLocalizedFailureErrorKey，如果存在，则使用，与NSLocalizedFailureReasonErrorKey的值组合使用(如果存在) 在userInfoValueProvider中查找NSLocalizedDescriptionKey，如果存在则使用 在userInfoValueProvider中查找NSLocalizedFailureErrorKey，如果存在则使用，与NSLocalizedFailureReasonErrorKey的值组合使用(如果存在) 在userInfo或者userInfoValueProvider查找NSLocalizedFailureErrorKey，如果存在则使用 上文中提到的userInfoValueProvider我也不知道是什么东西，我猜测可能是NSError的类方法+ (id _Nullable (^)(NSError * _Nonnull, NSErrorUserInfoKey _Nonnull))userInfoValueProviderForDomain:(NSErrorDomain)errorDomain; 中的返回值 localizedRecoverySuggestion NSLocalizedRecoverySuggestionErrorKey的对应值，即userInfo[NSLocalizedRecoverySuggestionErrorKey]，一段该错误的恢复建议，适合在alert中显示为辅助消息。 localizedFailureReason localizedFailureReason的对应值，即userInfo[localizedFailureReason]，一段本地化的错误解释 如何使用调用系统API时返回的NSError了解过上面的知识之后，那我们要怎样更好的使用系统返回给我们的NSError呢，下面是我自己使用的方式： 123456789101112- (void)showErrorDetail:(NSError *)error viewController:(UIViewController *)viewController{ if (![viewController isKindOfClass:[UIViewController class]]) { return; } if (![error isKindOfClass:[NSError class]] || !error) { return; } UIAlertController *alertController = [UIAlertController alertControllerWithTitle:error.localizedDescription message:error.localizedRecoverySuggestion preferredStyle:UIAlertControllerStyleAlert]; [alertController addAction:[UIAlertAction actionWithTitle:NSLocalizedString(@&quot;确定&quot;, nil) style:UIAlertActionStyleDefault handler:nil]]; [viewController presentViewController:alertController animated:YES completion:nil];} 如何创建一个NSError作为开发者，我们需要怎么样使用NSError，才能更好的传递错误信息呢？首先，我们可以按Foundation库中很多类那个样子，在一个自定义方法中定义NSError **类型的形参。然后，我们也可以定义属于自己的错误域、错误代码常量和userInfo中的Key。 12345678910// 自定义DomainNSString *const JYCustomErrorDomain = @&quot;JYCustomErrorDomain&quot;;// 自定义keyNSString *const JYValidationStatusErrorKey = @&quot;JYValidationStatusErrorKey&quot;;// 自定义错误码typedef NS_ENUM(NSInteger, JYCustomErrorCode){ JYCustomErrorCodeGen = -999, JYCustomErrorCodeRequired = -1000}; 使用userInfo字典来创建一个NSError12345678NSDictionary *userInfo = @{ NSLocalizedDescriptionKey: NSLocalizedString(@&quot;Operation was unsuccessful.&quot;, nil), NSLocalizedFailureReasonErrorKey: NSLocalizedString(@&quot;The operation timed out.&quot;, nil), NSLocalizedRecoverySuggestionErrorKey: NSLocalizedString(@&quot;Have you tried turning it off and on again?&quot;, nil) };NSError *error = [NSError errorWithDomain:JYCustomErrorDomain code:JYCustomErrorCodeGen userInfo:userInfo]; 将错误信息包装在NSError对象中，很容易在不同对象或者上下文中进行传递。 结束参考来源： NSError 苹果文档","link":"/2019/03/13/NSError%E4%BA%86%E8%A7%A3%E4%B8%80%E5%93%88/"},{"title":"Objective-C引用计数原理","text":"在 Objective-C 2.0 中，我们无需手动进行内存管理，因为ARC会自动帮我们在编译的时候，在合适的地方对对象进行retain和release操作。本文将结合runtime 750版本源码 探究 ARC 环境下引用计数的实现原理。 如何存储引用计数从 5S 开始，iPhone 都采用了64位架构的处理器，为了节省内存和提高执行效率，苹果提出了Tagged Pointer的概念，专门用来存储小的对象，例如 NSNumber 和 NSDate。这一类变量本身的值需要占用的内存大小常常不需要8字节，拿整数来说，4个字节所能表示的有符号整数可以达到20多亿(2^31=2147483648，另外 1 位作为符号位)，基本可以处理大多数情况。所以我们将一个对象的指针(64位下8字节)拆成两部分，一部分用来存储数据，另一部分作为特殊标记，表示这是一个 Tagged Pointer, 不指向任何一个地址。也就是当某些类使用 Tagged Pointer 来存储数据后，它就不是一个对象了，因为它并没有指向任何地址，变成了一个披着对象皮的普通变量而已，而对于这一类的‘对象’，它的内存是分配在栈中，由系统分配以及释放，所以它的引用计数也没有意义了，当然你仍然可以使用CFGetRetainCount方法去获取它的引用计数，返回的是它的指针地址。 而在某些平台中(比如arm64)，isa 实例的一部分空间也会被用来存储引用计数，当引用计数超过一定值之后，runtime 会使用一张散列表(哈希表)来管理其引用计数；如果不使用 isa 存储引用计数则会直接存储到散列表中。 isa 指针用64位(8字节)来存储一个内存地址显然是种浪费，于是可以将一部分的空间用来存储引用计数。当 isa 指针第一位为1时即表示使用优化的 isa 指针，这里列出64位环境下的 isa 结构： 1234567891011121314151617181920212223242526272829303132union isa_t { isa_t() { } isa_t(uintptr_t value) : bits(value) { } Class cls; uintptr_t bits;#if SUPPORT_NONPOINTER_ISA# if __arm64__# define ISA_MASK 0x00000001fffffff8ULL# define ISA_MAGIC_MASK 0x000003fe00000001ULL# define ISA_MAGIC_VALUE 0x000001a400000001ULL struct { uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 30; // MACH_VM_MAX_ADDRESS 0x1a0000000 uintptr_t magic : 9; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 19;# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18) }; // SUPPORT_NONPOINTER_ISA#endif}; SUPPORT_NONPOINTER_ISA表示是否支持在 isa 指针内添加额外的信息，例如引用计数，析构状态，被__weak变量引用的情况等。目前仅支持 arm64架构的设备支持。 变量名 含义 indexed 0 表示普通的 isa 指针，1 表示可以存储引用计数 has_assoc 表示该对象是否包含 associated object(关联对象) has_cxx_dtor 表示该对象是否有 C++ 的析构函数 shiftcls 类的指针 magic 固定值为 0xd2，用于在调试时分辨对象是否未完成初始化 weakly_referenced 表示该对象是否有过 weak 对象，如果没有，则析构时更快 deallocating 表示该对象是否正在析构 has_sidetable_rc 表示该对象的引用计数值是否过大无法存储在 isa 指针 extra_rc 存储引用计数值减一后的结果 在64位环境下，isa 会存储引用计数，当 has_sidetable_rc 的值为1时，那么溢出的引用计数将会存储在一张全局散列表中，也就是引用计数 = isa保存的引用计数 + 哈希表保存的引用计数 + 1。后面会详细讲到。 哈希表 DenseMap123456789101112typedef objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,true&gt; RefcountMap;template&lt;typename KeyT, typename ValueT, bool ZeroValuesArePurgeable = false, typename KeyInfoT = DenseMapInfo&lt;KeyT&gt; &gt;class DenseMap : public DenseMapBase&lt;DenseMap&lt;KeyT, ValueT, ZeroValuesArePurgeable, KeyInfoT&gt;, KeyT, ValueT, KeyInfoT, ZeroValuesArePurgeable&gt; { // ...省略} runtime 使用 DenseMap 哈希表(也叫散列表，类似NSDictionary)的别名RefcountMap来存储引用计数。DenseMap 继承于 DenseMapBase 这个 C++ 类，通过观察 DenseMapBase 的内部实现我们可以发现以下几点： 键 KeyT 的类型为DisguisedPtr&lt;objc_object&gt;，这个类是对objc_object *指针及其一些操作进行的封装，目的是不受内存泄漏工具leaks的检测 值 ValueT 的类型为 size_t, size_t在64位环境下等同于 unsigned long。保存的值等于引用计数减一 模板的 KeyInfoT 类型为 DenseMapInfo，在这里等同于DenseMapInfo&lt;DisguisedPtr&gt;。DenseMapInfo 封装了比较重要的方法，用于在哈希表中查找 key 映射的内容 123456789101112131415template&lt;typename T&gt;struct DenseMapInfo&lt;T*&gt; { static inline T* getEmptyKey() { uintptr_t Val = static_cast&lt;uintptr_t&gt;(-1); return reinterpret_cast&lt;T*&gt;(Val); } static inline T* getTombstoneKey() { uintptr_t Val = static_cast&lt;uintptr_t&gt;(-2); return reinterpret_cast&lt;T*&gt;(Val); } static unsigned getHashValue(const T *PtrVal) { return ptr_hash((uintptr_t)PtrVal); } static bool isEqual(const T *LHS, const T *RHS) { return LHS == RHS; }}; 指针哈希算法实现： 123456789#if __LP64__static inline uint32_t ptr_hash(uint64_t key){ key ^= key &gt;&gt; 4; key *= 0x8a970be7488fda55; key ^= __builtin_bswap64(key); return (uint32_t)key;}#endif 虽然不完美，但是速度很快(注释说的。。。) 简单来讲，DenseMap 通过对象的指针地址来映射其引用计数 SideTable123456struct SideTable { spinlock_t slock; RefcountMap refcnts; weak_table_t weak_table; // ...省略} 介绍完存储引用计数的哈希表，那么这个哈希表是存储在哪里的呢？答案是保存在一个叫做SideTable的结构体中，通过观察它的结构组成，我们可以可以看到有三个成员变量slock, refcnts和weak_table。 slock是一个自旋锁，保证线程安全 refcnts的类型是 RefcountMap，也就是上一节提到过的 DenseMap 类型的别名。用来保存引用计数 weak_table用来保存__weak修饰的指针。当一个对象 delloc 时，通过这个表将这些指向要释放对象的用__weak修饰的指针置为nil，避免野指针的情况出现。 StripedMap知道引用计数的哈希表是保存在SideTable中，那么SideTable实例保存在哪里呢？答案是在一个全局的StripedMap&lt;SideTable *&gt;类型的静态变量SideTableBuf中 123456789alignas(StripedMap&lt;SideTable&gt;) static uint8_t SideTableBuf[sizeof(StripedMap&lt;SideTable&gt;)];static void SideTableInit() { new (SideTableBuf) StripedMap&lt;SideTable&gt;();}static StripedMap&lt;SideTable&gt;&amp; SideTables() { return *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);} 之所以在初始化时将 SideTableBuf 定义成 uint8_t 是因为方便计算内存大小，在SideTables()方法中我们可以看到SideTableBuf会被强制转换成StripedMap&lt;SideTable&gt;*类型。实际上 SideTableBuf 也是哈希表，根据指针地址映射到相应的SideTable类型的变量。下面是StripedMap这个类的定义： 12345678910111213141516171819202122template&lt;typename T&gt;class StripedMap {#if TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR enum { StripeCount = 8 };#else enum { StripeCount = 64 };#endif struct PaddedT { T value alignas(CacheLineSize); }; PaddedT array[StripeCount]; static unsigned int indexForPointer(const void *p) { uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(p); return ((addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)) % StripeCount; } public: T&amp; operator[] (const void *p) { return array[indexForPointer(p)].value; } // ...省略} StripedMap中有一个PaddedT类型的数组array，在模拟器中容量为64，在真机中为8。PaddedT结构体大小为64个字节，其成员变量 value 的类型实际是我们之前传入 SideTable。当系统调用SideTable&amp; table = SideTables()[]时首先会执行SideTables()得到SideTableBuf， 然后在StripedMap中执行T&amp; operator[] (const void *p)方法获取相应的SideTable。 12345678T&amp; operator[] (const void *p) { return array[indexForPointer(p)].value; } static unsigned int indexForPointer(const void *p) { uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(p); return ((addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)) % StripeCount;} 在indexForPointer()函数中返回相应 SideTable 的index。(addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)这一步我也不是很懂，应该是类似于产生一个随机数，后面的% StripeCount返回一个 [0, StripeCount)的数，也就是相应 SideTable 的index。所以一个 SideTable 应该是对应许多的对象的。 保存引用计数的哈希表保存在SideTable结构体中，而SideTable保存在一个全局的静态变量StripedMap&lt;SideTable&gt; SideTableBuf中。在真机下，SideTableBuf能够储存8个SideTable实例。StripedMap的方法indexForPointer()通过对象的指针计算出相应 SideTable 的 index。一个 SideTable 对应多个对象 获取引用计数在 ARC 环境下我们可以使用方法CFGetRetainCount得到对象的引用计数。在 runtime 中，通过调用objc_object的rootRetainCount()获取引用计数： 1234567891011121314151617181920inline uintptr_t objc_object::rootRetainCount(){ if (isTaggedPointer()) return (uintptr_t)this; sidetable_lock(); isa_t bits = LoadExclusive(&amp;isa.bits); ClearExclusive(&amp;isa.bits); if (bits.nonpointer) { uintptr_t rc = 1 + bits.extra_rc; if (bits.has_sidetable_rc) { rc += sidetable_getExtraRC_nolock(); } sidetable_unlock(); return rc; } sidetable_unlock(); return sidetable_retainCount();} isTaggedPointer在前面我们已经分析过了如果是Tagged Pointer类型的对象时是怎么样的。此时对象在栈中分配，由系统自动销毁内存(先进后出）,所以此时对它求引用计数返回其地址。下面让我们重点看一下sidetable_retainCount()这个方法 当 isa 的 nonpointer = 1 的情况我们开头也分析过了，此时 isa 指针也用来存储引用计数，如果引用计数溢出则将溢出部分存储在哈希表中 下面让我们研究一下不使用isa优化是怎么从哈希表中获取引用计数的 12345678910111213141516uintptr_tobjc_object::sidetable_retainCount(){ SideTable&amp; table = SideTables()[this]; size_t refcnt_result = 1; table.lock(); RefcountMap::iterator it = table.refcnts.find(this); if (it != table.refcnts.end()) { // this is valid for SIDE_TABLE_RC_PINNED too refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT; } table.unlock(); return refcnt_result;} 首先得到 SideTable 实例。 成员变量 refcnts 就是之前说的保存引用计数的哈希表，在哈希表中根据指针值查找引用计数。 it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT 注意result从第三位才开始保存数据，所以需要将数据向右移动2位才能取到引用计数。第1位用来保存该对象是否被用__weak修饰的变量引用，第2位用来表示该对象是否正在析构 将右移后得到的数+1(refcnt_result)后返回。这也是为什么之前说哈希表保存的引用计数是实际值 -1 之后的值的原因。 Retain在非 ARC 环境中可以使用retain和release方法对引用计数进行加减操作，在 ARC 环境中我们无需也无法使用这两个方法操作引用计数，但是你可以使用CFRetain()对对象进行 retain 操作。最终会调用 objc_object的rootRetain方法 123456789inline id objc_object::rootRetain(){ assert(!UseGC); if (isTaggedPointer()) return (id)this; return sidetable_retain();} 类似于上一节中获取引用计数的方法，当对象属于Tagged Pointer时则返回该对象。所以我们接着看sidetable_retain()方法： 12345678910111213141516id objc_object::sidetable_retain(){#if SUPPORT_NONPOINTER_ISA assert(!isa.nonpointer);#endif SideTable&amp; table = SideTables()[this]; table.lock(); size_t&amp; refcntStorage = table.refcnts[this]; if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) { refcntStorage += SIDE_TABLE_RC_ONE; } table.unlock(); return (id)this;} 首先得到 SideTable 实例。从实例中得到存储引用技术的哈希表refcnts，在哈希表中根据对象的地址找到对应的引用计数refcntStorage，判断引用计数的值是否有溢出，如果没有则对引用计数 + 1，返回对象。上一节我们讲过 refcntStorage 中第三位才开始用来存储引用计数，所以读数时需要先往右边移动两位，那为什么这里的代码没有呢？ 123456#define SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)#define SIDE_TABLE_DEALLOCATING (1UL&lt;&lt;1) // MSB-ward of weak bit#define SIDE_TABLE_RC_ONE (1UL&lt;&lt;2) // MSB-ward of deallocating bit#define SIDE_TABLE_RC_PINNED (1UL&lt;&lt;(WORD_BITS-1))#define SIDE_TABLE_RC_SHIFT 2 注意观察SIDE_TABLE_RC_ONE的定义，是一个8字节的 unsigned long 类型，值为1，向左偏移了两位。refcntStorage += SIDE_TABLE_RC_ONE两者相加的话则直接从第三位开始相加了，所以可以使用 SIDE_TABLE_RC_ONE 对引用计数进行 +1 和 -1 操作。同样的，在上面的代码中, SIDE_TABLE_RC_PINNED用来判断引用计数值是否有溢出。 Releaserelease 最终会调用 objc_object的方法rootRelease() 12345678910111213141516171819202122232425262728293031323334inline bool objc_object::rootRelease(){ if (isTaggedPointer()) return false; return sidetable_release(true);}uintptr_t objc_object::sidetable_release(bool performDealloc){#if SUPPORT_NONPOINTER_ISA assert(!isa.nonpointer);#endif SideTable&amp; table = SideTables()[this]; bool do_dealloc = false; table.lock(); RefcountMap::iterator it = table.refcnts.find(this); if (it == table.refcnts.end()) { do_dealloc = true; table.refcnts[this] = SIDE_TABLE_DEALLOCATING; } else if (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) { // SIDE_TABLE_WEAKLY_REFERENCED may be set. Don't change it. do_dealloc = true; it-&gt;second |= SIDE_TABLE_DEALLOCATING; } else if (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) { it-&gt;second -= SIDE_TABLE_RC_ONE; } table.unlock(); if (do_dealloc &amp;&amp; performDealloc) { ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc); } return do_dealloc;} 在这个方法你可以知道为什么哈希表中保存的引用计数是实际值 -1 之后的值。it-&gt;second &lt; SIDE_TABLE_DEALLOCATING用来判断保存的引用计数值是否小于1，如果小于1的话则对该值标记为正在析构：it-&gt;second |= SIDE_TABLE_DEALLOCATING;，并且在随后对该对象发送 delloc 消息。举个例子，一个对象 sark，实际的引用计数为1，在哈希表中保存的值为0，当这个对象进行release操作后，sark 的引用计数变成了0，也就是需要进行销毁操作了。而到了该方法中，会判断保存的引用计数的值是否小于1，如果是的话则进行 delloc 操作，并且将哈希表中存储的值标记为正在析构状态。而 sark 原先保存着的引用计数值就是 =0，这样设计避免了在哈希表存储的引用计数出现负数的情况。 alloc，new， copy 和 mutableCopycopy 以及 mutableCopy是NSCopying和NSMutableCopying 协议上的方法，需要在各类上自己去实现copyWithZone: 和mutableCopyWithZone:方法。无论是深拷贝还是浅拷贝都会增加引用计数。 123456+ (id)new { return [callAlloc(self, false/*checkNil*/) init];}+ (id)alloc { return _objc_rootAlloc(self);} [cls alloc]以及[cls allocWithZone:nil]方法最终会调用callAlloc()方法，所以 alloc 和 new 这两个方法后面都会调用callAlloc()这个方法,因为 Objective-C 2.0 忽视垃圾回收和 NSZone，那么后续的调用顺序依次是为： 1234callAlloc()class_createInstance()_class_createInstanceFromZonecalloc() calloc()函数相比于malloc()函数的优点是它将分配的内存区域初始化为0，相当于malloc()后再用memset()方法初始化一遍。 单例其实这一节是对上一节内容的补充。记得我刚出来工作的时候，单例是这样写的： 123456789101112131415@implementation Son+ (instancetype)shareManager{ static Son *son; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ son = [super allocWithZone:nil]; }); return son;}+ (instancetype)allocWithZone:(struct _NSZone *)zone{ return [self shareManager];}@end 当时组长问我为什么要这样子写(因为跟他们写的方式不一样)，我也答不上来，因为这种代码都是直接google的。但是看了callAlloc()实现之后我明白为什么了。在上一节我们已经知道了 alloc 和 new 都会接着调用callAlloc() 1234567891011121314151617181920212223242526272829303132static ALWAYS_INLINE idcallAlloc(Class cls, bool checkNil, bool allocWithZone=false){ if (slowpath(checkNil &amp;&amp; !cls)) return nil;#if __OBJC2__ if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) { // No alloc/allocWithZone implementation. Go straight to the allocator. // fixme store hasCustomAWZ in the non-meta class and // add it to canAllocFast's summary if (fastpath(cls-&gt;canAllocFast())) { // No ctors, raw isa, etc. Go straight to the metal. bool dtor = cls-&gt;hasCxxDtor(); id obj = (id)calloc(1, cls-&gt;bits.fastInstanceSize()); if (slowpath(!obj)) return callBadAllocHandler(cls); obj-&gt;initInstanceIsa(cls, dtor); return obj; } else { // Has ctor or raw isa or something. Use the slower path. id obj = class_createInstance(cls, 0); if (slowpath(!obj)) return callBadAllocHandler(cls); return obj; } }#endif // No shortcuts available. if (allocWithZone) return [cls allocWithZone:nil]; return [cls alloc];} 如果类重载了allocWithZone方法，那么cls-&gt;ISA()-&gt;hasCustomAWZ()将会返回YES，也就是说当我们用alloc或者new创建实例的时候，就不会走系统的方法，而会走重载的allocWithZone方法了。我们在重载allocWithZone方法时返回[self shareManager]（注意此时的self代表Son类）, 因为shareManager方法返回的是一个静态变量。 还有一个需要注意的点就是在shareManager中，我们使用son = [super allocWithZone:nil];初始化实例，为什么不使用son = [[super alloc] init];来初始化呢？代码中的[super alloc];在编译后会变成objc_msgSendSuper(objc_super super, @selector(alloc))(大致意思是这样)。其中objc_super是一个结构体，只有两个成员变量id receiver和Class class，receiver 仍是 self（Son类）， class 为 Father类。当我们想通过[super alloc]创建实例的时候，会从 Father类中查找 +alloc 方法，如果没有实现则在 NSObject 中查找 +alloc 方法。而方法里面的参数 self 仍旧为 Son 类而不是 Father 类，所以还是会去调用重载的allocWithZone方法，导致死循环。 引用Objective-C 引用计数原理","link":"/2019/07/03/Objective-C%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%8E%9F%E7%90%86/"},{"title":"Objective-C类和对象的内存分布","text":"之前在别人博客下面看到了一个问题，觉得挺有意思的。但是自己想回答的时候又发现好像有一些知识点还不是很熟悉，觉得有点迷糊，所以准备再研究一下底层再来回答问题。现在把这个坑填上吧。 OC对象的指针类型Objective-C 是一门动态语言，而动态语言是在运行时确定数据类型，变量使用之前不需要类型声明。但是我们在写代码的时候还是要给对象一个类型或者使用id的，我自己觉得这么做是为了通过编译（例如声明了类型为NSObject的实例sark，却调用了方法foo，那么编译就通不过了）。实际上动态语言的一个特性多态就是这么实现的，即用父类的指针指向子类的实例。 对象的内存分布还是举个例子会明白一点。需要注意的是需要在模拟器上调试，在真机调试会有问题的。 1234567891011@interface Father : NSObject@property (nonatomic, copy) NSString *name;@end@implementation ViewController- (void)foo { Father *father1 = [Father new]; father1.name = @&quot;001&quot;; id father2 = [Father new];}@end 调试之前，我们要明白几点常识。在计算机中每个字节都是有一个地址的，每个字节有8个bit，每个bit可以存储1或者0，这8个bit就是这个字节的值。在小端系统中，低位的值存储在低地址上。使用 x 命令调试。格式：x/&lt;n/f/u&gt; &lt;addr&gt; x 显示内存 n 正整数，表示需要显示的内存单元的个数 f 表示addr指向的内存内容的输出格式 s: 对应输出字符串 x: 按十六进制格式显示变量 d: 按十进制格式显示变量 c: 按字符格式显示变量 u 以多少个字节作为一个内存单元 b: 1 byte h: 2 bytes w: 4 bytes g: 8 bytes 打断点，然后输入命令: x/8xg father1, 即：以8个字节为一个单元，从 father1 指针的地址开始起8个单元的值 1234567891011(lldb) x/8xg father10x6000000128f0: 0x000000010be34050(Class) 0x000000010bdcc058(name) 0x600000012900: 0x00006000000128a0 0x00000001000000020x600000012910: 0x000000010f8f8e58 0x00000000000000000x600000012920: 0x0000000000000000 0x0000000000000000(lldb) x/8xg father20x600000012490: 0x000000010be34050(Class) 0x0000000000000000(name)0x6000000124a0: 0xbadd2dcdc19dbead 0x00006000000124f00x6000000124b0: 0x0000000000000000 0x00000000000000000x6000000124c0: 0x00007f8ae3c140c0 0x00006080000092b0 这里我提前将这些地址代表的意思标注好了。father2虽然是id类型的，但是它跟father1第一个8字节所存储的地址是相同的，都是0x000000010be34050。其实这个地址就是 Father类的地址。我们可以使用下面的方法验证： 12(lldb) po (Class)0x000000010be34050Father 所以一个实例对象第一个8字节存储的是这个类的指针，那么后面的字节存储的是什么呢？答案是这个实例的成员变量，在上面的例子中我们给实例father1的成员变量name赋值了001, 现在让我们验证一下： 12(lldb) po (id)0x000000010bdcc058001 因为我们没有对father2的成员变量 name 赋值，所以这8个字节的值是空的。 打开 runtime 750版本源码，查看 id 和 Class 的定义 12345678910111213141516171819202122232425262728293031typedef struct objc_class *Class;typedef struct objc_object *id;struct objc_object {private: isa_t isa;}union isa_t { isa_t() { } isa_t(uintptr_t value) : bits(value) { } Class cls; uintptr_t bits;#if defined(ISA_BITFIELD) struct { ISA_BITFIELD; // defined in isa.h };#endif};struct objc_class : objc_object { // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() { return bits.data(); }} id的定义很简单，是一个指向 objc_object 的指针，而 objc_object 只有一个私有成员变量 isa。objc_class 继承于 objc_object，所以你也可以用 id 来声明 Class 的变量，例如id foo = [NSObject class];。 isa是一个联合体，里面的 struct 在不同架构的CPU中定义是不同的。在 64 位CPU中，isa 可以用来存储更多的信息，例如引用计数，是否有关联对象等，可以看我的这篇博客Objective-C引用计数原理 使用clang rewrite-objc ViewController.m将代码转化成C++实现，可以看到 Father 这个类变成了如下的结构体 1234567struct Father_IMPL { struct NSObject_IMPL NSObject_IVARS; NSString *_name;};struct NSObject_IMPL { Class isa;}; 看到这个结构体你是不是就明白了为什么对象的内存分布是下图这个样子的？需要注意的是，NSObject 的实例虽然理论上只有8个字节，但是它的实例实际上有 16 个字节，后面8个字节是空的。 研究到这里，我们就可以回答开头的那个问题了。 指针的类型是id类型，而指针指向的类型可以是别的类。因为 OC 是动态语言，变量的类型需要在运行时才能够确定。 指针保存的是对象内存的首地址 64位平台中，对象首地址开始的8个字节存储的是类的指针。也就是通过这个才能确定该类的类型 是不是很简单！下面继续让我们研究下 Class 的内存分布问题 Class的内存分布让我们继续回到之前的代码调试。上一节中我们已经知道了Father类的地址了 123456789(lldb) x/16xg 0x000000010be340500x10be34050: 0x000000010be34028(meta-class) 0x000000010f8f8e58(superClass) 0x10be34060: 0x00006000000972f0(bucket_t *_buckets) 0x0000000200000003(_mask &amp; _occupied )0x10be34070: 0x0000600000074302 0x000000010f8f8e080x10be34080: 0x000000010f8f8e08 0x000000010f5485200x10be34090: 0x0000000000000000 0x000000010bdd7df00x10be340a0: 0x000000010be34078 0x000000010f8f8e580x10be340b0: 0x000000010f548520 0x00000000000000000x10be340c0: 0x000000010bdd7e38 0x000000010f8f8e08 PS: 注意不要使用真机来调试，因为我调试的时候发现跳不到那个内存地址中，但在模拟器中没这个问题… 配套的我们把 objc_class 的定义放到下面。 12345678910struct objc_class : objc_object { // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() { return bits.data(); }} 因为 objc_class 继承于 objc_object，所以 Class 的第一个8字节还是 isa 指针，也就是一个指向元类(meta-Class)的指针。如果你不知道元类是什么意思的话就去百度，我也懒得讲了。第2个8字节储存的是指向父类的指针。先让我们验证一下 12345lldb) po (Class)0x000000010be34028Father(lldb) po (Class)0x000000010f8f8e58NSObject 结论正确。让我们接着看cache_t的定义： 1234567891011121314151617struct cache_t { struct bucket_t *_buckets; mask_t _mask; mask_t _occupied;}struct bucket_t {private: // IMP-first is better for arm64e ptrauth and no worse for arm64. // SEL-first is better for armv7* and i386 and x86_64.#if __arm64__ MethodCacheIMP _imp; cache_key_t _key;#else cache_key_t _key; MethodCacheIMP _imp;#endif} cache_t关系到方法查找的缓存。当对实例发送消息后，会先到Class的缓存中查找有没有该方法的缓存，如果有则直接调用方法的实现，提高效率。 大致可以看出，bucket_t是一个哈希表，根据_key找到其映射的方法实现_imp，而_key就是 SEL(方法的名字 const char *)。cache_t是中的_mask和_occupied是两个4字节的变量，应该代表的是缓存的数量。所以，Class 第三个8字节存储的是bucket_t *类型的指针，第4个8字节保存的是 _mask 和 _occupied。因为是小端，低位地址存储低位的数据，所以 _mask 的值是0x00000003，而 _occupied 的值是0x00000002 接下来看 Class 的第3个成员变量class_data_bits_t bits; 123456789struct class_data_bits_t { // Values are the FAST_ flags above. uintptr_t bits; public: class_rw_t* data() { return (class_rw_t *)(bits &amp; FAST_DATA_MASK); }} 在64位下，uintptr_t 为8个字节。class_data_bits_t 的公共方法有很多，主要是配合掩码进行一些读写操作。继续看class_rw_t的定义 1234567891011121314151617181920struct class_rw_t { // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName;#if SUPPORT_INDEXED_ISA uint32_t index;#endif}; 在结构体中，你可以看到有一个成员变量的类型是class_ro_t，是不是很像class_rw_t。从字面意思上可以猜测，一个是readwriite，一个是readonly。因为 OC 是动态语言，可以在运行时添加方法和成员变量，运行时添加的方法或者成员变量就是添加到class_rw_t上的，而class_ro_t存储的是一些编译后Class的信息。在class_data_bits_t的定义中，我们知道了需要掩码FAST_DATA_MASK才能得到 class_rw_t 的地址。下面是 class_rw_t的内存分布 123456789// 得到class_rw_t的内存地址0x0000600000074302 &amp; 0x00007ffffffffff8 = 0x600000074300;(lldb) x/16xg 0x6000000743000x600000074300: 0x00000000800a0000(flags &amp; version) 0x000000010bdd7da8(ro)0x600000074310: 0x000000010bdd7d18(methods) 0x000000010bdd7d90(properties) 0x600000074320: 0x0000000000000000(protocols) 0x000000010be33f60(firstSubclass)0x600000074330: 0x000000010ee88c68(nextSiblingClass) 0x0000000000000000(demangledName)0x600000074340: 0xbadd2dcdc19dbead 0x0000600000074240 因为在代码中我还声明了一个 Father 的子类 Son，没想到在这里出现，没错，就是这个 firstSubclass。至于如果有多个子类，确定哪个是 firstSubclass 我就不清楚了。。。 12(lldb) po (Class)0x000000010be33f60Son 再来看一下class_ro_t的定义： 123456789101112131415161718struct class_ro_t { uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties;} 然后是它的内存分布： 123456(lldb) x/16xg 0x000000010bdd7da80x10bdd7da8: 0x0000000800000184(flags &amp; instanceStart) 0x0000000000000010(instanceSize &amp; reserved)0x10bdd7db8: 0x000000010bd3ea79(ivarLayout) 0x000000010bd3eafc(name)0x10bdd7dc8: 0x000000010bdd7d18(baseMethodList) 0x0000000000000000(baseProtocols)0x10bdd7dd8: 0x000000010bdd7d68(ivars) 0x0000000000000000(weakIvarLayout)0x10bdd7de8: 0x000000010bdd7d90(baseProperties) 0x0000002800000081 可以看到 ro 的成员变量中有instanceStart和instanceSize。这两个值的作用是非脆弱成员变量。即如果基类如果增加了成员变量，不需要重新编译，只需要在初始化系统自动修改instanceStart和instanceSize的值，就能够继续使用子类。具体你可以看我的这篇博客 谈Objective-C类成员变量 ivarLayout 记录了那些是 storng 的ivar name 存储的是这个类的名字，你可以使用po (char *)0x000000010bd3eafc打印该名字 ivars 存储的是该类的成员变量(不包括关联对象) weakIvarLayout 记录了哪一些是 weak 的ivar 还可以看到 ro 的baseMethodList和rw的methods的地址都是0x000000010bdd7d18，ro 的baseProperties和rw的properties的地址都是0x000000010bdd7d90 实际上 rw 的三个成员变量，methods, properties, protocols的类型都继承于list_array_tt，这个列表可能有以下3中值：1. 空值 2. 指向列表的指针 3. 指向列表的指针的数组。所以这就是为什么Class可以在类目中添加方法和协议，只需要在这个列表数组中再添加一个指向类目中方法和协议列表的指针就好了。因为在这个实例中没有使用类目添加方法，所以rw中methods数组仅有一个值，这个值等于ro的baseMethodList。 先来研究methods。 123456789101112131415161718192021 struct method_t { SEL name; const char *types; MethodListIMP imp;}struct method_list_t { uint32_t entsizeAndFlags; uint32_t count; method_t first;} (lldb) x/16xg 0x000000010bdd7d180x10bdd7d18: 0x000000030000001a(entsizeAndFlags &amp; count) 0x000000010f547965(name)0x10bdd7d28: 0x000000010bd41271(types) 0x000000010b7e01e0(imp)0x10bdd7d38: 0x000000010fd3a28e(name) 0x000000010bd41284(types)0x10bdd7d48: 0x000000010b7e0180(imp) 0x0000000112f11912(name)0x10bdd7d58: 0x000000010bd4128c(types) 0x000000010b7e01a0(imp)0x10bdd7d68: 0x0000000100000020 0x000000010be30c500x10bdd7d78: 0x000000010bd19fc8 0x000000010bd4130b0x10bdd7d88: 0x0000000800000003 0x0000000100000010 entsizeAndFlags 第一个4字节保存的是 entsize 和标记, entsize 我的理解好像是method_t的长度。第二个4字节保存的是方法的数量，在上面的例子中我们可以知道一共保存了3个方法。后面保存了3个method_t的实例，每个实例占用了24个字节。每个 method_t 实例，第一个8字节为 sel，即方法名字；第二个8自己保存了方法的参数类型；第3个8字节是方法的函数指针。我们把上面保存的3个方法的信息按顺序打印出来 .cxx_destruct v16@0:8 name @16@0:8 setName: v24@0:8@16 第2和第3个方法比较好理解，系统为我们自动生成了属性 name 的 getter 和 setter 方法。第1个方法cxx_destruct 的作用是在delloc时释放该类的成员变量的，具体你可以看这篇博客 探究ARC下dealloc实现 properties 与 methods 类似，因为继承与同一个结构体。这里简单分析一下，内存分布为 entsizeAndFlags(4字节), count(4字节)，property_t数组。property_t里面有两个成员变量，一个是属性的名字，一个是属性的属性。。。 大致上这就是 Class 的内存分布了，下面这张图能够简要的概括了： 引用ObjectC对象内存布局分析","link":"/2019/07/10/Objective-C%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"title":"YTKNetwork 源码解读 (一) 之 YTKBaseRequest","text":"因为 YTKBaseRequest .h/.m 里代码数目不多，所以这里将从头开始逐行介绍，有一些直接就写在注释里了，有一些需要注意的地方会特别摘出来讲解的。 不知道你有没有注意到 NS_ENUM 后面没有跟着指定一个名字，是的，如果你不需要指定一个类型名字的话，可以直接这样子写。YTKRequestValidationErrorInvalidStatusCode 值的是 reponse.statusCode 不在 200~299 这个区间内，跟 AFHTTPResponseSerializer 的 acceptableStatusCodes 的范围一致 常见的请求方法 请求的序列化样式，相对于 AFNetworking 少了 AFPropertyListRequestSerializer，可能是因为这种编码方式比较少见吧。 相应的序列化样式，相对于 AFNetworking 少了 AFXMLDocumentResponseSerializer，AFPropertyListResponseSerializer，AFImageResponseSerializer，AFCompoundResponseSerializer 几个类型 对应于 NSURLSessionTask 的 priority 属性，需要在 iOS8 以后的系统中使用，不过一般也不需要再兼容之前的系统了吧。。。 AFMultipartFormData 在 AFNetworking 用于 Content-Type 为 application/form-data 的请求，将数据添加到请求体中。一般用于 upload task 中。在 AFConstructingBlock 类型的 block 中，你可以将数据添加数据添加到请求体中在 AFURLSessionTaskProgressBlock 的 block 你可以追踪上传的进度 你可以实现这两个协议，以便在 request 的不同阶段进行相应的处理需要注意的是这些方法的执行顺序不要搞错了 接下来介绍 YTKBaseRequest 这个类，它是一个抽象类，提供了构建 requeset 时的许多选项 这里大部分的属性是映射 NSHTTPURLResponse， NSURLRequest，NSURLSessionTask 这几个类的属性的。 需要注意的是 responseObject，如果 resumableDownloadPath 不为空并且 requestTask 是 DownloadTask 类型的，那么这个属性的值就一个文件路径(NSURL)，用来保存下载数据的 tag 可以用来标记 YTKBaseRequest，默认值是 0userInfo 可以用来添加额外信息 requestAccessories 是一个数组，可以用来保存多个实现了 YTKRequestAccessory 协议的对象constructingBodyBlock 用来将数据添加到请求体中resumableDownloadPath 是保存下载数据文件的路径，当下载请求失败时，部分的下载数据会自动保存到这个文件中，否则数据会保存到 responseData/responseString 中resumableDownloadProgressBlock 可以用来追踪下载进度uploadProgressBlock 可以用来追踪上传进度 -setCompletionBlockWithSuccess:failure: 用来添加请求 成功/失败 的回调-clearCompletionBlock: 将请求 成功/失败 的回调 block 置为 nil，避免循环引用-addAccessory: 用来添加实现 YTKRequestAccessory 的对象 -start：开启任务。需要注意是为了让 task 在完成之前不被释放掉，会在这个 task 添加到单例 YTKNetworkAgent 的成员变量 _requestsRecord中 -stop：取消任务。我感觉这个方法叫做 cancle 比较合适，我一开始看到 stop 还以为是 suspend 的意思 -startWithCompletionBlockWithSuccess:failure:，设置请求 失败/成功 的回调，并开启任务 这部分是你实现 YTKBaseRequest 子类时可以覆写的方法 -requestCompletePreprocessor，-requestCompleteFilter，-requestFailedPreprocessor，-requestFailedFilter：这几个方法都是对请求 成功/失败 结果的处理，结合之前讲过 YTKRequestDelegate，YTKRequestAccessory 两个协议里面的方法，下面给出这些方法的执行顺序. 请求成功后回调的执行顺序： requestCompletePreprocessor：如果使用 cache 的话是在主线程，否则的话在其它线程执行。下面的方法均在主线程执行 requestWillStop requestCompleteFilter requestFinished successCompletionBlock requestDidStop 请求失败后回调的执行顺序 requestFailedPreprocessor：如果使用 cache 的话是在主线程，否则的话在其它线程执行。下面的方法均在主线程执行 requestWillStop requestFailedFilter requestFailed failureCompletionBlock requestDidStop 方法 -cacheFileNameFilterForRequestArgument 用来对请求参数 argument 进行过滤后返回一个新的参数，用在获取缓存文件名字上。 方法 -requestAuthorizationHeaderFieldArray，用于身份验证，在这个方法中你需要返回一个容量为 2 的数组，第一个元素表示账号，第二个元素表示密码。该认证方式使用用户的 账号/密码 作为凭证信息，进行 base64 编码添加到请求头 Authorization 中传输到服务器中 方法 buildCustomUrlRequest，在这个方法里面你可以放回一个自定义的 request，而不是使用 AFNetworking 的 AFHTTPRequestSerializer 生成。如果你返回了一个不为 nil 的对象，那么将忽略 requestUrl, requestTimeoutInterval, requestArgument, allowsCellularAccess, requestMethod and requestSerializerType 方法 jsonValidator，在这个方法里面，你可以对 reponse 序列化后的 JSON 对象进行验证。举个例子，我们要向网址 http://www.yuantiku.com/iphone/users 发送一个 GET 请求，请求参数是 userId 。我们想获得某一个用户的信息，包括他的昵称和等级，我们需要服务器必须返回昵称（字符串类型）和等级信息（数值类型），则可以覆盖 jsonValidator 方法，实现简单的验证。 123456- (id)jsonValidator { return @{ @&quot;nick&quot;: [NSString class], @&quot;level&quot;: [NSNumber class] };} 方法 statusCodeValidator，我觉得如果是验证状态码的话好得加个状态码的参数啊，不过无所谓啦，反正可以自己获取状态码然后再进行判断。该方法返回一个布尔值，如果返回的是 NO 的话将会报错。 接下来讲 .m 文件 在 .h 文件中这些属性都是只读的，在 .m 文件中改成可读写，防止外部修改这些属性的值。 将 NSURLSessionTask，NSURLResponse 的一些属性映射成自己的属性，便于使用 设置请求 成功/失败 的回调需要注意的是可以添加多个实现了 YTKRequestAccessory 协议的对象 开启/关闭 请求的方法。在 start 方法中： 12345678// 触发 YTKRequestAccessory 代理- (void)toggleAccessoriesWillStartCallBack { for (id&lt;YTKRequestAccessory&gt; accessory in self.requestAccessories) { if ([accessory respondsToSelector:@selector(requestWillStart:)]) { [accessory requestWillStart:self]; } }} 在成功创建 task 后，task 将会被添加到 _requestsRecord 属性中避免被释放。随后调用 resume 开启任务如果我们没有覆写方法 buildCustomUrlRequest 返回自定义的 request，系统会根据 YTKBaseRequest 创建 request。这部分在 sessionTaskForRequest:error: 中实现 获取 YTKBaseRequest 实例上各种属性的值，例如方法类型，参数，然后在根据 method 的不同，使用不同的方法创建 task。因为这部分内容都在 YTKNetworkAgent，这里就简单提下。在后面讲解 YTKNetworkAgent 部分的时候再仔细说 在 stop 方法： 12345678// 执行代理[self toggleAccessoriesWillStopCallBack];// 将 delegate 置为 nilself.delegate = nil;// task cancle[[YTKNetworkAgent sharedAgent] cancelRequest:self];// 执行代理[self toggleAccessoriesDidStopCallBack]; 如果你的请求是下载任务，并且你指定了一个缓存文件名，那么下载好的部分数据将会写入这个临时文件中，在下次恢复下载时使用。当然如果要使用断点下载，还需要满足下面的几个条件： 这个资源自你第一次请求后没有改变 这个任务是一个 HTTP 或者 HTTP GET 请求 服务器在 reponse header 提供了 ETag 或者 Last-Modified 字段 服务器支持字节范围请求 本地临时文件没有被删除 由于 YTKBaseRequest 是一个基类，所以在这些需要子类覆写的方法里面内容不多 覆写了 -description 方法，方便打印信息","link":"/2020/07/13/YTKNetwork-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E4%B8%80-%E4%B9%8B-YTKBaseRequest/"},{"title":"YTKNetwork 源码解读 (三) 之 YTKNetworkAgent","text":"这一篇主要用来介绍 YTKNetworkAgent 这个类。当我们生成一个 YTKBaseRequest 实例，使用 -start 方法来发起请求，底层其实是使用 YTKNetworkAgent 来帮助序列化请求 request，以及请求结果 reponse 的序列化和回调。 YTKNetworkConfig 定义了一个叫做 AFURLSessionTaskDidFinishCollectingMetricsBlock 的 block 类型，看过 AF 源码的同学应该知道在 AFURLSessionManager.m 文件中同样定义了这个名字的 block，在同一个文件中 typedef 重复定义貌似不会报错。 NSURLSessionTaskMetrics 是 session 任务指标的封装，每个实例均包含下面几个属性： taskInterval：表示任务从创建到完成花费的总时间，任务的创建时间是任务被实例化时的时间；任务完成时间是任务的内部状态将要变为完成的时间 redirectCount：表示被重定向的次数 transactionMetrics：包含了任务执行过程中每个请求/响应事务中收集的指标，指标是 NSURLSessionTaskTransactionMetrics 类型 这个 block 用于 NSURLSessionTaskDelegate 协议的回调方法 URLSession:task:didFinishCollectingMetrics:，简单的，你可以在这个方法中统计网络流量 YTKUrlFilterProtocol 协议里面只有一个方法 - (NSString *)filterUrl:(NSString *)originUrl withRequest:(YTKBaseRequest *)request，该方法在方法 -buildRequestUrl 中被调用，用来加工 requestUrl 返回的字符串 Url。YTKNetworkConfig 可以添加多个实现 YTKUrlFilterProtocol 协议的实例 YTKCacheDirPathFilterProtocol 协议里面只有一个方法 - (NSString *)filterCacheDirPath:(NSString *)originPath withRequest:(YTKBaseRequest *)request，用来加工缓存的默认目录 /Library/LazyRequestCache，YTKNetworkConfig 可以添加多个实现了 YTKCacheDirPathFilterProtocol 的实例 NS_UNAVAILABLE 这个宏的作用是你无法使用这个宏修饰的方法，也就是你只能只用 +sharedConfig 方法来生成实例，也就是单例 baseUrl: 域名，类似 http://www.yuantiku.com，默认值为 nil cdnUrl：cdn url，默认值是 nil urlFilters：只读，你可以使用实例方法 -addUrlFilter： 来添加实现了 YTKUrlFilterProtocol 协议的实例，该协议在上面已经提到过了 cacheDirPathFilters：只读，你可以使用实例方法 -addCacheDirPathFilter： 来添加实现了 YTKCacheDirPathFilterProtocol 协议的实例，该协议在上面已经提到过了 securityPolicy：安全策略，与证书相关 debugLogEnabled：是否开启 debug 模式，开启后可打印 log sessionConfiguration：session config collectingMetricsBlock：收集指标后的回调 这些就不讲了 对应于 .h 文件中的 urlFilters, cacheDirPathFilters 属性，只是一个为只读，而上面的是成员变量可以直接使用 单例的写法，并在 init 进行初始化。需要注意的是安全策略 securityPolicy 为默认策略，也就是无条件信任服务器的证书 比较简单就不说了 YTKNetworkConfig 是一个单例，你可以用它来： 设定域名 baseUrl 设定 cdn Url 设定安全策略 开启 log 对接口 url 进行修改 对缓存路径进行修改 YTKNetworkAgent 跟上面一样 addRequest：生成 NSURLSessionDataTask，并开启任务; 通过此方法会添加到一个字典集合中 cancelRequest：取消任务，并从集合中移除 cancelAllRequests：取消所有的任务，并从集合中移除 构建请求的 url 字符串 互斥锁，用来保持线程安全。这里使用宏来简化锁的使用使用方式为： 初始化锁：pthread_mutex_init(&amp;_lock, NULL) 上锁：pthread_mutex_lock(&amp;_lock) 解锁：pthread_mutex_unlock(&amp;_lock) 销毁锁，虽然在文件中并没有这步操作：pthread_mutex_destroy(&amp;_lock) 这里是一些 YTKNetworkAgent 的私有成员变量 _manager：序列化参数，上传的附件，响应结果并发起请求 _config：网络配置，上一节已经讲过了 _jsonResponseSerializer：将响应结果序列化成 json _xmlParserResponseSerialzier：将响应结果序列化成 xml _requestsRecord：task 集合，强引用 task，使其在请求过程中不会被释放 _processingQueue：并行队列，用来分配请求成功时的回调 _lock：互斥锁 _allStatusCodes：状态码集合，用来验证响应结果 生成 YTKNetworkAgent 实例并初始化，值得注意的是这里的状态码集合范围是 (100， 500)，不同于 AFN 的 (200， 300) 懒加载 _jsonResponseSerializer、_xmlParserResponseSerialzier 这两个序列化器，它们只有当 responseSerializerType 为 YTKResponseSerializerTypeJSON、YTKResponseSerializerTypeXMLParser 才会被使用 这个方法的作用是构建 request 的 url 先让我们了解一下 URL 的组成，这里举一个例子：http://www.example.com:80/path/to/myfile.html?key1=value1&amp;key2=value2#SomewhereInTheDocument 其中： scheme：因特网服务类型，这里是 http domain：因特网域名，在这里是 www.example.com port：主机上的端口号，默认端口号是 80 path：服务器上的资源路径，在这里是 /path/to/myfile.html parameter：提供给服务器的额外参数，在这里是 ?key1=value1&amp;key2=value2 在这个方法中，如果一个 url 存在 host 跟 scheme，那么就会把它当做一个完整的 url，不需要拼接直接返回 这个方法的作用是创建一个请求序列化器 ① 前面部分是根据 requestSerializerType 类型创建不同的 requestSerializer红色框里面的内容是服务器如果需要 账号/密码 验证时，使用 setAuthorizationHeaderFieldWithUsername：password：将这些信息添加到请求头中① 后面部分的内容是设置你自定义的请求头信息 这个方法的作用是创建 NSURLSessionTask task 根据参数 YTKBaseRequest 获取到请求 method，url，参数，要上传的文件信息，进度 block以及请求序列化器 获取到上面的信息后，根据 method 选择不同的构建方法创建 NSURLSessionTask 当 method 是 GET 时，有两种情况，一种是下载任务，一种是数据任务 这个方法用来构建下载任务。下载任务有断点下载的作用，所以在这里我们需要判断之前是否下载了部分数据，如果是的话则继续下载，否则的话则重头开始下载。 首先我们需要构建 request，这部分由 AFN 的请求序列器 requestSerializer 完成，简单点讲就是设置请求头，设置请求体(将参数编码)，创建 NSMutableURLRequest 代码块 1 的作用是确保下载路径是一个文件路径，而不是文件夹路径。下载任务完成后，AFN 使用方法 moveItemAtURL:toURL:error: 将文件移动到指定路径，如果此时该路径下已经有一个文件存在，就会失败，所以 YTK 这里在下载前就先判断是否文件，如果存在的话则移除这个文件 代码块 2 的作用是恢复断点下载 首先获取到之前下载好的数据，这些数据会被保存在 /tmp/Incomplete 文件夹下面 获取这些数据，并进行验证。断点数据被保存时会被当做一个 plist 文件，包含了许多的 key 来记录下载信息，所以 YTK 使用 validateResumeData 方法来对这些数据进行验证 当断点数据存在并且有效时，使用 AFHTTPSessionManager 的实例方法 downloadTaskWithResumeData:progress:destination:completionHandler 方法来创建一个下载任务 到这里如果没有断点下载，则使用 AFHTTPSessionManager 的实例方法 downloadTaskWithRequest:progress:destination:completionHandler 方法重新创建一个下载任务 这个方法的作用是创建数据任务，流程大概就是： requestSerializer 生成 NSMutableURLRequest，需要注意的是如果有文件上传的话需要用另一个方法来初始化 request 使用 AFHTTPSessionManager 生成 NSURLSessionDataTask，具体实现还是自己翻 AFN 的代码吧 这个方法的作用是生成任务 task，添加到字典集合中强引用避免被销毁，开启任务 代码块 1 的作用是初始化 NSURLSessionTask 实例 如果我们使用了 -buildCustomUrlRequest 自定义了 NSURLRequest，那么将使用 AFHTTPSessionManager 的方法 dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler 来创建 NSURLSessionTask，你对 YTKBaseRequest 一些属性的设置都将失效 如果没有自定义 NSURLRequest，那么将使用 sessionTaskForRequest:error: 来创建 NSURLSessionTask，这个方法我们在上面已经讲过了 代码块 2 的作用是在创建 NSURLSessionTask 的过程中失败了，则直接执行失败回调 代码块 3 的作用是为 NSURLSessionTask 设置优先级，因为这个属性是 iOS8 之后才有的，所以先用 respondsToSelector: 方法判断了下 当 NSURLSessionTask 创建成功后，使用 -addRequestToRecord: 添加到字典集合 _requestsRecord， key/value 对应于 task.taskIdentifier/request 由于刚创建的 NSURLSessionTask 处于 suspend 暂停状态，所以需要使用 resume 方法来开启 该方法用来取消 request。 当 task 是下载任务时，且 YTKBaseRequest 的 resumableDownloadPath 属性不为 nil，取消任务会将已经下载好的数据保存在本地文件中，以便于下次下载时不重复下载。需要注意时，这些数据不只是你要下载的文件数据，而是一个 plist 文件，里面有许多键值对，例如 NSURLSessionDownloadURL，NSURLSessionResumeBytesReceived，NSURLSessionResumeCurrentRequest数据保存的文件路径是 /tmp/Incomplete/resumableDownloadPath，其中 resumableDownloadPath 部分是你自己设定的值 取消任务 task 之后，会将 task 从集合 _requestsRecord 中移除 该方法用来取消所有添加到集合中的任务，值得注意的是锁的使用，这里将锁作用在数据的添加和读取上 该方法用来验证 request 的响应结果，此时请求已经完成，且响应数据已经被序列化赋值给了 YTKBaseRequest 实例。 首先验证状态码，有效的状态码范围是 (200，299)，在这个范围内说明请求被服务器接收并处理。如果无效则返回 如果 YTKBaseRequest 的 responseJSONObject 属性和方法 -jsonValidator 返回值不为 nil，则需要验证 JSON，如果 JSON 中相应字段的值不为 nil，则验证成功; 如果失败则返回 代码块 1：当我们取消 task 后，底层的 AFN 会立刻调用失败回调，进而调用这个方法。为了防止这种情况，我们在这里做了一个判断，如果 request 为 nil 的时候立即返回 代码块 2：序列化响应结果，根据 responseSerializerType 属性的不同，将数据序列化成不同类型，比如 JSON Object，NSXMLParser。具体实现过程由 AFN 的响应序列化器实现 到这一步如果都没有出现 error，则调用方法 -validateResult:error: 验证响应结果，这个方法我们在上面已经讲过 如果验证成功，则调用 -requestDidSucceedWithRequest： 方法处理; 否则，调用 -requestDidFailWithRequest：error: 处理，这两个方法我们随后会讲到 无论验证成功还是失败，最后都要将 request 从集合 _requestsRecord 中移除，并清空自己的 successCompletionBlock、failureCompletionBlock、uploadProgressBlock 请求成功后的处理方法，会依次调用下面几个方法 requestCompletePreprocessor：如果使用 cache 的话是在主线程，否则的话在其它线程执行。下面的方法均在主线程执行 requestWillStop requestCompleteFilter requestFinished successCompletionBlock requestDidStop 请求失败的处理方法 代码块 1：如果此时有断点数据且 resumableDownloadPath 属性不为 nil，则将其保存在本地，用于下载任务 代码块 2：对于断点下载的任务，后面恢复下载的任务开启时，responseObject 的值会被赋予断点数据的文件路径。如果下载任务请求失败了，那么将把断点数据读取出来，然后把文件删除，不是很明白为什么把数据读取出来 代码块 3：执行一些失败的回调，执行顺序如下： requestFailedPreprocessor：如果使用 cache 的话是在主线程，否则的话在其它线程执行。下面的方法均在主线程执行 requestWillStop requestFailedFilter requestFailed failureCompletionBlock requestDidStop 总结YTKNetworkAgent 是 YTK 实现请求的类，它序列化了请求以及响应数据，并且实现了断点下载的功能。","link":"/2020/08/06/YTKNetwork-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E4%B8%89-%E4%B9%8B-YTKNetworkAgent/"},{"title":"YTKNetwork 源码解读 (二) 之 YTKRequest","text":"YTKCacheMetadata YTKCacheMetadata 表示缓存元数据，保存了跟缓存相关的一些信息，例如创建时间，创建时的版本号，app 版本号等。通过比较 YTKCacheMetadata，来判断本地缓存是否有效。如果无效的话则重新发起请求，有效的话则从本地缓存加载 reponse 数据 下面几种比较 YTKCacheMetadata 的情况会被认为本地无效： version 不匹配 sensitiveDataString 不匹配。不要被它的名字给误导了，其实它就相当于一个额外的一个标识符，自己可以设定，如果 sensitiveDataString 不相等说明不匹配 creationDate 取创建日期到现在的时间戳，如果超过了设定的缓存有效时间说明缓存无效 appVersionString 不匹配，app 版本号不匹配 还有一个属性 NSStringEncoding stringEncoding 用于将本地数据转换成字符串时使用。 另外 YTKCacheMetadata 还支持 NSSecureCoding 协议，协议里的方法就不讲了。 定义了一些跟缓存相关的一些状态码 YTKRequest YTKRequest 是 YTKBaseRequest 的子类，为 YTKBaseRequest 增加了缓存功能 response 数据是否保存到本地需要满足两个条件: 当前 response 不是来自于缓存，即 response 需要来自于 request 缓存有效时间 cacheTimeInSeconds 需要大于 0 -cacheVersion，-cacheSensitiveData 这两个标识符都是自己设定的。保存缓存时，也会将缓存元数据保存在本地，当需要加载缓存时，会先把缓存元数据取出来，比较 cacheVersion，cacheSensitiveData 这两个标识符跟当前的标识符是否相等，如果有不相等说明缓存无效 接下来是 YTKRequest.m 部分 两个宏 NSFoundationVersionNumber_iOS_8_0 和 NSFoundationVersionNumber_With_QoS_Available 用来处理系统在 iOS8 之前和之后两种情况，不过在 iOS11 之后，我们可以使用 if (@available(iOS 10, macOS 10.12, watchOS 3, tvOS 10, *)) 这个关键字来处理系统版本不同的问题 这里创建了一个串行队列，对于 iOS8 之后的系统，还指定了它的队列优先级为 QOS_CLASS_BACKGROUND。需要注意的是 QOS_CLASS_BACKGROUND 的优先级别是最低的，可能是因为不想占用太多系统资源吧。这个队列用来将 response 保存到本地文件中 上面几种不同类型的缓存对应 YTKResponseSerializerType 的类型 cacheData 和 cacheString 对应于 YTKResponseSerializerTypeHTTP cacheData 和 cacheJSON 对应于 YTKResponseSerializerTypeJSON cacheData 和 cacheXML 对应于 YTKResponseSerializerTypeXMLParser 因为 YTKRequest 是 YTKBaseRequest 的子类，在这里覆写了它的 start 方法。 有三种情况会导致不使用缓存数据： 设置 YTKRequest 的属性 ignoreCache 为 YES，这样会忽略缓存直接进行请求 如果当前任务是一个下载任务，此时不会对 response 结果进行缓存，自然也就不会有读取缓存这个过程 加载缓存时出现了问题。例如缓存元数据验证时出现问题，或者是读取缓存文件时出现的问题 如果加载缓存成功，会在主队列分发一个异步任务，用来执行请求完成后的一些方法，这些我们在讲 YTKBaseRequest 的时候提到过了需要注意的是下面这行代码 1YTKRequest *strongSelf = self; 这是为了防止执行异步任务的时候 self 突然被释放了。不过我的理解是，既然 GCD 已经强引用了 self，那么在 block 执行完毕之前，self 都是不会被释放掉的，所以这句代码貌似有点多余了 使用 -loadCacheWithError 方法来加载本地缓存，分这么几步： 判断是否设置了缓存有效时间，如果没有的话说明不使用缓存了，直接返回 加载缓存元数据，如果元数据不存在，说明缓存也不存在 验证缓存元数据，判断缓存是否有效 加载本地缓存 在这里，我们先讲一下第三步验证缓存元数据的方法，加载缓存元数据和加载缓存后面再讲 首先比较缓存的有效时间，因为缓存元数据中保存了缓存的创建日期，所以这里比较简单 比较缓存版本号，因为是 long long 类型，所以直接比较就可以 比较 sensitiveDataString 标识符，因为是字符串类型，所以需要使用 isEqualToString 方法比较。值得注意的是，对于符号 ||，当前面那个条件满足之后就不会再去比较后面那个条件了，所以我们写代码的时候可以把比较简单的判断条件放在前面，同理还有 &amp;&amp; 比较 app 版本号。这里我觉得只需要使用 dispatch_once 进行一次比较就可以了。如果变 app 版本号变更了，则清除缓存，后面就不再需要比较; 如果版本号没有变更，后面也不需要比较了 123456// 忽略缓存，开启请求- (void)startWithoutCache { // 清空跟缓存相关的属性 [self clearCacheVariables]; [super start];} 如果不使用缓存，则调用这个方法来开启任务。 清空跟缓存相关属性的值，需要注意的是，并不会清除本地的缓存文件(如果有) requestCompletePreprocessor 方法在得到请求结果后调用。由于 YTKRequest 覆写了父类 YTKBaseRequest 的 requestCompletePreprocessor 方法，所以首先需要调用父类的 requestCompletePreprocessor 方法。如果 YTKRequest 的 writeCacheAsynchronously 属性值为 YES，则表示在执行请求回调的线程(一般为主线程)，将请求结果保存在本地文件中; 如果值是 NO，则在私有的串行队列 ytkrequest_cache_writing_queue 添加一个异步任务来处理 saveResponseDataToCacheFile 方法的作用是将数据保存到本地。 检查数据是否是来自缓存，如果是的话则返回; 否则执行下一步 将数据保存到本地，文件名字根据接口名字、参数、请求方式来生成 生成一个 YTKCacheMetadata 实例，保存缓存元数据，然后使用归档的方式将其保存到本地中，其文件名字为 “缓存名字.metadata” 覆写这些方法，用来控制请求缓存的使用 cacheTimeInSeconds：缓存使用时间 cacheVersion：缓存版本，充当一个标记 cacheSensitiveData：也是一个标记 writeCacheAsynchronously：是否异步保存缓存 属性 _dataFromCache 用来标记此时的请求结果是否来自于缓存根据请求格式 responseSerializerType 的不同，缓存将被转换成的对象也不相同，所以这里有很多成员变量 _cacheData/_cacheXML/_cacheJSON/_cacheString 加载缓存元数据，使用归档加载，如果加载成功，则该方法返回 YES。这里需要注意的是 YTKLog 这个宏 展开来其实是一个 C 函数，参数是 format 和可变参数。方法的实现被包含在了一个 #ifdef/#endif 里面，这样做的好处是在正式版本环境 RELEASE 时，不会再打印 log，减少系统开销 这个方法的作用是加载本地缓存 首先判断缓存文件是否存在，存在的话则读取数据 data，随后根据属性 responseSerializerType 的值将 data 转换成不同格式的对象 清除跟缓存相关的几个属性，需要注意的是并没有主动的清除本地缓存 该方法用来创建文件夹，需要注意的是 createDirectoryAtPath:withIntermediateDirectories:attributes:error:，该方法可以用来创建中间目录。例如我们创建一个名字为 app/doc/user/info 的文件夹，而当前只存在 app 这个文件夹的话，使用该方法会帮我们创建好 doc，user，info 这几个文件夹 根据 path 来查找是否存在该文件夹，如果不存在的话则使用 createBaseDirectoryAtPath 来创建文件夹; 如果存在的话则判断是否是文件，如果是文件的话则移除该文件，然后使用 createBaseDirectoryAtPath 来创建文件夹 可以看到 createBaseDirectoryAtPath，createBaseDirectoryAtPath 两个方法的使用是为了确保生成指定名字的文件夹 该方法用来创建缓存存放的文件目录 默认的文件夹位置是 /Library/LazyRequestCache，但是我们可以使用 YTKNetworkConfig 的实例方法 addCacheDirPathFilter 来修改文件夹的名字在确定好文件夹名字之后，使用 createDirectoryIfNeeded 创建该文件夹 该方法用来确定缓存文件的名字 得到请求的 url， basicUrl，参数，然后拼接成一个字符串 requestInfo，随后使用 YTKNetworkUtils 的方法 md5StringFromString，从 requestInfo 中提取 md5，将其作为缓存文件的名字 得到了文件夹名字和文件名字，我们就可以将其拼接成缓存文件的路径啦 总结YTKRequest 作为 YTKBaseRequest 的子类，为其添加了缓存这个功能。在我们的使用中自定义的 request 子类也是需要直接继承与 YTKRequest 的","link":"/2020/08/03/YTKNetwork-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E4%BA%8C-%E4%B9%8B-YTKRequest/"},{"title":"YTKNetwork 源码解读 (四) 之 YTKBatchRequest 和 YTKChainRequest","text":"这篇是 YTKNetwork 源码阅读的最后一篇，主要讲解的是 YTKBaseRequest(批量请求)，YTKChainRequest(链式请求) 两个部分。 YTKBatchRequestYTKBatchRequest 用于完成批量请求的任务。当初始化时，需要指定 YTKBatchRequest 的数目，后续无法再添加新的请求。随后按添加顺序依次发起请求，当其中的一个请求失败时判定为 YTKBatchRequest 请求失败，同时 cancel 其它正在执行的请求 协议，用于 YTKBatchRequest 请求失败或者成功的回调 这些是 YTKBatchRequest 的属性，大部分看注释就能理解了。 需要注意的是： 代理的执行顺序在 block 之前 tag 需要自己手动赋值来区分 YTKBatchRequest，默认值都是 0 初始化方法，在这里你需要指定 YTKRequest 数组。个人觉得最好将其它默认的初始化方法给禁用掉 设置 YTKBatchRequest 请求成功和失败的回调，当请求结束后，会调用 -clearCompletionBlock 将 block 置为 nil YTKRequestAccessory 协议用于执行请求不同阶段的回调 请求的开启和取消 请求的数据是否来自于缓存。所有请求中，如果有一个请求的数据来自于缓存，那么这个方法就会返回 YES 初始化方法，将参数 requestArray 赋值给属性 _requestArray，并且会判断里面的元素是否是 YTKRequest 实例，如果不是的话会返回。初始化内部属性 finishedCount，该属性表示已完成请求的数目 方法开头会判断属性 finishedCount 的值是否大于 0，如果 0 的话则返回。这说明当 YTKBatchRequest 实例创建只能调用 start 方法一次，再次调用的话可能会出现重复开启任务的问题，这里个人还是觉得要进行下判断比较好。将 YTKRequest 的 delegate 设置为自己，同时清空 YTKRequest 的 block 回调，以确保只有 YTKBatchRequest 处理请求完成后的回调，最后开启请求 触发即将停止回调 toggleAccessoriesWillStopCallBack，并调用 clearRequest 方法循环将 YTKRequest 进行停止操作，随后将自己从 YTKBatchRequestAgent 中移除。 循环调用 YTKRequest 的 stop 方法 设置 YTKBatchRequest 的完成回调，当所有请求都成功调用或者其中一个失败时使用 可以看到，只要一个请求的数据来自于缓存，那么方法的返回结果就是 NO 当请求成功后，YTKBatchRequest 在这个方法里面处理数据。 _finishedCount 的值 +1 如果 _finishedCount 的值等于请求的个数，说明所有的请求都已请求成功，这种情况表示 YTKBatchRequest 请求成功，执行相应的回调 YTKBatchRequest 在这个方法里面处理请求失败的情况。一个请求失败意味着 YTKBatchRequest 的失败，所以也不用接着处理那些完成的请求。在这里会循环取消 YTKRequest 请求接着执行失败回调，并将自己从 YTKBatchRequestAgent 移除。 YTKBatchRequestAgent 是一个单例，作用是强引用 YTKBatchRequest，避免被销毁。当任务执行完毕后，将 YTKBatchRequest 移除 小总结YTKBatchRequest 是一个批量执行请求的类，能够批量执行 YTKRequest 类型的请求。请求的开启顺序按照任务的添加顺序执行，单个 YTKRequest 完成后，不会执行 YTKRequest 自己的回调 block，代理等回调方法。当所有请求成功后，执行 YTKBatchRequest 的代理回调，回调 block; 否则执行 YTKBatchRequest 的失败回调 YTKChainRequestYTKChainRequest 也是批量处理请求的类，只不过是当前面的请求完成后再执行下一个请求。 YTKChainRequest 完成的回调。可以看到在失败回调中多了一个参数 failedBaseRequest 比较简单，看注释就好了。id&lt;YTKRequestAccessory&gt; 是实现了协议 YTKRequestAccessory 的实例，这个协议里面有请求各种状态的方法，例如将要发起请求，将要结束请求 通过该方法向 YTKChainRequest 里面添加请求，同时设定该请求的完成回调。我们知道 YTKBaseRequest 可以通过设定属性来设置完成回调，但这里为什么还需要这个方法来设定呢？通过属性设定的回调是否会触发呢？这些在后面会讲到的 一些内部用到的属性 requestArray：请求数组 requestCallbackArray：请求完成回调数组，有的请求没有设定回调，那么会往数组里面添加一个什么都不做的空回调 nextRequestIndex：下一个执行的请求的序号 emptyCallback：空回调 初始化实例，可以看到 _emptyCallback 其实是一个不执行任何操作的 block 开启任务后，通过 startNextRequest 方法开启第一个请求，并将 YTKChainRequest 添加到单例 YTKChainRequestAgent 中，防止被销毁 该方法用来开启下一个未执行的请求。_nextRequestIndex 表示该请求在数组中的位置，如果超出了数组范围则返回。通过 _nextRequestIndex 得到该请求，随后将 delegate 设置为自己，并清除其完成回调，随后开启请求，返回 YES; 否则返回 NO 取消 YTKChainRequest，并将 YTKChainRequest 从单例 YTKChainRequestAgent 中移除。通过调用 clearRequest 方法取消当前的请求 获取到当前的 YTKBaseRequest，由于 _nextRequestIndex 表示下一个未执行的请求位置，所以这里要 -1。清空 _requestArray 和 _requestCallbackArray 这两个数组 添加请求及其完成回调。在 startNextRequest 方法中，我们知道，开启单个任务 YTKBaseRequest 之前，会将 YTKBaseRequest 的 delegate 设置为自己，并清除其回调 block。所以，这里我们需要通过 _requestCallbackArray 这种方式来额外添加回调需要注意的是该回调仅在请求成功时被调用 这里是 YTKBaseRequest 的代理方法，当请求成功后调用。从 _requestCallbackArray 数组中获取该请求的完成回调。当所有的请求都获取成功后，执行 YTKChainRequestAgent 的完成回调 这里是 YTKBaseRequest 的代理方法，当请求失败后调用。需要注意的是，当单个 YTKBaseRequest 请求失败，判断 YTKChainRequestAgent 请求失败，执行其完成回调如果你想执行 YTKBaseRequest 的失败回调，你可以在代理方法 chainRequestFailed:failedBaseRequest: 中，通过 YTKBaseRequest 得到响应数据，随后执行后续操作 小总结YTKChainRequest 是一个批量同步执行请求的类，能够批量执行 YTKBaseRequest 类型的请求。你可以自定义 YTKChainRequest 的实例方法添加 YTKBaseRequest 和 成功回调。 不同于 YTKBatchRequest，YTKChainRequest 中可添加的 request 类型是 YTKBaseRequest 而不是 YTKRequest","link":"/2020/08/12/YTKNetwork-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E5%9B%9B-%E4%B9%8B-YTKBatchRequest-%E5%92%8C-YTKChainRequest/"},{"title":"YYModel实现原理","text":"其实很早开始就想写这个了，因为自己一直在用这个库，而且它的代码量也比较少，另外作者ibireme写的代码质量很高。为了提高自己，拜读大神写的库是一个很好的方式。本文将从头开始分析代码，所以文字可能会比较多。 YYClassMethodInfo这个类保存了 Method 的信息(其实后面好像也没怎么用到。。。)。 该类的属性及描述如下： 属性名字 描述 Method method 对应的Method NSString *name 方法的名字 SEL sel 方法选择器 IMP imp 方法实现 NSString *typeEncoding 参数及返回值类型的编码 NSString *returnTypeEncoding 返回值类型的编码 NSArray&lt;NSString *&gt; *argumentTypeEncodings 参数类型的编码 想更多的了解类型编码可以去看Type Encodings这篇博客，主要是runtime加快消息的分发你可以使用@encode将相应类型转换成内部表示的字符串，当然也有一大部分内部使用的类型编码无法用@encode()返回。 YYClassPropertyInfo这个类保存了 Property 信息，主要用到等有setter和getter方法，成员变量名称，编码方式(很重要，根据这个来确定属性类型以及其它修饰符)。该类的属性及描述如下： 属性名字 描述 objc_property_t property 对应的Property NSString *name 名字 YYEncodingType type 类型编码的类型 NSString *typeEncoding 类型编码 NSString *ivarName 成员变量名称，加了个_前缀 Class cls 属性类型 NSArray&lt;NSString *&gt; *protocols 被包含着的协议，可能为空 SEL getter getter方法，不能为空 SEL setter setter方法，不能为空 属性转换成YYClassPropertyInfo的过程比较麻烦，比较复杂的地方在于需要通过解析属性的类型编码，来确定 YYClassPropertyInfo 的YYEncodingType type属性。 YYEncodingType 主要包含了以下几方面的信息： YYEncodingTypeMask： 属性值的类型，例如c的基本数据类型，结构体，id类型，class类型 YYEncodingTypeQualifierMask：不知道怎么形容这个，在Type Encodings这篇博客里面说是内部使用的类型编码。例如：const，in，out YYEncodingTypePropertyMask：属性关键词，例如：strong， weak， readonly YYClassIvarInfo这个类保存了 Ivar 的信息。貌似不会用到，这里就不展开讲了。 YYClassInfo每一个类(包括元类)都有一个对应的 YYClassInfo 实例。非元类对应的实例创建之后会被保存在一个静态字典缓存 classCache 中，元类对应的实例保存在另一个静态字典缓存 metaCache 中，以Class -&gt; YYClassInfo的映射关系保存在缓存中。如果缓存中没有，则重新创建一个。创建时，首先会通过 runtime 的方法得到父类，是否是元类，元类，名字等基本信息，然后按顺序分别将它所有的的 Method，Property，Ivar 生成对应的 YYClassMethodInfo，YYClassPropertyInfo，YYClassIvarInfo实例，添加到 YYClassInfo 中。创建完成之后开始创建父类的 YYClassInfo 实例，一直到根类。 YYClassInfo 保存了 Class 的绝大部分信息，但是 objc 是一门动态的语言，可以在运行时添加方法，属性等信息，这也意味着 YYClassInfo 里面保存的信息可能不是最新的。所以当你对 Class 做了一些修改之后，你需要先获得该 Class 对应的 YYClassInfo实例，然后手动调用- (void)setNeedUpdate;来刷新保存在缓存中的 info 信息。 属性名称 描述 Class cls 对应类 Class superCls 对应类的父类 Class metaCls 对应类的元类 BOOL isMeta 对应类是否是元类 NSString *name 类名 YYClassInfo *superClassInfo 父类对应的 YYClassInfo 实例 NSDictionary&lt;NSString *, YYClassIvarInfo *&gt; *ivarInfos 所有成员变量信息 NSDictionary&lt;NSString *, YYClassMethodInfo *&gt; *methodInfos 所有方法信息 NSDictionary&lt;NSString *, YYClassPropertyInfo *&gt; *propertyInfos 所有属性信息 YYModel协议如果默认的模型转换不能满足你的需求，那么你可以通过实现 YYModel 协议中的方法达到自定义键值转化的过程。下面，简单介绍一下它的几个方法： + (nullable NSDictionary&lt;NSString *, id&gt; *)modelCustomPropertyMapper; 实现这个方法，你可以自定义mode property -&gt; json key之间的映射关系，你可以定义一个属性映射多个 key。举个注释中的例子： 1234567891011121314151617181920212223242526json: { &quot;n&quot;:&quot;Harry Pottery&quot;, &quot;p&quot;: 256, &quot;ext&quot; : { &quot;desc&quot; : &quot;A book written by J.K.Rowling.&quot; }, &quot;ID&quot; : 100010 } model: @interface YYBook : NSObject &lt;YYModel&gt; @property NSString *name; @property NSInteger page; @property NSString *desc; @property NSString *bookID; @end @implementation YYBook + (NSDictionary *)modelCustomPropertyMapper { return @{@&quot;name&quot; : @&quot;n&quot;, @&quot;page&quot; : @&quot;p&quot;, @&quot;desc&quot; : @&quot;ext.desc&quot;, @&quot;bookID&quot;: @[@&quot;id&quot;, @&quot;ID&quot;, @&quot;book_id&quot;]}; } @end 在上面的那个例子中，实现该方法后，字典中 n 对应于属性 name，p 对应于属性 page。。。 + (nullable NSDictionary&lt;NSString *, id&gt; *)modelContainerPropertyGenericClass; 实现该方法，你可以自定义容器类属性的泛型。例如 NSArray 和 NSDictionary 类的属性，你可以通过该方法你定义它们的元素(数组) value(字典)的类型 + (nullable Class)modelCustomClassForDictionary:(NSDictionary *)dictionary; 通过该方法，你可以自定义 json/字典 在不同的情况转化成不同 Class 的实例。 1234567891011121314151617@class YYCircle, YYRectangle, YYLine; @implementation YYShape+ (Class)modelCustomClassForDictionary:(NSDictionary*)dictionary { if (dictionary[@&quot;radius&quot;] != nil) { return [YYCircle class]; } else if (dictionary[@&quot;width&quot;] != nil) { return [YYRectangle class]; } else if (dictionary[@&quot;y2&quot;] != nil) { return [YYLine class]; } else { return [self class]; }}@end + (nullable NSArray&lt;NSString *&gt; *)modelPropertyBlacklist; 黑名单，数组中的元素代表的是属性的名字。如果这个方法实现了，那么数组中的属性则不会被赋值。 + (nullable NSArray&lt;NSString *&gt; *)modelPropertyWhitelist; 白名单，数组的元素代表的是属性的名字。如果这个方法实现，那么不在这个数组中的属性不会被赋值 - (NSDictionary *)modelCustomWillTransformFromDictionary:(NSDictionary *)dic; 在数据模型转换之前，对json字典进行修改。如果实现了这个方法，那么将使用修改后的字典进行mode转换 - (BOOL)modelCustomTransformFromDictionary:(NSDictionary *)dic; 如果你想自定义数据模型转换，那么你可以实现这个方法。在这个方法里你可以生成 mode 的实例，并根据 dic 对实例的属性赋值，记得创建成功后返回 YES - (BOOL)modelCustomTransformToDictionary:(NSMutableDictionary *)dic; fixme 不知道干嘛 _YYModelMeta这是一个内部类，它主要用来保存类的信息，每一个类都有一个对应的 _YYModelMeta 实例。创建好的实例会被保存在一个静态字典缓存中 cache，以clss -&gt; _YYModelMeta的映射关系存储。如果缓存中没有该实例，则重新创建一个。看到这你是不是会觉得很像之前提到的YYClassInfo？简单点说，YYClassInfo 全盘记录了 class 的信息，_YYModelMeta 是对这些信息进行了加工整理。 下面是 _YYModelMeta 的构造函数，代码比较多，可以直接跳到后面看分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150- (instancetype)initWithClass:(Class)cls { YYClassInfo *classInfo = [YYClassInfo classInfoWithClass:cls]; if (!classInfo) return nil; self = [super init]; // 得到自定义黑名单 NSSet *blacklist = nil; if ([cls respondsToSelector:@selector(modelPropertyBlacklist)]) { NSArray *properties = [(id&lt;YYModel&gt;)cls modelPropertyBlacklist]; if (properties) { blacklist = [NSSet setWithArray:properties]; } } // 得到自定义白名单 NSSet *whitelist = nil; if ([cls respondsToSelector:@selector(modelPropertyWhitelist)]) { NSArray *properties = [(id&lt;YYModel&gt;)cls modelPropertyWhitelist]; if (properties) { whitelist = [NSSet setWithArray:properties]; } } // 自定义容器类属性的泛型 NSDictionary *genericMapper = nil; if ([cls respondsToSelector:@selector(modelContainerPropertyGenericClass)]) { genericMapper = [(id&lt;YYModel&gt;)cls modelContainerPropertyGenericClass]; if (genericMapper) { NSMutableDictionary *tmp = [NSMutableDictionary new]; [genericMapper enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) { if (![key isKindOfClass:[NSString class]]) return; Class meta = object_getClass(obj); if (!meta) return; if (class_isMetaClass(meta)) { tmp[key] = obj; } else if ([obj isKindOfClass:[NSString class]]) { Class cls = NSClassFromString(obj); if (cls) { tmp[key] = cls; } } }]; genericMapper = tmp; } } // 创建所有的元属性（不包括根类NSObject和NSProxy等属性） NSMutableDictionary *allPropertyMetas = [NSMutableDictionary new]; YYClassInfo *curClassInfo = classInfo; while (curClassInfo &amp;&amp; curClassInfo.superCls != nil) { // recursive parse super class, but ignore root class (NSObject/NSProxy) for (YYClassPropertyInfo *propertyInfo in curClassInfo.propertyInfos.allValues) { if (!propertyInfo.name) continue; if (blacklist &amp;&amp; [blacklist containsObject:propertyInfo.name]) continue; if (whitelist &amp;&amp; ![whitelist containsObject:propertyInfo.name]) continue; _YYModelPropertyMeta *meta = [_YYModelPropertyMeta metaWithClassInfo:classInfo propertyInfo:propertyInfo generic:genericMapper[propertyInfo.name]]; if (!meta || !meta-&gt;_name) continue; if (!meta-&gt;_getter || !meta-&gt;_setter) continue; if (allPropertyMetas[meta-&gt;_name]) continue; allPropertyMetas[meta-&gt;_name] = meta; } curClassInfo = curClassInfo.superClassInfo; } if (allPropertyMetas.count) _allPropertyMetas = allPropertyMetas.allValues.copy; NSMutableDictionary *mapper = [NSMutableDictionary new]; NSMutableArray *keyPathPropertyMetas = [NSMutableArray new]; NSMutableArray *multiKeysPropertyMetas = [NSMutableArray new]; // 得到自定义数据字典key到mode属性之间的映射关系 if ([cls respondsToSelector:@selector(modelCustomPropertyMapper)]) { NSDictionary *customMapper = [(id &lt;YYModel&gt;)cls modelCustomPropertyMapper]; [customMapper enumerateKeysAndObjectsUsingBlock:^(NSString *propertyName, NSString *mappedToKey, BOOL *stop) { _YYModelPropertyMeta *propertyMeta = allPropertyMetas[propertyName]; if (!propertyMeta) return; [allPropertyMetas removeObjectForKey:propertyName]; if ([mappedToKey isKindOfClass:[NSString class]]) { if (mappedToKey.length == 0) return; propertyMeta-&gt;_mappedToKey = mappedToKey; NSArray *keyPath = [mappedToKey componentsSeparatedByString:@&quot;.&quot;]; for (NSString *onePath in keyPath) { if (onePath.length == 0) { NSMutableArray *tmp = keyPath.mutableCopy; [tmp removeObject:@&quot;&quot;]; keyPath = tmp; break; } } if (keyPath.count &gt; 1) { propertyMeta-&gt;_mappedToKeyPath = keyPath; [keyPathPropertyMetas addObject:propertyMeta]; } propertyMeta-&gt;_next = mapper[mappedToKey] ?: nil; mapper[mappedToKey] = propertyMeta; } else if ([mappedToKey isKindOfClass:[NSArray class]]) { NSMutableArray *mappedToKeyArray = [NSMutableArray new]; for (NSString *oneKey in ((NSArray *)mappedToKey)) { if (![oneKey isKindOfClass:[NSString class]]) continue; if (oneKey.length == 0) continue; NSArray *keyPath = [oneKey componentsSeparatedByString:@&quot;.&quot;]; if (keyPath.count &gt; 1) { [mappedToKeyArray addObject:keyPath]; } else { [mappedToKeyArray addObject:oneKey]; } if (!propertyMeta-&gt;_mappedToKey) { propertyMeta-&gt;_mappedToKey = oneKey; propertyMeta-&gt;_mappedToKeyPath = keyPath.count &gt; 1 ? keyPath : nil; } } if (!propertyMeta-&gt;_mappedToKey) return; propertyMeta-&gt;_mappedToKeyArray = mappedToKeyArray; [multiKeysPropertyMetas addObject:propertyMeta]; propertyMeta-&gt;_next = mapper[mappedToKey] ?: nil; mapper[mappedToKey] = propertyMeta; } }]; } // 对所有的元属性数据进行整理 [allPropertyMetas enumerateKeysAndObjectsUsingBlock:^(NSString *name, _YYModelPropertyMeta *propertyMeta, BOOL *stop) { propertyMeta-&gt;_mappedToKey = name; propertyMeta-&gt;_next = mapper[name] ?: nil; mapper[name] = propertyMeta; }]; // 将整理好的数据赋值给属性 if (mapper.count) _mapper = mapper; if (keyPathPropertyMetas) _keyPathPropertyMetas = keyPathPropertyMetas; if (multiKeysPropertyMetas) _multiKeysPropertyMetas = multiKeysPropertyMetas; _classInfo = classInfo; _keyMappedCount = _allPropertyMetas.count; _nsType = YYClassGetNSType(cls); _hasCustomWillTransformFromDictionary = ([cls instancesRespondToSelector:@selector(modelCustomWillTransformFromDictionary:)]); _hasCustomTransformFromDictionary = ([cls instancesRespondToSelector:@selector(modelCustomTransformFromDictionary:)]); _hasCustomTransformToDictionary = ([cls instancesRespondToSelector:@selector(modelCustomTransformToDictionary:)]); _hasCustomClassFromDictionary = ([cls respondsToSelector:@selector(modelCustomClassForDictionary:)]); return self;} 创建一个 YYClassInfo 的实例 classInfo 如果实现了协议的方法modelPropertyBlacklist，则得到黑名单列表 blacklist 如果实现了协议的方法modelPropertyWhitelist，则得到白名单列表 whitelist 如果实现了协议的方法modelContainerPropertyGenericClass，则得到容器类的泛型 genericMapper，映射关系为property -&gt; class 创建该类以及父类(不包括根类)所有的元属性 _YYModelPropertyMeta 遍历第一步中得到的 classInfo 的 propertyInfos 属性 如果 blacklist 不为空，并且该属性的名字在里面，则 continue 如果 whitelist 不为空，且该属性的名字不在里面，则 continue 创建 _YYModelPropertyMeta 实例 meta，将 YYClassPropertyInfo 信息赋值给 meta，并添加到字典 allPropertyMetas 中，映射关系为property name -&gt;_YYModelPropertyMeta 创建字典 mapper，其映射关系为mappedToKey -&gt; _YYModelPropertyMeta，mappedToKey 即json字典中的key。 如果实现了协议的方法modelCustomPropertyMapper，得到字典 customMapper，映射关系property name -&gt; json key。为了方便我们把 key 叫做 propertyName， value 叫做 mappedToKey 遍历 customMapper。根据 propertyName 在 allPropertyMetas 中找到对应的 _YYModelPropertyMeta 实例 meta，如果 meta 不为空，则将其移出 allPropertyMetas 如果 mappedToKey 是字符串类型，则将其赋值给 meta 的 _mappedToKey 属性。如果 mappedToKey 的格式使用的 keyPath(类似 @”json.key”)，则将该 mappedToKey 使用 @”.” 分割，将分割后等数组赋值给 mata 的 _mappedToKeyPath 属性，并且将 meta 添加到 keyPathPropertyMetas 数组。最后以mappedToKey -&gt; meta的映射将其添加到字典 mapper 中， 如果 mappedToKey 是数组类型，则说明一个属性可能映射了多个json字典的key。此时需要遍历 mappedToKey，它的每一个元素为 oneKey，使用@”.”分割，来判断是否使用了keyPath，分割后得到数组 keyPath。如果 keyPath 的 count 大于1，则将数组 keyPath 添加到 mappedToKeyArray 数组，如果不是则将 oneKey 添加到 mappedToKeyArray，meta 的 _mappedToKey 取值于遍历时第一个 oneKey。当遍历结束，将 mappedToKeyArray 赋值给 meta 的 mappedToKeyArray。最后以mappedToKey -&gt; meta的映射关系将其添加到字典 mapper，将 meta 添加到数组 multiKeysPropertyMetas 中 遍历第五步中的 allPropertyMetas，为了方便我们将字典中的 key 称为 key，value 称为 meta。 将 key 赋值给对应 meta 的 _mappedToKey，并且以property name -&gt; meta的映射添加到 mapper 当一个json字典的key对应着多个属性时，你可以使用 _YYModelPropertyMeta 的 _next来处理 fixme 最后是为 _YYModelMeta 其它一些属性赋值 从这个函数中我们可以看出，_YYModelMeta 处理了好几种情况下的数据模型转换问题 当自定义了映射关系，一个属性对应多个 key 时，使用 _multiKeysPropertyMetas 来处理 当自定义了映射关系，一个 key 对应多个属性时，使用 _YYModelPropertyMeta 的 _next 来处理 _mapper 中包含了 key 跟 属性之间的映射关系 默认情况下，key 即为属性名，此时使用 _allPropertyMetas 来处理 通过一些bool值来表明 Class 实现了 》的哪几个方法 通过下图的_YYModelPropertyMeta的属性说明，能帮助更好的理解这一点 属性 说明 _classInfo 对应YYClassInfo实例 _mapper 字典，映射关系：json字典key -&gt; 属性。如果一个key对应多个属性时，_mapper数量会小于属性数量 _allPropertyMetas 所有的_YYModelPropertyMeta实例数组 _keyPathPropertyMetas 使用了keyPath映射的_YYModelPropertyMeta实例数组 _multiKeysPropertyMetas 被多个key映射的_YYModelPropertyMeta实例数组 _keyMappedCount 等同于_mapper的count _nsType 是 Founddation 的什么类，可能不是 _hasCustomWillTransformFromDictionary 是否实现了协议方法modelCustomWillTransformFromDictionary _hasCustomTransformFromDictionary 是否实现了协议方法modelCustomTransformFromDictionary _hasCustomTransformToDictionary 是否实现了协议方法modelCustomTransformToDictionary _hasCustomClassFromDictionary 是否实现了协议方法modelCustomClassForDictionary 数据模型转换通过 _YYModelMeta 生成实例的 modelMeta ，我们可以知道json字典跟属性之间的对应关系。所以，接下来要做的就是数据模型之间转换了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (BOOL)yy_modelSetWithDictionary:(NSDictionary *)dic { if (!dic || dic == (id)kCFNull) return NO; if (![dic isKindOfClass:[NSDictionary class]]) return NO; _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)]; if (modelMeta-&gt;_keyMappedCount == 0) return NO; if (modelMeta-&gt;_hasCustomWillTransformFromDictionary) { dic = [((id&lt;YYModel&gt;)self) modelCustomWillTransformFromDictionary:dic]; if (![dic isKindOfClass:[NSDictionary class]]) return NO; } ModelSetContext context = {0}; context.modelMeta = (__bridge void *)(modelMeta); context.model = (__bridge void *)(self); context.dictionary = (__bridge void *)(dic); if (modelMeta-&gt;_keyMappedCount &gt;= CFDictionaryGetCount((CFDictionaryRef)dic)) { CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &amp;context); if (modelMeta-&gt;_keyPathPropertyMetas) { CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas, CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas)), ModelSetWithPropertyMetaArrayFunction, &amp;context); } if (modelMeta-&gt;_multiKeysPropertyMetas) { CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas, CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas)), ModelSetWithPropertyMetaArrayFunction, &amp;context); } } else { CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_allPropertyMetas, CFRangeMake(0, modelMeta-&gt;_keyMappedCount), ModelSetWithPropertyMetaArrayFunction, &amp;context); } if (modelMeta-&gt;_hasCustomTransformFromDictionary) { return [((id&lt;YYModel&gt;)self) modelCustomTransformFromDictionary:dic]; } return YES;} 首先根据 modelMeta 的 _hasCustomClassFromDictionary 来判断是否自定义了mode的类型，如果是，则获得自定的 mode 类型cls，并根据cls得到对应的 _YYModelMeta 实例 modelMeta。根据 modelMeta 的 _hasCustomWillTransformFromDictionary 来判断是否在转换前json字典进行修改，如果修改了则使用修改后的字典来转换mode。随后生成一个结构体 context，用来存储转换时要用到的信息。 比较 modelMeta 的 _keyMappedCount 与 json字典的 count 之间的大小 _keyMappedCount 大于等于字典的 count，则首先遍历字典，对里面的键值对调用ModelSetWithDictionaryFunction方法。如果 modelMeta 的 _keyPathPropertyMetas 和 _multiKeysPropertyMetas 不为空，则对里面的每个元素调用ModelSetWithPropertyMetaArrayFunction方法 _keyMappedCount 小于字典的 count，则对 _allPropertyMetas 里面的每个元素调用ModelSetWithPropertyMetaArrayFunction方法 (应该是哪个少遍历哪个，减少开销。。。) 首先让我们看一下上面提到的第一个方法ModelSetWithDictionaryFunction 123456789101112static void ModelSetWithDictionaryFunction(const void *_key, const void *_value, void *_context) { ModelSetContext *context = _context; __unsafe_unretained _YYModelMeta *meta = (__bridge _YYModelMeta *)(context-&gt;modelMeta); __unsafe_unretained _YYModelPropertyMeta *propertyMeta = [meta-&gt;_mapper objectForKey:(__bridge id)(_key)]; __unsafe_unretained id model = (__bridge id)(context-&gt;model); while (propertyMeta) { if (propertyMeta-&gt;_setter) { ModelSetValueForProperty(model, (__bridge __unsafe_unretained id)_value, propertyMeta); } propertyMeta = propertyMeta-&gt;_next; };} 这个方法比较简单，根据 key 在 meta 的 _mapper 中找到相应的 _YYModelPropertyMeta 实例，随后调用ModelSetValueForProperty方法为该属性赋值，这个方法稍后再提。因为存在一个 key 对应多个 属性的情况，所以对该属性赋值后，会沿着 _next 继续为其它对应的属性赋值。 然后再看一下第二个方法ModelSetWithPropertyMetaArrayFunction 1234567891011121314151617181920static void ModelSetWithPropertyMetaArrayFunction(const void *_propertyMeta, void *_context) { ModelSetContext *context = _context; __unsafe_unretained NSDictionary *dictionary = (__bridge NSDictionary *)(context-&gt;dictionary); __unsafe_unretained _YYModelPropertyMeta *propertyMeta = (__bridge _YYModelPropertyMeta *)(_propertyMeta); if (!propertyMeta-&gt;_setter) return; id value = nil; if (propertyMeta-&gt;_mappedToKeyArray) { value = YYValueForMultiKeys(dictionary, propertyMeta-&gt;_mappedToKeyArray); } else if (propertyMeta-&gt;_mappedToKeyPath) { value = YYValueForKeyPath(dictionary, propertyMeta-&gt;_mappedToKeyPath); } else { value = [dictionary objectForKey:propertyMeta-&gt;_mappedToKey]; } if (value) { __unsafe_unretained id model = (__bridge id)(context-&gt;model); ModelSetValueForProperty(model, value, propertyMeta); }} 这个方法里主要做了这么几件事情： 找到json字典中的数据 调用ModelSetValueForProperty方法将数据赋值给属性，是的，又是这个方法 如何取值当调用 ModelSetWithPropertyMetaArrayFunction 方法时，传入了上下文 context(里面包含了我们要用到的json字典context-&gt;dictionary)和元属性_YYModelPropertyMeta *propertyMeta。接下来就是分不同的情况来取值了： 如果有多个key对应同一个属性时，那么会取第一个key且相应json字典中value不为空时的value。例如，有一个json @{@”name” : @”11”, @”title” : @”222”}, 如果有 @”age”, @”name”, @”title” 这几个 key 对应同一个属性 name，那么只会取json中 @”name” 对应的值 如果使用了 keyPath 来定义属性的映射，那么在json字典中会逐级获取数据(不知道怎么表达了。。。)，例如有一个json @{@”info” : @{@”name” : @”111”}}, 并且使用@”info.name”来映射属性，那么首先会取得 @”info”对应的字典 dic，然后再在dic中取得@”name”的值 如果没有上述两种情况，则直接根据key在json字典中取值 好了，是不是看了感觉还挺简单的，复杂的其实在赋值这一步！ 如何赋值赋值的过程比较复杂，且代码量比较多, 这里就不贴出来了。在这里我简单的分析一下过程： 首先属性是基本数据类型 12345if (meta-&gt;_isCNumber) { NSNumber *num = YYNSNumberCreateFromID(value); ModelSetNumberToProperty(model, num, meta); if (num) [num class]; // hold the number} 这个比较简单。首先将从json字典得到的value进行处理，得到一个 NSNumber 类型的数据 num。然后将 num 转换成相应类型的数据，通过objc_msgSend消息发送赋值给该属性。由于在赋值的函数中参数的类型是__unsafe_unretained(类似weak)，所以需要在赋值成功前持有该数据，否则程序会因为 num 成为野指针而崩溃，所以在ModelSetNumberToProperty后面还有这样一行代码if (num) [num class];，看似没用，其实还是有点用的。如果你想对__unsafe_unretained了解深一点可以看孙源的这篇博客 然后时属性属于 Foundation 类型时，会先将 value 转换成属性的类型meta-&gt;_nsType，然后通过objc_msgSend赋值给属性。当属性属于数组（NSArray, NSMutableArray）和字典（NSDictionary, NSMutableDictionary）时复杂一点： 数组 如果没有指定泛型，那么直接把value复制给属性 会遍历数组value，将元素转换成相应的泛型，然后添加到一个新数组value中，最后将该value赋值给属性 字典 如果没有指定泛型，那么直接把value复制给属性 会遍历字典values，将value转化成相应的泛型，添加到一个新字典vlues中。最后将该values赋值给属性 属性属于其它的类型，例如自定义的 objc 类，block，c的结构体，联合，数组等，转换过程跟之前也是差不多的。 总结写了好几天，终于完成了。希望大家看完后对这个库的使用能够有所帮助。在这里可算是帮我解决了个疑问：在自定义mode中就算为容器类指定了泛型，但转换的时候还是会失败, 原因是我们不能在类型编码中得到泛型的信息… 引用：YYModel","link":"/2019/07/30/YYModel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"title":"iOS EventKit日历提醒","text":"EKEventStore EKEventStore用于应用访问日历或者提醒事件，在iOS中，创建好实例之后，必须使用requestAccessToEntityType：completion：方法访问实体类型。 与一个EKEventStore实例相关联的事件，提醒，日历数据无法在另一个EKEventStore实例中使用，所以你最好创建一个常驻的实例，例如创建一个单例。 在iOS10.0或者之后的版本，你必须在info.plist文件中添加权限请求，否则应用将会崩溃。提醒和日历分别是NSRemindersUsageDescription和NSCalendarsUsageDescription。 在macOS中，使用initWithAccessToEntityTypes:代替默认初始化方法，可以接受的实体类型是EKEntityMaskEvent和EKEntityMaskReminder 12345678910111213// 创建实例EKEventStore *eventStore = [[EKEventStore alloc] init];self.eventStore = eventStore;// 获取数据[self.eventStore requestAccessToEntityType:EKEntityTypeEvent completion:^(BOOL granted, NSError * _Nullable error) { if (granted) { NSLog(@&quot;授权通过&quot;); // 下一步操作... } else { NSLog(@&quot;授权没有通过&quot;); }}]; 获取授权状态12345678910111213141516171819202122232425262728293031// 获取授权状态EKAuthorizationStatus eventStatus = [EKEventStore authorizationStatusForEntityType:EKEntityTypeEvent];switch (eventStatus) { case EKAuthorizationStatusNotDetermined:// 未进行选择 { // 弹框 提示授权 @weakify(self) [self.eventStore requestAccessToEntityType:EKEntityTypeEvent completion:^(BOOL granted, NSError * _Nullable error) { @strongify(self) if (granted) { NSLog(@&quot;授权通过&quot;); // 下一步操作... } else { NSLog(@&quot;授权没有通过&quot;); } }]; }break; case EKAuthorizationStatusRestricted:// 未授权 { NSLog(@&quot;未授权&quot;); }break; case EKAuthorizationStatusDenied:// 拒绝 { NSLog(@&quot;拒绝&quot;); }break; case EKAuthorizationStatusAuthorized:// 已授权 { NSLog(@&quot;已授权&quot;); }break; default:break;} EKSource 日历源 你不需要创建此类的实例; 相反，你从EKEventStore实例中获取EKSource对象。 使用sources属性获取事件存储的所有EKSource对象，并使用此类中的实例方法访问该对象。 EKSource为日历所属的集合的抽象超类。一个EKEventStore可以包含多个EKSource，一个日历源可以包含多个日历对象。 日历的类型： 12345678typedef NS_ENUM(NSInteger, EKSourceType) { EKSourceTypeLocal, EKSourceTypeExchange, EKSourceTypeCalDAV,//Represents a CalDAV or iCloud source EKSourceTypeMobileMe, EKSourceTypeSubscribed, EKSourceTypeBirthdays}; 获取指定的日历源1234567NSArray *sources = self.eventStore.sources; for (EKSource *source in sources) { if (source.sourceType == EKSourceTypeCalDAV) { // 当前source的类型为EKSourceTypeCalDAV，你还可以使用title属性进行筛选 break; } } EKCalendar 日历 type 这个属性跟所属于的EKSource实例的type对应 calendarIdentifier，我们可以根据这个属性，使用EKEventStore的实例方法来获取指定的EKCalendar对象。需要注意的是，当发生了完全同步之后，这个值是会变化的。 会发生完全同步的几种情况： 在iPhone上，用户手动修改了日历的名字，添加/编辑/删除事件 用户在mac上对iCloud日历进行了一些修改，iOS设备会通知iCloud日历已更改，从而发生同步 第三方应用程序收到日历通知，iOS在后台启动，应用根据通知创建一些日历事件 也就是说，完全同步事件可以随时发生。当发生完全同步时，你可以通过下面的代码获得通知 12345[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(storeChanged:) name:EKEventStoreChangedNotification object:eventStore]; 如果需要的话，收到通知之后，重新创建EKCalendar实例是有意义的。 创建添加日历创建日历之前，我们先要找到它所属于的日历源(当然这取决与你想把它放在哪个日历源)。创建时，我们先要判断是否已经有相同名字的日历存在，如果没有的话，则继续创建。 12345678910111213141516171819202122232425262728293031323334353637- (void)checkJYCalendar{ NSArray *sources = self.eventStore.sources; for (EKSource *source in sources) { if (source.sourceType == EKSourceTypeCalDAV) { NSSet *calendars = [source calendarsForEntityType:EKEntityTypeEvent]; BOOL needAdd = true; for (EKCalendar *calendar in calendars) { if ([calendar.title isEqualToString:@&quot;测试日历&quot;]) { needAdd = false; _calendar = calendar; break; } } // 如果没找到日历，则创建一个 if (needAdd) { EKCalendar *calendar = [EKCalendar calendarForEntityType:EKEntityTypeEvent eventStore:self.eventStore]; calendar.source = source; calendar.title = @&quot;测试日历&quot;; calendar.CGColor = [UIColor greenColor].CGColor; NSError *error; [self.eventStore saveCalendar:calendar commit:YES error:&amp;error]; if (error) { JYLog(@&quot;创建日历失败 error:%@&quot;,error); } else { JYLog(@&quot;创建日历成功&quot;); } _calendar = calendar; } break; } }} 获取日历集可以用下面两种实例方法获取日历数据 123456// EKEventStore的实例方法- (NSArray&lt;EKCalendar *&gt; *)calendarsForEntityType:(EKEntityType)entityType NS_AVAILABLE(10_8, 6_0);// EKSource的实例方法- (NSSet&lt;EKCalendar *&gt; *)calendarsForEntityType:(EKEntityType)entityType NS_AVAILABLE(10_8, 6_0); EkEvent 日历事件 代表添加到日历中的事件。使用类方法eventWithEventStore:来创建实例 属性说明 eventIdentifier：您可以使用此标识符使用EKEventStore方法eventWithIdentifier：查找事件。 如果事件的日历发生更改，则其标识符很可能也会更改。 allDay：设置是否是全天时间 startDate：事件开始时间 endDate：事件结束时间 structuredLocation：往事件里添加地理信息位置，get方法仅返回地理位置的名称 如果你创建了一个日历事件，并且设置了重复规则：从2019-01-01开始，连续10天，每天9：00-9：30。这就就相当于你创建了10个日历事件！对每天的日历事件来说，9：00即·startDate·，9：30即·endDate·，也不是说2019-01-10 9：30是·endDate·！ 事件修改当你对EKEvent的属性修改完成之后，可以用EKEventStore的方法- (BOOL)saveEvent:(EKEvent *)event span:(EKSpan)span commit:(BOOL)commit error:(NSError **)error进行保存 EKSpan有两种类型，EKSpanThisEvent和EKSpanFutureEvents 举个例子，你创建了一个·EkEvent·对象，并且添加到了日历中了。它的规则为：连续10天，每天的早上9：00- 9：30。当你使用·EKEventStore·的方法·eventsMatchingPredicate：·查找时间时，就会得到10个·EKEventStore·对象，如果是事件发生顺序的快慢来编号（1-10），那么对于第一个·EkEvent·对象讲，·EKSpanThisEvent·指的是自己，而·EKSpanFutureEvents·指的是编号为（1-10）的几个对象；对于第二个·EkEvent·对象讲，·EKSpanThisEvent·指的是自己，而·EKSpanFutureEvents·指的是编号为（2-10）的几个对象。总之，最好自己尝试一下看看这到底是什么。 事件刷新当在其它地方对事件进行了修改之后，你可以收到EKEventStoreChangedNotification的通知，这个时候你可以选择使用实例方法refresh，更新事件的数据 在日历中添加事件12345678910111213141516171819202122232425262728293031323334/** 添加事件到日历中 */- (BOOL)addEventToCalendarWithTitle:(NSString *)title location:(NSString *)location startDate:(NSDate *)start endDate:(NSDate *)end alarmArray:(NSArray *)alarmArray{ EKEvent *newEvent = [EKEvent eventWithEventStore:self.eventStore]; newEvent.title = title; newEvent.startDate = start; newEvent.endDate = end; newEvent.location = location; newEvent.notes = @&quot;这是备注&quot;; newEvent.allDay = false; // 重复规则, 具体代码在下面会讲到 EKRecurrenceRule *rule = [self getRecurrenceRule]; // 设置提醒，具体代码在下面会讲到 [newEvent addAlarm:[self getAlarm]]; newEvent.calendar = self.calendar; NSError *error = nil; [self.eventStore saveEvent:newEvent span:EKSpanThisEvent commit:YES error:&amp;error]; if (isNull(error)) { JYLog(@&quot;添加Event成功&quot;); return YES; } else { JYLog(@&quot;添加Event失败 error:%@&quot;, error); return NO; }} EKRecurrenceRule重复周期 目前无法直接修改EKRecurrenceRule或其任何属性。 通过创建新的EKRecurrenceRule并设置事件或提醒以使用新创建的重复规则。 一般使用方法下面的方法来创建实例： 123456789- (instancetype)initRecurrenceWithFrequency:(EKRecurrenceFrequency)type interval:(NSInteger)interval daysOfTheWeek:(nullable NSArray&lt;EKRecurrenceDayOfWeek *&gt; *)days daysOfTheMonth:(nullable NSArray&lt;NSNumber *&gt; *)monthDays monthsOfTheYear:(nullable NSArray&lt;NSNumber *&gt; *)months weeksOfTheYear:(nullable NSArray&lt;NSNumber *&gt; *)weeksOfTheYear daysOfTheYear:(nullable NSArray&lt;NSNumber *&gt; *)daysOfTheYear setPositions:(nullable NSArray&lt;NSNumber *&gt; *)setPositions end:(nullable EKRecurrenceEnd *)end; type: 重复规则的频率，可以是每天，每周，每周和每年 interval: 周期间隔，必须大于0 days: 事件发生在一周的哪几天，是一个包含了EKRecurrenceDayOfWeek对象的数组 monthDays: 事件发生在一月的哪几天，值必须在131或者-1-31之间，当为-1时，即代表这个月的倒数第一天，这个参数仅当type为EKRecurrenceFrequencyMonthly有效 months: 事件发生在一年的哪几月，值必须在112或者-1-12之间，当为-1时，即代表这年的倒数第一个月，这个参数仅当type为EKRecurrenceFrequencyYearly有效 weeksOfTheYear: 事件发生在一年的哪几周，值必须在153或者-1-53之间，当为-1时，即代表这年的倒数第一周，这个参数仅当type为EKRecurrenceFrequencyYearly有效 daysOfTheYear: 事件发生在一年的哪几天，值必须在1366或者-1-366之间，当为-1时，即代表这年的倒数第一天，这个参数仅当type为EKRecurrenceFrequencyYearly有效 setPositions: 额外的重复条件 end: 结束规则，为空时即代表永久重复 12345678910111213141516EKRecurrenceRule *rule = nil; // 每两天执行一次 rule = [[EKRecurrenceRule alloc] initRecurrenceWithFrequency:EKRecurrenceFrequencyDaily interval:2 end:nil]; // 工作日都执行 rule = [[EKRecurrenceRule alloc] initRecurrenceWithFrequency:EKRecurrenceFrequencyWeekly interval:1 daysOfTheWeek:@[[EKRecurrenceDayOfWeek dayOfWeek:2], [EKRecurrenceDayOfWeek dayOfWeek:3], [EKRecurrenceDayOfWeek dayOfWeek:4], [EKRecurrenceDayOfWeek dayOfWeek:5], [EKRecurrenceDayOfWeek dayOfWeek:6]] daysOfTheMonth:nil monthsOfTheYear:nil weeksOfTheYear:nil daysOfTheYear:nil setPositions:nil end:nil]; // 每两周的周1执行 rule = [[EKRecurrenceRule alloc] initRecurrenceWithFrequency:EKRecurrenceFrequencyWeekly interval:2 daysOfTheWeek:@[[EKRecurrenceDayOfWeek dayOfWeek:2]] daysOfTheMonth:nil monthsOfTheYear:nil weeksOfTheYear:nil daysOfTheYear:nil setPositions:nil end:nil]; // 在每年的第二周以及最后一周的工作执行 rule = [[EKRecurrenceRule alloc] initRecurrenceWithFrequency:EKRecurrenceFrequencyYearly interval:1 daysOfTheWeek:@[[EKRecurrenceDayOfWeek dayOfWeek:2], [EKRecurrenceDayOfWeek dayOfWeek:3], [EKRecurrenceDayOfWeek dayOfWeek:4], [EKRecurrenceDayOfWeek dayOfWeek:5], [EKRecurrenceDayOfWeek dayOfWeek:6]] daysOfTheMonth:nil monthsOfTheYear:nil weeksOfTheYear:nil daysOfTheYear:nil setPositions:@[@2, @-1] end:nil]; EKEvent *event = [[EKEvent alloc] init]; [event addRecurrenceRule:rule]; EKAlarm创建提醒EKAlarm在Event Kit中代表警告。你可以使用alarmWithAbsoluteDate和alarmWithAbsoluteDate来创建实例。 可以用下面的方法来创建实例 1234// 设置绝对时间+ (EKAlarm *)alarmWithAbsoluteDate:(NSDate *)date; // 设置相对时间（相对event的start date），单位是秒，设置负值表示事件前提醒，设置正值是事件发生后提醒+ (EKAlarm *)alarmWithRelativeOffset:(NSTimeInterval)offset; 设置了提醒后,我们打开iOS系统自带的日历App,会发现只会显示2个提醒,看不到多余的提醒.但是实际测试发现全部提醒都可以工作,而且我们可以在Mac的日历程序中看到所有的提醒。 属性说明： structuredLocation：与proximity配合使用，简单来说，就是当你进入或者离开某个范围时，就可以发出提醒 1234EKAlarm *alarm = nil; // 事件前5分钟提醒alarm = [EKAlarm alarmWithRelativeOffset:-60. * 5]; 结束目前我对系统的日历讲解就到这啦，受限于个人的技术水平以及没有深度的使用，可能会有点错误的地方，希望指正，以后我发现错误之后也会及时来更新的！","link":"/2019/03/01/iOS-EventKit%E6%97%A5%E5%8E%86%E6%8F%90%E9%86%92/"},{"title":"iOS weak弱引用底层实现","text":"源码版本：objc4-779.1当然还是推荐使用这个来学习：可编译的源码 weak是一个所有权修饰符, 它提供弱引用的功能, 即弱引用者(weak 修饰的变量, 后统称为弱引用者)不能持有引用对象, 当引用对象被释放时, 此弱引用者被置为 nil.此文将探究弱引用在底层是如何实现 弱引用者如何注册到弱引用表首先我们研究弱引用者是如何注册到弱引用表中的调试代码如下(代码需要在开头提到的可编译版本里面才能运行, 后面不再解释), 注意里面打了个断点, 运行程序 点击 step into, 会跳转到函数objc_initWeak()中 这个函数的作用是初始化弱引用者.需要注意的是storeWeak模板里面的两个参数 DontHaveOld, DoHaveNew. 它们分别是HaveOld和HaveNew枚举的变量. 枚举里面变量的含义如下 DontHaveOld: 表示弱引用者之前没有引用对象, 例如在用__weak id weakPtr = [[NSObject alloc] init];初始化弱引用者 DoHaveOld: 表示弱引用者之前有引用对象. 此时需要将弱引用者从弱引用表中注销 DontHaveNew: 表示弱引用者没有引用一个新的对象 DoHaveNew: 表示弱引用者引用了一个新的对象. 此时需要将弱引用者注册到弱引用表中 继续 step into, 跳转到storeWeak()函数里面 函数里面代码比较多, 为了方便, 我把它分成了几部分来说明 SideTable跟弱引用的实现息息相关, 在这里可以看到对这个类的详细说明.这里我就简单的介绍一下, 它是存放引用计数表和弱引用表的结构. 它有三个成员变量:引用计数表, 弱引用表, 自旋锁. 在我们操作引用计数表或者弱引用表的时候自旋锁会加锁防止竞态条件的出现. 代码块 1 的作用: 加锁, 防止在修改哈希表时可能出现的竞态条件. 按锁地址(从低到高)顺序加锁, 防止可能出现的锁的排序问题. 如果弱引用者的引用对象改变了(这是因为如果并发修改弱引用者的引用对象, 在加锁之前, 可能原先的引用对象会改变), 则重复执行retry部分的代码 代码块 2 的作: 保证引用对象的 isa 指针已经初始化过. 如果未初始化, 则对该对象的非元类 Class 进行初始化. 代码块 3 的作: 在弱引用表上注销弱引用者, 后面会再来讲这个部分 代码块 4 的作用: 在弱引用表上注册弱引用者 代码块 5 的作用: 对象被弱引用者引用了, 则修改对象 isa 指针上位域的信息, 将weakly_referenced置为 YES, 表示该对象被一个弱引用者引用. 需要注意的是, 如果这个对象后续不再被弱引用者引用了, isa 指针上的weakly_referenced值仍旧是 YES 接着, 我们把断点移动到weak_register_no_lock()函数里面, 同样, 我把它分成几部分来讲解. referent 表示引用对象, referrer 表示弱引用者 代码块 1 的作用是: 保证引用对象是可用的. 如果引用对象正处于被销毁的状态, 那么程序会崩溃 代码块 2 的作用是: 根据引用对象找到对应的 weak_entry_t 实例(后面统称为为弱条目), 并将该弱引用者保存到弱条目中 下面是append_referrer()函数的实现, 写了点注释就不展开讲了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253static void append_referrer(weak_entry_t *entry, objc_object **new_referrer){ if (! entry-&gt;out_of_line()) { // 使用内部数组来保存弱引用者. 遍历内部数组, 如果有空位则用该空位保存弱引用者并返回 for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) { if (entry-&gt;inline_referrers[i] == nil) { entry-&gt;inline_referrers[i] = new_referrer; return; } } // 如果执行到这里, 说明内部数组都被使用了. 所以需要扩容, 即创建一个外部数组来保存弱引用者 // 先初始化一个跟内部数组长度一样的数组, 并将内部数组的数据转移过去 weak_referrer_t *new_referrers = (weak_referrer_t *) calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t)); // This constructed table is invalid, but grow_refs_and_insert // will fix it and rehash it. for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) { new_referrers[i] = entry-&gt;inline_referrers[i]; } entry-&gt;referrers = new_referrers; entry-&gt;num_refs = WEAK_INLINE_COUNT; entry-&gt;out_of_line_ness = REFERRERS_OUT_OF_LINE; entry-&gt;mask = WEAK_INLINE_COUNT-1; entry-&gt;max_hash_displacement = 0; } ASSERT(entry-&gt;out_of_line()); // 如果外部数组中有 3/4 的元素都被使用了, 则进行扩容 if (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * 3/4) { // 扩容的长度为原来的 2 倍, 最小值为 8. return grow_refs_and_insert(entry, new_referrer); } // 根据指针的哈希值来计算位置 index size_t begin = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask); size_t index = begin; size_t hash_displacement = 0; while (entry-&gt;referrers[index] != nil) { // 发生了哈希碰撞, 则增加下标, 查看下一个位置是否为空 hash_displacement++; index = (index+1) &amp; entry-&gt;mask; if (index == begin) bad_weak_table(entry); } // 重新计算 entry 的最大哈希偏移量 if (hash_displacement &gt; entry-&gt;max_hash_displacement) { entry-&gt;max_hash_displacement = hash_displacement; } // 将新的弱引用者保存到弱引用条目中 weak_referrer_t &amp;ref = entry-&gt;referrers[index]; ref = new_referrer; // num_refs + 1 entry-&gt;num_refs++;} 代码块 3 的作用: 生成一个新的弱引用条目, 将弱引用者保存到弱条目中. 随后将弱条目插入到弱引用表中 第一行代码的作用是初始化一个weak_entry_t的实例 new_entry 第二行代码里面函数的作用是, 如果弱引用表的成员变量weak_entries数组里面有 3/4 的数量的弱条目被使用了, 则进行扩容. 长度为原来的 2 倍, 最小为 64 第三行代码的作用是将新生成的弱条目插入到弱引用表中 至此, 我们已经大致了解了弱引用者是如何注册到弱引用条目的, 这里小总结一下: 首先判断引用对象是否处于销毁状态, 否则是的话程序会崩溃 根据引用对象获取到对应的SideTable, 它里面有成员变量弱引用表weak_table_t 在弱引用表中根据引用对象来查找对应的弱引用条目, 如果存在则将该弱引用者保存在该条目中. 如果不存在则新生成一个条目, 将弱引用者保存到该条目, 随后将条目插入到弱引用表中 在弱引用表中插入弱条目根据引用对象的哈希值来计算 index, 在弱条目中插入弱引用者根据弱引用者的哈希值来计算 index 在此过程中, 不对任何的弱引用者进行赋值, 即不对 *referrer 进行赋值操作 弱引用者如何从弱引用表中注销这部分用来探究弱引用者如何从弱引用表中注销实验代码如下 点击step into跳转到objc_storeWeak()函数里面 首先弱引用者 w1 引用了对象 o1, w1 会被注册到 o1 对应的弱引用条目中. 随后我们给它设置了一个新的引用对象 o2, 那么, w1 会先从 o1 的条目中注销, 然后注册到 o2 的条目中. 继续调试, 将断点移动到storeWeak()函数里面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687template &lt;HaveOld haveOld, HaveNew haveNew, CrashIfDeallocating crashIfDeallocating&gt;static id storeWeak(id *location, objc_object *newObj){ ASSERT(haveOld || haveNew); if (!haveNew) ASSERT(newObj == nil); Class previouslyInitializedClass = nil; id oldObj; SideTable *oldTable; SideTable *newTable; // Acquire locks for old and new values. // Order by lock address to prevent lock ordering problems. // Retry if the old value changes underneath us. retry: if (haveOld) { oldObj = *location; oldTable = &amp;SideTables()[oldObj]; } else { oldTable = nil; } if (haveNew) { newTable = &amp;SideTables()[newObj]; } else { newTable = nil; } SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); if (haveOld &amp;&amp; *location != oldObj) { SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); goto retry; } // Prevent a deadlock between the weak reference machinery // and the +initialize machinery by ensuring that no // weakly-referenced object has an un-+initialized isa. if (haveNew &amp;&amp; newObj) { Class cls = newObj-&gt;getIsa(); if (cls != previouslyInitializedClass &amp;&amp; !((objc_class *)cls)-&gt;isInitialized()) { SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); class_initialize(cls, (id)newObj); // If this class is finished with +initialize then we're good. // If this class is still running +initialize on this thread // (i.e. +initialize called storeWeak on an instance of itself) // then we may proceed but it will appear initializing and // not yet initialized to the check above. // Instead set previouslyInitializedClass to recognize it on retry. previouslyInitializedClass = cls; goto retry; } } // Clean up old value, if any. if (haveOld) { weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location); } // Assign new value, if any. if (haveNew) { newObj = (objc_object *) weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, crashIfDeallocating); // weak_register_no_lock returns nil if weak store should be rejected // Set is-weakly-referenced bit in refcount table. if (newObj &amp;&amp; !newObj-&gt;isTaggedPointer()) { newObj-&gt;setWeaklyReferenced_nolock(); } // Do not set *location anywhere else. That would introduce a race. *location = (id)newObj; } else { // No new value. The storage is not changed. } SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); return (id)newObj;} 函数里面大部分内容已经在上一节中介绍过, 这里就不重复了这里我们要讲解的是weak_unregister_no_lock()函数. 这个函数的作用是将销弱引用者从引用对象对应的弱引用条目中注销. 函数实现如下: referent表示原先的引用对象, referrer表示弱引用者 代码块 1 的作用是根据引用对象查找弱引用条目, 然后存在则将该弱引用者从条目中注销 函数remove_referrer()的实现如下, 写了点注释就不展开讲了 123456789101112131415161718192021222324252627282930313233343536373839404142static void remove_referrer(weak_entry_t *entry, objc_object **old_referrer){ if (! entry-&gt;out_of_line()) { //使用内部数组保存弱引用者, 此时遍历该数组, 找到对应的弱引用者, 如果找到的话则将其从数组中移除 for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) { if (entry-&gt;inline_referrers[i] == old_referrer) { entry-&gt;inline_referrers[i] = nil; return; } } _objc_inform(&quot;Attempted to unregister unknown __weak variable &quot; &quot;at %p. This is probably incorrect use of &quot; &quot;objc_storeWeak() and objc_loadWeak(). &quot; &quot;Break on objc_weak_error to debug.\\n&quot;, old_referrer); objc_weak_error(); return; } // 此时使用外部数组来保存弱引用者 // 根据弱引用者的哈希值来得到对应元素的 index size_t begin = w_hash_pointer(old_referrer) &amp; (entry-&gt;mask); size_t index = begin; size_t hash_displacement = 0; while (entry-&gt;referrers[index] != old_referrer) { // 如果发生了哈希碰撞, 则偏移+1 往下继续查找该弱引用者.当偏移量超过最大偏移量时程序崩溃 index = (index+1) &amp; entry-&gt;mask; if (index == begin) bad_weak_table(entry); hash_displacement++; if (hash_displacement &gt; entry-&gt;max_hash_displacement) { _objc_inform(&quot;Attempted to unregister unknown __weak variable &quot; &quot;at %p. This is probably incorrect use of &quot; &quot;objc_storeWeak() and objc_loadWeak(). &quot; &quot;Break on objc_weak_error to debug.\\n&quot;, old_referrer); objc_weak_error(); return; } } // 找到对应弱引用则将其从外部数组中移除 entry-&gt;referrers[index] = nil; entry-&gt;num_refs--;} 代码块 2 的作用是判断弱引用条目中注册的弱引用者的数量是否为 0, 如果为 0 则将该弱引用条目从弱引用表中清除. weak_entry_remove()函数的实现如下, 写了点注释就不展开讲了 123456789101112static void weak_entry_remove(weak_table_t *weak_table, weak_entry_t *entry){ // remove entry // 如果使用的外部数组, 则将外部数组销毁. 如果使用内部数组, 则会在销毁条目时将内部数组也销毁 if (entry-&gt;out_of_line()) free(entry-&gt;referrers); // 销毁弱引用条目 bzero(entry, sizeof(*entry)); weak_table-&gt;num_entries--; // 当条目数量超过 1024, 并且使用了不到 1/16, 则将条目数量缩小为原来的 1/8 weak_compact_maybe(weak_table);} 至此, 我们已经大致了解了弱引用者如何从弱引用表中注销的, 我小总结一下: 根据旧引用对象获取SideTable 根据就引用对象在SideTable的弱引用表中获取对应的弱引用条目 在弱引用条目中查找是否注册了该弱引用者, 如果存在的话则移除 若弱引用者移除后弱引用表中弱引用者的数量为 0, 则将该条目从弱引用表中移除 如条目移除后, 条目的数量超过 1024, 且使用的数量少于 1/16, 则将条目的容量缩小为原先的 1/8 引用对象销毁后弱引用者如何置为 nil我们都知道当引用对象被销毁后, 弱引用者会被置为 nil.这部分用来粗略的讲解其实现 添加一个symbolic breakpoint, 在symbol里面输入[NSObject dealloc] 点击 continue program execution, 跳转到dealloc()函数中 对 o1 的引用计数 -1 , o1 的引用计数就变成了 0, 需要销毁. 即调用 NSObject 的 dealloc 方法 随后一直跳转到objc_object::clearDeallocating_slow()函数里面.这个函数的作用是清除该对象在SideTable中存在于引用计数表或者弱引用表中的数据 因为研究的是对弱引用的操作, 所以这边我们只需要关注weak_clear_no_lock()函数.它的实现如下, 写了注释就不展开讲了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void weak_clear_no_lock(weak_table_t *weak_table, id referent_id) { // referent 表示引用对象, 即这里要被销毁的对象 objc_object *referent = (objc_object *)referent_id; // 根据引用对象找到对应的弱引用条目 weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); if (entry == nil) { /// XXX shouldn't happen, but does with mismatched CF/objc //printf(&quot;XXX no entry for clear deallocating %p\\n&quot;, referent); return; } // zero out references // 数组指针 weak_referrer_t *referrers; // 数组长度 size_t count; if (entry-&gt;out_of_line()) { referrers = entry-&gt;referrers; count = TABLE_SIZE(entry); } else { referrers = entry-&gt;inline_referrers; count = WEAK_INLINE_COUNT; } for (size_t i = 0; i &lt; count; ++i) { objc_object **referrer = referrers[i]; if (referrer) { // 将弱引用者置为 nil if (*referrer == referent) { *referrer = nil; } else if (*referrer) { _objc_inform(&quot;__weak variable at %p holds %p instead of %p. &quot; &quot;This is probably incorrect use of &quot; &quot;objc_storeWeak() and objc_loadWeak(). &quot; &quot;Break on objc_weak_error to debug.\\n&quot;, referrer, (void*)*referrer, (void*)referent); objc_weak_error(); } } } // 将所有弱引用者置为 nil 后, 将该条目从弱引用表中删除 weak_entry_remove(weak_table, entry);} 至此, 我们已经大致了解了引用对象销毁后弱引用者如何置为 nil 的, 这里小总结一下: 当对象的引用计数为 0 时, 会调用 dealloc 方法用来销毁对象. 如果有弱引用者引用者该对象, 那么会从弱引用表中找到对象的弱引用条目, 将条目中所有注册的弱引用者置为 nil, 随后将该条目从弱引用表中删除.","link":"/2020/04/23/iOS-weak%E5%BC%B1%E5%BC%95%E7%94%A8%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"},{"title":"iOS如何配置Bugly符号表(2020年最新)","text":"本文将粗略的讲解 Bugly 的集成过程, 其中配置符号表部分会说的仔细一点 符号表就是内存地址与函数名, 文件名, 行号的映射表. 通过上传符号表, 我们能将 App 发生 Crash 的程序堆栈进行解析还原. Bugly 是我在用的一个崩溃日志收集分析工具. 集成使用简单并且免费.之前一直使用Xcode + sh方式自动配置符号表, 直到有一天看到 crash 堆栈没有被解析, 才知道这个方法已无法上传符号表. 上网找过一些解决方法, 大致就是找到符号表后延迟以后再上传, 但也没什么效果. 随后再上官网查看文档, 使用官方手动配置的方法, 成功的上传了符号表和解析堆栈. 创建应用上 官网 创建产品.创建成功后获取应用的 App ID 集成使用Cocoapods集成pod 'Bugly' 初始化 SDK在工程AppDelegate.m的application:didFinishLaunchingWithOptions:方法中初始化： 1234- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { [Bugly startWithAppId:@&quot;此处替换为你的AppId&quot;]; return YES;} 手动配置符号表下载 最新版 请点击我这个连接去下载, 这个是 3.0.0 版本的. 包里面有几个文件: buglySymboliOS.jar: 符号表工具JAR包 buglySymboliOS.bat: Windows的脚本 buglySymboliOS.sh: Shell脚本 settings.txt: 默认符号表配置文件 符号表工具iOS版-使用指南 运行需要Java 运行环境 (JRE􏲀JDK􏰅􏱺􏱿􏰎&gt;=1.6) 使用脚本时, 请保证脚本和 jar 包在同个目录下! 获取 dSYM 文件 iOS 平台中, 􏲜􏲝􏲐􏱓dSYM 文件是指具有调试信息的目标文件, 文件名通常为: dSYM􏰔􏰕􏰫􏰈􏰄􏰳􏲁􏲂􏲃􏲄􏰞􏲅􏲆􏰔􏰕􏱓􏰔􏰕􏲡􏰻􏳋􏱈􏱣xxx.app.dSYM 我使用下面的方式来找到它: 将最后的 dSYM 文件拷贝出来一份集中备份 dSYM 的符号表生成和上传 生成 我使用下面的方式来生成和上传 dSYM 文件 12cd /Users/dqh/Desktop/buglySymboliOS3.0.0java -jar buglySymboliOS.jar -i /Users/AAAA_1.0.15.app.dSYM -u -id 123456 -key 123456-2608-4a57-8af8-ff9c4d481f3e -package com.kikido.youappname -version 1.3.5 你需要更改以下选项信息: i /Users/AAAA_1.0.15.app.dSYM: 更改为 [i 自己 dSYM 文件存放的地址] id 123456: 更改为 [id 你自己在 Bugly 申请到的 apple id] key 123456-2608-4a57-8af8-ff9c4d481f3e: 更改为 [key 你自己在 Bugly 申请到的 apple key] package com.kikido.youappname: 更改为 [package 你自己 app 的 bundle id] version 1.3.5: 更改为 [version 你自己 app 的 version] 工具选项说明如下 选项 说明 -i 指定文件路径, 可指定目录(必选)􏰈􏰭􏰔􏰕􏲯􏲰􏱓􏲇􏰈􏰭􏲅􏲒􏱪􏲟􏰡􏱫􏰈􏰭􏰔􏰕􏲯􏲰􏱓􏲇􏰈􏰭􏲅􏲒 -o 􏲱􏲲􏰞􏰀􏰁􏰂输出的符号表 zip 文件的路径, 必须是 zip 文件 -d 调试模式开关(默认关闭) -s 指定配置文件(默认读取 JAR 目录下的 settings.text 文件) -u 上传开关 -id app id -key app key -package app 包名 -version app 版本 -symbol 生成 symbol 文件 更多信息请查看符号表工具iOS版-使用指南.pdf 使用上面的命令之后就会在本地生成符号表文件, 并上传到符号表. 下面是 crash 的堆栈解析, 完美","link":"/2020/04/20/iOS%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEBugly%E7%AC%A6%E5%8F%B7%E8%A1%A8-2020%E5%B9%B4%E6%9C%89%E6%95%88/"},{"title":"iOS应用 main 执行前发生的事情","text":"这篇是对 iOS 应用启动时，main 函数执行前发生的事的一点总结，限于水平，如有错误请指正~ FAT 二进制FAT 二进制文件，将多种架构的 Mach-O 文件合并而成。它通过 Fat Header 来记录不同架构在文件中的偏移量，Fat Header 占一页(64位16kb，32位4kb)的空间。按分页来存储这些 segement 和 header 会浪费空间，但这有利于虚拟内存的实现。 Mach-O 文件Mach-O为 Mach Object 文件格式的缩写，它是一种用于可执行文件，目标代码，动态库，内核转储的文件格式。在 Mac OS X 系统中使用 Mach-O 作为其可执行文件类型。它的组成结构如下图所示： 每个 Mach-O 文件包括一个 Mach-O Header，然后是一系列的载入命令 load commands，再是一个或多个段(segment)，每个段包括0到255个节(section)。Mach-O使用REL再定位格式控制对符号的引用。Mach-O在两级命名空间中将每个符号编码成“对象-符号名”对（所以需要保持 selector 的唯一），在查找符号时则采用线性搜索法。 Mach-O包含了几个 segment，每个 segment 又包含几个 section。segment的名字都是大写的，例如__DATA;section的名字都是小写的, 例如 __text。在 Mach-O 的类型不为MH_OBJECT时，空间大小为页的整数倍。页的大小跟硬件有关，在 arm64 架构一页是16kb，其余为4kb。section 虽然没有整数倍页大小的限制，但是 section 之间不会有重叠。 Mach-O Header推荐使用MachOView这个软件查看 Mach-O 的文件结构。注意需要手动关闭 processing，不然会闪退。下面是用 MachOView 查看自己的应用结构： 东西有点多就没有截取全部。我们查看一下Mach-O Header部分 下面是64位架构下header的数据结构： 12345678910struct mach_header_64 { uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */ uint32_t reserved; /* reserved */}; Mach-O 全部的 filetype 和 flags 可以在loader.h中找到。 除了MH_OBJECT以外的所有类型，段(Segment)的空间大小均为页的整数倍。页的大小跟硬件有关系，在 arm64 架构下一页为16kb，其它为4kb。 Load commandsLoad commands紧跟在头部之后, 当加载过 header 之后，会通过解析Load commands来加载剩下的数据，确定其内存的分布。下面是 load commands 的结构定义： 1234struct load_command { uint32_t cmd; /* 载入命令类型 */ uint32_t cmdsize; /* total size of command in bytes */}; 所有load commands的大小即为 Header-&gt;sizeofcmds, 共有 Header-&gt;ncmds 条load command。load command 以LC开头，不同的加载命令有不同的专有的结构体，cmd 和 cmdsize 是都有的，分别为命令类型（即命令名称），这条命令的长度。这些加载命令告诉系统应该如何处理后面的二进制数据，对系统内核加载器和动态链接器起指导作用。如果当前 LC_SEGMENT 包含 section，那么 section 的结构体紧跟在 LC_SEGMENT 的结构体之后，所占字节数由 SEGMENT 的 cmdsize 字段给出。 cmd(命令名称) 作用 LC_SEGMENT_64 将对应的段中的数据加载并映射到进程的内存空间去 LC_SYMTAB 符号表信息 LC_DYSYMTAB 动态符号表信息 LC_LOAD_DYLINKER 启动动态加载连接器/usr/lib/dyld程序 LC_UUID 唯一的 UUID，标示该二进制文件，128bit LC_VERSION_MIN_IPHONEOS/MACOSX 要求的最低系统版本（Xcode中的Deployment Target） LC_MAIN 设置程序主线程的入口地址和栈大小 LC_ENCRYPTION_INFO 加密信息 LC_LOAD_DYLIB 加载的动态库，包括动态库地址、名称、版本号等 LC_FUNCTION_STARTS 函数地址起始表 LC_CODE_SIGNATURE 代码签名信息 注意：不同类型的 segment 会使用不同的函数来加载 SegmentMach-O 文件中由许多个段（Segment），每个段都有不同的功能，每个段包含了许多个小的Section。LC_SEGMENT意味着这部分文件需要映射到进程的地址空间去，几乎所有 Mach-O 都包含这三个段： __TEXT：包含了执行代码和其它只读数据(如C 字符串)。权限：只读(VM_PROT_READ)，可执行(VM_PROT_EXECUTE) __DATA：程序数据，包含全局变量，静态变量等。权限：可读写(VM_PROT_WRITE/READ) 可执行(VM_PROT_EXECUTE) __LINKEDIT：包含了加载程序的”元数据”，比如函数的名称和地址。权限：只读(VM_PROT_READ) 除了上面三个，还有一个常见的 segment： __PAGEZERO：空指针陷阱段，映射到虚拟内存空间的第一页，用于捕捉对 NULL 指针的引用 LC_SEGMENT_64 的结构定义为： 12345678910111213struct segment_command_64 { /* for 64-bit architectures */ uint32_t cmd; /* LC_SEGMENT_64 */ uint32_t cmdsize; /* includes sizeof section_64 structs */ char segname[16]; /* segment name */ uint64_t vmaddr; /* memory address of this segment */ uint64_t vmsize; /* memory size of this segment */ uint64_t fileoff; /* file offset of this segment */ uint64_t filesize; /* amount to map from the file */ vm_prot_t maxprot; /* maximum VM protection */ vm_prot_t initprot; /* initial VM protection */ uint32_t nsects; /* number of sections in segment */ uint32_t flags; /* flags */}; 可以看到这里大部分的成员变量都是帮助内核将 segment 映射到虚拟内存的。nsects即表明该段中包含多少个 section，section是具体数据存放的地方。cmdsize表示当前 segment 结构体以及它所包含的所有 section 结构体的总大小。 文件映射的起始位置由fileoff给出，映射到地址空间的vmaddr处。 Sectionsection 的名字均为小写。section 是具体数据存放的地方，它的结构体跟随在 LC_SEGMENT 结构体之后。在64位环境中它的结构定义为： 1234567891011121314struct section_64 { /* for 64-bit architectures */ char sectname[16]; /* name of this section */ char segname[16]; /* segment this section goes in */ uint64_t addr; /* memory address of this section */ uint64_t size; /* size in bytes of this section */ uint32_t offset; /* file offset of this section */ uint32_t align; /* section alignment (power of 2) */ uint32_t reloff; /* file offset of relocation entries */ uint32_t nreloc; /* number of relocation entries */ uint32_t flags; /* flags (section type and attributes)*/ uint32_t reserved1; /* reserved (for offset or index) */ uint32_t reserved2; /* reserved (for count or sizeof) */ uint32_t reserved3; /* reserved */}; 其中flasg字段储存了两个属性的值：type 和 attributes。type 只能有一个值，而 attributes 的值可以有多个。如果 segment 中任何一个 section 拥有属性 S_ATTR_DEBUG，那么该段所有的 section 都会拥有这个属性。属性详情可以参考loader.h section name 作用 __text 主程序代码 __stub_helper 用于动态链接的存根 __symbolstub1 用于动态链接的存根 __objc_methname Objective-C 的方法名 __objc_classname Objective-C 的类名 __cstring 硬编码的字符串 __lazy_symbol 懒加载，延迟加载节，通过 dyld_stub_binder 辅助链接 _got 存储引用符号的实际地址，类似于动态符号表 __nl_symbol_ptr 非延迟加载节 __mod_init_func 初始化的全局函数地址，在 main 之前被调用 __mod_term_func 结束函数地址 __cfstring Core Foundation 用到的字符串（OC字符串） __objc_clsslist Objective-C 的类列表 __objc_nlclslist Objective-C 的 +load 函数列表，比 __mod_init_func 更早执行 __objc_const Objective-C 的常量 __data 初始化的可变的变量 __bss 未初始化的静态变量 虚拟内存在 segment 的结构体中，我们可以看到vmaddr和vmsize两个成员变量，它们分别代表 segment 在虚拟内存中的地址以及大小。 虚拟内存就是一层间接寻址（indirection）。软件工程中有句格言就是任何问题都能通过添加一个间接层来解决。虚拟内存解决的是管理所有进程使用物理 RAM 的问题。通过添加间接层来让每个进程使用逻辑地址空间，它可以映射到 RAM 上的某个物理页上。这种映射不是一对一的，逻辑地址可能映射不到 RAM 上，也可能有多个逻辑地址映射到同一个物理 RAM 上。针对第一种情况，当进程要存储逻辑地址内容时会触发 page fault；第二种情况就是多进程共享内存。 对于文件可以不用一次性读入整个文件，可以使用分页映射（mmap()）的方式读取。也就是把文件某个片段映射到进程逻辑内存的某个页上。当某个想要读取的页没有在内存中，就会触发 page fault，内核只会读入那一页，实现文件的懒加载。 也就是说 Mach-O 文件中的__TEXT段可以映射到多个进程，并可以懒加载，且进程之间共享内存。__DATA段是可读写的。这里使用到了Copy-On-Write技术，简称 COW。也就是多个进程共享一页内存空间时，一旦有进程要做写操作，它会先将这页内存内容复制一份出来，然后重新映射逻辑地址到新的 RAM 页上。也就是这个进程自己拥有了那页内存的拷贝。这就涉及到了 clean/dirty page 的概念。dirty page 含有进程自己的信息，而 clean page 可以被内核重新生成（重新读磁盘）。所以 dirty page 的代价大于 clean page。 在多个进程加载 Mach-O 文件时__TEXT和__LINKEDIT因为只读，都是可以共享内存的。而__DATA因为可读写，就会产生 dirty page。当 dyld 执行结束后，__LINKEDIT就没用了，对应的内存页会被回收。 dyld dyld（the dynamic link editor），Apple 的动态链接器。在内核完成映射进程的工作后会启动dyld，负责加载应用依赖的所有动态链接库，准备好运行所需的一切。在 App 启动的时候，首先会加载 App 的 mach-o 文件，从 load commands 中得到 dyld 的路径，并且运行。随后 dyld 做的事情顺序概括如下： 初始化运行环境 加载主程序执行文件 生成 image, 将image添加到一个全局容器中 加载共享缓存 根据依赖链递归加载动态链接库 dylib，如果在缓存中有加载好的 image 则直接拿出来，否则生成一个新的 image，将image添加到一个全局容器中 link 主执行文件 link dylib 根据依赖链递归修正指针 Rebase 根据依赖链递归符号绑定 Bind 初始化 dylib（runtime 的初始化就在这个时候） 在加载完所有的 dylib 之后，它们处于互相独立的状态，所以还需要将它们绑定起来。代码签名让我们不能修改指令，所以不能直接让一个 dylib 调用另一个 dylib，这时需要很多间接层。这个时候需要 dyld 来修正指针(rebasing)和绑定符号(binding)。 详细可以查看 dyld 的源码中的_main函数。下面会分析上述的其中几个步骤。 ImageLoader ImageLoader是一个将 mach-o 文件里面二进制数据(编译过的代码、符号等)加载到内存的基类，它负责将 mach-o 中的二进制数据映射到内存，它的实例就是我们熟悉的 image。 每一个 mach-o 文件都会有一个对应的 image，实例的类型根据 mach-o 格式的不同也会不同。 ImageLoaderMachOClassic: 用于加载__LINKEDIT段为传统格式的 mach-o 文件 ImageLoaderMachOCompressed: 用于加载__LINKEDIT段为压缩格式的 mach-o 文件 因为dylib之间有依赖关系，所以系统会沿着依赖链递归加载 image。 Rebasingdylib的二进制数据会随机的映射到内存的一个随机地址ASLR(Address space layout randomization,)中，这个随机的地址跟代码和数据指向的旧地址(preferred_address)会有一定的偏差，dyld需要修正这个偏差(slide)，做法就是将dylib内部的指针地址都加上这个偏移值，偏移值的计算方法如下： slide = actual_address - preferred_address 随后就是不断的将__DATA段中需要修正的指针加上这个偏移值。注意：每次程序启动后的地址都会变化，所以指针的地址都需要重新修正。 在 mach-o 的一个载入命令LC_DYLD_INFO_ONLY可以查看到rebase, bind, week_bind,lazy_bind的偏移量和大小。 Bindingbinding处理那些指向dylib外部的指针，它们实际上被符号名称(symbol)绑定，也就是个字符串。比如我们 objc 代码中需要使用到 NSObject, 即符号_OBJC_CLASS_$_NSObject，但是这个符号不存在当前的 image 中，而是在系统库 Foundation.framework中，因此就需要binding这个操作将对应关系绑定到一起。 Lazy BindinglazyBinding就是在加载动态库的时候不会立即 binding, 当时当第一次调用这个方法的时候再实施 binding。 做到的方法也很简单： 通过dyld_stub_binder这个符号来做。lazy binding 的方法第一次会调用到 dyld_stub_binder, 然后 dyld_stub_binder负责找到真实的方法，并且将地址bind到桩上，下一次就不用再bind了。多数符号都是 lazy binding 的 Runtime每一个dylib都有自己的初始化方法，当相应的 image 被加载到内存后，就会调用初始化方法。当然这不是调用名为initialize方法，而是C++静态对象初始化构造器，__attribute__((constructor))标记的方法以及Initializer方法。你可以在程序中设置环境变量DYLD_PRINT_INITIALIZERS来打印dylib的初始化方法。 我们可以看到程序首先调用了libSystem这个dylib的初始化方法。libSystem是很多系统的lib的集合，包括 libdispatch(GCD), libsystem_c(c语言库), libsystem_blocks(block)。在libSystem的源码init.c中我们可以看到，它的初始化方法libSystem_initializer会调用libdispatch_init();, 然后逐步调用到_objc_init，也就是 objc 和 runtime 的入口。添加一个符号断点_objc_init，下面是方法调用栈： 注意：runtime 和 objc 属于libobjc 下面是_objc_init的实现： 12345void _objc_init(void){ // 省略... _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);} 上面的map_images不是将 image 添加到内存中的意思，在这个方法被调用的时候，已经完成了 image 的映射以及指针修正，绑定符号的工作了。这个函数实际上是将 image 中 OBJC 相关的信息进行初始化，具体实现可以查看_read_image的源码，因为代码太多所以这里就不贴出来了，下面是具体做的事情： 会将所有的 Class 存放在一张映射类名与 Class 的全局表中gdb_objc_realized_classes 随后调用readClass函数将 每一个 Class 添加到gdb_objc_realized_classes表中。 确定 selector 是唯一的 read protocols: 读取protocol realizeClasses：这一步的意义就是动态链接好class, 让class处于可用状态，主要操作如下： 检查ro是否已经替换为rw,没有就替换一下。 检查类的父类和metaClass是否已经realize,没有就先把它们先realize 重新layout ivar. 因为只有加载好了所有父类，才能确定ivar layout 把一些flags从ro拷贝到rw 链接class的 nextSiblingClass 链表 attach categories: 合并categories的method list、 properties、protocols到 class_rw_t 里面 read categories：读取类目 在map_images结束会调用load_images函数。这一步做的事情比较少，就是调用我们熟悉的+(load)函数。父类会先调用，除了 Class，每个类目的+(load)方法也会被调用一次，但顺序就不一定了。 总结在这里对 main 函数之前的操作做一个小总结吧： 将 App 的 mach-o header 读取到内存中 根据 load commands 获取 dyld 的路径，运行 dyld 初始化运行环境，加载 dylib，如果缓存中存在则从缓存中拿出加载过的 image，否则新建一个 image，加载到内存中 修正指针(rebase)，绑定符号(bind) 初始化 dylib，运行 runtime runtime 将 image 中有关 OBJC 的数据进行初始化 调用 +(load) 方法 dyld 调用 main 函数 花了一周的时间用来研究这部分的内容，终于填完坑了很舒服最大的感受就是学习完后，看 clang 编译后的 C++ 代码能看懂的更多了。比如添加完一个类目之后，会将这个这个类目添加到__DATA的section __objc_catlist中，以前不知道啥意思现在就明白了。也明白 xcode 的许多设置是用来干嘛的，总之好处多多学习也是一个递归的过程，加油跳出这个递归吧！ 引用iOS 程序 main 函数之前发生了什么优化 App 的启动时间dyld源码分析-动态加载loaddyld与ObjC","link":"/2019/07/19/iOS%E5%BA%94%E7%94%A8-main-%E6%89%A7%E8%A1%8C%E5%89%8D%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B%E6%83%85/"},{"title":"iOS检测私有Api的方法","text":"首先你有个可以提交审核的ipa，可以先将项目 archive, 在window-&gt;organizer中，选择distribute app -&gt; ios app store -&gt; export，将ipa导出到本地中 将ipa解压，会有两个文件夹Payload、Symbols cd到Payload里面的app 有两种方式可以检测打包文件是否包含字符串 strings - -a -arch armv7 “AAAA” | grep 你想搜的方法名 strings - -a -arch armv7 “AAAA” &gt; test.txt 第二种可以自己去生成的test.text文件中搜索相应方法名字","link":"/2019/06/20/iOS%E6%A3%80%E6%B5%8B%E7%A7%81%E6%9C%89Api%E7%9A%84%E6%96%B9%E6%B3%95/"},{"title":"iOS的锁以及GCD相关","text":"这段时间的研究内容的是锁，因为实际开发中用到的比较少，文中难免会有错误，希望能够多多指正。这篇博客的第一部分是一些计算机的基础知识，然后介绍一些常见的锁以及它们的工作原理，最后部分是 GCD 相关的一些内容。 一些基础知识下面是一些计算机知识，比较枯燥。你可以跳过这一部分，直接看后面的内容，等看到一些不懂的概念的时候再跳回来看这部分内容。 时间片时间片又称为“量子”或者“处理器片”，是分时操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。现代操作系统(例如 Windows，Mac OS X)允许同时运行多个进程。例如，在打开音乐播放器的同时用浏览器浏览网页并下载文件。由于有些计算机只有一个CPU，所以不可能真正地同时运行多个任务。这些进程“看起来像”同时运行，实则是轮番运行，由于时间片通常很短（在Linux上为5ms－800ms），用户不会感觉到。 时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。通常状况下，一个系统所有的进程被分配到的时间片长短并不相等，尽管初始时间片基本相等，系统通过测量进程的阻塞和执行状态的时间长短来计算每个进程的交互性。交互性和每个进程预设的静态优先级(Nice值)的叠加即是动态优先级，动态优先级按比例缩放就是要分配给那个进程时间片的长短。一般的，为了获得较快的响应速度，交互性强的进程(即趋向于IO消耗型)被分配到的时间片要长于交互性弱的进程。 进程基本状态进程有以下几种状态： new：创建状态。进程正在被创建，仅仅在堆上分配内存，尚未进入就绪态 ready：就绪态。进程已处于准备运行的状态，即进程已获得除了 CPU 之外的所需资源，一旦分配到 CPU 时间片即可进入运行状态 run：运行态。进程正在运行，占用 CPU 资源，执行代码。任意时间点，处于运行状态的进程(线程)的总数，不会超过 CPU 的总核数 wait：阻塞态。进程处于等待某一事件而放弃 CPU，暂停运行。阻塞状态分3种： 阻塞在对象等待池：当进程在运行时执行wait()方法，将线程放入等待池 阻塞在对象锁池：当对象在运行时企图获取已经被其它进程占用的同步锁时，会把线程放入锁池 其它阻塞状态：当进程在运行时执行sleep()方法，或调用其它进程的join()方法，或发出I/O请求时，进入阻塞状态 dead：死亡态。进程正在被结束，这可能是进程正常结束或其它原因中断运行。进程结束运行前，系统必须置进程为dead态，再处理资源释放和回收等工作 在特定的情况下，这三种状态可以相互转换 ready -&gt; run: 就绪态的进程获得 CPU 时间片，进入运行态 run -&gt; ready: 运行态的进程在时间片用完后，必须出让 CPU，进入就绪态 run -&gt; wait: 当进程请求资源的使用权或等待事件发生(如I/O完成)时，由运行态转换为阻塞态 wait -&gt; ready: 当进程已经获取所需资源的使用权或者等待时间已完成时，中断处理程序必须把相应进程的状态由阻塞态转为就绪态 进程以及线程的关系 进程是资源分配的最小单位 进程（Process)是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。每个进程都占用一个进程表项，该表项包含了操作系统对进程进行描述和控制的全部信息，包括程序计数器，堆栈指针，内存分配状况，打开文件的状态，账号和调度信息 线程是”轻量级的进程“，是 CPU 调度的最小单位 一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。就绪状态是指线程具备运行的所有条件，逻辑上可以运行，在等待处理机；运行状态是指线程占有处理机正在运行；阻塞状态是指线程在等待一个事件（如某个信号量），逻辑上不可执行。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。 进程和线程的区别有以下几点： 调度：在多线程os中，线程是调度和分配的基本单位，进程是资源分配的最小单位。在同一进程中，线程的切换不会引起进程的切换。线程上下文切换比进程上下文切换要快很多 资源：进程是拥有资源的一个基本单位，他可以拥有自己的资源，一般地说，线程不拥有系统资源(只有一些必不可少的资源)，但它可以访问其隶属进程的资源 系统开销：在创建和销毁进程时，系统都要为之分配和回收资源，因此，操作系统所付出的开销显著的大于创建或销毁线程的开销 通信：进程间通信IPC，线程间可以直接读写进程数据段(如全局变量)来进行通信 在多线程os中，进程不是一个可执行的实体 对比维度 进程 线程 数据共享、同步 数据共享复杂，需要用IPC；数据是分开的，同步简单 因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂 内存、CPU 占用内存多，切换复杂，CPU利用率低 内存占用少，切换简单，CPU利用率高 创建销毁、切换 创建销毁、切换复杂，速度慢 创建销毁、切换简单，速度很快 编程、调试 编程简单，调试简单 编程复杂，调试复杂 可靠性 进程间不会互相影响 线程可能会引起进程异常 分布式 适用于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单 适用于多核分布式 哈希表哈希表(Hash table, 也叫散列表)，是根据 key 而直接访问在内存存储位置的数据结构。哈希表本质是一个数组， 通过哈希函数(散列函数)将 key 转换成 index，根据 index 在数组中找到相应的数据。举个例子：为了在电话本中查找某人的号码，可以创建一个按照人名首字母顺序排列的表，在首字母为“W”的表中查找“王”姓的电话号码，显然比直接查找就要快的多。这里使用人名作为 key，“取首字母“就是这个例子中的哈希函数 F()，存放首字母的表对应哈希表。 不管哈希函数设计的如何完美，都可能出现不同的 key 经过哈希函数处理后得到相同的 hash 值。解决哈希冲突的方法，常见的有下面两种： 开放定址法：使用两个大小为N的数组(一个存放keys，一个存放values)。使用数组中的空位解决碰撞，当碰撞发生时，直接 hash 值+1，如果此时对应下标的位置仍被占用，则 hash 值继续+1；如果位置为空，则将 key 存放在此位置中。举个例子：将关键字为{89, 18, 49, 48, 69}插入到一个散列表中。假定取关键字除以10的余数为哈希函数法则。 散列地址 空表 插入89 插入18 插入49 插入58 插入69 0 49 49 49 1 58 58 2 69 3 4 5 6 7 8 18 18 18 18 9 89 89 89 89 89 第一次冲突发生在填装49的时候。地址为9的单元已经填装了89这个关键字，所以取49的哈希值并+1，得到10，也就是0，发现该地址为空，所以将49填装在地址为0的空单元。第二次冲突则发生在58上，取哈希值为8，因为位置9和0都已经占用，往下查找3个单位，将58填装在地址为1的空单元。69同理。 拉链法：将哈希表同一个存储位置的所有元素保存在一个链表中。实现时，一种策略是散列表同一位置的所有冲突结果都是用栈存放的，即新元素被插入到链表头中。简单讲就是数组+链表 iOS 关联对象及 weak 对象均以该方法储存。 原子性原子指化学反应中的基本为例，原子在化学反应中不可分割。计算机中所谓原子性是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何的上下文切换(context switch)。 临界区临界区指的是一个访问共享资源的代码片段，并非一种机制或是算法。一个程序可以拥有多个临界区域。当有一个线程在访问临界区，那么其它线程将被挂起。临界区被释放后，其它线程可继续抢占该临界区 锁在计算机科学中，锁是一种同步机制，用于限制多线程环境中对临界区的访问，你可以理解锁是用于排除并发的一种的策略。但如果使用不当，可能会引起死锁，锁封护(lock convoying，多个同优先级的线程重复竞争同一把锁，此时大量虽然被唤醒而得不到锁的线程被迫进行调度切换)等不良影响。 互斥锁互斥锁是一种用于多线程编程中，防止两条线程同时对同一公共资源(比如全局变量)进行读写的机制。互斥锁是排它的，当锁被某个线程获取之后，其它访问临界区的线程进入阻塞态。只有当获取了锁的线程释放这个锁，被阻塞的线程才会被唤醒进入运行态。 举个例子：一段代码（甲）正在分步修改一块数据。这时，另一条线程（乙）由于一些原因被唤醒。如果乙此时去读取甲正在修改的数据，而甲碰巧还没有完成整个修改过程，这个时候这块数据的状态就处在极大的不确定状态中，读取到的数据当然也是有问题的。更严重的情况是乙也往这块地方写数据，这样的一来，后果将变得不可收拾。因此，多个线程间共享的数据必须被保护。达到这个目的的方法，就是确保同一时间只有一个临界区域处于运行状态，而其他的临界区域，无论是读是写，都必须被挂起并且不能获得运行机会。 互斥锁在申请锁时，调用了pthread_mutex_lock方法，它在不同的系统上实现各有不同，有时候它的内部是使用信号量来实现，即使不用信号量，也会调用到lll_futex_wait函数，从而导致线程休眠。上文说到如果临界区很短，忙等的效率也许更高，所以在有些版本的实现中，会首先尝试一定次数(比如 1000 次)的 test-and-test，这样可以在错误使用互斥锁时提高性能。另外，由于pthread_mutex有多种类型，可以支持递归锁等，因此在申请加锁时，需要对锁的类型加以判断，这也就是为什么它和信号量的实现类似，但效率略低的原因。 @synchronized使用方式： 123@synchronized (obj) { // do something...} @synchronized(id obj)关键字锁，使用的时候需要添加一个OC对象。在很多情况下，@synchronized 的可读性更高，使用更方便。开始的时候，我一直不敢用这个锁。因为我不知道 obj 需要什么样子的变量才可以，局部变量有用吗，还是一定需要全局变量什么的？但是看了关于 @synchronized，这儿比你想知道的还要多这篇博客之后，理解了它的实现原理，才明白，obj只要是个oc对象就行，当然，在实际使用的时候，你输入的这个对象最好不可以被外界所修改。 现在简单讲解一下关于 @synchronized，这儿比你想知道的还要多这篇博客里面 @synchronized 的工作原理： @synchronized 使用哈希链表的方式存储锁SyncData。SyncData 是链表上的元素，每个SyncData都有一个递归互斥锁recursive_mutex_t mutex，一个id object(传入的obj)，一个int threadCount(使用或等待的线程数量，等于0代表这个锁可以被复用)以及下一个节点struct SyncData* nextData。结构体SyncList的成员变量SyncData *data用来记录链表上的头节点，spinlock_t lock用来防止多线程并发对链表进行修改 当你调用 @synchronized(obj) 时，首先会根据 obj 的内存地址计算出其哈希值，然后在哈希表上找到相应的SyncList实例，接下来根据 obj 来查找有没有未被使用(threadCount == 0)的SyncData实例，如果有则使用这个锁；如果没有则新建一个SyncData锁实例，将锁插入到链表的SyncList的头结点中(这样查找会快一点，因为新建的锁往往使用的频繁一点)。上面的查找和新建过程都是加锁的，结束后解锁。 使用时可能有两种特殊情况 输入 nil此时 @synchronized 不起作用，即锁不生效 输入的 obj 在 @synchronized 的 block 里面被释放掉了对 @synchronized 的使用没有影响。你可以使用clang -rewrite-objc xx.m将代码转换成 C++ 实现 123456789101112131415161718192021222324252627// 代码- (void)foo { NSObject *object = [NSObject new]; @synchronized (object) { NSLog(@&quot;测试@synchronized&quot;); }}// c++实现static void _I_MyObject_foo(MyObject * self, SEL _cmd) { NSObject *object = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;new&quot;)); { id _rethrow = 0; id _sync_obj = (id)object; objc_sync_enter(_sync_obj);try { struct _SYNC_EXIT { _SYNC_EXIT(id arg) : sync_exit(arg) {} ~_SYNC_EXIT() {objc_sync_exit(sync_exit);} id sync_exit; } _sync_exit(_sync_obj); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h0_ybj03b8d0mj52n8dx82v2br40000gn_T_MyObject_807aa3_mi_1); } catch (id e) {_rethrow = e;}{ struct _FIN { _FIN(id reth) : rethrow(reth) {} ~_FIN() { if (rethrow) objc_exception_throw(rethrow); } id rethrow; } _fin_force_rethow(_rethrow);}}} 看到这几行代码id _rethrow = 0; id _sync_obj = (id)object; objc_sync_enter(_sync_obj);，在内部会将 obj 的值复制一份，所以即使你将 obj 置为 nil，还是能够正常使用。 pthread_mutexpthread_mutex 的常见用法如下： 12345678910pthread_mutexattr_t attr; pthread_mutexattr_init(&amp;attr); pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_NORMAL); // 定义锁的属性pthread_mutex_t mutex; pthread_mutex_init(&amp;mutex, &amp;attr) // 创建锁pthread_mutex_lock(&amp;mutex); // 申请锁 // 临界区pthread_mutex_unlock(&amp;mutex); // 释放锁 对于 pthread_mutex 来说，它的用法和之前没有太大的改变，比较重要的是锁的类型，可以有PTHREAD_MUTEX_NORMAL、PTHREAD_MUTEX_ERRORCHECK、PTHREAD_MUTEX_RECURSIVE等等，具体的特性就不做解释了，网上有很多相关资料。一般情况下，一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃。假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。然而这种情况经常会发生，比如某个函数申请了锁，在临界区内又递归调用了自己。辛运的是 pthread_mutex 支持递归锁，也就是允许一个线程递归的申请锁，只要把 attr 的类型改成 PTHREAD_MUTEX_RECURSIVE 即可。 NSLock 和 NSRecursiveLock使用方式： 1234567891011- (void)foo { NSLock *lock = [NSLock new]; [lock lock]; // do something... [lock unlock]; NSRecursiveLock *recursiveLock = [NSRecursiveLock new]; [recursiveLock lock]; // do something... [recursiveLock unlock];} NSLock 和 NSRecursiveLock 是 Objective-C 以对象的形式暴露给开发者的一种锁，它们的内部实现都是使用的pthread_mutex，属性为PTHREAD_MUTEX_ERRORCHECK，它会损失一定新能换来错误提示。理论上来说，NSLock 和 pthread_mutex 拥有相同的运行效率，实际由于封装的原因会略慢一点。由于有缓存存在，相差不会很多。 NSRecursiveLock 与 NSLock 的区别在于内部封装的 pthread_mutex_t 对象的类型不同，NSRecursiveLock 的类型为 PTHREAD_MUTEX_RECURSIVE。 自旋锁自旋锁是计算机科学用于多线程同步的一种锁，线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。 自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。因此操作系统的实现在很多地方往往用自旋锁。Windows操作系统提供的轻型读写锁（SRW Lock）内部就用了自旋锁。显然，单核CPU不适于使用自旋锁，这里的单核CPU指的是单核单线程的CPU，因为，在同一时间只有一个线程是处在运行状态，假设运行线程A发现无法获取锁，只能等待解锁，但因为A自身不挂起，所以那个持有锁的线程B没有办法进入运行状态，只能等到操作系统分给A的时间片用完，才能有机会被调度。这种情况下使用自旋锁的代价很高。 获取、释放自旋锁，实际上是读写自旋锁的存储内存或寄存器。因此这种读写操作必须是原子的。通常用test-and-set(TLS 检查并设置)等原子操作来实现。 OSSpinLock使用方式： 1234567891011121314151617181920212223#import &lt;libkern/OSAtomic.h&gt;- (void)foo { __block OSSpinLock osLock = OS_SPINLOCK_INIT; // 线程1 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{ NSLog(@&quot;线程1 准备上锁&quot;); OSSpinLockLock(&amp;osLock); NSLog(@&quot;线程1&quot;); OSSpinLockUnlock(&amp;osLock); NSLog(@&quot;线程1 解锁完成&quot;); }); // 线程2 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), ^{ NSLog(@&quot;线程2 准备上锁&quot;); OSSpinLockLock(&amp;osLock); NSLog(@&quot;线程2&quot;); OSSpinLockUnlock(&amp;osLock); NSLog(@&quot;线程2 解锁完成&quot;); });} 由于使用OSSpinLock的使用中可能会出现优先级反转的问题，苹果在 iOS10 发布之后，将 OSSpinLock 比较为了 Deprecated，并且提供了新的 os_unfair_lock 作为代替。 优先级翻转：有高优先级任务 a，低优先级任务 b，资源 y。b 获得锁并在访问 y，a 在等待。此时由于自旋锁，所以 a 处于忙等状态而占用大量 CPU，此时 b 无法获得时间片，而一直无法完成任务，释放掉锁。详细可以看这篇博客不再安全的 OSSpinLock os_unfair_lock使用方式： 12345678910#include &lt;os/lock.h&gt;// 初始化os_unfair_lock_t lock;lock = &amp;(OS_UNFAIR_LOCK_INIT);// 加锁os_unfair_lock_lock(lock);// 临界区// 解锁os_unfair_lock_unlock(lock); 自旋锁和互斥锁的对比相同点： 都能保证同一时间只有一个线程访问共享资源。都能保证线程安全 不同点： 互斥锁：如果共享数据已经有其他线程加锁了，线程会进入休眠状态等待锁。一旦被访问的资源被解锁，则等待资源的线程会被唤醒 自旋锁：如果共享数据已经有其他线程加锁了，线程会以死循环的方式等待锁，一旦被访问的资源被解锁，则等待资源的线程会立即执行 自旋锁的效率高于互斥锁，因为没有切换线程的消耗 信号量信号量（英语：semaphore）又称为信号标，是一个同步对象，用于保持在0至指定最大值之间的一个计数值。当线程完成一次对该 semaphore 对象的等待（wait）时，该计数值减一；当线程完成一次对 semaphore 对象的释放（release）时，计数值加一。当计数值为0，则线程等待该 semaphore 对象不再能成功直至该 semaphore 对象变成 signaled 状态。semaphore 对象的计数值大于0，为 signaled 状态；计数值等于0，为 nonsignaled 状态. semaphore 对象适用于控制一个仅支持有限个用户的共享资源，是一种不需要使用忙碌等待（busy waiting）的方法。 信号量的概念是由荷兰计算机科学家艾兹赫尔·戴克斯特拉（Edsger W. Dijkstra）发明的，广泛的应用于不同的操作系统中。在系统中，给予每一个进程一个信号量，代表每个进程当前的状态，未得到控制权的进程会在特定地方被强迫停下来，等待可以继续进行的信号到来。如果信号量是一个任意的整数，通常被称为计数信号量（Counting semaphore），或一般信号量（general semaphore）；如果信号量只有二进制的0或1，称为二进制信号量（binary semaphore）。在linux系统中，二进制信号量（binary semaphore）又称互斥锁（Mutex）。 dispatch_semaphore_t使用方式： 1234567// 创建一个信号量5的锁dispatch_semaphore_t lock = dispatch_semaphore_create(5);// 如果信号量的值 &gt; 0，就让信号量的值减1，然后继续往下执行代码// 如果信号量的值 &lt;= 0，就会休眠等待，直到信号量的值变成&gt;0，就让信号量的值减1，然后继续往下执行代码dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);// 让信号量的值+1dispatch_semaphore_signal(lock); 注意，正常的使用顺序是先降低(wait)然后再提高(signal)，这两个函数通常成对使用。 信号量是允许并发访问的，也就是说，允许多个线程同时执行多个任务。信号量可以由一个线程获取，然后由不同的线程释放。 在dispatch_semaphore_wait()函数中，第二个参数超时时间我们可以选择DISPATCH_TIME_NOW或者DISPATCH_TIME_FOREVER。根据这个值，信号量最终会表现为互斥或者自旋的方式实现，这也是为什么评测中信号量性能总是优于互斥低于自旋。虽然信号量的性能不是最优，但是这种结合方案保证了它的作用范围更大。 条件锁在线程间的同步中，有这样一种情况：线程 A 需要等条件 C 成立,才能继续往下执行.现在这个条件不成立，线程 A 就阻塞等待。而线程 B 在执行过程中，使条件 C 成立了，就唤醒线程 A 继续执行。对于上述情况，可以使用条件变量来操作。 条件变量，类似信号量，提供线程阻塞与信号机制，可以用来阻塞某个线程，等待某个数据就绪后，随后唤醒线程。一个条件变量总是和一个互斥量搭配使用。 NSCodition它通常用于表明共享资源是可被访问或者确保一系列任务能按照指定的执行顺序执行。如果一个线程视图访问一个共享资源，而正在访问该资源的线程将其条件设置为不可访问，那么该线程会被阻塞，直到正在访问该资源的线程将访问条件更改为可访问状态或者说给被阻塞的线程发送信号后，被阻塞的线程才能正常访问这个资源。 NSCondition 的底层是通过条件变量(condition variable) pthread_cond_t 来实现的。条件变量有点像信号量，提供了线程阻塞与信号机制，因此可以用来阻塞某个线程，并等待某个数据就绪，随后唤醒线程，比如常见的生产者-消费者模式。 1234567891011121314151617@property (nonatomic, strong) NSCondition *lock;- (void)customer { [_lock lock]; while (!data) { [lock wait]; } // 消费者消费数据 [_lock unlock];}- (void)producer { [_lock lock]; // 生产数据 [_lock signal]; [_lock unlock];} NSCodition 可以给每个每个线程加锁，加锁后线程仍旧能够进入临界区。所以 NSCodition 使用 wait 并加锁之后，并不能真正的保证线程安全。当一个 broadcast 操作发出后，如果有两个线程都在做消费者操作，那同时都会消耗掉资源，可能会引发错误。所以我们在方法customer中，使用while (!data)来判断资源是否存在，而不是if (!data)。注意：signal只能唤醒单个 race 竞太，而broadcast是广播，唤醒所有 NSCoditionLockNSConditionLock 称为条件锁，只有 condition 参数与初始化时候的 condition 相等，lock 才能正确进行加锁操作。 这里分清两个概念： unlockWithCondition: 它是先解锁，再修改 condition 参数的值。 并不是当 condition 符合某个件值去解锁。 lockWhenCondition: 它与unlockWithCondition:不一样，不会修改 condition 参数的值，而是符合 condition 的值再上锁。 在这里可以利用 NSConditionLock 实现任务之间的依赖. 条件变量和信号量的区别每个信号量都有一个与之关联的值，signal 时+1，wait 时-1，任何线程都可以发出一个信号，即使没有线程在等待该信号量的值。可是对于条件变量，例如 signal 发出信号后，没有任何线程阻塞在wait 上，那这个条件变量上的信号会直接丢失掉。条件变量 NSCodition 可以使用方法broadcast唤醒所有阻塞的线程。 读写锁读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。这种锁相对于自旋锁而言，能提高并发性，因为在多处理器系统中，它允许同时有多个读者来访问共享资源，最大可能的读者数为实际的逻辑CPU数。写者是排他性的，一个读写锁同时只能有一个写者或多个读者（与CPU数相关），但不能同时既有读者又有写者。 pthread_rwlock使用方式： 1234567891011121314151617181920#import &lt;pthread.h&gt;//初始化锁pthread_rwlock_t lock;pthread_rwlock_init(&amp;lock, NULL); //读加锁pthread_rwlock_rdlock(&amp;lock);//读尝试加锁pthread_rwlock_trywrlock(&amp;lock); //写加锁pthread_rwlock_wrlock(&amp;lock);//写尝试加锁pthread_rwlock_trywrlock(&amp;lock); //解锁pthread_rwlock_unlock(&amp;lock);//销毁pthread_rwlock_destroy(&amp;lock); 同一时间，只能有1个线程进行写操作 同一时间，允许多个线程进行读操作 同一时间，不允许同时有读和写操作 具体使用： 123456789101112131415161718192021222324252627282930#import &lt;pthread.h&gt;@property (nonatomic, assign) pthread_rwlock_t lock;- (void)foo { pthread_rwlock_init(&amp;_lock, NULL); dispatch_queue_global_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); for (int i = 0; i &lt; 100; i++) { dispatch_async(queue, ^{ [self read]; }); dispatch_async(queue, ^{ [self write]; }); }}- (void)read { pthread_rwlock_rdlock(&amp;_lock); sleep(1); NSLog(@&quot;%s&quot;, __func__); pthread_rwlock_unlock(&amp;_lock);}- (void)write { pthread_rwlock_wrlock(&amp;_lock); sleep(1); NSLog(@&quot;%s&quot;, __func__); pthread_rwlock_unlock(&amp;_lock);} barrierdispatch_barrier_async和dispatch_barrier_sync的共同点： 会先完成在它们前面插入的任务，然后再执行自己的任务 执行完自己的任务，再执行后面插入的任务 不同点： dispatch_barrier_sync会先将自己的任务执行完，在会插入后面的任务 dispatch_barrier_sync不会等自己的任务执行完，就会把后面的任务插入队列，然后等待自己的任务结束在执行后面的任务 注意： dispatch_barrier_async和dispatch_barrier_sync指定的队列必须是自己创建的并发队列，如果是串行队列或者全局并发队列，那么这两个方法的行为就会类似dispatch_async和dispatch_sync dispatch_barrier_sync 如果指定当前队列可能会引起死锁 具体使用： 12345678910111213141516171819202122232425262728293031323334- (void)foo { dispatch_queue_t queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^{ NSLog(@&quot;test1&quot;); }); dispatch_async(queue, ^{ NSLog(@&quot;test2&quot;); }); dispatch_async(queue, ^{ NSLog(@&quot;test3&quot;); }); dispatch_barrier_async(queue, ^{ for (int i = 0; i &lt;= 50000000; i++) { if (5000 == i) { NSLog(@&quot;point1&quot;); }else if (6000 == i) { NSLog(@&quot;point2&quot;); }else if (7000 == i) { NSLog(@&quot;point3&quot;); } } NSLog(@&quot;barrier&quot;); }); NSLog(@&quot;aaa&quot;); dispatch_async(queue, ^{ NSLog(@&quot;test4&quot;); }); dispatch_async(queue, ^{ NSLog(@&quot;test5&quot;); }); dispatch_async(queue, ^{ NSLog(@&quot;test6&quot;); });} GCD串行和并发队列dispatch queue分发队列，我喜欢叫它任务分发队列，而任务就是我们在 block 中写的代码。任务队列有两种： 串行：当一个任务执行完，才能执行下一个任务。 并行：当一个任务刚提交，不需要等它结束，就开始执行下一个任务。并发队列支持障碍任务（barrier block） 这两种队列均遵循 FIFO 原则，即先提交的任务先执行，举个简单的例子：有三个任务，三个任务的输出分别是1，2，3。串行队列输出的结果是1，2，3；而并行队列的输出结果就不一定了。 虽然并行队列可以同时执行多个任务，但还是需要当前系统的状态来。如果当前系统最多只能处理2个任务，那么1、2就会排在前面先执行，等其中一个任务结束了，再执行任务3。 同步和异步同步和异步针对的是线程。 同步任务： 同步任务会阻塞当前线程，必须等待任务执行完毕返回，才能继续执行下一个任务 作为一个优化，可能会在当前线程执行同步任务，因为切换线程需要消耗较多资源。但如果是在主队列中，则该任务会在主线程中执行 在当前队列中执行同步任务会导致死锁。 异步任务： 提交完任务后就立即返回，不会等待任务执行完毕。不会阻塞当前线程，会开启新的线程 这里结合队列举几个例子例子1： 1234567891011121314151617- (void)foo { dispatch_queue_t queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_SERIAL); NSLog(@&quot;任务0&quot;); dispatch_sync(queue, ^{ sleep(1); NSLog(@&quot;任务1 %@&quot;, [NSThread currentThread]); }); dispatch_async(queue, ^{ sleep(10); NSLog(@&quot;任务2 %@&quot;, [NSThread currentThread]); }); dispatch_sync(queue, ^{ NSLog(@&quot;任务3 %@&quot;, [NSThread currentThread]); }); NSLog(@&quot;任务4&quot;);} 输出结果如下： 123452019-08-23 11:18:06.165116+0800 190611[6192:1600283] 任务02019-08-23 11:18:07.166471+0800 190611[6192:1600283] 任务1 &lt;NSThread: 0x280a95dc0&gt;{number = 1, name = main}2019-08-23 11:18:17.167838+0800 190611[6192:1600318] 任务2 &lt;NSThread: 0x280414100&gt;{number = 3, name = (null)}2019-08-23 11:18:17.168202+0800 190611[6192:1600283] 任务3 &lt;NSThread: 0x280a95dc0&gt;{number = 1, name = main}2019-08-23 11:18:17.168329+0800 190611[6192:1600283] 任务4 分析一下代码的执行流程： 创建一个串行队列。串行队列里的任务是顺序执行的，且需要当前任务执行返回，才能执行下一个任务 任务1是同步任务，会阻塞当前线程(主线程)。任务1在主线程中执行 等任务1执行后，执行任务2。任务2是一个异步任务，所以在一个新线程中执行。当任务2执行完毕(过了10秒)，执行任务3 任务3是一个同步任务，阻塞当前线程。任务3在主线程中执行 任务3执行完毕后，主线程不再被阻塞，执行任务4 通过上面的例子，我们可以得出这样的结论： 串行中的任务遵循先提交新执行的原则，且是按顺序一个一个执行的。不管任务是同步的还是异步的 同步任务会在当前线程中执行，并阻塞当前线程。异步任务会在一个新的线程中执行 例子2： 1234567891011121314151617- (void)foo { dispatch_queue_t queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_CONCURRENT); NSLog(@&quot;任务0&quot;); dispatch_sync(queue, ^{ sleep(1); NSLog(@&quot;任务1 %@&quot;, [NSThread currentThread]); }); dispatch_async(queue, ^{ sleep(10); NSLog(@&quot;任务2 %@&quot;, [NSThread currentThread]); }); dispatch_sync(queue, ^{ NSLog(@&quot;任务3 %@&quot;, [NSThread currentThread]); }); NSLog(@&quot;任务4&quot;);} 输出结果如下： 123452019-08-23 11:26:58.546591+0800 190611[6206:1601450] 任务02019-08-23 11:26:59.547963+0800 190611[6206:1601450] 任务1 &lt;NSThread: 0x280283c40&gt;{number = 1, name = main}2019-08-23 11:26:59.548243+0800 190611[6206:1601450] 任务3 &lt;NSThread: 0x280283c40&gt;{number = 1, name = main}2019-08-23 11:26:59.548320+0800 190611[6206:1601450] 任务42019-08-23 11:27:09.553363+0800 190611[6206:1601490] 任务2 &lt;NSThread: 0x280c060c0&gt;{number = 3, name = (null)} 分析一下代码的执行流程： 创建一个并行队列。并行队列里的任务也是顺序执行的，但不需要当前任务结束返回就能执行下一个任务 任务1是一个同步任务，会阻塞当前线程(主线程)，并且执行任务(耗时1秒)。结束后，释放线程。执行任务3 任务3也是一个同步任务，会阻塞当前线程(主线程)。结束后，执行任务4 任务2是一个异步任务，虽然这个任务的提交时间跟任务1差不多，但它需要执行(10秒)，所以它是最后才完成的 通过上面的例子，我们可以得出这样的结论： 并发队列虽然是”并发”，但仍是按照任务提交顺序来执行任务的，只不过它不需要等待任务结束返回就可以开始执行下一个任务，所以表现起来像是并发的。 在上面的例子中，任务1和任务3同样都是同步任务。同步任务会阻塞当前线程，任务1因为先提交所以先执行，然后阻塞主线程。任务3虽然在任务1执行后也跟着执行，但是因为主线程被任务1阻塞了，所以必须等待任务1执行完毕释放线程才能接着执行任务 下面我提几个问题，因为我在我好多博客里都看到了错误的结论 在主队列中使用同步任务是否会造成死锁？ 如果你直接在主线程中使用主队列提交一个同步任务是会造成死锁的。但下面这种情况就不会例子3： 123456789- (void)foo { dispatch_queue_t queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^{ dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@&quot;任务1&quot;); }); }); NSLog(@&quot;任务0&quot;);} 输出结果是 122019-08-23 14:35:44.580059+0800 190611[6310:1614276] 任务02019-08-23 14:35:44.587546+0800 190611[6310:1614276] 任务1 为什么呢？同步任务往往会阻塞当前线程，任务1在一个异步任务中提交，而异步任务中会创建一个新线程。所以，任务1仅仅是阻塞了这个新的线程。主队列是一个串行队列，任务0是可以算作提交的第一个任务，任务1是后面提交的任务，所以先执行任务1，再执行任务1. 还有很多说在并行队列中同步任务是顺序执行的 在并行队列中的同步任务是否是顺序执行的？ 在上面的例子2中是顺序执行，但下面这个例子里的就不会例子4： 12345678910111213dispatch_queue_t queue1 = dispatch_queue_create(NULL, DISPATCH_QUEUE_CONCURRENT);dispatch_queue_t queue2 = dispatch_queue_create(NULL, DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue2, ^{ dispatch_sync(queue1, ^{ sleep(3); NSLog(@&quot;任务1&quot;); });});dispatch_sync(queue1, ^{ NSLog(@&quot;任务2&quot;);});NSLog(@&quot;任务0&quot;); 输出结果： 1232019-08-23 14:56:55.999218+0800 190611[6346:1617197] 任务22019-08-23 14:56:55.999259+0800 190611[6346:1617197] 任务02019-08-23 14:56:59.008903+0800 190611[6346:1617213] 任务1 在任务2顺序执行的原因是在第一个同步任务阻塞了当前的线程。但在这个例子中，第一个同步任务，阻塞的是异步任务中创建的新线程，而不是主线程，所以第二个同步任务任务2会率先完成。 所以不要去背别人写好的规则，要学会自己去分析。下面是几点总结，类似于数学中的”公理“，能帮助你分析 串行和并行队列，都是先执行先提交的任务。串行会等这个任务结束再执行下一个任务，而并行队列不会等它结束就执行下一个任务 同步任务会在当前线程中执行，除了主队列提交的同步任务会在主线程中执行 异步任务中会创建一个新的线程 更难的案例分析案例1 1234567- (void)foo { NSLog(@&quot;任务1&quot;); dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{ NSLog(@&quot;任务2&quot;); }); NSLog(@&quot;任务3&quot;);} 输出结果： 1232019-08-23 15:07:03.149869+0800 190611[6361:1618423] 任务12019-08-23 15:07:03.149920+0800 190611[6361:1618423] 任务22019-08-23 15:07:03.149937+0800 190611[6361:1618423] 任务3 这里谈一下我的理解 首先我会将 foo() 这个方法当做在主队列中的第一个同步任务，把它叫做任务0好了 任务0在主线程中执行。任务2是一个同步任务，所以它会阻塞主线程。任务2提交到了一个并发队列中，而不是主队列，所以不会造成死锁。 任务2完成，释放主线程，执行任务3 如果把任务2中的队列替换成主队列，就会造成死锁。 1234567- (void)foo { NSLog(@&quot;任务1&quot;); dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@&quot;任务2&quot;); }); NSLog(@&quot;任务3&quot;);} 原因是主队列是一个串行队列，任务按顺序执行。所以先要执行任务0，而任务2需要任务0执行完毕才能执行，但是任务2会阻塞主线程，导致两个任务谁都无法完成，造成死锁。 案例2 123456789101112- (void)foo { dispatch_queue_t queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_SERIAL); NSLog(@&quot;任务1&quot;); dispatch_async(queue, ^{ NSLog(@&quot;任务2&quot;); dispatch_sync(queue, ^{ NSLog(@&quot;任务3&quot;); }); NSLog(@&quot;任务4&quot;); }); NSLog(@&quot;任务5&quot;); } 输出结果是 1，5，2 或者是 1，2，5 分析流程： 首先执行任务1 创建一个串行队列，并添加一个异步任务。由于异步任务和任务5不知道哪个会先执行，所以输出结果可能是 1，5，2 或者是 1，2，5 在异步任务中，首先执行任务2.然后在当前串行队列中使用了同步任务，造成死锁 案例3 12345678910111213- (void)foo { dispatch_async(dispatch_get_global_queue(0, 0), ^{ NSLog(@&quot;任务1&quot;); dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@&quot;任务2&quot;); }); NSLog(@&quot;任务3&quot;); }); NSLog(@&quot;任务4&quot;); while (1) { } NSLog(@&quot;任务5&quot;); } 输出结果是 1,4 或者是 4,1分析流程： 首先在并行队列中添加一个异步任务，所以不确定任务1跟任务4哪个先执行。所以输出结果是 1,4 或者是 4,1 在异步任务中，先执行任务1。然后碰到一个主队列的同步任务，由于是同步任务，所以会阻塞当前线程。该同步任务会等待主队列中的任务5执行完成然后再执行，但是任务5前面有一个死循环，所以任务5永远不会完成，也就是任务2永远无法完成，于是会一直卡着线程 总结写了很多，写的也很杂，但如果你想了解锁，了解多线程的话，这些知识都是少不了的。为了让硬件得到充分利用，我们会使用 GCD 来使用多线程，而为了多线程安全，我们又会使用锁。学习本身也是一个递归的过程，希望大家看完能有所收货~","link":"/2019/08/23/iOS%E7%9A%84%E9%94%81%E4%BB%A5%E5%8F%8AGCD%E7%9B%B8%E5%85%B3/"},{"title":"[self class]和[super class]","text":"今天在学习runtime的时候，碰到一个有意思的题目，相信很多人都曾经看到过： 1234567891011@implementation Son : Father- (id)init { self = [super init]; if (self) { NSLog(@&quot;%@&quot;, NSStringFromClass([self class])); NSLog(@&quot;%@&quot;, NSStringFromClass([super class])); } return self;}@end 输出为Son和Son，为什么呢？当我们使用 clang -rewrite-objc Son.m文件，可以看到 12NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_xy_nncr8hn96cd0_rdymw2f0qcw0000gn_T_MyObject_bf216e_mi_1, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(&quot;class&quot;)))); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_xy_nncr8hn96cd0_rdymw2f0qcw0000gn_T_MyObject_bf216e_mi_2, NSStringFromClass(((Class (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){(id)self, (id)class_getSuperclass(objc_getClass(&quot;Son&quot;))}, sel_registerName(&quot;class&quot;)))); 这里需要明白以下几个概念： 方法中的隐藏参数 self我们经常在方法中使用self关键字来引用实例本身，但从没有想过为什么self就能取到调用当前方法的对象吧。其实self的内容是在方法运行时被偷偷的动态传入的。当objc_msgSend找到方法对应的实现时，它将直接调用该方法实现，并将消息中所有的参数都传递给方法实现,同时,它还将传递两个隐藏的参数: 接收消息的对象（也就是self指向的内容） 方法选择器（_cmd指向的内容）之所以说它们是隐藏的是因为在源代码方法的定义中并没有声明这两个参数。它们是在代码被编译时被插入实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。 12static void _I_MyObject_test(MyObject * self, SEL _cmd) {} 使用 clang 将代码转换成C++实现，我们可以看到方法的两个隐藏参数 self 和 _cmd objc_msgSend 和 objc_msgSendSuper的定义先给出 objc_msgSend 和 objc_msgSendSuper的定义： 123id objc_msgSend(id self, SEL op, ...)id objc_msgSendSuper(struct objc_super *super, SEL op, ...) 而 ‘objc_super’的定义如下： 1234struct objc_super { __unsafe_unretained id receiver; __unsafe_unretained Class super_class;}; - (Class)class 方法的实现123- (Class)class { return object_getClass(self);} 现在再让我们看一下调用 [super class] 会发生什么 当我们对 super 关键字发送消息时，编译器会创建一个 objc_super 的结构体，其中 receiver 仍旧为 self，而super_class为父类 调用 objc_msgSendSuper()方法，会去 Father 的实例方法列表中寻找 class 这个方法，找不到，去 NSObject 中查找 调用 NSObject 的 - (Class)class 方法，因为隐藏参数 self 为 son的实例，所以返回 Son 所以当我们调用 [self class] 和 [super class] 方法返回的都是 Son。 加入我们在Father中重载 -(Class)class 方法 123- (Class)class { return NSClassFromString(@&quot;Father&quot;)} 那么得到的输出将变成 Son 和 Father！","link":"/2019/06/13/self-class-%E5%92%8C-super-class/"},{"title":"从源码读懂 Runloop","text":"runloop 是和线程密切相关的一个组件，它帮助线程管理需要被处理的事件和消息，例如网络连接，异步回调，定时器…当有事件或消息要处理时唤醒线程处理，否则休眠等待接收 mach 消息。 runloop 提供了一个入口函数 CFRunLoopRun()。当线程执行这个函数，runloop 就会在默认 mode 下一直处于函数内部 接收消息-&gt;等待-&gt;处理 的循环中，就像它的名字一样 ‘run loop’，在一直跑圈。正在情况下，当休眠时间超时或者当前 mode 中一个 mode item(observer/timer/source) 都没有，则 runloop 会直接退出，不再进入循环。main runloop 的超时时间被设定为 DISPATCH_TIME_FOREVER，且系统会在应用启动时向默认 mode 注册许多的 mode item，这意味着 main runloop 将永远的执行下去，这保证了当前应用能够随时的响应用户时间，但却不一直占用 CPU 资源 runloop 的核心是 mach_msg() 函数。使用这个函数，你可以向指定的 mach port 发送消息或者接受到 other 向某个 mach port 发送的消息，区别在于函数的参数 option 是什么值。在等待过程中，runloop 处于休眠状态且不占用 cpu 资源。 以下内容摘抄自 深入理解RunLoop为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图： 本文所用的源码为 Swift 版本的 CoreFoundation 源码 https://github.com/apple/swift-corelibs-foundation/ runloop 与线程的关系每个线程都有一个对应的 runloop。苹果不允许我们直接创建 runloop ，但他提供了两个函数来获取 runloop：CFRunLoopGetCurrent() 和 CFRunLoopGetMain()。这两个函数的实现如下： 12345678910111213CFRunLoopRef CFRunLoopGetMain(void) { CHECK_FOR_FORK(); static CFRunLoopRef __main = NULL; // no retain needed if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed return __main;}CFRunLoopRef CFRunLoopGetCurrent(void) { CHECK_FOR_FORK(); CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop); if (rl) return rl; return _CFRunLoopGet0(pthread_self());} CHECK_FOR_FORK() 这个宏应该是用来检查是否进程复制，相关内容我不大明白，这里略过。 可以看到这两个函数后面都调用了 _CFRunLoopGet0() 函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// should only be called by Foundation// t==0 is a synonym for &quot;main thread&quot; that always worksCF_EXPORT CFRunLoopRef _CFRunLoopGet0(_CFThreadRef t) { /// kNilPthreadT == (pthread *)0x0 if (pthread_equal(t, kNilPthreadT)) { t = pthread_main_thread_np(); } __CFLock(&amp;loopsLock); if (!__CFRunLoops) { /// 创建缓存字典。随后创建主线程的 run loop，并且以 key(thread)/value(runloop) 的形式保存到缓存字典 CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks); CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np()); /// 将 main runloop 保存到缓存字典中，其中 key 为主线程 CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop); if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) { CFRelease(dict); } CFRelease(mainLoop); } CFRunLoopRef newLoop = NULL; /// 在缓存中查找 runloop 是否已经创建 CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); if (!loop) { /// 如果 runloop 不存在则新建一个，并保存到缓存中 newLoop = __CFRunLoopCreate(t); cf_trace(KDEBUG_EVENT_CFRL_LIFETIME|DBG_FUNC_START, newLoop, NULL, NULL, NULL); CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop); loop = newLoop; } __CFUnlock(&amp;loopsLock); // don't release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it if (newLoop) { CFRelease(newLoop); } if (pthread_equal(t, pthread_self())) { /// TSD means thread specific data _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL); if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) {#if _POSIX_THREADS /// PTHREAD_DESTRUCTOR_ITERATIONS 的定义为 4 _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);#else _CFSetTSD(__CFTSDKeyRunLoopCntr, 0, &amp;__CFFinalizeRunLoop);#endif } } return loop;} _CFRunLoopGet0 函数大致做了下面几样事情 进入到这个函数，首先会判断缓存字典 dict 是否存在，如果不存在则创建 随后在缓存中查找 main runloop 是否存在，若不存在则创建 main runloop，并以 key(thread)/value(runloop) 的形式保存到缓存中， 接着在缓存中查找当前线程对应的 runloop 是否存在，若不存在则创建，并保存到缓存中 在 _CFRunLoopGet0 函数结尾部分可以看到 _CFSetTSD() 和 _CFGetTSD() 这两个函数的出现 TSD 是 thread specific data 的缩写，你也可以叫它为 TLS(Thread-Local Storage)。它是线程私有的数据变量，其它线程无法访问，但同一个线程中的任意函数都可以访问到 下面是它在内存管理中的一个应用：我们知道非 alloc/new/copy/mutableCopy 方法创建的对象，需要先对其 autorelease，随后变量持有时再对其 retain。既然一加一减，那为什么不让变量持有对象呢？于是 ARC 为了优化，使用了objc_autoreleaseReturnValue() 和 objc_retainAutoreleasedReturnValue() 两个函数，在 autorelease 时在 TLS 中存入一个标记，在 retain 时从 TLS 取出这个标记，该标记即用来表示是否使用优化，如果使用，则跳过 autorelease 和 retain 两个步骤。 使用 TSD 时， 我们需要先为其开辟一块内存空间，例如使用 calloc() 函数 使用 pthread_key_create(pthread_key_t *key, void (*destructor)(void *))； 函数，得到一个 pthread_key_t 类型的 key，destructor 函数的作用是线程结束时销毁该快内存。当 key 被创建出来后，任意线程都能访问它，但需要各自为它绑定不同的值 使用 pthread_setspecific(__CFTSDIndexKey, arg) 函数，将 key 与第一步中创建的内存空间绑定 因为每个线程能够拥有的 TSD 数目是有限的，为了节约，所以你可以将 key 与一个数据结构(数组/字典)绑定起来保存在 TSD 中。在 runloop 中，key 对应的数据结构是 __CFTSDTable 在 TSD 。__CFTSDTable 有两个数组类型的成员变量：data 和 destructors。其中 data 用来保存数据，destructors 保存的函数在每次线程退出时调用。数组的容量是一个固定值：CF_TSD_MAX_SLOTS(70)在 _CFSetTSD() 函数中，runloop 在数组下标为 __CFTSDKeyRunLoopCntr(3) 的位置插入数据 (PTHREAD_DESTRUCTOR_ITERATIONS/4/-1) 和函数 __CFFinalizeRunLoop 。当每次线程退出时，调用 __CFFinalizeRunLoop 函数，将下标 __CFTSDKeyRunLoopCntr 对应的值 -1，变为 0 时将 runloop 从缓存中清除 runloop，mode 以及 mode item一个 runloop 可以包含若干 mode，每个 mode 又包含若干 Source/Timer/Observer。但是 runloop 每次只能指定一个 mode 运行，处理该 Mode 里面的 Source/Timer/Observer 事件，这个 mode 被称作 CurrentMode。如果需要切换 mode，可以强制当前 mode 退出(例如 CFRunLoopStop() 函数)，然后再指定别的 mode 进入。苹果的这种设定，我的理解是为了优化效率：将不同的事件归类到不同的 mode 当中，线程只能处理某个 mode 的事件而不是所有的事件 函数 CFRunLoopStop() 可以使得 runloop 强制退出CFRunLoopStop() 函数的作用是将当前 mode 标记为 stopped 状态，然后发送 mach 消息给当前 mode，runloop 被唤醒后识别出 mode 的 stopped 状态，随即退出循环。 CFRunLoop 的结构如下： 1234567891011121314151617181920212223242526272829303132333435struct __CFRunLoop { /// 类似于 isa CFRuntimeBase _base; _CFRecursiveMutex _lock; /* locked for accessing mode list */ /// other 可以向该 mach port 发送消息以唤醒 runloop __CFPort _wakeUpPort; // used for CFRunLoopWakeUp /// 用来记录每次运行主函数时的一次信息，每次进入主函数时重置该属性 volatile _per_run_data *_perRunData; // reset for runs of the run loop /// runloop 对应的线程 _CFThreadRef _pthread; /// 线程，windows 平台下用到的， uint32_t _winthread; /// common 类型的 mode 集合 CFMutableSetRef _commonModes; /// 被添加到 kCFRunLoopCommonModes mode 中的 mode item 集合 CFMutableSetRef _commonModeItems; /// runloop 当前运行的 mode CFRunLoopModeRef _currentMode; /// runloop 拥有的 mode 集合，Set CFMutableSetRef _modes; /// 添加到 runloop 的 block，链表结构，这个是头 struct _block_item *_blocks_head; /// 添加到 runloop 的 block，链表结构，这个是尾 struct _block_item *_blocks_tail; /// runloop 运行时的时间戳，但源码内未见其实用 ？ CFAbsoluteTime _runTime; /// runloop 累计的休眠时间 CFAbsoluteTime _sleepTime; /// 对应的 NSRunLoop 对象 CFTypeRef _counterpart; /// 貌似是用来标记是否在当前线程销毁别的线程的 runloop _Atomic(uint8_t) _fromTSD; /// 设置定时器时用到 CFLock_t _timerTSRLock;}; CFRunLoop 的构建函数如下： 12345678910111213141516171819202122static CFRunLoopRef __CFRunLoopCreate(_CFThreadRef t) { CFRunLoopRef loop = NULL; CFRunLoopModeRef rlm; uint32_t size = sizeof(struct __CFRunLoop) - sizeof(CFRuntimeBase); loop = (CFRunLoopRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, CFRunLoopGetTypeID(), size, NULL); if (NULL == loop) { return NULL; } (void)__CFRunLoopPushPerRunData(loop); _CFRecursiveMutexCreate(&amp;loop-&gt;_lock); loop-&gt;_wakeUpPort = __CFPortAllocate((uintptr_t)loop); if (CFPORT_NULL == loop-&gt;_wakeUpPort) HALT; __CFRunLoopSetIgnoreWakeUps(loop); loop-&gt;_commonModes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks); CFSetAddValue(loop-&gt;_commonModes, kCFRunLoopDefaultMode); loop-&gt;_modes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks); loop-&gt;_pthread = t; loop-&gt;_timerTSRLock = CFLockInit; rlm = __CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, true); if (NULL != rlm) __CFRunLoopModeUnlock(rlm); return loop;} 注意到 runloop 使用 loop-&gt;_wakeUpPort = __CFPortAllocate((uintptr_t)loop); 代码为其生成了一个 wake up port。就像申请了一个 qq 号一样，你可以登录这个账号接收到别人发给你的消息，在这里，runloop 使用这个 mach port 来接受被 wake up 的消息同时，runloop 还会创建一个 kCFRunLoopDefaultMode 默认类型的 mode __CFRunLoopMode 结构如下: 123456789101112131415161718192021222324252627282930313233343536373839404142struct __CFRunLoopMode { CFRuntimeBase _base; _CFRecursiveMutex _lock; /* must have the run loop locked before locking this */ /// mode name，例如 kCFRunLoopDefaultMode CFStringRef _name; /// 标记 mode 是否停止 Boolean _stopped; /// 为了内存对齐 char _padding[3]; /// sources0 集合，Set CFMutableSetRef _sources0; /// sources1 集合，Set CFMutableSetRef _sources1; /// observer 集合，Array CFMutableArrayRef _observers; /// timer 集合，Array CFMutableArrayRef _timers; /// 字典，映射关系 port -&gt; sources1 CFMutableDictionaryRef _portToV1SourceMap; /// 可能接受到 mach 消息的 mach port 集合 __CFPortSet _portSet; /// observer 注册的观察时间点 CFIndex _observerMask;#if USE_DISPATCH_SOURCE_FOR_TIMERS /// dispatch_source_t 类型的定时器 dispatch_source_t _timerSource; /// dispatch_source_t 定时器运行的 dispatch_queue_t dispatch_queue_t _queue;/// Run Loop Mode Queue /// dispatch_source_t 定时器是否被触发 Boolean _timerFired; // set to true by the source when a timer has fired /// 是否设置了 dispatch_source_t 定时器 Boolean _dispatchTimerArmed;#endif /// mk_timer 定时器触发后发送消息的 mach port __CFPort _timerPort; /// 是否设置了 mk_timer 定时器 Boolean _mkTimerArmed; /// 注册在 rlm 的 timer 中，最早的触发时间戳，单位为纳秒 uint64_t _timerSoftDeadline; /* TSR */ /// 注册在 rlm 的 timer 中，最早的触发时间戳 + 宽余量(tolerance)，单位为纳秒 uint64_t _timerHardDeadline; /* TSR */}; Source0/Source1/Timer/Observer 被统称为 mode item，一个 mode item 可以被同时加入多个 mode，但重复加入同一个 mode 时是不会有效果的。Source0/Source1 可以注册到多个 runloop 中，而 Timer/Observer 只能注册在同一个 runloop如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。 有一个特殊的 mode，名字叫做 kCFRunLoopCommonModes，Foundation 中叫 NSRunLoopCommonModes。说它特殊是因为 runloop 并不能在 mode 下运行，但是你却可以往它里面添加 mode item。mode item 添加后会放在 runloop-&gt;_commonModeItems 中，并同步到 ”common“ 类型的 mode 当中。我们熟知的 kCFRunLoopDefaultMode 和 UITrackingRunLoopMode 即是 ”common“ 类型。 我们可以看到 mode 的结构体中定义了两种类型的的定时器(NSTimer 我会称呼为 timer，底层的定时器称呼为 定时器，NSTimer 由 底层定时器实现，后面不在重复)： dispatch_source_t _timerSource mk_timer 实际上，NSTimer 由这两种定时器实现，具体使用哪一种根据创建 NSTimer 时指定的 tolerance(宽余量) 决定。如果 tolerance 为 0 则使用 mk_timer，否则使用 dispatch_source_t。我猜测是因为 mk_timer 精度更高但是不能响应 tolerance，所以在 tolerance 不为 0 的情况下使用 dispatch_source_t。这一部分在将 CFRunLoopTimerRef 这一节时还会介绍 __CFRunLoopMode 的构建函数如下，直接跳过也行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667static CFRunLoopModeRef __CFRunLoopFindMode(CFRunLoopRef rl, CFStringRef modeName, Boolean create) { CHECK_FOR_FORK(); CFRunLoopModeRef rlm; struct __CFRunLoopMode srlm; memset(&amp;srlm, 0, sizeof(srlm)); _CFRuntimeSetInstanceTypeIDAndIsa(&amp;srlm, _kCFRuntimeIDCFRunLoopMode); srlm._name = modeName; rlm = (CFRunLoopModeRef)CFSetGetValue(rl-&gt;_modes, &amp;srlm); if (NULL != rlm) { __CFRunLoopModeLock(rlm); return rlm; } if (!create) { return NULL; } rlm = (CFRunLoopModeRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, _kCFRuntimeIDCFRunLoopMode, sizeof(struct __CFRunLoopMode) - sizeof(CFRuntimeBase), NULL); if (NULL == rlm) { return NULL; } _CFRecursiveMutexCreate(&amp;rlm-&gt;_lock); rlm-&gt;_name = CFStringCreateCopy(kCFAllocatorSystemDefault, modeName); rlm-&gt;_portSet = __CFPortSetAllocate(); rlm-&gt;_timerSoftDeadline = UINT64_MAX; rlm-&gt;_timerHardDeadline = UINT64_MAX; kern_return_t ret = KERN_SUCCESS;#if TARGET_OS_MAC#if USE_DISPATCH_SOURCE_FOR_TIMERS rlm-&gt;_timerFired = false; rlm-&gt;_queue = _dispatch_runloop_root_queue_create_4CF(&quot;Run Loop Mode Queue&quot;, 0); mach_port_t queuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue); if (queuePort == MACH_PORT_NULL) CRASH(&quot;*** Unable to create run loop mode queue port. (%d) ***&quot;, -1); rlm-&gt;_timerSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, rlm-&gt;_queue); __block Boolean *timerFiredPointer = &amp;(rlm-&gt;_timerFired); dispatch_source_set_event_handler(rlm-&gt;_timerSource, ^{ *timerFiredPointer = true; }); // Set timer to far out there. The unique leeway makes this timer easy to spot in debug output. dispatch_source_set_timer(rlm-&gt;_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 321); dispatch_resume(rlm-&gt;_timerSource); ret = __CFPortSetInsert(queuePort, rlm-&gt;_portSet); if (KERN_SUCCESS != ret) CRASH(&quot;*** Unable to insert timer port into port set. (%d) ***&quot;, ret); #endif#endif rlm-&gt;_timerPort = mk_timer_create(); if (rlm-&gt;_timerPort == MACH_PORT_NULL) { CRASH(&quot;*** Unable to create timer Port (%d) ***&quot;, rlm-&gt;_timerPort); } ret = __CFPortSetInsert(rlm-&gt;_timerPort, rlm-&gt;_portSet); if (KERN_SUCCESS != ret) CRASH(&quot;*** Unable to insert timer port into port set. (%d) ***&quot;, ret); ret = __CFPortSetInsert(rl-&gt;_wakeUpPort, rlm-&gt;_portSet); if (KERN_SUCCESS != ret) CRASH(&quot;*** Unable to insert wake up port into port set. (%d) ***&quot;, ret); #if TARGET_OS_WIN32 rlm-&gt;_msgQMask = 0; rlm-&gt;_msgPump = NULL;#endif CFSetAddValue(rl-&gt;_modes, rlm); CFRelease(rlm); __CFRunLoopModeLock(rlm); /* return mode locked */ return rlm;} 这里有一部分代码比较重要，这里我把它摘出来 123456789101112131415161718192021222324252627 rlm-&gt;_timerFired = false;rlm-&gt;_queue = _dispatch_runloop_root_queue_create_4CF(&quot;Run Loop Mode Queue&quot;, 0);mach_port_t queuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);if (queuePort == MACH_PORT_NULL) CRASH(&quot;*** Unable to create run loop mode queue port. (%d) ***&quot;, -1);rlm-&gt;_timerSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, rlm-&gt;_queue); __block Boolean *timerFiredPointer = &amp;(rlm-&gt;_timerFired);dispatch_source_set_event_handler(rlm-&gt;_timerSource, ^{ *timerFiredPointer = true;}); // Set timer to far out there. The unique leeway makes this timer easy to spot in debug output.dispatch_source_set_timer(rlm-&gt;_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 321);dispatch_resume(rlm-&gt;_timerSource); ret = __CFPortSetInsert(queuePort, rlm-&gt;_portSet);rlm-&gt;_timerPort = mk_timer_create();if (rlm-&gt;_timerPort == MACH_PORT_NULL) { CRASH(&quot;*** Unable to create timer Port (%d) ***&quot;, rlm-&gt;_timerPort);}ret = __CFPortSetInsert(rlm-&gt;_timerPort, rlm-&gt;_portSet);if (KERN_SUCCESS != ret) CRASH(&quot;*** Unable to insert timer port into port set. (%d) ***&quot;, ret);ret = __CFPortSetInsert(rl-&gt;_wakeUpPort, rlm-&gt;_portSet);if (KERN_SUCCESS != ret) CRASH(&quot;*** Unable to insert wake up port into port set. (%d) ***&quot;, ret); 首先是 dispatch_source_t 部分： 为了让 dispatch_source_t 定时器能够开启，我们为当前 mode 创建了一个 dispatch_queue_t queue，这个 queue 用来执行定时器任务，并且为定时器触发设定了一个回调 ^{ *_timerFired = true; });，即当定时器触发后将 _timerFired 设定为 true。每个 dispatch_queue_t 都对应着一个 mach port，随后我们将其添加到 _portSet 中 然后是 mk_timer 部分 为了让 mk_timer 触发后能够通知到 mode，我们为 mode 申请了一个 mach port mk_timer_create，并且将其添加到 _portSet 中 CFRunLoopObserverRefCFRunLoopObserverRef 观察者。Observer 可以观测的时间点有以下几个： 123456789typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) { kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop kCFRunLoopAllActivities = 0x0FFFFFFFU // 所有时间点}; CFRunLoopObserverRef 的结构如下： 123456789101112131415struct __CFRunLoopObserver { CFRuntimeBase _base; _CFRecursiveMutex _lock; CFRunLoopRef _runLoop; /// 表示注册到了多少个 mode 中 CFIndex _rlCount; /// 观测时间点 CFOptionFlags _activities; /* immutable */ /// 优先级，数值越低表示优先级越高 CFIndex _order; /* immutable */ /// 回调 CFRunLoopObserverCallBack _callout; /* immutable */ /// 回调执行需要的上下文 CFRunLoopObserverContext _context; /* immutable, except invalidation */}; Observer 的结构定义比较简单，这里也不分析看看注释就好了。我们可以使用 CFRunLoopAddObserver() 向 mode 添加 Observer，实现就不贴了(自己可以在源码中找到)，这里讲一下函数里面看到的几个点： Observer 如果已经被添加到了 runloop，那么它就不能被添加到别的 runloop 里了。但是它还可以被添加到其它的 mode 当中 Observer 被添加到 mode 的 _observers 时会根据其 _order 进行排序，_order 数值越大在数组中的位置越靠后 Observer 被添加到一个 mode 后其 _rlCount + 1，并将其 _activities 同步到 mode 的 _observerMask 当中 每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。当 runloop 在主函数中处于不同的时间点时，我们会通知注册了当前时间点的 Observer，对符合要求的 Observer 调用其回调函数。 需要注意的是，如果 Observer 不是重复的，那么当它执行一次回调后就会从 mode 中移除 CFRunLoopSourceRefCFRunLoopSourceRef 的结构如下： 12345678910111213141516struct __CFRunLoopSource { CFRuntimeBase _base; _CFRecursiveMutex _lock; /// 数值越低，优先级越高 CFIndex _order; /* immutable */ /// 仅对 sourece0 有效。它的值是激活时的时间戳，有值时表示此 sourece0 已准备好被执行 _Atomic uint64_t _signaledTime; /// source retain run loops CFMutableBagRef _runLoops; union { /// source0 CFRunLoopSourceContext version0; /* immutable, except invalidation */ /// source1 CFRunLoopSourceContext1 version1; /* immutable, except invalidation */ } _context;}; 可以看到 source1 与 source0 结构中的大部分成员变量都是相同的，除了最后的 _context 不同。观察 CFRunLoopSourceContext 和 CFRunLoopSourceContext1 的结构体之后，我们可以知道： source1 相比于 source0 多了一个 mach port，这使得 source1 通过内核和其他线程相互发送消息，主动唤醒其它 runloop source0 相比于 source1 多了两个函数指针 schedule 和 cancel，分别在创建和销毁时调用，具体作用不知道，猜测是为了用来做一些初始操作 CFRunLoopSource 是添加到 runloop 中输入源的抽象表达。输入源通常会产生异步事件，例如网络端口上到达的消息或用户执行的操作。 输入源类型通常定义了一个用于创建和操作该类型对象的API，就像它是一个独立于 runloop 的实体一样。它提供一个函数来为对象创建一个CFRunLoopSource。CFRunLoopSource 可以被注册到 runloop，作为 runloop 和实际输入源类型对象之间的中介。输入源的例子包括CFMachPort、CFMessagePort和CFSocket。 CFRunLoopSource 有两类，Source0 由应用程序手动管理。当一个 Source0 准备好了被处理，应用程序的某些部分，也许是等待某个事件的线程上的代码，必须调用 CFRunLoopSourceSignal 来告诉 runloop Source0 已经准备好了。CFSocket的 runloop Source目前是用 Source0 来实现的。 Source1 由 runloop 和内核管理。Source1 使用Mach端口来发出信号。当 Source1 的Mach端口上有消息到达时，内核会自动把 Source1 标记为激活状态。当 Source1 启动时，消息内容被交给 Source1 来处理。CFMachPort和CFMessagePort的 runloop Source 目前是用 Source0 来实现的。 Source 可以同时注册多个 runloop 和 runloop mode。当 Source 发出信号时，无论哪一个 runloop 恰好先检测到信号，都会启动该 Source。将 Source 添加到多个线程的 runloop 中，可用于管理正在处理离散数据集的 “工作线程 “池，例如通过网络的客户端-服务器消息。当消息到达时， Source 得到信号，一个随机线程接收并处理请求。 我们可以使用 CFRunLoopAddSource() 函数将 Source 添加到 mode，实现太长了这里就不贴了，自己可以翻源码。这里简单的分析下 如果是 Source1，会预先测试该 mach port 是否能够发送消息，如果不能说明这个 Source1 有问题，直接崩溃 将 Source 依据类型分别添加到 rlm 的 _sources0 或者 _sources1 中。如果是 Source1 类型，则将其 mach port 添加到 rlm 的 _portSet，并以 key(mach port)/value(Source1) 的形式添加到 rlm 的 _portToV1SourceMap 将 runloop 添加到 Source 的 _runLoops Source0 和 Source1 的处理函数分别是 __CFRunLoopDoSource0/__CFRunLoopDoSource1没什么好说的，就是调用各自的回调函数。执行完毕后，Source 也不会被移除，所以你可以向 runloop 添加一个 source 来保证其线程一直存活 CFRunLoopTimerRefCFRunLoopTimerRef 的结构如下： 123456789101112131415161718192021222324struct __CFRunLoopTimer { CFRuntimeBase _base; /// 用 Bit 保存信息。Bit 0 表示 fireing 状态，Bit 1 表示是否在调出时被触发(不是很明白)，Bit 2 表示是否处于销毁状态 Bit 3 表示是否有效 uint16_t _bits; _CFRecursiveMutex _lock; /// 包含此 timer 的 runloop CFRunLoopRef _runLoop; /// 包含此 timer 的 mode 集合 CFMutableSetRef _rlModes; /// 下次触发的时间戳，单位秒 CFAbsoluteTime _nextFireDate; /// 重复执行时的间隔。该值为 0 表示 timer 不重复 CFTimeInterval _interval; /* immutable */ /// 偏差，一般设定为间隔的 10% 比较好 CFTimeInterval _tolerance; /* mutable */ /// 下次触发时的 mach 时间戳 uint64_t _fireTSR; /* TSR units */ /// 优先级，数值越低表示优先级越高。貌似对 timer 没什么作用 CFIndex _order; /* immutable */ /// 触发时的回调 CFRunLoopTimerCallBack _callout; /* immutable */ /// 回调调用时需要的上下文 CFRunLoopTimerContext _context; /* immutable, except invalidation */}; 需要注意的是: _nextFireDate 是下次触发时间相对于 2001-1-1 00：00：00 的时间戳，单位是秒 _fireTSR 下一次触发时间的 macg 时间戳，单位为纳秒 _order 貌似在 timer 没什么用，至少在 CF 源码内没发现其用途 在前面我们提到过，timer(NSTimer/CFRunLoopTimerRef) 的功能实际上是由 mode 操作实现的。对于一个有宽余量 tolerance 的 timer 来说，它的触发时间是在 (fireDate) ~ (fireDate + tolerance) 之间的，我们把它最早的触发时间称为 SoftDeadline，最晚的触发时间称为 HardDeadline。一个 mode 可能管理着多个 timer，它们被集中放在 _timers 中。其中的每个 timer 都有自己的 SoftDeadline 和 HardDeadline。由于 _timers 是按触发时间的早晚来排序的，所以，这所有 timer 中， SoftDeadline 最小的肯定是 _timers 数组中第一个 timer 的 SoftDeadline，我们将其赋值给 mode 的成员变量 _timerSoftDeadline。但是 HardDeadline 最小的却不一定是 _timers 数组中第一个 timer 的 HardDeadline，因为这还需要比较 tolerance 的大小，总之，我们将 HardDeadline 的最小值赋值给 mode 的成员变量 _timerHardDeadlinemode 在获取到 _timerSoftDeadline 和 _timerHardDeadline 之后，就开始设置定时器，如果 _timerSoftDeadline 和 _timerSoftDeadline 相等，说明 tolerance 等于 =，此时 mode 使用 mk_timer 设置定时器; 否则 mode 使用 dispatch_source_t 设置定时器。定时器触发，说明有 timer 需要执行回调了。这个时候我们在 _timers 数组中，判断哪些 timer 的 _fireTSR 时间小于等于当前时间，执行这些 timer 的回调，并重新计算出它们下一次的触发时间 fireTSR，然后重新计算出 mode 的 timerSoftDeadline 和 _timerHardDeadline，并开启下一个定时器。 想知道这些在源码中具体是怎么样的，就看接下来的分析吧~ 我们可以使用 CFRunLoopTimerCreate() 来创建 CFRunLoopTimerRef 实例。这个函数比较长而且简单这里就不贴了函数里面值得注意的有下面几点： 默认的 _tolerance 为 0，但实际上即使你设置为 0 还是不能保证会准时出发 如果你设置的 fireDate 比现在要早，那么 _fireDate 会被赋值为 now，表示立刻触发。对于 repeat 的 timer 来讲，下一次触发时间还是会正常的 timer 创建后自然是要添加到 mode 中去了，CFRunLoopAddTimer() 帮助我们完成这个操作。因为同上的理由这里就不贴代码了，主要就是在验证 timer 是否有效，最后如果有效的话则调用 __CFRepositionTimerInMode() 函数将 timer 添加到 mode 的 _timers 中 下面是 __CFRepositionTimerInMode() 函数的实现： 12345678910111213141516171819202122232425static void __CFRepositionTimerInMode(CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt, Boolean isInArray) { if (!rlt) return; CFMutableArrayRef timerArray = rlm-&gt;_timers; if (!timerArray) return; Boolean found = false; // If we know in advance that the timer is not in the array (just being added now) then we can skip this search /// 如果已经在数组中，则执行这一步 if (isInArray) { CFIndex idx = CFArrayGetFirstIndexOfValue(timerArray, CFRangeMake(0, CFArrayGetCount(timerArray)), rlt); if (kCFNotFound != idx) { CFRetain(rlt); CFArrayRemoveValueAtIndex(timerArray, idx); found = true; } } if (!found &amp;&amp; isInArray) return; /// 在数组中找到合适的位置 CFIndex newIdx = __CFRunLoopInsertionIndexInTimerArray(timerArray, rlt); /// 在 timer 插入到上一步找到的位置中 CFArrayInsertValueAtIndex(timerArray, newIdx, rlt); __CFArmNextTimerInMode(rlm, rlt-&gt;_runLoop); if (isInArray) CFRelease(rlt);} 函数主要做了下面几件事： 如果该 timer 已经在数组中，则找到其位置并从数组中移除。然后在数组找到适合其插入的位置，找到后重新添加到数组中 如果该 timer 不在数组中，则在数组找到适合其插入的位置，找到后将其添加到数组中 以上两步将 timer 成功添加到数组后，调用 __CFArmNextTimerInMode() 重新计算 mode 的 _timerHardDeadline 和 _timerSoftDeadline __CFArmNextTimerInMode() 的实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100static void __CFArmNextTimerInMode(CFRunLoopModeRef rlm, CFRunLoopRef rl) { /// min soft uint64_t nextHardDeadline = UINT64_MAX; /// min hard uint64_t nextSoftDeadline = UINT64_MAX; if (rlm-&gt;_timers) { // Look at the list of timers. We will calculate two TSR values; the next soft and next hard deadline. // The next soft deadline is the first time we can fire any timer. This is the fire date of the first timer in our sorted list of timers. // The next hard deadline is the last time at which we can fire the timer before we've moved out of the allowable tolerance of the timers in our list. for (CFIndex idx = 0, cnt = CFArrayGetCount(rlm-&gt;_timers); idx &lt; cnt; idx++) { CFRunLoopTimerRef t = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm-&gt;_timers , idx); // discount timers currently firing if (__CFRunLoopTimerIsFiring(t)) continue; uint64_t oneTimerHardDeadline; uint64_t oneTimerSoftDeadline = t-&gt;_fireTSR; if (os_add_overflow(t-&gt;_fireTSR, __CFTimeIntervalToTSR(t-&gt;_tolerance), &amp;oneTimerHardDeadline)) { oneTimerHardDeadline = UINT64_MAX; } // We can stop searching if the soft deadline for this timer exceeds(超过 the current hard deadline. Otherwise, later timers with lower tolerance could still have earlier hard deadlines. if (oneTimerSoftDeadline &gt; nextHardDeadline) { break; } if (oneTimerSoftDeadline &lt; nextSoftDeadline) { nextSoftDeadline = oneTimerSoftDeadline; } if (oneTimerHardDeadline &lt; nextHardDeadline) { nextHardDeadline = oneTimerHardDeadline; } } /// 如果 _timerHardDeadline 和 _timerSoftDeadline 没变就不需要重新设置定时器了 if (nextSoftDeadline &lt; UINT64_MAX &amp;&amp; (nextHardDeadline != rlm-&gt;_timerHardDeadline || nextSoftDeadline != rlm-&gt;_timerSoftDeadline)) { if (CFRUNLOOP_NEXT_TIMER_ARMED_ENABLED()) { CFRUNLOOP_NEXT_TIMER_ARMED((unsigned long)(nextSoftDeadline - mach_absolute_time())); } cf_trace(KDEBUG_EVENT_CFRL_NEXT_TIMER_ARMED, rl, rlm, (nextSoftDeadline - mach_absolute_time()), 0);#if USE_DISPATCH_SOURCE_FOR_TIMERS // We're going to hand off the range of allowable timer fire date to dispatch and let it fire when appropriate for the system. /// 宽容度 uint64_t leeway = __CFTSRToNanoseconds(nextHardDeadline - nextSoftDeadline); dispatch_time_t deadline = __CFTSRToDispatchTime(nextSoftDeadline); if (leeway &gt; 0) {/// 截止时间 - 预期时间 &gt; 0 // Only use the dispatch timer if we have any leeway // &lt;rdar://problem/14447675&gt; // Cancel the mk timer if (rlm-&gt;_mkTimerArmed &amp;&amp; rlm-&gt;_timerPort) { AbsoluteTime dummy; mk_timer_cancel(rlm-&gt;_timerPort, &amp;dummy); rlm-&gt;_mkTimerArmed = false; } // Arm the dispatch timer dispatch_source_set_timer(rlm-&gt;_timerSource, deadline, DISPATCH_TIME_FOREVER, leeway); rlm-&gt;_dispatchTimerArmed = true; } else { // Cancel the dispatch timer if (rlm-&gt;_dispatchTimerArmed) { // Cancel the dispatch timer dispatch_source_set_timer(rlm-&gt;_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 888); rlm-&gt;_dispatchTimerArmed = false; } // Arm the mk timer if (rlm-&gt;_timerPort) { mk_timer_arm(rlm-&gt;_timerPort, nextSoftDeadline); rlm-&gt;_mkTimerArmed = true; } }#else if (rlm-&gt;_timerPort) { mk_timer_arm(rlm-&gt;_timerPort, nextSoftDeadline); }#endif } else if (nextSoftDeadline == UINT64_MAX) { // Disarm the timers - there is no timer scheduled if (rlm-&gt;_mkTimerArmed &amp;&amp; rlm-&gt;_timerPort) { AbsoluteTime dummy; mk_timer_cancel(rlm-&gt;_timerPort, &amp;dummy); rlm-&gt;_mkTimerArmed = false; } #if USE_DISPATCH_SOURCE_FOR_TIMERS if (rlm-&gt;_dispatchTimerArmed) { dispatch_source_set_timer(rlm-&gt;_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 333); rlm-&gt;_dispatchTimerArmed = false; }#endif } } rlm-&gt;_timerHardDeadline = nextHardDeadline; rlm-&gt;_timerSoftDeadline = nextSoftDeadline;} 函数里面值得注意的有下面几点： _timerSoftDeadline 和 _timerSoftDeadline 取值都是 timer 中最小的 SoftDeadline 和 SoftDeadline，但是拥有最小 SoftDeadline 的 timer 的 SoftDeadline 却不一定是最小的，因为这还要考虑 _tolerance 如果 _timerSoftDeadline 和 _timerSoftDeadline 和之前的值相同，说明不需要重新设置 mode 里面的定时器了 如果 _timerSoftDeadline 和 _timerSoftDeadline 相同，则使用 mk_timer 设置定时器;否则使用 dispathch_source_t 设置定时器。我猜测是 mk_timer 精度更高，但是不能使用宽余量，所以此时用 dispatch_source_t 代替 添加完成后，自然是要看如何执行 timer 的，__CFRunLoopDoTimers() 函数帮我们完成该操作 12345678910111213141516171819202122232425262728293031323334static Boolean __CFRunLoopDoTimers(CFRunLoopRef rl, CFRunLoopModeRef rlm, uint64_t limitTSR) { /* DOES CALLOUT */ cf_trace(KDEBUG_EVENT_CFRL_IS_DOING_TIMERS | DBG_FUNC_START, rl, rlm, limitTSR, 0); Boolean timerHandled = false; CFMutableArrayRef timers = NULL; for (CFIndex idx = 0, cnt = rlm-&gt;_timers ? CFArrayGetCount(rlm-&gt;_timers) : 0; idx &lt; cnt; idx++) { CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm-&gt;_timers, idx); if (__CFIsValid(rlt) &amp;&amp; !__CFRunLoopTimerIsFiring(rlt)) { /// 将符合触发要求的 timer 取出来放在 timers 数组中 if (rlt-&gt;_fireTSR &lt;= limitTSR) { if (!timers) timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeArrayCallBacks); CFArrayAppendValue(timers, rlt); } } } CFRUNLOOP_ARP_BEGIN; for (CFIndex idx = 0, cnt = timers ? CFArrayGetCount(timers) : 0; idx &lt; cnt; idx++) { CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(timers, idx); Boolean did = __CFRunLoopDoTimer(rl, rlm, rlt); timerHandled = timerHandled || did; } if (timers) CFRelease(timers); CFRUNLOOP_ARP_END; cf_trace(KDEBUG_EVENT_CFRL_IS_DOING_TIMERS | DBG_FUNC_END, rl, rlm, limitTSR, 0); return timerHandled;} 方法给定了一个触发时间 limitTSR，遍历 _timers 并收集所有触发时间 _fireTSR 小于 limitTSR 的 timer对所有符合触发要求的 timer 调用 __CFRunLoopDoTimer() 函数，看样子具体的执行过程是在这里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148static Boolean __CFRunLoopDoTimer(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt) { /* DOES CALLOUT */ cf_trace(KDEBUG_EVENT_CFRL_TIMERS_FIRING | DBG_FUNC_START, rl, rlm, rlt, 0); Boolean timerHandled = false; uint64_t oldFireTSR = 0; /* Fire a timer */ CFRetain(rlt); __CFRunLoopTimerLock(rlt); if (__CFIsValid(rlt) &amp;&amp; rlt-&gt;_fireTSR &lt;= mach_absolute_time() &amp;&amp; !__CFRunLoopTimerIsFiring(rlt) &amp;&amp; rlt-&gt;_runLoop == rl) { /// if1 start void *context_info = NULL; void (*context_release)(const void *) = NULL; if (rlt-&gt;_context.retain) { context_info = (void *)rlt-&gt;_context.retain(rlt-&gt;_context.info); context_release = rlt-&gt;_context.release; } else { context_info = rlt-&gt;_context.info; } /// _interval = 0 表示 timer 触发过一次过就会被置为不可用状态 Boolean doInvalidate = (0.0 == rlt-&gt;_interval); __CFRunLoopTimerSetFiring(rlt); // Just in case the next timer has exactly the same deadlines as this one, we reset these values so that the arm next timer code can correctly find the next timer in the list and arm the underlying timer. /// SoftDeadline 表示第一个 timer 第一次 fire 的时间，HardDeadline 表示最后一个 timer 第一次 fire 的时间 /// 重设这两个值，便于找到下一个未处理的 timer rlm-&gt;_timerSoftDeadline = UINT64_MAX; rlm-&gt;_timerHardDeadline = UINT64_MAX; __CFRunLoopTimerUnlock(rlt); __CFLock(&amp;rl-&gt;_timerTSRLock); oldFireTSR = rlt-&gt;_fireTSR; __CFUnlock(&amp;rl-&gt;_timerTSRLock); __CFArmNextTimerInMode(rlm, rl); __CFRunLoopModeUnlock(rlm); __CFRunLoopUnlock(rl); CFRunLoopTimerCallBack callout = rlt-&gt;_callout; cf_trace(KDEBUG_EVENT_CFRL_IS_CALLING_TIMER | DBG_FUNC_START, callout, rlt, context_info, 0); __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(callout, rlt, context_info); cf_trace(KDEBUG_EVENT_CFRL_IS_CALLING_TIMER | DBG_FUNC_END, callout, rlt, context_info, 0); CHECK_FOR_FORK(); if (doInvalidate) { /// remove timer CFRunLoopTimerInvalidate(rlt); /* DOES CALLOUT */ } if (context_release) { context_release(context_info); } __CFRunLoopLock(rl); __CFRunLoopModeLock(rlm); __CFRunLoopTimerLock(rlt); timerHandled = true; __CFRunLoopTimerUnsetFiring(rlt); } /// if1 end if (__CFIsValid(rlt) &amp;&amp; timerHandled) { /// if2 start /* This is just a little bit tricky: we want to support calling * CFRunLoopTimerSetNextFireDate() from within the callout and * honor that new time here if it is a later date, otherwise * it is completely ignored. */ if (oldFireTSR &lt; rlt-&gt;_fireTSR) { /// if3 start /* Next fire TSR was set, and set to a date after the previous * fire date, so we honor it. */ __CFRunLoopTimerUnlock(rlt); // The timer was adjusted and repositioned, during the // callout, but if it was still the min timer, it was // skipped because it was firing. Need to redo the // min timer calculation in case rlt should now be that // timer instead of whatever was chosen. __CFArmNextTimerInMode(rlm, rl); } else { uint64_t nextFireTSR = 0LL; uint64_t intervalTSR = 0LL; if (rlt-&gt;_interval &lt;= 0.0) { } else if (TIMER_INTERVAL_LIMIT &lt; rlt-&gt;_interval) { intervalTSR = __CFTimeIntervalToTSR(TIMER_INTERVAL_LIMIT); } else { intervalTSR = __CFTimeIntervalToTSR(rlt-&gt;_interval); } if (LLONG_MAX - intervalTSR &lt;= oldFireTSR) { nextFireTSR = LLONG_MAX; } else { if (intervalTSR == 0) { // 15304159: Make sure we don't accidentally loop forever here CRSetCrashLogMessage(&quot;A CFRunLoopTimer with an interval of 0 is set to repeat&quot;); HALT; } uint64_t currentTSR = mach_absolute_time(); nextFireTSR = oldFireTSR; while (nextFireTSR &lt;= currentTSR) { nextFireTSR += intervalTSR; } } CFRunLoopRef rlt_rl = rlt-&gt;_runLoop; if (rlt_rl) { /// if3 start CFRetain(rlt_rl); CFIndex cnt = CFSetGetCount(rlt-&gt;_rlModes); STACK_BUFFER_DECL(CFTypeRef, modes, cnt); CFSetGetValues(rlt-&gt;_rlModes, (const void **)modes); // To avoid A-&gt;B, B-&gt;A lock ordering issues when coming up // towards the run loop from a source, the timer has to be // unlocked, which means we have to protect from object // invalidation, although that's somewhat expensive. for (CFIndex idx = 0; idx &lt; cnt; idx++) { CFRetain(modes[idx]); } __CFRunLoopTimerUnlock(rlt); for (CFIndex idx = 0; idx &lt; cnt; idx++) { CFStringRef name = (CFStringRef)modes[idx]; modes[idx] = (CFTypeRef)__CFRunLoopFindMode(rlt_rl, name, false); CFRelease(name); } __CFLock(&amp;rl-&gt;_timerTSRLock); rlt-&gt;_fireTSR = nextFireTSR; rlt-&gt;_nextFireDate = CFAbsoluteTimeGetCurrent() + __CFTimeIntervalUntilTSR(nextFireTSR); for (CFIndex idx = 0; idx &lt; cnt; idx++) { CFRunLoopModeRef rlm = (CFRunLoopModeRef)modes[idx]; if (rlm) { __CFRepositionTimerInMode(rlm, rlt, true); } } __CFUnlock(&amp;rl-&gt;_timerTSRLock); for (CFIndex idx = 0; idx &lt; cnt; idx++) { __CFRunLoopModeUnlock((CFRunLoopModeRef)modes[idx]); } CFRelease(rlt_rl); } else { __CFRunLoopTimerUnlock(rlt); __CFLock(&amp;rl-&gt;_timerTSRLock); rlt-&gt;_fireTSR = nextFireTSR; rlt-&gt;_nextFireDate = CFAbsoluteTimeGetCurrent() + __CFTimeIntervalUntilTSR(nextFireTSR); __CFUnlock(&amp;rl-&gt;_timerTSRLock); } } /// if3 end } else { __CFRunLoopTimerUnlock(rlt); } /// if2 end CFRelease(rlt); cf_trace(KDEBUG_EVENT_CFRL_TIMERS_FIRING | DBG_FUNC_END, rl, rlm, rlt, 0); return timerHandled;} 这个函数比较长，但是也比较重要 再判断一次 timer 是否满足 设置 timer 为触发状态，并设置 mode 的 _timerSoftDeadline，_timerHardDeadline 为 UINT64_MAX，调用 __CFArmNextTimerInMode() 在 mode 开启下一个定时器(因为之前设置的已经触发了) 执行 timer 的回调，结束之后如果 timer 不重复则将其从 mode 中移除，否则将 timer 设置为未触发状态 接下来重新调用一次 __CFArmNextTimerInMode()，因为上一次调用 __CFArmNextTimerInMode，这个 timer 处于触发状态所以不能参与，现在是未触发状态就可以参与了 至此，CFRunLoopTimerRef 的分析完毕 dispatch_source_t 使用12345678dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());dispatch_source_set_timer(source, dispatch_time(DISPATCH_TIME_NOW, 0), 3 * NSEC_PER_SEC, 0);dispatch_source_set_event_handler(source, ^{ //定时器触发时执行 NSLog(@&quot;timer响应了&quot;);});//启动timerdispatch_resume(source); 在 runloop 中，给 dispatch_source_t 的触发时间设置为 DISPATCH_TIME_FOREVER 达到取消定时器触发的目的 需要注意的是，dispatch_source_set_timer() 函数中，如果触发时间是 DISPATCH_TIME_NOW 或者 dispatch_time 类型的，那么定时器将对照 mach 时间来触发; 否则，将对照 gettimeofday(3) 来触发 mk_timer 使用MK_TIMER的原理很简单，其核心就是： mk_timer_arm(mach_port_t, expire_time) 在 expire_time 的时候给指定了 mach_port 的发送消息 mk_timer_cancel(mach_port_t, &amp;result_time) 取消 mk_timer_arm 注册的消息 Runloop 主函数这里我也写一个 runloop 的内部逻辑，可以跳过先看后面的分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/** @param seconds：超时时间 @param stopAfterHandle：处理完 source 即退出，默认为 false @param previousMode：默认为 nil，如果不为空，则表示 __CFRunLoopRun 还未退出就又调用了一次 __CFRunLoopRun*/static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) { // dispatchPort 表示 dispatch_main_queue port，可能为空 __CFPort dispatchPort = ...; // modeQueuePort 表示 dispatch_rlm_queue port，可能为空 mach_port_name_t modeQueuePort = ...; /// 当超时时间大于 0 且小于某个值，则用 dispatch_source_t 开启一个定时器 if (seconds &gt; 0 &amp;&amp; seconds &lt; DISPATCH_TIME_FOREVER) { dispatch_source_t timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); dispatch_resume(timeout_timer); } Boolean didDispatchPortLastTime = true; int32_t retVal = 0; do { /// 可能会接收到 mach 消息 的 mach port 集合 __CFPortSet waitSet = rlm-&gt;_portSet; /// 通知 Observers: RunLoop 即将处理 Timer __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers); /// 通知 Observers: RunLoop 即将处理 Sources __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources); /// 执行被加入的 block __CFRunLoopDoBlocks(rl, rlm); /// 处理 Source0 Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle); if (sourceHandledThisLoop) { /// 执行完 source0 的回调函数，可能会向 RunLoop 加入了一些新的 block，所以在这里执行它们 __CFRunLoopDoBlocks(rl, rlm); } /// poll 表示本次 loop 不会进入休眠状态，即不会休眠等待 mach msg Boolean poll = ...; /// 通知 Observers: RunLoop 即将休眠 if (!poll) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting); /// 设置 runloop 为休眠状态 __CFRunLoopSetSleeping(rl); do { /** 休眠接受 mach msg，有以下几种情况会被唤醒 1. 定时器触发唤醒 2. source1 事件 3. 调用 CFRunLoopWakeUp() 唤醒 4. 超时唤醒 */ __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort); if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) { /// 定时器触发唤醒 if (rlm-&gt;_timerFired) { rlm-&gt;_timerFired = false; break; } } else { /// 其它情况唤醒 break; } } while (1) /// 通知 Observers: RunLoop 的线程刚刚被唤醒了。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting); handle_msg:; if (MACH_PORT_NULL == livePort) { /// 被其它原因唤醒，例如 poll = true // handle nothing } else if (livePort == rl-&gt;_wakeUpPort) { /// 被 CFRunLoopWakeUp 唤醒 // handle nothing } else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) { /// 被 dispatch_source_t 类型的定时器唤醒 /// 处理 timer __CFRunLoopDoTimers(rl, rlm, mach_absolute_time()) } else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) { //// 被 mk_timer 类型的定时器唤醒 /// 处理 timer __CFRunLoopDoTimers(rl, rlm, mach_absolute_time()) } else if (livePort == dispatchPort) { /// 被 main_dispatch_queue port 发送的消息 /// 处理提交到主队列的任务 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(); } else { /// 处理 source1 __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply); if (NULL != reply) { /// source1 可以向别的 port 发送消息 (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL); } } if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) { /// 进入loop时参数说处理完事件就返回。 retVal = kCFRunLoopRunHandledSource; } else if (timeout) { /// 超出传入参数标记的超时时间了 retVal = kCFRunLoopRunTimedOut; } else if (__CFRunLoopIsStopped(runloop)) { /// 被外部调用者强制停止了 retVal = kCFRunLoopRunStopped; } else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) { /// source/timer/observer一个都没有了 retVal = kCFRunLoopRunFinished; } } while (ret) return ret;} 初始化 dispatchPort 和 modeQueuePort 两个端口dispatchPort 表示 dispatch_main_queue port(主队列的 mach port)，可能为空modeQueuePort 表示 dispatch_rlm_queue port(当前 mode 队列的 mach port)，这个 port 是用来处理 timer 的，可能为空 当超时时间 second 大于 0 且小于某个值时，初始化一个dispatch_source_t 类型的定时器，并开启，用来处理 runloop 超时的情况。如果超时，则调用函数 CFRunLoopWakeUp() 唤醒 rl 接着进入了一个内部循环 do {} while () 中 在处理 source0 之前我们先调用 __CFRunLoopDoBlocks() 函数处理加入的 block。处理完 source0 之后立马又调用了一次 __CFRunLoopDoBlocks()，我裂解为在执行 source0 的回调函数中，有可能像 rlm 又添加了 block，所以要处理它们。 这里我有个猜测，使用 dispatch_async(dispatch_queue_t queue, dispatch_block_t block) 添加的 block 其实是添加到 rlm 里面的，只不过因为对 GCD 不熟悉现在还无法下结论。但使用代码调试的时候可以看到 block 是在 __CFRunLoopDoBlocks 里面被调用的。 这里分为两部分，首先声明了一个布尔值 poll，它表示 runloop 在此次 loop 中不会进入休眠等待 mach msg 的状态，处理完任务就退出。它的成立条件可以是下面条件中的一种 处理了 source0 超时时间为 0 source0 并不能主动唤醒 runloop，所以处理 source0 之前必须要用 CFRunLoopWakeUp() 唤醒 runloop。这也就能理解 poll 的作用了，人家唤醒你来处理任务，肯定是希望你赶紧处理完然后退出的，怎么还能让你浪费时间休眠接受 mach msg 呢 后面应该不可能调到红色框内，因为前面 didDispatchPortLastTime 初始化为了 true。我猜测这是因为 swift 中这部分的实现跟 oc 中的实现不完全一样。总之这里就不管了了 runloop 进入休眠状态，调用 __CFRunLoopServiceMachPort() 接受 mach msg，接受到消息后被唤醒。 此时如果接收到消息的 port 不是 modeQueuePort(rlm_queue_port)，则继续走下。如果是的话，则调用 _dispatch_runloop_root_queue_perform_4CF() 函数。 在创建 rlm 时我们创建一个 dispatch_queue_t，赋值给了 _queue。创建了一个 dispatch_source_t 定时器，并将其回调 handler block 提交给了 _queue。当定时器被触发时，发送消息给 modeQueuePort，接受到消息后，我们需要调用 _dispatch_runloop_root_queue_perform_4CF() 函数处理之前提交过的 handler block，而这个回调在初始化 rlm 就已经写死了：将 rlm-&gt;_timerFired 赋值为 true。 所以接下来有个判断 rlm-&gt;_timerFired 是否为 true，如果为 true 即定时器触发了，所以跳出循环去处理 timer 的回调。如果不是我就不清楚是什么情况了 接下来就是 runloop 处理被唤醒的原因了 此种情况是因为在接受消息时因为各种原因没有正确的接收到消息而退出休眠的状态，例如设置超时时间为 0，mach_msg 还没接收到消息就退出接受状态了 runloop 被调用 CFRunLoopWakeUp 函数唤醒 被 rlm-&gt;_timerSource 定时器唤醒。 此时去执行可用的 timer 回调。 如果不存在符合要求的 timer，说明定时器触发早了了，说明我们设置的触发时间有问题。调用 __CFArmNextTimerInMode() 设置下一个触发的时间点 被 mk_timer 唤醒 此时去执行可用的 timer 回调。在 windows 平台 mk_timer 定时器可能提前触发，所以我们需要重新开启 mk_timer 定时器，除了调用 __CFArmNextTimerInMode 函数，还需要先将 rlm 的_timerSoftDeadline 和 _timerHardDeadline 改变才行。 被 dispatch_main_queue 唤醒 调用 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE 处理提交到 dispatch_main_queue 的任务 被 source1 唤醒 调用 CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION 处理 source1。因为 source1 自己拥有一个 mach port，在 source1 的回调函数中可能会往别的 port 发送消息 执行了上述可能的各种回调，可能又有 block 提交到了当前 runloop 当中，所以我们这里再调用一次 __CFRunLoopDoBlocks() 最后，根据前面的处理结果来判断是否退出 loop 用 RunLoop 实现的功能这一部分我觉得 https://blog.ibireme.com/2015/05/18/runloop/ 这一篇文章里面已经写的很好了，我这里就不赘述了。 参考深入理解RunLoophttps://zhuanlan.zhihu.com/p/63184073","link":"/2020/05/24/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%AF%BB%E6%87%82-Runloop/"},{"title":"使用HealthKit莫名崩溃","text":"今天在测试自己写的框架，[JYAuthorizationManager](www.baidu.com)，然后在测试`HealthKit`权限的时候老是莫名的闪退，下面是系统的log： 1Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: 'NSHealthShareUsageDescription must be set in the app's Info.plist in order to request read authorization for the following types: HKQuantityTypeIdentifierStepCount' 原因指的是plist文件里面没有加权限描述，但其实我已经加过了。于是各种找原因，才发现了解决方法： &gt; 健康的权限描述里面不能有*中文*。我也是醉了。。。 ! HealthKit的权限描述 参考：https://www.jianshu.com/p/780521c34de9","link":"/2019/03/13/%E4%BD%BF%E7%94%A8HealthKit%E8%8E%AB%E5%90%8D%E5%B4%A9%E6%BA%83/"},{"title":"大牛博客","text":"分享下对我帮助比较大，且自己认为干货比较多的大牛的博客地址： 杨萧玉 孙源 MrPeak","link":"/2019/05/14/%E5%A4%A7%E7%89%9B%E5%8D%9A%E5%AE%A2/"},{"title":"使用mac终端在阿里云服务器上搭建JDK Tomcat","text":"趁双11的时候低价购入了一台低配的ECS服务器，准备用来搭后台。搭建环境的时候发现网上大部分文章都是window环境下的，不过总算是弄好了，在这里简单的记录下整个搭建的过程。 连接阿里云 打开终端，使用下面的命令行远程连接阿里云 12ssh root@xx.xx.xx.xx(公网ip) 新建远程连接-安全文件传输。连接成功之后可以从本地往服务器传输文件。 当然，你也可以用命令行sftp root@xxx.xxx.xxx.xxx(公网ip)进行连接 下载JDK以及Tomcat的安装包我下载的的是 JDK8以及Tomcat8.5 将安装包传输到阿里云服务器在 远程连接文件传输之后，将下载好的安装包传输到阿里云服务器的/usr文件下 1put 本地文件的绝对路径 /usr 上传成功之后，我们可以关闭这个窗口了。然后在另一个连接了服务器的终端上，使用ls -l查看文件，刚刚上传的JDK,Tomcat两个安装包已经在里面了。 创建文件夹创建几个文件夹，放置解压安装包之后的文件： JDK: /usr/java/jdkTomcat: /usr/java/tomcat 创建文件夹的命令如下： 1234mkdir javacd javamkdir jdkmkdir tomcat 解压安装包将/usr下面的两个安装包分别解压到刚刚创建好的文件夹里面 12tar -zxvf jdk-8u181-linux-x64.tar.gz -C /usr/java/jdktar -zxvf apache-tomcat-8.5.35.tar.gz -C /usr/java/tomcat 配置JDK环境使用下面的命令打开profile文件并编辑 1vi /etc/profile 需要添加的代码如下： 12345#set java environmentexport JAVA_HOME=/usr/java/jdk/jdk1.8.0_171export JRE_HOME=/usr/java/jdk/jdk1.8.0_171/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$JAVA_HOME:$PATH 添加完毕之后保存，然后使用命令source /etc/profile 检查环境变量是否设置成功完成上面的操作之后，你可以使用下面的命令来检查环境变量是否设置成功，如果成功的话，则JDK环境配置完成。 1java -version 配置Tomcat环境进入到Tomcat安装目录的bin文件下1cd /usr/java/tomcat/apache-tomcat-8.5.35/bin 编辑setclasspath.sh文件1vi setclasspath.sh 在末尾加上下面的代码 12export JAVA_HOME=/usr/java/jdk/jdk1.8.0_181export JRE_HOME=/usr/java/jdk/jdk1.8.0_181/jre 启动Tomcat完成上一步之后，保存退出编辑。使用下面的命令: 1source setclasspath.sh 在bin目录下启动Tomcat 1./startup.sh 访问tomcat如果你是第一次设置的话，那么在用浏览器（公网ip:8080）访问的时候会发现访问被拒绝，原因是在阿里云服务器没有添加安全策略组，解决办法如下： 配置成功!","link":"/2018/12/13/%E4%BD%BF%E7%94%A8mac%E7%BB%88%E7%AB%AF%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%90%AD%E5%BB%BAJDK-Tomcat/"},{"title":"如何使用 JYSqlModel","text":"JYSqlModel是一个高效的 model、sqlite数据的转换工具。在 JYSqlModel，每一条数据库的数据都会被当做一个 model，所以当你对 model 执行相应的增删改查操作时，即对数据库进行着增删改查操作，这意味着你不再需要记得什么字段，什么约束，甚至可以不再使用 sql 语句来操作数据库！JYSqlModel 依赖于库FMDB，使用前请保证你的项目中有这个库。JYSqlModel 的思路来源来自于YYModel 使用前请将JYSqlModel和JYClassInfo的 .h 和 .m 文件，放到工程中。 创建表在 JYSqlModel 中，一个 model 对应于一个表。首先，你需要给这个表确定好一个名字，所以你必须在 model 内重载 JYSqlModel 的类方法+ (nonnull NSString *)tbName;。注意这个名字不能重复重复。系统会在启动的时候，会根据 model 结构创建相应的表。表中字段(column)与 model 属性是一一对应的，在默认情况下，字段名字即是属性名字，当然你也可以使用协议中的方法自定义字段名，这个后面会详细讲。字段的类型会根据属性的类型分成不同的类型，目前只支持下表中的几种类型： 字段类型 描述 对应属性类型 integer 整型数 c的整型，NSNumber real 浮点数 c的浮点型，NSDecimalNumber text 文本 NSString，NSMutableString，NSURL blob 二进制数据 NSData，NSMutableData date 日期 NSDate bool 布尔值 c的bool unknow 除上面所以，会报错 除上面所有 如果你的类型不是上面支持的几种类型之一，那么就会被归为 unkonw 类型，随即就会报错。这样做的原因一方面是因为自己的知识不够丰富，不知道怎么处理其它的类型，另一方面避免复杂类型引起不可预料的错误。在后期的话可能还会支持 NSArray 等容器类型。 下面是一个简单的例子： 1234567891011121314@interface Student : JYSqlModel@property (nonatomic, copy) NSString *name;@property (nonatomic, copy) NSString *school;@property (nonatomic, assign) NSInteger age;@property (nonatomic, assign) CGFloat height;@property (nonatomic, strong) NSDate *birthDay;@end@implementation Student+ (NSString *)tbName{ return @&quot;sudent&quot;;}@end 下面是创建相应表的 sql： 1create table if not exists sudent (school text ,age integer ,birthDay date ,name text ,height real) 是不是很简单，你只需要新建一个JYSqlModel的子类，并给它指定一个表名，就能自动的创建一个表。 增JYSqlModel 提供了以下几种方法来帮助你将 model 写入数据库： 123456// 1+ (BOOL)addModel:(nonnull __kindof JYSqlMode *)model;// 2+ (BOOL)addModels:(nonnull NSArray&lt;__kindof JYSqlMode *&gt; *)models;// 3- (BOOL)addToSql; 方法1和方法2类似，都是使用类方法来添加 model 到数据库中。需要注意的是，model 的类需要跟类一致，否则会添加失败。方法3是实例方法。添加成功会返回 YES，否则返回 NO 删JYSqlModel 提供了以下几种方法来帮助你将 model 从数据库中删除： 123456// 1+ (BOOL)deleteModelBySql:(nonnull NSString *)sql;// 2+ (BOOL)deleteModelByPrimaryKey:(NSString *)primaryKey value:(NSInteger)value;// 3+ - (BOOL)deleteFromSql; 方法1的话需要你自己写删除 sql，适用于删除语句比较简单或者批量删除的时候。你可以在子类中，根据这个方法封装一个更简单的方法。举个例子： 12345678910@interface Student : JYSqlMode + (BOOL)deleteModeByPKValue:(NSInteger)value;@end@implementation JYPerson + (BOOL)deleteModeByPKValue:(NSInteger)value { NSString *sql = [NSString stringWithFormat:@&quot;delete from tbName where pk = %zd&quot;, value]; [JYSonModel deleteModelBySql:sql]; } @end 现在你只需要一个pk值就能删除数据库记录了。当然你也可以封装一个实例方法，这样连参数都不需要了。 方法2需要你指定一个主键名字以及主键值来删除相应记录。类似于方法1，你也可以根据该方法封装一个更简便的方法！ 方法3不需要你提供什么参数，使用起来更简单，但是如果对应表中没有主键，该删除方法就会失败，因为无法定位到具体到某一条记录。 改JYSqlModel 提供了以下几种方法来帮助你更新数据库中的记录： 1234// 1+ (BOOL)updateModelBySql:(NSString *)sql;// 2+ (BOOL)updateModel:(nonnull __kindof JYSqlMode *)model primaryKey:(NSString *)primaryKey value:(NSInteger)value; 方法1的话需要你自己提供更新 sql，适用于更新字段比较少或者批量更新的时候。 方法2需要你提供一个主键来确定是哪条记录，以便更新相应数据。该方法将更新除主键和autoincrement以外所有的字段，适用于更新字段比较多的情况。 查JYSqlModel 提供了以下几种方法来帮助你查找数据库中的记录： 1234// 1+ (nullable NSArray&lt;__kindof JYSqlMode *&gt; *)findModelsBySql:(nonnull NSString *)sql;// 2+ (nullable NSArray&lt;__kindof JYSqlMode *&gt; *)findAllModels; 方法1需要你自己提供查找 sql，返回结果将以 model 数组返回。 方法2将会查找出表中所有的记录，以 model 数组的形式返回。 数据迁移在项目更新中，如果我们需要增加、删除 model 中的某些属性，或者改变属性的类型要怎么办呢？很简单，你只需要对 model 进行修改，在项目运行时，JYSqlMode 会检测新 model 的结构以及旧表的结构，来判断是否需要进行数据迁移。所谓的数据迁移也就是，将旧表重命名，根据新 model 的结构新建一个表，然后将旧表的数据迁移到新的表中。如此操作之后，新表的结构与新 model 的结构就一一对应了，保证了你在执行增删改查操作时不会出错。 当然，也有一些情况下，可能你做了修改也不会触发数据迁移。例如，如果仅仅是改变了字段的约束条件，那么是不会触发数据迁移的。解决办法最后面会给出。 JYSqlMode下面是协议JYSqlMode的可选方法，帮助你执行一些自定义操作： 1234// 1+ (nullable NSDictionary&lt;NSString *, id&gt; *)jyCustomPropertyMapper;// 2+ (nullable NSDictionary&lt;NSString *, NSDictionary *&gt; *)jyCustomPropertyConstraint; 方法1帮助你实现自定义 属性 -&gt; 表字段名 的映射。举个例子： 123456789101112131415@interface Student : JYSqlMode &lt;JYSqlMode&gt;@property NSString *name;@property NSString *title;@property NSInteger age;@endimplementation Student+ (nullable NSDictionary&lt;NSString *, id&gt; *)jyCustomPropertyMapper {return @{ @&quot;name&quot; : @&quot;fName&quot;, @&quot;title&quot; : @&quot;ftitle&quot;, @&quot;age&quot; : @&quot;fage&quot; }}@end 在相应的表中，fName 将会对应属性 name，ftitle 将会对应属性 title，fage 将会对应属性 age 方法2帮助你实现自定义字段的约束条件。目前仅支持以下几种约束类型： JYColumnConstraintKeyNotNull -&gt; not null JYColumnConstraintKeyDefault -&gt; default JYColumnConstraintKeyDefaultValue -&gt; 默认值，需要与 JYColumnConstraintKeyDefault 配套使用 JYColumnConstraintKeyUnique -&gt; unique JYColumnConstraintKeyPrimaryKey -&gt; primary key JYColumnConstraintKeyAutoIncrement -&gt; autoincrement 需要注意的是，JYColumnConstraintKeyDefault 需要配合 JYColumnConstraintKeyDefaultValue 使用，设置一个默认值。举个例子： 123456789101112131415161718192021222324@interface Student : JYSqlModel &lt;JYSqlModel&gt;@property (nonatomic, assign) NSInteger fid;@property (nonatomic, copy) NSString *name;@property (nonatomic, copy) NSString *school;@property (nonatomic, assign) CGFloat height;@property (nonatomic, strong) NSDate *birthDay;@end@implementation Student+ (nullable NSDictionary&lt;NSString *, NSDictionary *&gt; *)jyCustomPropertyConstraint;{ return @{ @&quot;fid&quot; : @{ JYColumnConstraintKeyPrimaryKey : @YES, JYColumnConstraintKeyUnique : @YES JYColumnConstraintKeyAutoIncrement : @YES }, @&quot;school&quot; : @{ JYColumnConstraintKeyDefault : @YES, JYColumnConstraintKeyDefaultValue : @&quot;背背山小学&quot; } };}@end 这样子，你就定义了一个primary key unique autoincrement的主键 fid，以及一个default '背背山小学'的字段 school。 @note限于个人水平，JYSqlModel 肯定会在一些的问题。也许你会奇怪明明按说明操作了，但没有出现想要的结构。下面我将总结一下使用时需要注意的地方： 已存在一个旧表，若只是修改了相应字段的约束条件，这些约束条件是不会立刻生效的。一个解决办法是预留一个字段，当你需要更新表结构的时候修改这个预留字段的名字 已存在一个旧表，如果你为它设置了一个主键，抱歉设置会失败。解决方法参考第1条 NSNumber类型的属性会存储到 integer 类型的字段中，如果想保存成浮点数的话，请将属性类型改为 NSDecimalNumber 或者直接使用 C 的浮点类型 float, double等 如果你在运行时动态的为 model 新增了属性，抱歉，表结构也不会更新","link":"/2019/08/15/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-JYSqlModel/"},{"title":"如何使用JTForm","text":"JTForm是一个能简单快速的搭建流畅复杂表单的库，灵感来自于XLForm与Texture。JTForm能帮助你像html一样创建表单。不同于XLForm是一个UIViewController的子类，JTForm是UIView的子类，也就是说，你可以像使用UIView一样使用JTForm，应用范围更广，更方便。JTForm也可以用来创建列表，而不仅仅是表单。 JTForm使用Texture完成视图的布局与加载，所以集成了Texture的优点：异步渲染，极度流畅。使用JTForm，你可以忘记许多原生控件时需要注意的东西：高度设置，单元行复用等。为了避免ASTableNode重载时图片闪烁的问题，自定义了JTNetworkImageNode代替ASNetworkImageNode。 下面是demo运行在公司老旧设备5s的截图，可以看到fps基本保持在60左右。 安装测试一下 使用cocoapods：pod 'JTForm', '~&gt; 0.0.1' 注意事项 如果库自带的单元行满足不了需求，需要自定义单元行的时候，需要了解Texture的相关知识。 如果你的项目中有类似‎IQKeyboardManager的第三方，请在使用JTForm的时候禁用他们，不然会跟库的键盘弹起相冲突。如果你想禁用JTForm的键盘弹起，你可以设置JTForm的属性showInputAccessoryView为NO 简单使用 下面是构建该表单一部分的代码以及注释 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 构建表描述JTFormDescriptor *formDescriptor = [JTFormDescriptor formDescriptor];// 是否在必填行的title前面添加一个红色的*formDescriptor.addAsteriskToRequiredRowsTitle = YES;JTSectionDescriptor *section = nil;JTRowDescriptor *row = nil; #pragma mark - float text// 创建节描述 section = [JTSectionDescriptor formSection];// 为section创建header title，目前需要手动输入header view的heightsection.headerAttributedString = [NSAttributedString attributedStringWithString:@&quot;float text&quot; font:nil color:nil firstWordColor:nil];// 目前需要手动输入header view的height，不然是默认值，可能会出现排版显示问题section.headerHeight = 30.;// 将节描述添加到表描述中[formDescriptor addFormSection:section]; // 创建行描述，rowType为必填项，创建单元行时根据rowType来选择创建不同的单元行 row = [JTRowDescriptor formRowDescriptorWithTag:JTFormRowTypeFloatText rowType:JTFormRowTypeFloatText title:@&quot;测试&quot;];// 是否必填row.required = YES;// 将行描述添加到表描述中[section addFormRow:row]; #pragma mark - formatter row = [JTRowDescriptor formRowDescriptorWithTag:@&quot;20&quot; rowType:JTFormRowTypeNumber title:@&quot;百分比&quot;];NSNumberFormatter *numberFormatter = [NSNumberFormatter new];numberFormatter.numberStyle = NSNumberFormatterPercentStyle;// 添加valueFormatter，是NSFormatter的子类，能将value转换成不同的文本。常用的有nsdateformatter// 这里valueFormatter的作用是将数字转换成百分数，例如10-&gt;1000%row.valueFormatter = numberFormatter;row.value = @(100);row.required = YES;// 在title前面添加图片row.image = [UIImage imageNamed:@&quot;jt_money&quot;];[section addFormRow:row]; row = [JTRowDescriptor formRowDescriptorWithTag:@&quot;21&quot; rowType:JTFormRowTypeNumber title:@&quot;人民币&quot;];NSNumberFormatter *numberFormatter1 = [NSNumberFormatter new];numberFormatter1.numberStyle = NSNumberFormatterCurrencyStyle;// 这里valueFormatter的作用是将数字转换成货币，例如10-&gt;￥10row.valueFormatter = numberFormatter1;row.value = @(100);row.required = YES;row.image = [UIImage imageNamed:@&quot;jt_money&quot;];[section addFormRow:row]; #pragma mark - common row = [JTRowDescriptor formRowDescriptorWithTag:JTFormRowTypeName rowType:JTFormRowTypeName title:@&quot;JTFormRowTypeName&quot;];// 占位符row.placeHolder = @&quot;请输入姓名...&quot;;// 赋值row.value = @&quot;djdjd&quot;;row.required = YES;[section addFormRow:row];// 创建JTForm，formDescriptor不能为空JTForm *form = [[JTForm alloc] initWithFormDescriptor:formDescriptor];form.frame = CGRectMake(0, 0, kJTScreenWidth, kJTScreenHeight-64.);[self.view addSubview:form];self.form = form; 行描述 JTRowDescriptor行描述JTRowDescriptor是单元行的数据源，我们通过修改行描述来控制着单元行的行为，例如：是否显示，是否可编辑，高度。下面是JTRowDescriptor的主要属性和常用方法 configMode配置模型。 titleColor：标题颜色 contentColor：详情颜色 placeHolderColor：占位符颜色 disabledTitleColor：禁用时标题颜色 disabledContentColor：禁用时详情颜色 bgColor：控件背景颜色 titleFont：标题字体 contentFont：详情字体 placeHlderFont：占位符字体 disabledTitleFont：禁用时标题字体 disabledContentFont：禁用时详情字体 JTSectionDescriptor和JTFormDescriptor同样具有这些属性，作用也类似。优先级JTRowDescriptor &gt; JTSectionDescriptor &gt; JTFormDescriptor image &amp; imageUrl用于加载图片，样式类似于UITableViewCell的imageView。image应用于静态图片，imageUrl用于加载网络图片。 rowType创建表单时，根据rowType来创建不同类型的单元行。目前库自带的rowType都已经添加到了[JTForm cellClassesForRowTypes]字典中，其中rowType为key，单元行类型Class为value。在创建时单元行时，你就可以通过字典根据rowType得到相应单元行的Class。 所以当你自定义单元行时，你需要在+ (void)load中，将相应的rowType以及对应的Class添加到[JTForm cellClassesForRowTypes]字典中。 tagnullable，若不为空，表单将其添加到字典中，其中key为tag，value为JTRowDescriptor实例。所以如果创建表单时有多个行描述tag值一样的话，字典中将只会保存最后添加进去的JTRowDescriptor。 你可以在表单中，根据tag值找到相对应的行描述。且在获取整个表单值的时候也会派上用场。 height该属性控制着单元行高度。默认值为JTFormUnspecifiedCellHeight，即不指定高度(自动调节高度)。 单元行高度的优先级： JTRowDescriptor的height属性 JTBaseCellDelegate的方法+ (CGFloat)formCellHeightForRowDescriptor:(JTRowDescriptor *)row; 自动调节高度 action响应事件，目前仅用于点击单元行。如果单元行上有多个控件有响应事件时，建议使用- (JTBaseCell *)cellInForm;得到当前的单元行cell，然后用[cell.button addTarget:self action:action forControlEvents:UIControlEvents]添加响应事件。 hidden &amp; disabledhidden：bool值，控制隐藏或者显示当前单元行disabled：bool值，控制当前单元行是否接受响应事件 JTSectionDescriptor和JTFormDescriptor同样具有这些属性，作用也类似。优先级JTRowDescriptor &gt; JTSectionDescriptor &gt; JTFormDescriptor cellConfigAfterUpdate &amp; cellConfigWhenDisabled &amp; cellConfigAtConfigure &amp; cellDataDictionary cellConfigAfterUpdate：配置cell，在‘update’方法后使用 cellConfigWhenDisabled：配置cell，当’update’方法后，且disabled属性为Yes时被使用 cellConfigAtConfigure：配置cell，当cell调用config之后，update方法之前调用 cellDataDictionary：预留，你可以选择使用时机 text文本方面的，属性比较多，统一放到这里讲 valueFormatter：文本格式转换，可以将数据格式化为一种易读的格式。‘NSFormatter’是一个抽象类，我们只使用它的子类，类似’NSDateFormatter’和‘NSNumberFormatter’ placeHolder：占位符，当value为空时显示该内容 maxNumberOfCharacters：文本类单元行能输入最大字符数 - (nullable NSString *)displayContentValue;:在未编辑状态时，详情的显示内容 - (nullable NSString *)editTextValue;：在编辑状态时，详情的显示内容 验证器你可以通过- (void)addValidator:(nonnull id&lt;JTFormValidateProtocol&gt;)validator;添加一个或多个验证器，验证器的作用是对单元行的值进行验证，来判断是否符合你的要求，例如：身份证格式，密码的复杂程度，字数长度等。 当然，除了库自带的验证器外，你可以自定义自己的验证器，注意需要实现代理JTFormValidateProtocol。 单元行类型文本类 JTFormRowTypeFloatText JTFormRowTypeText JTFormRowTypeName JTFormRowTypeEmail JTFormRowTypeNumber JTFormRowTypeInteger JTFormRowTypeDecimal JTFormRowTypePassword JTFormRowTypePhone JTFormRowTypeURL JTFormRowTypeTextView JTFormRowTypeInfo 主要的区别是键盘不同，需要注意的是：JTFormRowTypeTextView和JTFormRowTypeInfo是textview，而其它几种是textfield。 select类 JTFormRowTypePushSelect push到另一个vc中，仅可选择一个 JTFormRowTypeMultipleSelect push到另一个vc中，可选择多个 JTFormRowTypeSheetSelect UIAlertController，样式为UIAlertControllerStyleActionSheet JTFormRowTypeAlertSelect UIAlertController，样式为UIAlertControllerStyleAlert JTFormRowTypePickerSelect 类似于弹出键盘，inputview为UIPickeraaa 选择项通常会拥有一个展示文本，一个是代表value的id。例如你在选择汽车型号的时候，展示给你的是不同汽车的型号的文本，当你选中之后传给后台的是代表该型号的文本。 在选择类的单元行中，我们使用的选择项类型是JTOptionObject，主要由两个属性formDisplayText和formValue，含义顾名思义。选择项可以通过selectorOptions赋值得到，在单元行选中之后，单元行的value也是JTOptionObject类型(单选)或者为NSArray&lt;JTOptionObject *&gt; *类型(多选)，你可以使用NSObject类目方法- (id)cellValue;得到value。 date类 JTFormRowTypeDate JTFormRowTypeTime JTFormRowTypeDateTime JTFormRowTypeCountDownTimer JTFormRowTypeDateInline 除了JTFormRowTypeDateInline，其余集中的区别只是UIDatePicker中timeStyle和timeStyle的区别。JTFormRowTypeDateInline的效果如下： 其它 JTFormRowTypeSwitch JTFormRowTypeCheck JTFormRowTypeStepCounter JTFormRowTypeSegmentedControl JTFormRowTypeSlider 具体样式可以看demo JTBaseCell单元行的基类，如果你需要自定义单元行的话需要继承它。JTBaseCell里面的属性和方法都比较简单，需要注意的是JTBaseCellDelegate，下面来我来说明一下它的几个方法： configrequired。初始化控件，在这个方法里只需要创建需要的控件，但不需要为控件添加内容，因为这个时候并没有添加进去数据源JTRowDescriptor。在生命周期内该方法只会被调用一次，除非调用JTRowDescriptor的方法reloadCell，该方法会重新创建单元行。 子类中实现时需要调用[super config] updaterequired。更新视图内容，在生命周期中会被多次调用。在这个方法中，我们可以为已经创建好的内容添加内容。 子类中实现时需要调用[super update] 其它 剩下的几个方法都是@optional + (CGFloat)formCellHeightForRowDescriptor:(JTRowDescriptor *)row 指定单元行的高度 - (BOOL)formCellCanBecomeFirstResponder 指示单元行是否能够成为第一响应者, 默认返回NO - (BOOL)formCellBecomeFirstResponder 单元行成为第一响应者 - (BOOL)formCellResignFirstResponder 单元行放弃第一响应者 - (void)formCellDidSelected 当前的单元行被选中了 - (NSString *)formDescriptorHttpParameterName 为单元行设置一个参数名称。若不为空，当调用JTFormDescriptor的方法httpParameters返回的表单字典中，key为该参数名称，value为JTRowDescriptor的value。 - (void)formCellHighlight 单元行高亮 - (void)formCellUnhighlight 单元行不高亮 自定义单元行以demo中我自定义的单元行IGCell为例。 + (void)load首先，你需要一个rowType来代表该行。然后在+ (void)load方法中[[JTForm cellClassesForRowTypes] setObject:self forKey:JTFormRowTypeIGCell];将rowType与单元行关联起来。 config12345- (void)config{ [super config]; // 你的代码} 在这里你可以创建好控件，但不需要为控件添加内容。注意需要调用[super config];。 update12345- (void)update{ [super update]; // 你的代码} 在这个方法中，我们可以为已经创建好的内容添加内容。。注意需要调用[super update]; layoutSpecThatFits- (ASLayoutSpec *)layoutSpecThatFits:(ASSizeRange)constrainedSize。在这个方法中，你需要创建好布局。对此，你需要额外学习Texture(原AsyncDisplayKit)的布局系统。 表单行为控制hidden当表单完成之后，你可以通过改变JTRowDescriptor,JTSectionDescriptor,JTFormDescriptor hidden的值来隐藏或者显示相应的单元行，单元节，表单。 disabled你可以通过改变JTRowDescriptor,JTSectionDescriptor,JTFormDescriptor disabled的值来决定相应的单元行，单元节，表单是否可以被编辑。 delete row12JTSectionDescriptor *section = [JTSectionDescriptor formSection];section.sectionOptions = JTFormSectionOptionCanDelete; 你可以这样创建节描述，就可以让单元节具有删除单元行功能。 FAQ如何给section自定义 header/footer你也可以通过设置JTSectionDescriptor的headerHieght和headerView或者footerHieght和footerView属性来自定义header/footer。目前需要手动设置高度… 如何拿到表单的值你可以通过JTForm的- (NSDictionary *)formValues获取表单值。如果设置了验证器或者有必填项，可以先调用- (NSArray&lt;NSError *&gt; *)formValidationErrors来获取错误集合，再获取表单值进行其它操作。 如何给日期行设置最大，最小日期你可以通过下面的代码这样设置，虽然丑陋，但是能用… 12[row.cellConfigAtConfigure setObject:[NSDate date] forKey:@&quot;minimumDate&quot;];[row.cellConfigAtConfigure setObject:[NSDate dateWithTimeIntervalSinceNow:(60*60*24*3)] forKey:@&quot;maximumDate&quot;]; 如何改变cell的高度单元行高度的优先级： JTRowDescriptor的height属性 JTBaseCellDelegate的方法+ (CGFloat)formCellHeightForRowDescriptor:(JTRowDescriptor *)row; 根据布局来生成高度 如何自定义类似于JTFormRowTypeDateInline的内联行如果你想要创建类似JTFormRowTypeDateInline的内联行，就意味着你需要自定义两种单元行。拿JTFormRowTypeDateInline举个例子，A：JTFormDateCell，B：JTFormDateInlineCell。当你选中A时，B显示出来，再选中A，B消失。 首先，创建两种单元行A, B B在load方法中，还需要额外添加[[JTForm inlineRowTypesForRowTypes] setObject: A.rowType forKey:B.rowType] 剩下的操作为以下代码，你可以照着写。这里简单说明以下，当你选择A时，会调用formCellCanBecomeFirstResponder和formCellBecomeFirstResponder方法。随后调用canBecomeFirstResponder和becomeFirstResponder，注意这里必须调用super的方法，不然当前单元行无法成为第一响应者。在becomeFirstResponder中，我们创建B，并且添加到A后面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960- (BOOL)formCellCanBecomeFirstResponder{ return [self canBecomeFirstResponder];}- (BOOL)formCellBecomeFirstResponder{ if ([self isFirstResponder]) { return [self resignFirstResponder]; } return [self becomeFirstResponder];}- (BOOL)canBecomeFirstResponder{ [super canBecomeFirstResponder]; return !self.rowDescriptor.disabled;}- (BOOL)becomeFirstResponder{ [super becomeFirstResponder]; NSIndexPath *currentIndexPath = [self.rowDescriptor.sectionDescriptor.formDescriptor indexPathForRowDescriptor:self.rowDescriptor]; JTSectionDescriptor *section = [self.rowDescriptor.sectionDescriptor.formDescriptor.formSections objectAtIndex:currentIndexPath.section]; JTRowDescriptor *inlineRow = [JTRowDescriptor formRowDescriptorWithTag:nil rowType:JTFormRowTypeInlineDatePicker title:nil]; JTFormDateInlineCell *inlineCell = (JTFormDateInlineCell *)[inlineRow cellInForm]; NSAssert([inlineCell conformsToProtocol:@protocol(JTFormInlineCellDelegate)], @&quot;inline cell must conform to protocol 'JTFormInlineCellDelegate'&quot;); inlineCell.connectedRowDescriptor = self.rowDescriptor; [section addFormRow:inlineRow afterRow:self.rowDescriptor]; [self.findForm ensureRowIsVisible:inlineRow]; BOOL result = [super becomeFirstResponder]; if (result) { [self.findForm beginEditing:self.rowDescriptor]; } return result;}- (BOOL)canResignFirstResponder{ BOOL result = [super canResignFirstResponder]; return result;}- (BOOL)resignFirstResponder{ BOOL result = [super resignFirstResponder]; if ([self.rowDescriptor.rowType isEqualToString:JTFormRowTypeDateInline]) { NSIndexPath *currentIndexPath = [self.rowDescriptor.sectionDescriptor.formDescriptor indexPathForRowDescriptor:self.rowDescriptor]; NSIndexPath *nextRowPath = [NSIndexPath indexPathForRow:currentIndexPath.row + 1 inSection:currentIndexPath.section]; JTRowDescriptor *inlineRow = [self.rowDescriptor.sectionDescriptor.formDescriptor formRowAtIndex:nextRowPath]; if ([inlineRow.rowType isEqualToString:JTFormRowTypeInlineDatePicker]) { [self.rowDescriptor.sectionDescriptor removeFormRow:inlineRow]; } } return result;}","link":"/2019/05/16/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8JTForm/"},{"title":"如何创建和使用Bundle资源包","text":"说来惭愧，虽然已经创建过好几次了，但是偶尔还是会忘记步骤，所以在这里记录一下子，方便查阅。 简单来说，bundle就是一个文件，里面包含很多资源子文件，例如图片，音频，视频等。这些子文件是静态的，不参与编译。 创建及设置 创建bundle 将base sdk改成iOS样式，默认是macOS样式 将COMBINE_HIDPI_IMAGES设置为NO，否则打包完成之后的png图片将变为tiff格式 添加多语言 添加文字文件，文件名字为Localizable.strings 文件本地化，点击按钮后选择english 添加其他语言类型，例如chinese-simplified 添加图片等文件资源目前我的操作是将这些文件直接拖到项目中 如何调用bundle里面的资源将bundle拖到项目中，并且添加到build phases的Copy Bundle Resource中 图片类资源UIImage *image = [UIImage imageNamed:@&quot;bundleName/picName&quot;] bundleName: 包名picName: 图片名 语言本地化12345NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;bundleName&quot; withExtension:@&quot;bundle&quot;];NSBundle *bundle = [NSBundle bundleWithURL:url];NSString *language = [NSLocale preferredLanguages].firstObject;bundle = [NSBundle bundleWithPath:[bundle pathForResource:language ofType:@&quot;lproj&quot;]];NSString *value = [bundle localizedStringForKey:key value:key table:nil]; bundleName：包名","link":"/2019/05/14/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8Bundle%E8%B5%84%E6%BA%90%E5%8C%85/"},{"title":"如何将自己的库上传到cocoapods","text":"假设到这里你已经将你的代码上传了github上，如果没有的话就先别看了。在这里我会用自己的项目JTForm来讲解一下整个过程 生成及修改配置文件在创建之前，你需要将你的代码提交到github上，并且为它生成一个相应版本号的tag pod trunk register [EMAIL] [USERNAME]当你运行pod trunk me后，发现不是如上图的结果，那么你可能需要重新登陆或者注册，也就是运行如下的命令pod trunk register [EMAIL] [USERNAME]，运行成功之后，你填的邮箱会收到一封邮件，点进去点击里面的链接就算是登录成功了。 pod spec create JTFormcd到项目中，在readme.md的位置使用pod spec create JTForm。这个命令会生成一个JTForm.podspec的文件。 编辑JTForm.podspec你可以直接参考或者复制别的项目podspec文件里面的内容，仅需修改一些信息。你也可以看官方文档自己编辑。 12345678910111213141516171819Pod::Spec.new do |s| s.name = &quot;JTForm&quot; s.version = &quot;0.0.1&quot; s.summary = &quot;简单快速的创建复杂且流畅的表单，XLForm与Texture相结合&quot; s.homepage = &quot;https://github.com/kikido/JTForm&quot; s.license = { :type =&gt; &quot;MIT&quot;, } s.author = { &quot;kikido&quot; =&gt; &quot;kikido1992@gmail.com&quot; } s.source = { :git =&gt; &quot;https://github.com/kikido/JTForm.git&quot;, :tag =&gt; s.version.to_s } s.source_files = &quot;JTForm&quot;, &quot;JTForm/**/*.{h,m}&quot; s.resource = 'JTForm/JTForm.bundle' s.dependency &quot;SDWebImage&quot;, &quot;~&gt; 4.4.6&quot; s.dependency &quot;Texture&quot;, '~&gt; 2.8' s.requires_arc = true s.ios.deployment_target = '9.0' s.xcconfig = { &quot;HEADER_SEARCH_PATHS&quot; =&gt; &quot;$(SRCROOT)/SDWebImage&quot; } # s.public_header_files = &quot;Classes/**/*.h&quot;end pod spec lint验证你编辑的podspec文件是否符合规范，如果出现error的话是不可以的，warning的话是可以的，可以使用命令pod spec lint --allow-warnings来忽略所有warnings。 下面是我验证时出现的问题： 原因是因为podspec文件里面s.ios.deployment_target = '8.0'，而Texture仅支持iOS9.0以上的版本，所以我这里做了以下的修改：s.ios.deployment_target = '9.0'。 重新验证，出现了以下错误： 一开始我以为我的.h直接引用了第三方的文件导致，后来才发现是因为没有暴露SDWebImage的头文件。解决办法：在podspec文件修改配置s.xcconfig = { &quot;HEADER_SEARCH_PATHS&quot; =&gt; &quot;$(SRCROOT)/SDWebImage&quot; } 答案来源：关于组件化使用私有Pods的一些记录 重新编译，通过 pod trunk push –allow-warnings使用pod trunk push --allow-warnings命令将自己的库发布到cocoapods上，大概8分钟左上 pod setup上传成功之后，使用pod search无法搜到自己的库的话，你可以这样做： 命令rm ~/Library/Caches/CocoaPods/search_index.json 完成后重新使用pod search搜索 版本升级当你需要升级自己库版本的时候，你可以这样做： 修改podspec中s.version的版本号 提交到git，并打上相应版本号的tag 进入到podspec目录下，使用命令pod trunk push --allow-warnings更新库 更换版本如果你对当前版本的库不满意，但是又不想升级版本号。你可以这样做： 去掉git上相应版本号的tag git上传新的内容 上传之后打上相应版本号的tag","link":"/2019/05/15/%E5%A6%82%E4%BD%95%E5%B0%86%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%93%E4%B8%8A%E4%BC%A0%E5%88%B0cocoapods/"},{"title":"探究 block 数据结构及内存管理","text":"本文首先将介绍一些 block 的基础, 随后着重介绍下面的内容 block 的数据结构 block 的内存管理(retain，release) 会用到下面这个可编译的源码 基础语法Block 的语法比较难记, 以至于出现了 fuckingblocksyntax 这样的网站专门用于记录 block 的语法, 摘录如下: 作为变量 1returnType (^blockName)(parameterTypes) = ^returnType(parameters) {...}; 作为属性 1@property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes); 作为函数声明参数 1- (void)someMethodThatTakesABlock:(returnType (^nullability)(parameterTypes))blockName; 作为函数调用中的参数 1[someObject someMethodThatTakesABlock:^returnType (parameters) {...}]; 作为 typedef 12typedef returnType (^TypeName)(parameterTypes);TypeName blockName = ^returnType(parameters) {...}; 捕获外部变量block 可以捕获来自外部作用域的变量(id 类型, C++类型, 基础数据类型, block), 这是 block 一个很强大的特性 1234567- (void)foo { int anInteger = 42; void (^testBlock)(void) = ^{ NSLog(@&quot;Integer is: %i&quot;, anInteger); }; testBlock();} 正常情况下, 捕获的外部变量在 block 里做的修改，在外部是不起作用的。如果想要在外部起作用，需要使用 __block 来声明变量: 1int __block anInteger = 42 所以，根据变量是否被 __block 修饰，可以将变量分为两类： by ref： 引用类型。该类的变量被 __block 修饰，在 block 内部对其修改，外部也生效 by copy：拷贝类型。该类的变量不被 __block 修饰，在 block 内部对其修改，外部不生效(全局/静态 变量除外) 至于原因进阶部分会进行详细的探究 进阶数据结构运行下面的代码 123456789101112131415161718typedef void(^BLK)(void);- (void)foo{ static int staticInt = 5; int ret = 5; BLK globalBlock = ^{ int a = staticInt; }; BLK mallocBlock = ^{ int a = ret; }; NSLog(@&quot;global = %@&quot;, globalBlock); NSLog(@&quot;malloc = %@&quot;, mallocBlock); NSLog(@&quot;stack = %@&quot;, ^{int a = ret;});} 打印结果为 123global = &lt;__NSGlobalBlock__: 0x104bb22b0&gt;malloc = &lt;__NSMallocBlock__: 0x281a21bf0&gt;stack = &lt;__NSStackBlock__: 0x16b8266d8&gt; 在 iOS 平台中, 一共有三种类型的 block: _NSConcreteGlobalBlock： 在 .data 区域, block 内部没有访问任何的外部非(静态变量 &amp;&amp; 全局变量)的变量(^{;}同样是该类型) _NSConcreteMallocBlock： 在堆中创建内存, 使用__strong修饰的 block _NSConcreteStackBlock： 在栈中创建内存, 使用__weak修饰的 block 或者是匿名 block 优先级为 _NSConcreteGlobalBlock &gt; _NSConcreteMallocBlock == _NSConcreteStackBlock，即满足 _NSConcreteGlobalBlock 条件的 block 就是 _NSConcreteGlobalBlock 类型的 _NSConcreteGlobalBlock 类型的 block 我不知道初始化的时候是否直接在 .data 区域创建。_NSConcreteMallocBlock 和 _NSConcreteStackBlock类型的 block 在初始化时在栈中创建，随后如果有 __storng 强指针引用的话，则进行 retain 操作，将其内存拷贝到堆中，后续的 retain 操作则只是增加 block 的引用计数 使用命令xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-13.0.0 YOUR_FILE_NAME将下面的代码转换成 C++ 实现 12345678910111213141516171819202122- (void)foo{ static int staticInt = 5; NSObject *commonObject = [[NSObject alloc] init]; __weak NSObject *weakObject = commonObject; __block NSObject *byrefObject = [[NSObject alloc] init]; __block __weak NSObject *byrefWeakObject = commonObject; BLK blockObject = ^{ NSObject *val = commonObject; }; BLK malocBlock = ^{ staticInt++; NSLog(@&quot;%@&quot;, commonObject); NSLog(@&quot;%@&quot;, byrefWeakObject); NSLog(@&quot;%@&quot;, weakObject); NSLog(@&quot;%@&quot;, byrefObject); NSLog(@&quot;%@&quot;, byrefWeakObject); NSLog(@&quot;%@&quot;, blockObject); }; NSLog(@&quot;malloc = %@&quot;, malocBlock);} 转换得到的 C++ 实现， 只截取部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107static void __Block_byref_id_object_copy_131(void *dst, void *src) { _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);}static void __Block_byref_id_object_dispose_131(void *src) { _Block_object_dispose(*(void * *) ((char*)src + 40), 131);}struct __Block_byref_byrefObject_0 { void *__isa;__Block_byref_byrefObject_0 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); NSObject *__strong byrefObject;};struct __Block_byref_byrefWeakObject_1 { void *__isa;__Block_byref_byrefWeakObject_1 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); NSObject *__weak byrefWeakObject;};struct __TestObject__foo_block_impl_0 { struct __block_impl impl; struct __TestObject__foo_block_desc_0* Desc; NSObject *__strong commonObject; __TestObject__foo_block_impl_0(void *fp, struct __TestObject__foo_block_desc_0 *desc, NSObject *__strong _commonObject, int flags=0) : commonObject(_commonObject) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __TestObject__foo_block_func_0(struct __TestObject__foo_block_impl_0 *__cself) { NSObject *__strong commonObject = __cself-&gt;commonObject; // bound by copy NSObject *val = commonObject; }static void __TestObject__foo_block_copy_0(struct __TestObject__foo_block_impl_0*dst, struct __TestObject__foo_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;commonObject, (void*)src-&gt;commonObject, 3/*BLOCK_FIELD_IS_OBJECT*/);}static void __TestObject__foo_block_dispose_0(struct __TestObject__foo_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;commonObject, 3/*BLOCK_FIELD_IS_OBJECT*/);}static struct __TestObject__foo_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __TestObject__foo_block_impl_0*, struct __TestObject__foo_block_impl_0*); void (*dispose)(struct __TestObject__foo_block_impl_0*);} __TestObject__foo_block_desc_0_DATA = { 0, sizeof(struct __TestObject__foo_block_impl_0), __TestObject__foo_block_copy_0, __TestObject__foo_block_dispose_0};struct __TestObject__foo_block_impl_1 { struct __block_impl impl; struct __TestObject__foo_block_desc_1* Desc; int *staticInt; NSObject *__strong commonObject; NSObject *__weak weakObject; __strong BLK blockObject; __Block_byref_byrefWeakObject_1 *byrefWeakObject; // by ref __Block_byref_byrefObject_0 *byrefObject; // by ref __TestObject__foo_block_impl_1(void *fp, struct __TestObject__foo_block_desc_1 *desc, int *_staticInt, NSObject *__strong _commonObject, NSObject *__weak _weakObject, __strong BLK _blockObject, __Block_byref_byrefWeakObject_1 *_byrefWeakObject, __Block_byref_byrefObject_0 *_byrefObject, int flags=0) : staticInt(_staticInt), commonObject(_commonObject), weakObject(_weakObject), blockObject(_blockObject), byrefWeakObject(_byrefWeakObject-&gt;__forwarding), byrefObject(_byrefObject-&gt;__forwarding) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __TestObject__foo_block_func_1(struct __TestObject__foo_block_impl_1 *__cself) { __Block_byref_byrefWeakObject_1 *byrefWeakObject = __cself-&gt;byrefWeakObject; // bound by ref __Block_byref_byrefObject_0 *byrefObject = __cself-&gt;byrefObject; // bound by ref int *staticInt = __cself-&gt;staticInt; // bound by copy NSObject *__strong commonObject = __cself-&gt;commonObject; // bound by copy NSObject *__weak weakObject = __cself-&gt;weakObject; // bound by copy __strong BLK blockObject = __cself-&gt;blockObject; // bound by copy (*staticInt)++; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h0_ybj03b8d0mj52n8dx82v2br40000gn_T_TestObject_1a9b07_mi_0, commonObject); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h0_ybj03b8d0mj52n8dx82v2br40000gn_T_TestObject_1a9b07_mi_1, (byrefWeakObject-&gt;__forwarding-&gt;byrefWeakObject)); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h0_ybj03b8d0mj52n8dx82v2br40000gn_T_TestObject_1a9b07_mi_2, weakObject); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h0_ybj03b8d0mj52n8dx82v2br40000gn_T_TestObject_1a9b07_mi_3, (byrefObject-&gt;__forwarding-&gt;byrefObject)); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h0_ybj03b8d0mj52n8dx82v2br40000gn_T_TestObject_1a9b07_mi_4, (byrefWeakObject-&gt;__forwarding-&gt;byrefWeakObject)); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h0_ybj03b8d0mj52n8dx82v2br40000gn_T_TestObject_1a9b07_mi_5, blockObject); }static void __TestObject__foo_block_copy_1(struct __TestObject__foo_block_impl_1*dst, struct __TestObject__foo_block_impl_1*src) {_Block_object_assign((void*)&amp;dst-&gt;commonObject, (void*)src-&gt;commonObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_assign((void*)&amp;dst-&gt;byrefWeakObject, (void*)src-&gt;byrefWeakObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;weakObject, (void*)src-&gt;weakObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_assign((void*)&amp;dst-&gt;byrefObject, (void*)src-&gt;byrefObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;blockObject, (void*)src-&gt;blockObject, 7/*BLOCK_FIELD_IS_BLOCK*/);}static void __TestObject__foo_block_dispose_1(struct __TestObject__foo_block_impl_1*src) {_Block_object_dispose((void*)src-&gt;commonObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_dispose((void*)src-&gt;byrefWeakObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;weakObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_dispose((void*)src-&gt;byrefObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;blockObject, 7/*BLOCK_FIELD_IS_BLOCK*/);}static struct __TestObject__foo_block_desc_1 { size_t reserved; size_t Block_size; void (*copy)(struct __TestObject__foo_block_impl_1*, struct __TestObject__foo_block_impl_1*); void (*dispose)(struct __TestObject__foo_block_impl_1*);} __TestObject__foo_block_desc_1_DATA = { 0, sizeof(struct __TestObject__foo_block_impl_1), __TestObject__foo_block_copy_1, __TestObject__foo_block_dispose_1};static void _I_TestObject_foo(TestObject * self, SEL _cmd) { static int staticInt = 5; NSObject *commonObject = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;)); __attribute__((objc_ownership(weak))) NSObject *weakObject = commonObject; __attribute__((__blocks__(byref))) __Block_byref_byrefObject_0 byrefObject = {(void*)0,(__Block_byref_byrefObject_0 *)&amp;byrefObject, 33554432, sizeof(__Block_byref_byrefObject_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;))}; __attribute__((__blocks__(byref))) __attribute__((objc_ownership(weak))) __Block_byref_byrefWeakObject_1 byrefWeakObject = {(void*)0,(__Block_byref_byrefWeakObject_1 *)&amp;byrefWeakObject, 33554432, sizeof(__Block_byref_byrefWeakObject_1), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, commonObject}; BLK blockObject = ((void (*)())&amp;__TestObject__foo_block_impl_0((void *)__TestObject__foo_block_func_0, &amp;__TestObject__foo_block_desc_0_DATA, commonObject, 570425344)); BLK malocBlock = ((void (*)())&amp;__TestObject__foo_block_impl_1((void *)__TestObject__foo_block_func_1, &amp;__TestObject__foo_block_desc_1_DATA, &amp;staticInt, commonObject, weakObject, blockObject, (__Block_byref_byrefWeakObject_1 *)&amp;byrefWeakObject, (__Block_byref_byrefObject_0 *)&amp;byrefObject, 570425344)); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_h0_ybj03b8d0mj52n8dx82v2br40000gn_T_TestObject_1a9b07_mi_6, malocBlock);} 需要注意的是，上面生成的 C++ 代码中 block 的结构体，并不符合最新版本 objc4-779.1 源码里 block 的结构定义 在 objc4-779.1 里 block 结构体的定义如下: 12345678910111213141516171819202122232425262728#define BLOCK_DESCRIPTOR_1 1struct Block_descriptor_1 { uintptr_t reserved; uintptr_t size;};#define BLOCK_DESCRIPTOR_2 1struct Block_descriptor_2 { // requires BLOCK_HAS_COPY_DISPOSE void (*copy)(void *dst, const void *src); void (*dispose)(const void *);};#define BLOCK_DESCRIPTOR_3 1struct Block_descriptor_3 { // requires BLOCK_HAS_SIGNATURE const char *signature; const char *layout; // contents depend on BLOCK_HAS_EXTENDED_LAYOUT};struct Block_layout { void *isa; volatile int32_t flags; // contains ref count int32_t reserved; void (*invoke)(void *, ...); struct Block_descriptor_1 *descriptor; // imported variables}; 不是有三种类型的 BLOCK_DESCRIPTOR 结构体，只是根据功能将其分为三部分，其实是一个整体注意下面两个结构体在内存上是完全一样的，原因是结构体本身并不带有任何额外的附加信息 123456789101112131415struct SampleA { int a; int b; int c;};struct SampleB { int a; struct Part1 { int b; }; struct Part2 { int c; };}; Block_layout 成员变量介绍: void *isa: isa 指针 int flags: 使用位域来保存信息, 例如引用计数, 是否正在被销毁等信息 int reserved: 保留变量 void (*invoke)(void *, …): 函数指针, 指向 block 实现函数的调用地址 struct Block_descriptor *descriptor: block 的附加描述信息，一般来说都包含 Block_descriptor_1，但是是否包含 Block_descriptor_2 和 Block_descriptor_3 需要根据捕获外部变量的类型来判断 还有一些捕获的外部变量 位域名 位置 含义 BLOCK_DEALLOCATING 0x0001 1 表示正在被销毁 BLOCK_REFCOUNT_MASK 0xfffe block 是引用计数 BLOCK_NEEDS_FREE 1 &lt;&lt; 24 1 表示 block 已拷贝到堆中 BLOCK_HAS_COPY_DISPOSE 1 &lt;&lt; 25 block 是否有 copy/dispos 函数，即 descriptor 是否包含 Block_descriptor_2 BLOCK_HAS_CTOR 1 &lt;&lt; 26 copy/dispose helper 函数里面有 C++代码 BLOCK_IS_GC 1 &lt;&lt; 27 1 表示使用 GC 管理内存，iOS 平台中不使用 GC BLOCK_IS_GLOBAL 1 &lt;&lt; 28 1 表示是个全局 block BLOCK_USE_STRET 1 &lt;&lt; 29 arm64 架构下没用，不知道干嘛的 BLOCK_HAS_SIGNATURE 1 &lt;&lt; 30 是否有函数类型编码 BLOCK_HAS_EXTENDED_LAYOUT 1 &lt;&lt; 31 GC 下使用 Block_descriptor 成员变量介绍: unsigned long int reserved: 预留变量 unsigned long int size: block 结构体的 size 大小 void (*copy)(void *dst, void *src): copy 函数，将 block 成员变量 从栈拷贝到堆中。后面会再介绍 void (*dispose)(void *): dispose 函数， 对 block 成员变量内存回收 const char *signature：函数的类型编码 const char *layout: GC 下使用，不知道具体作用 让我们对照着 C++ 实现捋一遍，因为实现里的 block 结构体是老版本所以跟上面讲的可能会有出入 1234567891011121314151617181920212223struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr;};struct __TestObject__foo_block_impl_1 { struct __block_impl impl; struct __TestObject__foo_block_desc_1* Desc; int *staticInt; NSObject *__strong commonObject; NSObject *__weak weakObject; __strong BLK blockObject; __Block_byref_byrefWeakObject_1 *byrefWeakObject; // by ref __Block_byref_byrefObject_0 *byrefObject; // by ref __TestObject__foo_block_impl_1(void *fp, struct __TestObject__foo_block_desc_1 *desc, int *_staticInt, NSObject *__strong _commonObject, NSObject *__weak _weakObject, __strong BLK _blockObject, __Block_byref_byrefWeakObject_1 *_byrefWeakObject, __Block_byref_byrefObject_0 *_byrefObject, int flags=0) : staticInt(_staticInt), commonObject(_commonObject), weakObject(_weakObject), blockObject(_blockObject), byrefWeakObject(_byrefWeakObject-&gt;__forwarding), byrefObject(_byrefObject-&gt;__forwarding) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }}; 在结构体 __TestObject__foo_block_impl_1 有很多捕获的外部变量充当的成员变量，如下所示 123456int *staticInt;NSObject *__strong commonObject;NSObject *__weak weakObject;__strong BLK blockObject;__Block_byref_byrefWeakObject_1 *byrefWeakObject; // by ref__Block_byref_byrefObject_0 *byrefObject; // by ref 为了尽可能的谈论多的情况，在示例代码中我在 block 加了许多不同类型的外部变量可以看到，全局/静态 变量和 __block 变量，都是将变量的地址保存在成员变量中，这样做的目的是为了在内部修改该变量在外部也会生效。而其它非 __block 变量则仅仅拷贝了值，类似于浅拷贝 __Block_byref_byrefWeakObject_1 是 Block_byref 类型的结构体。__block 变量在编译时变成对应的 Block_byref 实例，且实例持有该变量 Block_byref 结构体的定义如下： 1234567891011121314151617struct Block_byref { void *isa; struct Block_byref *forwarding; volatile int32_t flags; // contains ref count uint32_t size;};struct Block_byref_2 { // requires BLOCK_BYREF_HAS_COPY_DISPOSE void (*byref_keep)(struct Block_byref *dst, struct Block_byref *src); void (*byref_destroy)(struct Block_byref *);};struct Block_byref_3 { // requires BLOCK_BYREF_LAYOUT_EXTENDED const char *layout;}; 类似 Block_descriptor，根据功能将其分为三部分成员变量介绍： void *isa：一般指向 0x0，如果该变量还被 __weak 修饰，则指向 _NSConcreteWeakBlockVariable struct Block_byref *forwarding：指向该结构体。在拷贝到堆的过程中，在堆中新建一个结构体实例，此时栈中的实例并没有被销毁，将栈中实例 forwarding 指向堆中的实例 int flags：引用计数使用的 bit 数目和位置与 block 相同，其它不再介绍 int size：Block_byref 结构体的字节长度 void (*byref_keep)(struct Block_byref *dst, struct Block_byref *src)：Block_byref 的 copy 函数，帮助将实例持有的变量拷贝到堆中 void (*byref_destroy)(struct Block_byref *)：Block_byref 的 dispose 函数，帮助将持有的变量销毁 const char *layout：Block_byref 持有的变量 为了方便，后面将 Block_layout 的 copy/dispose 函数简称为 Block copy/dispose 函数; Block_byref 的 byref_keep/byref_destroy 函数简称为 __block copy/dispose 函数 在 foo() 函数中我们在 block 捕获了两个 __block 修饰的变量，下面是其中一个的 Block_byref 结构体 123456789struct __Block_byref_byrefObject_0 { void *__isa;__Block_byref_byrefObject_0 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); NSObject *__strong byrefObject;}; 编译时，编译器会将 __block 修饰的变量 byrefObject，转换成对应的 Block_byref 结构体 __Block_byref_byrefObject_0 实例，然后让实例持有该变量NSObject *__strong byrefObject; block 结构体 __TestObject__foo_block_impl_1 里面还定义了一个初始化方法： 123456_TestObject__foo_block_impl_1(void *fp, struct __TestObject__foo_block_desc_1 *desc, int *_staticInt, NSObject *__strong _commonObject, NSObject *__weak _weakObject, __strong BLK _blockObject, __Block_byref_byrefWeakObject_1 *_byrefWeakObject, __Block_byref_byrefObject_0 *_byrefObject, int flags=0) : staticInt(_staticInt), commonObject(_commonObject), weakObject(_weakObject), blockObject(_blockObject), byrefWeakObject(_byrefWeakObject-&gt;__forwarding), byrefObject(_byrefObject-&gt;__forwarding) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } 其中类似 : commonObject(_commonObject) 的写法是将形参NSObject *__strong _commonObject赋值给成员变量 _commonObject 参数 flags 有一个默认值 0, 在本例中传入的值为 570425344, 用二进制表示为 0b00100010000000000000000000000000，即第 30 位(BLOCK_USE_STRET), 第 26 位(BLOCK_HAS_COPY_DISPOSE) bit 的值 1 参数 fp 是函数指针, 在本例中它的实现如下: 123456789101112static void __TestObject__foo_block_func_1(struct __TestObject__foo_block_impl_1 *__cself) { __Block_byref_byrefWeakObject_1 *byrefWeakObject = __cself-&gt;byrefWeakObject; // bound by ref __Block_byref_byrefObject_0 *byrefObject = __cself-&gt;byrefObject; // bound by ref int *staticInt = __cself-&gt;staticInt; // bound by copy NSObject *__strong commonObject = __cself-&gt;commonObject; // bound by copy NSObject *__weak weakObject = __cself-&gt;weakObject; // bound by copy __strong BLK blockObject = __cself-&gt;blockObject; // bound by copy (*staticInt)++; // 省略。。。 } 也就是 block 里面的代码。可以看到非 __block 变量后面都写了注释 bound by copy，__block 变量后面的注释是 bound by ref，__block 变量都会转换成 Block_byref 实例保存在 block 中为了方便，后面将 __block 修饰的变量称为引用变量，否则称为拷贝变量 block 初始化参数 desc 的类型是__TestObject__foo_block_desc_1 * 结构体的定义如下: 123456static struct __TestObject__foo_block_desc_1 { size_t reserved; size_t Block_size; void (*copy)(struct __TestObject__foo_block_impl_1*, struct __TestObject__foo_block_impl_1*); void (*dispose)(struct __TestObject__foo_block_impl_1*);} __TestObject__foo_block_desc_1_DATA = { 0, sizeof(struct __TestObject__foo_block_impl_1), __TestObject__foo_block_copy_1, __TestObject__foo_block_dispose_1}; 并且初始化了一个结构体实例 __TestObject__foo_block_desc_1_DATA，其中 reserved 的值为 0, Block_size 的值为结构体 __TestObject__foo_block_impl_1 的字节长度copy 和 dispose 两个函数指针分别指向函数 __TestObject__foo_block_copy_1 和 __TestObject__foo_block_dispose_1实现如下: 123static void __TestObject__foo_block_copy_1(struct __TestObject__foo_block_impl_1*dst, struct __TestObject__foo_block_impl_1*src) {_Block_object_assign((void*)&amp;dst-&gt;commonObject, (void*)src-&gt;commonObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_assign((void*)&amp;dst-&gt;byrefWeakObject, (void*)src-&gt;byrefWeakObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;weakObject, (void*)src-&gt;weakObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_assign((void*)&amp;dst-&gt;byrefObject, (void*)src-&gt;byrefObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;blockObject, (void*)src-&gt;blockObject, 7/*BLOCK_FIELD_IS_BLOCK*/);}static void __TestObject__foo_block_dispose_1(struct __TestObject__foo_block_impl_1*src) {_Block_object_dispose((void*)src-&gt;commonObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_dispose((void*)src-&gt;byrefWeakObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;weakObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_dispose((void*)src-&gt;byrefObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;blockObject, 7/*BLOCK_FIELD_IS_BLOCK*/);} 这两个函数很容易看懂，有多少捕获的外部变量，就调用多少次 _Block_object_assign() 和 _Block_object_dispose() 函数。需要注意的是 _Block_object_assign() 的第三个参数，根据变量的类型不同传入不同的标记，后面会详细讲 与其类似的是 Block_byref 的 copy/dispose 函数在本例中它们的实现如下： 123456static void __Block_byref_id_object_copy_131(void *dst, void *src) { _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);}static void __Block_byref_id_object_dispose_131(void *src) { _Block_object_dispose(*(void * *) ((char*)src + 40), 131);} 可以看到，Block_byref 的 copy/dispose 函数最终也是调用 _Block_object_assign/_Block_object_dispose 函数 至于参数为什么要强转成 char*, 我的理解是这样的： 举个例子，定义一个 int 类型的数组, int a[10]。我们可以使用指针来代替数组的下标, 例如用(int *)a + 1来表示数组的第二个元素, 其距离第一个元素偏移了 4 个字节长度，所以强制转换成 char* 类型是为了每次偏移 1 个字节。上面的代码表示偏移了 40 个字节 而老版本 Block_byref 的定义(因为 C++ 实现符合源码) 123456789struct Block_byref { void *isa; struct Block_byref *forwarding; int flags; /* refcount; */ int size; void (*byref_keep)(struct Block_byref *dst, struct Block_byref *src); void (*byref_destroy)(struct Block_byref *); /* long shared[0]; */}; Block_byref 偏移 40 个字节后的位置刚好是持有变量的首地址，所以在这里传入的参数即是引用变量(被 __block 修饰的变量)至于后面的数字 131 后面再讲 好了，数据结构就分析到这啦。目前我们可以知道的是，block 以及 __block 变量在编译时会生成对应的 Block_layout，Block_byref 结构体，它们都有各自的 copy/dispose 函数 验证 block 数据结构这一节主要使用 lldb 用来验证 block 的数据结构 打个断点，使用命令 x/8xg ptr 根据上一节 block 结构体内容，我们可以知道各成员变量的值 block 成员变量 值 void *isa 0x00000001ca53c0f0 volatile int32_t flags 0xc3000002 int32_t reserved 0x0 void (*invoke)(void *, …) 0x0000000104bcce80 struct Block_descriptor_1 *descriptor 0x000000010519e290 捕获变量 _commonObject 0x0000000281eaac10 Block_byref * _byrefObject 0x0000000281225170 验证一下： isa 指针指向 __NSMallocBlock__，没问题 flags 用二进制表示为 0b11000011000000000000000000000010，即位域 BLOCK_HAS_SIGNATURE，BLOCK_HAS_EXTENDED_LAYOUT，BLOCK_HAS_COPY_DISPOSE，BLOCK_NEEDS_FREE 为 1 引用计数 BLOCK_REFCOUNT_MASK 为 1 可以通过上面的方法打印出函数指针的内容 成员变量 _commonObject 的值于 commonObject 相同，均为 0x0000000281eaac10，说明是浅拷贝 下面来验证 descriptor0x000000010519e290 为 Block_descriptor_1 结构体的首地址 Block_descriptor 成员变量 值 解释 uintptr_t reserved 0x0 预留字段 uintptr_t size 0x0000000000000030 十进制为 48，即 block 结构体的字节长度 void (*copy)(void *dst, const void *src) 0x0000000104bccee8 copy 函数指针 void (*dispose)(const void *) 0x0000000104bccf54 dispose 函数指针 const char *signature 0x000000010511847f 函数类型编码 const char *layout 0x0000000000000110 不知道干嘛的 打印下 block 函数的类型编码 成员变量 const char *layout 应该是在 GC 下使用的，具体作用不明白 接下来验证 Block_byref 的结构 Block_byref 成员变量 值 解释 void *isa 0x0 isa struct Block_byref *forwarding 0x0000000281225170 十进制为 48，即 block 结构体的字节长度 volatile int32_t flags 0x33000004 标记，二级制表示为 0b00110011000000000000000000000100 uint32_t size 0x00000030 Block_byref 结构体长度 byref_keep 0x000000010511847f __block copy 函数指针 byref_destroy 0x0000000000000110 __block dispose 函数指针 const char *layout 0x0000000281eaac50 持有的变量 byrefObject flags 表示引用计数为 2，因为初始化有一个，然后 block 有一个。位域 BLOCK_BYREF_LAYOUT_STRONG 为 1，表示该变量是 __strong 类型const char *layout 表示其持有的变量 如何将 block 从栈拷贝到堆中现在我们来探究一下 block 是如何从栈中拷贝到堆中的吧。除 global block 类型的 block 均在栈中创建，当被强引用，即 retain block 的话，block 就会从栈拷贝到堆中，如果已经在堆中，则增加其引用计数 step into _Block_copy 的函数实现在 clang-800 源码 中可以看到 123void *_Block_copy(const void *arg) { return _Block_copy_internal(arg, WANTS_ONE);} 我们主要看红色框框里面的代码： 首先通过 malloc() 在堆中新建一个 block 结构体实例，接着使用memmove()将旧实例的数据拷贝过去 重置新实例成员变量 flags 的 BLOCK_REFCOUNT_MASK(引用计数)部分 将新实例成员变量 flags 的位域 BLOCK_NEEDS_FREE 设置为 1, 表示该 block 在堆中 将新实例的 isa 指向 _NSConcreteMallocBlock 如果存在 Block copy 函数，则调用 上一节中已经提到过，这里再贴一下它的实现： 12345678static void __TestObject__foo_block_copy_1(struct __TestObject__foo_block_impl_1*dst, struct __TestObject__foo_block_impl_1*src) {_Block_object_assign((void*)&amp;dst-&gt;commonObject, (void*)src-&gt;commonObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_assign((void*)&amp;dst-&gt;byrefWeakObject, (void*)src-&gt;byrefWeakObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;weakObject, (void*)src-&gt;weakObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_assign((void*)&amp;dst-&gt;byrefObject, (void*)src-&gt;byrefObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;blockObject, (void*)src-&gt;blockObject, 7/*BLOCK_FIELD_IS_BLOCK*/);} 需要注意的是，如果外部变量是 C++类型，则不会调用 _Block_object_assign()函数，而是其对应的 const 拷贝构造方法。注释如下：In these cases helper functions are synthesized by the compiler for use in Block_copy and Block_release, called the copy and dispose helpers. The copy helper emits a call to the C++ const copy constructor for C++ stack based objects and for the rest calls into the runtime support function _Block_object_assign. The dispose helper has a call to the C++ destructor for case 1 and a call into _Block_object_dispose for the rest. _Block_object_assign函数的实现如下: 参数 flags 有以下几种情况: 由 Block copy 函数调用： id 3 (^Block) 7 __block 8 __weak __block 8+16 flags 有 4 种可能: 3， 7， 8， (8+16) 由 __block copy 函数调用： BLOCK_BYREF_CALLER (128)：表示由 __block copy 调用此时, 传入的 flags 有 4 种可能: __block id 128+3 __block (^Block) 128+7 __weak __block id 128+3+16 __weak __block (^Block) 128+7+16 总共有以上 8 种情况 需要注意的是，Block copy 调用该函数，第一个参数是指针的地址(void **)，第二个参数传入的是指针的值(void *)而 __block copy 调用该函数，传入的前两个参数均为指针的值(void *) 下面根据 case 条件分几步来讲解这个函数： 代码块 1: Block copy 函数调用，且该变量是 id 类型的 代码_Block_retain_object()最终会调用下面这个函数 123static void _Block_retain_object_default(const void *ptr) { (void)ptr;} 代码_Block_assign()最终会调用下面这个函数 123static void _Block_assign_default(void *value, void **destptr) { *destptr = value;} 不知道调用 _Block_retain_object 函数的目的是什么这一分支仅做了浅拷贝，拷贝指针内容 代码块 2: Block copy 函数调用，且该变量也是一个 block 这里首先调用了 _Block_copy_internal() 函数, 先将 block 类型的变量拷贝到堆中然后调用 _Block_assign 将其堆中的地址赋值给 Block 对应的成员变量 代码块 3: Block copy 函数调用，且变量被 __block 修饰 这里传入的第一个参数 void *dest 表示的是指针的地址 _Block_byref_assign_copy 实现中代码块 1 的逻辑如下 声明一个布尔值 isWeak， 用来表示该变量是否还被 __weak 修饰 _Block_allocator 函数最终调用 malloc() 函数, 在堆上拷贝一份同样内存大小的 Block_byrefs 实例 将旧实例的成员变量 flags 拷贝到新实例中, 并将新实例的引用计数设置为 2。 1 份是因为栈上有一个实例, 1 份是因为堆上也有一个， 1+1 就等于 2 了 将旧实例和新实例的成员变量 forwarding 均赋值为新实例 如果 isWeak 为 true, 则将 Block_byrefs 实例的 isa 指针指向 _NSConcreteWeakBlockVariable 如果实例有 __block copy/dispose helpers(还是调用 _Block_object_assign 函数), 则调用它对实例持有的变量进行拷贝到堆操作; 如果没有的话则将旧实例中 size 后面的成员变量拷贝到新实例的 bit 中 函数里面有一行看起来比较让人困扰的代码 1struct Block_byref_2 *src2 = (struct Block_byref_2 *)(src+1); 在前面的声明中，src 被声明成了 Block_byref * 类型，所以 src + 1 的意思是从 src 的首地址偏移 sizeof(Block_byref) 个字节，即 Block_byref_2 的首地址结构体拷贝完成后，随后将 Block_byref 持有的变量通过函数 *src2-&gt;byref_keep 也拷贝到堆中_Block_byref_assign_copy 实现中代码块 2 的作用是如果 Block_byref 持有的变量已经拷贝到堆中了, 则增加其引用计数 代码块 4: __block copy 函数调用，且持有的变量不被 __weak 修饰 最终会调用下面那个函数 123static void _Block_assign_default(void *value, void **destptr) { *destptr = value;} 浅拷贝 代码块 5: __block copy 函数调用，且持有的变量被 __weak 修饰 最终会调用下面那个函数: 123static void _Block_assign_weak_default(const void *ptr, void *dest) { *(void **)dest = (void *)ptr;} 这里讲一下我的理解：void * 是一个指针，里面保存了一个地址，但是我们不能 *(void *) 这样使用它，因为我们不知道它指向的结构是什么类型的。如果要使用的话就需要将其转换成其它类型，例如 int *，所以在这里可以仅仅把它看成是变量，保存了一个地址。而 void **，其表示指向指针的指针，不同于 void *，我们可以 *(void **) 这样使用它，因为我们知道 void ** 指向的内容是一个指针。 在 _Block_assign_weak_default 函数中，我们先将 dest 强转成 void ** 类型，然后就可以对其进行赋值操作啦 至此，整个拷贝流程已经讲的差不多了，这里总结一下： 一个 block 可能捕获多个外部变量 block 在栈中生成，retain 后，将栈中的内容拷贝到堆中 block 会调用 Block copy 函数，对其捕获的变量也进行拷贝操作 如果是 C++ 类型，则调用其 const 拷贝构造函数到堆中 如果是 block 类型，则将其拷贝到堆中 如果是 id 类型，因为已经在堆中了，所以进行浅拷贝，仅复制指针值 如果是 __block 修饰的变量，则将其对应的 Block_byref 结构体拷贝到堆中，随后调用 __block copy 函数将其持有的变量也拷贝到堆中 如何销毁 block这一节我们将探究如何销毁 block 创建一个 malloc block 类型的 block，foo() 结束，block 会被回收。在函数尾巴那里打个断点 step into 将断点停留在objc_release()函数runtime 通过该函数对 block 进行 release 操作，如果其引用计数变成 0，则销毁 继续 step into block 是特殊的类，自己重写了release()函数，所以代码 ISA()-&gt;hasCustomRR() 返回的结果是 true，将执行自己重写的 release() 函数继续 step into 因为没有 block 的 release()源码，通过调用栈发现随后调用了 _Block_release() 函数在可编译的源码中可以找到该函数的实现(直接在文件夹中搜索) 根据 if 的判断将函数分为三个部分 判断条件 1：如果是全局 block 或者其引用计数已经为 0(表示已经在销毁了)， 则返回 判断条件 2：如果使用 GC 管理内存，则执行什么什么操作。因为 iOS 平台不使用 GC，所以略过 判断条件 3：如果 block 已经在堆上了，则将其引用计数减 1，如果减为 0，则调用下面三个函数 123_Block_call_dispose_helper(aBlock);_Block_destructInstance(aBlock);_Block_deallocator(aBlock); 第一个函数 _Block_call_dispose_helper 在同个文件中搜索该函数，其实现如下 1234567static void _Block_call_dispose_helper(struct Block_layout *aBlock){ struct Block_descriptor_2 *desc = _Block_descriptor_2(aBlock); if (!desc) return; (*desc-&gt;dispose)(aBlock);} 如果存在 Block dispose 函数，则调用 123456789static void __TestObject__foo_block_dispose_1(struct __TestObject__foo_block_impl_1*src) {_Block_object_dispose((void*)src-&gt;byrefInt, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;commonObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_dispose((void*)src-&gt;byrefWeakObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;weakObject, 3/*BLOCK_FIELD_IS_OBJECT*/);_Block_object_dispose((void*)src-&gt;byrefObject, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;blockObject, 7/*BLOCK_FIELD_IS_BLOCK*/);} 通过判断条件将 _Block_object_dispose 分为几部分 判断条件 1：变量由 __block 修饰 代码byref = byref-&gt;forwarding;，因为可能会有 byref 在栈中，而 forwarding 此时却在堆中的情况。随后判断 byref 是否在栈中，如果是的话则立即返回。对 Block_byref 的引用计数减 1 随后判断是否为 0，如果是的话则调用其 byref_destroy 函数(也就是 _Block_object_dispose)，销毁其持有的变量最后将 Block_byref 结构体的内存释放掉 判断条件 2：变量是 Block 类型 调用 _Block_release 来销毁该 block 判断条件 3：变量是 id 类型 _Block_release_object 最终调用的函数如下 123static void _Block_release_object_default(const void *ptr) { (void)ptr;} 等于什么都没做，这是因为 id 类型的对象由 ARC 管理其内存。即不再被强指针引用时引用计数减 1 判断条件 4 什么都没做，如果走到走一步说明可能系统有异常 接着讲 block 销毁时调用的第二个函数 _Block_destructInstance。调试时，调用栈里也有这个函数 接着 step into 使用该函数，主要是为了将在弱引用表中注册的使用 __weak 引用 block 的变量置为 nil，因为 block 已经要被销毁了这里不仔细讲了 最后调用 _Block_deallocator() 函数，将 block 结构体的内存销毁 这里总结一下 block 的内存销毁流程： 先将 block 捕获的外部变量进行销毁 将弱引用 block 的指针置为 nil 将 block 结构体的内存销毁","link":"/2020/05/11/%E6%8E%A2%E7%A9%B6-block-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"探究ARC下dealloc实现","text":"我是前言目前正在看 oc 底层的东西，看了许多大牛的博客，发现有一些小问题： runtime 的版本可能跟作者当时写的版本不一致 许多方法一笔带过，因为基础知识的薄弱看不懂。。。 没有标明苹果文档的出处 所以我打算解决上面的一些问题，然后重新发一版，当然大部分的内容还是原作者写的 。runtime 的源码为 objc4-646.tar.gz版本 进入正题在 ARC 环境下，我们不需要主动的调用系统的析构函数 dealloc 就能够完成将对象以及父类的成员变量内存释放掉的操作： 1234567- (void)dealloc{ // ... // // 非Objc对象内存的释放，如CFRelease(...) // ... //} 问题来了： 这个对象成员变量（ivars）的释放操作去哪儿了？ 没有主动调用 [super dealloc]，那么是什么时候调用这个方法的？ ARC文档中对dealloc过程的解释clang ARC文档 A class may provide a method definition for an instance method named dealloc. This method will be called after the final release of the object but before it is deallocated or any of its instance variables are destroyed. The superclass’s implementation of dealloc will be called automatically when the method returns. 大概意思是：dealloc 方法在最后一次 release 后被调用，但此时实例变量（ivars）并未释放，父类的dealloc的方法将在子类dealloc方法返回后自动调用 The instance variables for an ARC-compiled class will be destroyed at some point after control enters the dealloc method for the root class of the class. The ordering of the destruction of instance variables is unspecified, both within a single class and between subclasses and superclasses. ARC下对象的实例变量在根类 [NSObject dealloc] 中释放（通常root class都是NSObject），变量释放顺序各种不确定（一个类内的不确定，子类和父类间也不确定，也就是说不用care释放顺序） 所以，我们不需要主动调用 [super dealloc] ，系统会自动调用，后面我们再讲这是怎么实现的。接下来我们来探究在根类 NSObject 析构时发生了什么 NSObject的析构过程通过 runtime 源码，我们可以发现 NSObject 调用 dealloc 时会调用 _objc_rootDealloc(NSObject.mm 2071行) 继而调用object_dispose(objc-object.h 301行) 随后调用objc_destructInstance(objc-runtime-new.mm 6838行), 下面讲一下rootDealloc 和objc_destructInstance函数 123456789101112131415161718inline void objc_object::rootDealloc(){ assert(!UseGC); if (isTaggedPointer()) return; if (isa.indexed &amp;&amp; !isa.weakly_referenced &amp;&amp; !isa.has_assoc &amp;&amp; !isa.has_cxx_dtor) { assert(!sidetable_present()); free(this); } else { object_dispose((id)this); }} 64位下，isa 指针的结构: 123456789101112131415// ...struct { uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 30; // MACH_VM_MAX_ADDRESS 0x1a0000000 uintptr_t magic : 9; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 19;# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18) };// ... indexed(1 bit) 0 表示普通的 isa 指针，1 表示使用优化，即Tagged Pointer存储引用计数 has_assoc(1 bit) 表示该对象是否包含 associated object，如果没有，则析构(释放内存)时会更快 has_cxx_dtor(1 bit) 表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构（释放内存）时更快 shiftcls(30 bits) 类的指针 magic(9 bits) 固定值为 0xd2，用于在调试时分辨对象是否未完成初始化。 weakly_referenced(1 bit) 表示该对象是否有过 weak 对象，如果没有，则析构（释放内存）时更快 deallocating(1 bit) 表示该对象是否正在析构 has_sidetable_rc(1 bit) 表示该对象的引用计数值是否过大无法存储在 isa 指针 extra_jc(19 bits) 表示引用计数值减一后的结果。例如，如果对象引用计数为4，则extra_jc为3 12345678910111213141516void *objc_destructInstance(id obj) { if (obj) { // Read all of the flags at once for performance. bool cxx = obj-&gt;hasCxxDtor(); bool assoc = !UseGC &amp;&amp; obj-&gt;hasAssociatedObjects(); bool dealloc = !UseGC; // This order is important. if (cxx) object_cxxDestruct(obj); if (assoc) _object_remove_assocations(obj); if (dealloc) obj-&gt;clearDeallocating(); } return obj;} objc_destructInstance干了三件事情： 执行了一个 object_cxxDestruct 函数 执行_object_remove_assocations函数去除和这个对象 assocate 的对象（常用于类目中添加的属性 ） 执行clearDeallocating， 清空引用计数并清除弱引用表，将所有使用__weak修饰的指向该对象的变量置为nil 所以，ARC 自动释放实例变量的地方就在 object_cxxDestruct 这个方法里面没跑了。 探究 object_cxxDestruct上面找到的名为object_cxxDestruct的方法最终成为下面的调用 12345678910111213141516171819static void object_cxxDestructFromClass(id obj, Class cls){ void (*dtor)(id); // Call cls's dtor first, then superclasses's dtors. for ( ; cls != NULL; cls = _class_getSuperclass(cls)) { if (!_class_hasCxxStructors(cls)) return; dtor = (void(*)(id)) lookupMethodInClassAndLoadCache(cls, SEL_cxx_destruct); if (dtor != (void(*)(id))_objc_msgForward_internal) { if (PrintCxxCtors) { _objc_inform(&quot;CXX: calling C++ destructors for class %s&quot;, _class_getName(cls)); } (*dtor)(obj); } }} 代码的大致意思是通过继承链(isa)向上递归调用 SEL_cxx_destruct这个函数的函数实现从这篇文章提到： ARC actually creates a -.cxx_destruct method to handle freeing instance variables. This method was originally created for calling C++ destructors automatically when an object was destroyed. 和《Effective Objective-C 2.0》中的： When the compiler saw that an object contained C++ objects, it would generate a method called .cxx_destruct. ARC piggybacks on this method and emits the required cleanup code within it. 可以了解到cxx_destruct方法原本是为了 C++ 对象析构的，ARC 借用了这个方法插入代码实现了自动释放的工作。 通过实验找出 .cxx_destruct12345678@interface Father : NSObject@property (nonatomic, copy) NSString *name;@end@interface Son : Father@property (nonatomic, copy) NSArray *toys;@end 只有两个简单的属性，找个地方写简单的测试代码： 123456789// start{ // before new Son *son = [Son new]; son.name = @&quot;sark&quot;; son.toys = @[@&quot;sunny&quot;, @&quot;xx&quot;]; // after new}// gone 当过了大括号的作用域，son 对象就会被释放。所以在after new这行son对象初始化完成，在gone这行son对象被dealloc。 本次实验使用 NSObject+DLIntrospection 这个扩展来作用调试工具，通过它可以轻松打出一个类的方法，成员变量等。将这个扩展引入工程，在 after new 处设置一个断点，在这里打印出 Son 类所有的方法名： 1234567po [[Son class] instanceMethods]&lt;__NSArrayI 0x280982520&gt;(- (void)setToys:(id)arg0 ,- (id)toys,- (void).cxx_destruct) 发现出现了.cxx_destruct这个方法，经过几次实验，发现： 只有在ARC下这个方法才会出现（试验代码的情况下） 只有当前类拥有实例变量时（不论是不是用property）这个方法才会出现，且父类的实例变量不会导致子类拥有这个方法 出现这个方法和变量是否被赋值，赋值成什么没有关系 使用 watchpoint 定位内存释放时刻依然在 after new 断点处，输入 lldb 命令： 12watchpoint set variable son-&gt;_name 将name的变量加入watchpoint，当这个变量被修改时会触发trigger：从中可以看出，在这个时刻，_name 从 0x0000000104ac5048 变成了0x0000000000000000，也就是nil，赶紧看下调用栈：发现果然跟到了.cxx_destruct方法，而且是在objc_storeStrong方法中释放 刨根问底.cxx_destruct知道了ARC环境下，对象实例变量的释放过程在 .cxx_destruct 内完成，但这个函数内部发生了什么，是如何调用 objc_storeStrong 释放变量的呢？从上面的探究中知道，.cxx_destruct 是编译器生成的代码，那它很可能在clang前端编译时完成，这让我联想到clang的Code Generation，因为之前曾经使用clang -rewrite-objc xxx.m时查看过官方文档留下了些印象，于是google：.cxx_destruct site:clang.llvm.org 结果发现clang的 doxygen 文档中 CodeGenModule 模块正是这部分的实现代码，cxx相关的代码生成部分源码在http://clang.llvm.org/doxygen/CodeGenModule_8cpp-source.html位于1827行，删减掉离题部分如下： 1234567891011121314151617/// EmitObjCIvarInitializations - Emit information for ivar initialization/// for an implementation.void CodeGenModule::EmitObjCIvarInitializations(ObjCImplementationDecl *D){ DeclContext* DC = const_cast&lt;DeclContext*&gt;(dyn_cast&lt;DeclContext&gt;(D)); assert(DC &amp;&amp; &quot;EmitObjCIvarInitializations - null DeclContext&quot;); IdentifierInfo *II = &amp;getContext().Idents.get(&quot;.cxx_destruct&quot;); Selector cxxSelector = getContext().Selectors.getSelector(0, &amp;II); ObjCMethodDecl *DTORMethod = ObjCMethodDecl::Create(getContext(), D-&gt;getLocation(), D-&gt;getLocation(), cxxSelector, getContext().VoidTy, 0, DC, true, false, true, ObjCMethodDecl::Required); D-&gt;addInstanceMethod(DTORMethod); CodeGenFunction(*this).GenerateObjCCtorDtorMethod(D, DTORMethod, false);} 这个函数大概作用是：获取到 .cxx_destruct 的selector，创建 Method，然后加入到这个类的方法列表中，最后一行的调用才是真的创建这个方法的实现。这个方法位于http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html 1354行，包含了构造和析构的 cxx 方法，继续跟随 .cxx_destruct，最终调用 emitCXXDestructMethod 函数，代码如下： 12345678910111213141516171819202122232425262728293031323334static void emitCXXDestructMethod(CodeGenFunction &amp;CGF, ObjCImplementationDecl *impl){ CodeGenFunction::RunCleanupsScope scope(CGF); llvm::Value *self = CGF.LoadObjCSelf(); const ObjCInterfaceDecl *iface = impl-&gt;getClassInterface(); for (const ObjCIvarDecl *ivar = iface-&gt;all_declared_ivar_begin(); ivar; ivar = ivar-&gt;getNextIvar()) { QualType type = ivar-&gt;getType(); // Check whether the ivar is a destructible type. QualType::DestructionKind dtorKind = type.isDestructedType(); if (!dtorKind) continue; CodeGenFunction::Destroyer *destroyer = 0; // Use a call to objc_storeStrong to destroy strong ivars, for the // general benefit of the tools. if (dtorKind == QualType::DK_objc_strong_lifetime) { destroyer = destroyARCStrongWithStore; // Otherwise use the default for the destruction kind. } else { destroyer = CGF.getDestroyer(dtorKind); } CleanupKind cleanupKind = CGF.getCleanupKind(dtorKind); CGF.EHStack.pushCleanup&lt;DestroyIvar&gt;(cleanupKind, self, ivar, destroyer, cleanupKind &amp; EHCleanup); } assert(scope.requiresCleanups() &amp;&amp; &quot;nothing to do in .cxx_destruct?&quot;);} 分析这段代码以及其中调用后发现：它遍历当前对象所有的实例变量（Ivars)，调用objc_storeStrong，从clang的ARC文档上可以找到 objc_storeStrong 的示意代码实现如下： 123456void objc_storeStrong(id *object, id value) { id oldValue = *object; value = [value retain]; *object = value; [oldValue release];} 在 .cxx_destruct 进行形如 objc_storeStrong(&amp;ivar, null) 的调用后，这个实例变量就被release和设置成nil了 自动调用[super dealloc]的实现按照上面的思路，自动调用 [super dealloc] 也一定是 CodeGen 的工作了，位于http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html 492行 StartObjCMethod 方法中： 12if (ident-&gt;isStr(&quot;dealloc&quot;)) EHStack.pushCleanup&lt;FinishARCDealloc&gt;(getARCCleanupKind()); 上面代码可以得知在调用dealloc方法时被插入了代码，由FinishARCDealloc结构定义： 12345678910111213141516171819202122232425struct FinishARCDealloc : EHScopeStack::Cleanup { void Emit(CodeGenFunction &amp;CGF, Flags flags) override { const ObjCMethodDecl *method = cast&lt;ObjCMethodDecl&gt;(CGF.CurCodeDecl); const ObjCImplDecl *impl = cast&lt;ObjCImplDecl&gt;(method-&gt;getDeclContext()); const ObjCInterfaceDecl *iface = impl-&gt;getClassInterface(); if (!iface-&gt;getSuperClass()) return; bool isCategory = isa&lt;ObjCCategoryImplDecl&gt;(impl); // Call [super dealloc] if we have a superclass. llvm::Value *self = CGF.LoadObjCSelf(); CallArgList args; CGF.CGM.getObjCRuntime().GenerateMessageSendSuper(CGF, ReturnValueSlot(), CGF.getContext().VoidTy, method-&gt;getSelector(), iface, isCategory, self, /*is class msg*/ false, args, method); }}; 上面代码基本上就是向父类转发dealloc的调用，实现了自动调用[super dealloc]方法。 总结 ARC下对象的成员变量在编译器插入的.cxx_desctruct方法自动释放 ARC下[super dealloc]方法也由编译器自动插入 所谓编译器插入代码过程需要进一步了解，还不清楚其运作方式 ARC环境，对象的实例变量将在根类 NSObject 的 dealloc 方法中释放内存 Father 的实例变量(如果有)将在它的 .cxx_desctruct方法中被释放，而 Son 的实例变量(如果有)将在它的 .cxx_desctruct方法中被释放 子类在调用 dealloc 方法时会被插入代码，自动调用父类的 dealloc 方法 引用ARC下dealloc过程及.cxx_destruct的探究iOS内存管理之二","link":"/2019/06/24/%E6%8E%A2%E7%A9%B6ARC%E4%B8%8Bdealloc%E5%AE%9E%E7%8E%B0/"},{"title":"探究runtime碰到的类和结构体","text":"在研究 runtime 时能遇到许多的类和结构体, 因为不可能每篇文章碰到就介绍一遍, 所以在这里统一把这些碰到的类和结构体介绍一下 SideTable这个类的作用是存放引用计数表和弱引用表, 并使用自旋锁来防止操作表结构时可能的竞态条件定义如下: 123456789101112131415161718192021222324struct SideTable { spinlock_t slock; RefcountMap refcnts; weak_table_t weak_table; SideTable() { memset(&amp;weak_table, 0, sizeof(weak_table)); } ~SideTable() { _objc_fatal(&quot;Do not delete SideTable.&quot;); } void lock() { slock.lock(); } void unlock() { slock.unlock(); } void forceReset() { slock.forceReset(); } // Address-ordered lock discipline for a pair of side tables. template&lt;HaveOld, HaveNew&gt; static void lockTwo(SideTable *lock1, SideTable *lock2); template&lt;HaveOld, HaveNew&gt; static void unlockTwo(SideTable *lock1, SideTable *lock2);}; 有下面几个成员变量 spinlock_t slock: 自旋锁 RefcountMap refcnts: 额外引用计数存储表 weak_table_t weak_table: 弱引用表, 用来存储弱引用者(weak 修饰的变量) 其中RefcountMap是类型objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,RefcountMapValuePurgeable&gt;的别名 DisguisedPtr定义如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344template &lt;typename T&gt;class DisguisedPtr { uintptr_t value; static uintptr_t disguise(T* ptr) { return -(uintptr_t)ptr; } static T* undisguise(uintptr_t val) { return (T*)-val; } public: DisguisedPtr() { } DisguisedPtr(T* ptr) : value(disguise(ptr)) { } DisguisedPtr(const DisguisedPtr&lt;T&gt;&amp; ptr) : value(ptr.value) { } DisguisedPtr&lt;T&gt;&amp; operator = (T* rhs) { value = disguise(rhs); return *this; } DisguisedPtr&lt;T&gt;&amp; operator = (const DisguisedPtr&lt;T&gt;&amp; rhs) { value = rhs.value; return *this; } operator T* () const { return undisguise(value); } T* operator -&gt; () const { return undisguise(value); } T&amp; operator * () const { return *undisguise(value); } T&amp; operator [] (size_t i) const { return undisguise(value)[i]; } // pointer arithmetic operators omitted // because we don't currently use them anywhere}; 这个类的作用是伪装指针, 避免引用计数表和弱引用表里面保存的指针被内存泄漏工具leaks当做是内存泄漏. 它的成员变量value存储的是经过函数disguise()处理后的指针. 你可以像操作指针一样操作DisguisedPtr实例. 为了实现这个功能, DisguisedPtr重载了许多的操作符, 例如-&gt;, *, =, ==, []. 不了解的同学可以自己查资料, 关键字 运算符重载operator DisguisedPtr一般用来充当 Key, 保存在结构体中 RefcountMapValuePurgeable定义如下: 12345struct RefcountMapValuePurgeable { static inline bool isPurgeable(size_t x) { return x == 0; }}; 只有一个内联函数RefcountMapValuePurgeable, 用来判断这个值需要是否析构释放内存 DenseMapInfo123456789101112131415template&lt;typename T&gt;struct DenseMapInfo&lt;DisguisedPtr&lt;T&gt;&gt; { static inline DisguisedPtr&lt;T&gt; getEmptyKey() { return DisguisedPtr&lt;T&gt;((T*)(uintptr_t)-1); } static inline DisguisedPtr&lt;T&gt; getTombstoneKey() { return DisguisedPtr&lt;T&gt;((T*)(uintptr_t)-2); } static unsigned getHashValue(const T *PtrVal) { return ptr_hash((uintptr_t)PtrVal); } static bool isEqual(const DisguisedPtr&lt;T&gt; &amp;LHS, const DisguisedPtr&lt;T&gt; &amp;RHS) { return LHS == RHS; }}; 它有两个内联函数: getEmptyKey(): 生成 empty 的标记 getTombstoneKey(): 生成墓碑标记(即代表之前被人使用过但现在已经没人用了) 有两个静态函数: getHashValue(): 根据指针返回一个哈希值 isEqual(): 判断两个参数是否相等 DenseMapInfo常常跟DisguisedPtr一起使用. 它的两个内联函数用来标记存储数据的DenseMapPair实例 bucket 的状态是否是 empty 或者 tombstoneKey. 它的getHashValue函数用来生成一个哈希值来确定 bucket 的序号 detail::DenseMapPair部分定义如下: 12345678910template &lt;typename KeyT, typename ValueT&gt;struct DenseMapPair : public std::pair&lt;KeyT, ValueT&gt; { // FIXME: Switch to inheriting constructors when we drop support for older // clang versions. // NOTE: This default constructor is declared with '{}' rather than // '= default' to work around a separate bug in clang-3.8. This can // also go when we switch to inheriting constructors. DenseMapPair() {}} 它的父类std::pair是一个结构体模板, 它将两个数据组合成一个数据, 类似于我们经常用的字典.DenseMapPair被用来在引用计数表中保存引用计数. 其中 key 的类型为DisguisedPtr DenseMap部分定义如下: 12345678910111213141516171819202122template &lt;typename KeyT, typename ValueT, typename ValueInfoT = DenseMapValueInfo&lt;ValueT&gt;, typename KeyInfoT = DenseMapInfo&lt;KeyT&gt;, typename BucketT = detail::DenseMapPair&lt;KeyT, ValueT&gt;&gt;class DenseMap : public DenseMapBase&lt;DenseMap&lt;KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;, KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt; { friend class DenseMapBase&lt;DenseMap, KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;; // Lift some types from the dependent base class into this class for // simplicity of referring to them. using BaseT = DenseMapBase&lt;DenseMap, KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;; BucketT *Buckets; unsigned NumEntries; unsigned NumTombstones; unsigned NumBuckets;public: /// Create a DenseMap wth an optional \\p InitialReserve that guarantee that /// this number of elements can be inserted in the map without grow() explicit DenseMap(unsigned InitialReserve = 0) { init(InitialReserve); }} 这个类就是之前提到的引用计数表, 它的成员里面有一个存储数组, 用来保存引用计数. 数组的元素类型为 detail::DenseMapPair如果一个对象的引用计数曾经溢出保存到表中, 当对象被销毁时, 会将表中对象使用过的存储器 bucket 标记为墓碑状态 1friend class DenseMapBase&lt;DenseMap, KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;; 用于声明一个友元类, 这样DenseMapBase就能访问DenseMap里面的私有属性和私有方法了 1using BaseT = DenseMapBase&lt;DenseMap, KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;; 为DenseMapBase&lt;DenseMap, KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;添加一个类型别名 1explicit DenseMap(unsigned InitialReserve = 0) { init(InitialReserve); } 上面那行代码的作用是显示的声明一个构造方式, 这样这类就不能隐式转换了 成员变量如下: Buckets: 一个 bucket 数组, 用于保存数据. 可扩容 NumEntries: Buckets 数组中已经被使用的数目 NumTombstones: Buckets 数组中 tombstone 的数目 NumBuckets: Buckets 数组的数目 weak_table_t123456struct weak_table_t { weak_entry_t *weak_entries; size_t num_entries; uintptr_t mask; uintptr_t max_hash_displacement;}; 这个结构体用来存储弱引用条目, 弱引用条目里面保存着对象以及它的弱引用者们.当数组数量超过 1024 且被使用的数量占比小于 1/16 时, 数组长度会缩小为原来的 1/8 它有 4 个成员变量: weak_entry_t *weak_entries: weak_entry_t 类型的数组. 弱引用条目, 用来保存弱引用者(被 weak 修饰的指针) size_t num_entries: 已经被使用的条目数量 uintptr_t mask: 条目数组的数量 uintptr_t max_hash_displacement: 用来记录数组中被使用条目的 index 的最大值 weak_entry_t123456789101112131415161718192021222324252627282930313233struct weak_entry_t { DisguisedPtr&lt;objc_object&gt; referent; union { struct { weak_referrer_t *referrers; uintptr_t out_of_line_ness : 2; uintptr_t num_refs : PTR_MINUS_2; uintptr_t mask; uintptr_t max_hash_displacement; }; struct { // out_of_line_ness field is low bits of inline_referrers[1] weak_referrer_t inline_referrers[WEAK_INLINE_COUNT]; }; }; bool out_of_line() { return (out_of_line_ness == REFERRERS_OUT_OF_LINE); } weak_entry_t&amp; operator=(const weak_entry_t&amp; other) { memcpy(this, &amp;other, sizeof(other)); return *this; } weak_entry_t(objc_object *newReferent, objc_object **newReferrer) : referent(newReferent) { inline_referrers[0] = newReferrer; for (int i = 1; i &lt; WEAK_INLINE_COUNT; i++) { inline_referrers[i] = nil; } }}; 这个结构体用来保存引用对象以及它的弱引用者, 属于一对多的关系当弱引用比较少的时候会将弱引用者保存在结构体里面, 当弱引用者数量超过 4 时会保存到外部的数组中 它有两个成员变量, 一个是DisguisedPtr&lt;objc_object&gt; referent;, 另一个是联合体 union.referent 表示引用对象, 当一个弱引用者引用了一个新的对象, 那么我们需要从弱引用条目中(weak_entry_t)移除该弱引用者 weak_referrer_t 是 DisguisedPtr&lt;objc_object *&gt; 类型的别名 第二个成员变量 union 里面有两个结构体, 我这里称呼它们为 s1, s2.因为是 union, 所以 s1 里面的 out_of_line_ness 跟 s2 里面的 inline_referrers 的第二个元素的低 2 个 bit 是重合的. 数组 inline_referrers 的元素是 weak_referrer_t 类型. 在 arm64 架构下, 指针 8 字节对齐, 意味着指针低 3 位肯定都是 0, 经过DisguisedPtr的伪装后, 它的低 2 位都是 1, 也就是 s1 的 out_of_line_ness 的值为 0b11.这个特性用来标记是否使用内部数组来保存弱引用者, 当使用外部数组时, 内部数组被清空, 将 out_of_line_ness 赋值为 0b10 来表示使用外部数组 当使用内部数组时 s1 的成员变量均没有意义 使用 s2 的 inline_referrers 数组来保存弱引用者. 当使用外部数组时 s1 的成员变量referrers是指向外部数组的指针; out_of_line_ness为常量 2, 表示使用了外部数组; mask表示外部数组的长度 - 1; num_refs表示外部数组中被使用的数量; max_hash_displacement表示哈希最大偏移量 此时 s2 的成员变量 inline_referrers 被清空","link":"/2020/04/23/%E6%8E%A2%E7%A9%B6runtime%E7%A2%B0%E5%88%B0%E7%9A%84%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/"},{"title":"深入了解 iOS 引用计数","text":"iOS 通过引用计数来管理内存，简单的说就是当一个 id 类型的对象引用计数变成 0 的时候就会被销毁，回收内存。本文将通过断点调试来探究引用计数的存储及读取在底层的实现。全程无聊，请配合源码阅读 源码版本：objc4-779.1当然还是推荐使用这个来学习：可编译的源码 引用计数存储在哪引用计数只适用于 id 类型的对象 有一种特殊的 id 类型对象，Tagged Pointer，如果不知道的话可以看我另一篇博客 深入了解Tagged Pointer了解一下 因为 Tagged Pointer 并不是真正的对象，所以它并不通过引用计数来管理其内存。用下面的代码求 n1 的引用计数，输出结果为 9223372036854775807 123// 创建一个 Tagged Pointer 对象NSNumber *n1 = [NSNumber numberWithInt:1];NSLog(@&quot;n1 rc = %ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(n1))); 我们知道每个 id 类型对象都有一个 isa 指针，其中只有 33 位用来保存其父类或者元类信息，剩余的31位也不能浪费啊，这其中就会一些 bit 用来保存引用计数。下面是 arm64 架构下的 isa 结构 1234567891011121314151617181920212223242526union isa_t { isa_t() { } isa_t(uintptr_t value) : bits(value) { } Class cls; uintptr_t bits; struct {# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL# define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 19# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18) };#endif}; 可以发现，isa_t 是一个联合体(union)，几个不同类型的变量 clas 和 bits 及 struct 共用同一段内存。当 isa 指针的第一位nonpointer为 1 时表示它是优化的 isa 指针，即将多余的 bit 用来存储其它信息，从它的名字nonpointer也可以看出它不再是一个纯粹的指针了。当为 1 时，第一个成员变量cls是没有用的，因为 isa 不再使用它来指向父类 cls。下面是 isa 指针各位域的含义 变量名 含义 nonpointer 表示是否对 isa 指针开启优化 0:纯isa指针，1:存储了额外信息 has_assoc 表示该对象是否包含 associated object，如果没有，则析构时会更快 has_cxx_dtor 表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快 shiftcls 类的指针 magic 固定值 0x1a, 用于调试器判断当前对象是真的对象还是没有初始化的空间 weakly_referenced 表示该对象是否有过 weak 对象，如果没有，则析构时更快 deallocating 表示该对象是否正在析构 has_sidetable_rc 表示该对象的引用计数值是否过大无法存储在 isa 指针 extra_rc 存储引用计数值减一后的结果 在 arm64 下, isa 使用 19 个 bit 用来存储引用计数. 当引用计数超过这个数时，将会把 RC_HALF 数量的引用计数存储在一个全局哈希表中，此时 has_sidetable_rc 变为 1 增加引用计数下面让我们通过调试来探究具体的存储过程因为是在模拟器中运行的，isa 最多只能使用 8 个 bit 来存储引用计数, 即在 isa 中只能存储不超过 256 的数目。所以我们只要将对象的引用计数增加到 256 以上，那么系统就会将多余的引用计数存储到哈希表。 123456void foo(void) { NSObject *o1 = [[NSObject alloc] init]; for (int i = 0; i &lt; 500; i++) { _objc_rootRetain(o1); }} _objc_rootRetain()方法最终会调用objc_object::rootRetain(bool tryRetain, bool handleOverflow), 这个方法的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566ALWAYS_INLINE id objc_object::rootRetain(bool tryRetain, bool handleOverflow){ if (isTaggedPointer()) return (id)this; bool sideTableLocked = false; bool transcribeToSideTable = false; isa_t oldisa; isa_t newisa; do { // 是否将引用计数转移到索引表中 transcribeToSideTable = false; // LoadExclusive 的作用是让读取操作原子化 oldisa = LoadExclusive(&amp;isa.bits); newisa = oldisa; // if (slowpath) else ()，表示大概率执行 else 后面的语句，用来提高效率。 // fastpath 则表示大概率执行 if 后面的语句 if (slowpath(!newisa.nonpointer)) { // arm64 架构下，一般的对象 nonpointer 为YES，但也有特例，例如 block 的 nonpointer 为 False，即不使用 isa 保存额外信息 ClearExclusive(&amp;isa.bits); if (rawISA()-&gt;isMetaClass()) return (id)this; if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock(); if (tryRetain) return sidetable_tryRetain() ? (id)this : nil; else return sidetable_retain(); } // don't check newisa.fast_rr; we already called any RR overrides if (slowpath(tryRetain &amp;&amp; newisa.deallocating)) { ClearExclusive(&amp;isa.bits); if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock(); return nil; } // 用来表示 isa 指针的值是否溢出。因为引用计数存储在指针的高位，当引用计数增加到一定程度，会超过最高位的数字，此时 carry 的值不等于 0，表示溢出 uintptr_t carry; // addc() 是一个内置函数，作用是将 isa 里面的引用计数 + 1 后保存 newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry); // extra_rc++ if (slowpath(carry)) { // newisa.extra_rc++ overflowed // 移除的话则需要对多余的引用计数保存到索引表中。 // 刚开始进入的时候 handleOverflow == false if (!handleOverflow) { ClearExclusive(&amp;isa.bits); return rootRetain_overflow(tryRetain); } // 加锁 if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock(); // 此时 isa 指针存储的引用计数应该是满的， extra_rc 的 19 位都是 1，将 extra_rc 赋值为原来的一半，也就是将 isa 的最高位赋值为 0，这样做的目的是下次引用计数增加的时候可以直接存储在 isa 中，而不需要调用索引表来存储。将 has_sidetable_rc 赋值为 1，标记有额外的引用计数存储在索引表中 sideTableLocked = true; transcribeToSideTable = true; newisa.extra_rc = RC_HALF; newisa.has_sidetable_rc = true; } // StoreExclusive(), 如果&amp;isa.bits和oldisa.bits相等，那么就把newisa.bits的值赋给&amp;isa.bits，并且返回true。 } while (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits))); if (slowpath(transcribeToSideTable)) { // Copy the other half of the retain counts to the side table. // 如果溢出的话，则将 isa 存储的引用计数赋值为最大值的一半，即 RC_HALF，那么减少的一半则转移到索引表中 sidetable_addExtraRC_nolock(RC_HALF); } if (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock(); return (id)this;} 写了点注释帮助你们理解. 现在我们在sidetable_addExtraRC_nolock(RC_HALF);那一行打个断点，启动程序 step into进入这个方法 因为用的模拟器，所以 RC_HALF == delta_rc == 128，符合预期。 代码SideTable&amp; table = SideTables()[this]，通过计算指针值得到哈希值获取到对应的 sidetable让我们点开方法SideTables() 12345static objc::ExplicitInit&lt;StripedMap&lt;SideTable&gt;&gt; SideTablesMap;static StripedMap&lt;SideTable&gt;&amp; SideTables() { return SideTablesMap.get();} class ExplicitInit 的定义 1234567891011121314template &lt;typename Type&gt;class ExplicitInit { alignas(Type) uint8_t _storage[sizeof(Type)];public: template &lt;typename... Ts&gt; void init(Ts &amp;&amp;... Args) { new (_storage) Type(std::forward&lt;Ts&gt;(Args)...); } Type &amp;get() { return *reinterpret_cast&lt;Type *&gt;(_storage); }}; ExplicitInit的作用是生成一个模板类型 Type 的实例。alignas(Type) uint8_t _storage[sizeof(Type)];成员变量_storage是一个 sizeof(Type) 长度的 uint8_t 数组，而 uint8_t 占用一个字节，所以实际上_storage的长度跟一个 Type 实例所占用的内存是一样多的。成员函数 Type &amp;get() 将 _storage 数组指针用reinterpret_cast&lt;Type *&gt;强转成了 Type * 类型指针，前面再加一个 *，说明返回的实际上是 Type 实例内存的首地址。而另一个成员函数init用来初始化生成的 Type 实例。 所以static StripedMap&lt;SideTable&gt;&amp; SideTables()函数实际上返回了一个全局静态StripedMap&lt;SideTable&gt;的实例。下面是class StripedMap的部分定义 12345678910111213141516171819202122232425template&lt;typename T&gt;class StripedMap {#if TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR enum { StripeCount = 8 };#else enum { StripeCount = 64 };#endif struct PaddedT { T value alignas(CacheLineSize); }; PaddedT array[StripeCount]; static unsigned int indexForPointer(const void *p) { uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(p); return ((addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)) % StripeCount; } public: T&amp; operator[] (const void *p) { return array[indexForPointer(p)].value; } // ...省略} 局部结构体PaddedT的作用是用来内存对齐，常量CacheLineSize是固定值 64。在 arm64 架构下，成员变量array是一个长度为 8，元素类型为 T，每个元素占 64 字节的数组，而在模拟器下是一个长度为 64，每个元素占 64 字节的数组。 成员函数indexForPointer用来根据指针来计算哈希值，确定对应于array里面第几个元素。 T&amp; operator[] (const void *p)使用 operator 关键字重载了[]符号。举个例子，StripedMap 有一个实例 sm，有一个 int 类型的变量 a，当执行sm[&amp;a]的代码时，就会跳转到T&amp; operator[] (const void *p)这个方法里面。而在上面的重载[]函数中，传入的参数为指针类型，然后计算出其数组 index，返回对应的元素 T，也就是 SideTable。 继续调试，断点此时在SideTable&amp; table = SideTables()[this];这一行。点击 step into _storage的数组长度为 4096，也就是 64 * 64，符合预期。继续step into，最终会跳转到下面这里 跳转到了重载的[]方法里面了。 目前已知道的情报就是，有一个全局的StripedMap条目索引，里面包含了若干个SideTable索引表。在使用时，根据指针得到对应的 sidetable。SideTable 的部分定义如下 12345678910111213struct SideTable { spinlock_t slock; RefcountMap refcnts; weak_table_t weak_table; SideTable() { memset(&amp;weak_table, 0, sizeof(weak_table)); } void lock() { slock.lock(); } void unlock() { slock.unlock(); } void forceReset() { slock.forceReset(); } // ...省略}; SideTable 的成员对象里面有一个自旋锁，引用映射表RefcountMap refcnts，弱引用表weak_table_t weak_table。在上面我们提到了每个 sidetable 占用 64 个字节, 那是因为 spinlock_t 占用 4, RefcountMap 占用 24, weak_table_t 占用 32, 加起来就是 64.在这里我们只了解下 RefcountMap, 因为它跟我们引用计数相关.RefcountMap是一个类型别名，它的定义如下： 1typedef objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,RefcountMapValuePurgeable&gt; RefcountMap; 先别急着查看DenseMap的定义，我们先看看DisguisedPtr是个什么类。它的定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041template &lt;typename T&gt;class DisguisedPtr { uintptr_t value; static uintptr_t disguise(T* ptr) { return -(uintptr_t)ptr; } static T* undisguise(uintptr_t val) { return (T*)-val; } public: DisguisedPtr() { } DisguisedPtr(T* ptr) : value(disguise(ptr)) { } DisguisedPtr(const DisguisedPtr&lt;T&gt;&amp; ptr) : value(ptr.value) { } DisguisedPtr&lt;T&gt;&amp; operator = (T* rhs) { value = disguise(rhs); return *this; } DisguisedPtr&lt;T&gt;&amp; operator = (const DisguisedPtr&lt;T&gt;&amp; rhs) { value = rhs.value; return *this; } operator T* () const { return undisguise(value); } T* operator -&gt; () const { return undisguise(value); } T&amp; operator * () const { return *undisguise(value); } T&amp; operator [] (size_t i) const { return undisguise(value)[i]; }}; 简单的说, 你可以像指针Type *一样的使用DisguisedPtr，但是其成员变量value保存的是伪装后的指针值。伪装函数是disguise()，0 和 0x800…00 经过伪装之后还是本身，但指针值也不可能是这两个值，所以无所谓的。 为了能像指针Type *一样的使用DisguisedPtr，在DisguisedPtr内部，重载了许多符号，例如 [], =, *, ()。具体就不分析了。 该类的作用是为了避免直接引用指针, 防止被 leaks 内存检测工具检测出内存泄漏 class RefcountMapValuePurgeable的定义如下： 12345struct RefcountMapValuePurgeable { static inline bool isPurgeable(size_t x) { return x == 0; }}; 它只有一个内联函数，根据 x 是否为 0 返回一个 bool 值。它的作用就是根据参数判断是否需要析构这个实例好了，了解完了DisguisedPtr和RefcountMapValuePurgeable，接下来我们来看DenseMap，它的定义如下 123456789101112131415161718template &lt;typename KeyT, typename ValueT, typename ValueInfoT = DenseMapValueInfo&lt;ValueT&gt;, typename KeyInfoT = DenseMapInfo&lt;KeyT&gt;, typename BucketT = detail::DenseMapPair&lt;KeyT, ValueT&gt;&gt;class DenseMap : public DenseMapBase&lt;DenseMap&lt;KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;, KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt; { friend class DenseMapBase&lt;DenseMap, KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;; using BaseT = DenseMapBase&lt;DenseMap, KeyT, ValueT, ValueInfoT, KeyInfoT, BucketT&gt;; BucketT *Buckets; unsigned NumEntries; unsigned NumTombstones; unsigned NumBuckets; public: explicit DenseMap(unsigned InitialReserve = 0) { init(InitialReserve); }} 代码friend class DenseMapBase的作用是声明一个友元类DenseMapBase，这样DenseMapBase在内存可以直接访问DenseMap private 的成员函数。 代码using BaseT = DenseMapBase的作用是为DenseMapBase指定一个别名BaseT 函数explicit DenseMap(), explicit的作用是用来声明类构造函数是显示调用的，而非隐式调用。 DenseMap里面有 4 个成员变量，Buckets 和 NumEntries，NumTombstones， NumBuckets。 Buckets, 存储引用计数的数组, 元素类似于字典, key 为指针, value 为引用计数. 数组可扩容 NumEntries 表示数组中用来存储引用计数的元素有几个 NumTombstones 数组中元素被用来存储一个对象的引用计数, 当这个对象被销毁后, 该元素被标记为墓碑. 该变量用来表示有多少个这种元素 NumBuckets 数组 Buckets 的长度 再来看一下模板里的几个类型 DenseMapInfo&lt;KeyT&gt;, detail::DenseMapPair&lt;KeyT, ValueT&gt; DenseMapInfo 有很多的模板定义，可以适用于各种类型。 123456789101112131415template&lt;typename T&gt;struct DenseMapInfo&lt;DisguisedPtr&lt;T&gt;&gt; { static inline DisguisedPtr&lt;T&gt; getEmptyKey() { return DisguisedPtr&lt;T&gt;((T*)(uintptr_t)-1); } static inline DisguisedPtr&lt;T&gt; getTombstoneKey() { return DisguisedPtr&lt;T&gt;((T*)(uintptr_t)-2); } static unsigned getHashValue(const T *PtrVal) { return ptr_hash((uintptr_t)PtrVal); } static bool isEqual(const DisguisedPtr&lt;T&gt; &amp;LHS, const DisguisedPtr&lt;T&gt; &amp;RHS) { return LHS == RHS; }}; 内联函数getEmptyKey和getTombstoneKey均返回一个特征值，用来标记 bucket 的状态 Empty 和 Tombstone。静态函数getHashValue根据指针计算出哈希值。ptr_hash()的实现如下： 1234567static inline uint32_t ptr_hash(uint64_t key){ key ^= key &gt;&gt; 4; key *= 0x8a970be7488fda55; key ^= __builtin_bswap64(key); return (uint32_t)key;} 看不懂，知道是计算哈希值的就好了。 最后一个静态函数isEqual用来比较两个参数是否相等。 接着看detail::DenseMapPair&lt;KeyT, ValueT&gt; 它的定义如下 1234567891011121314151617181920212223242526272829template &lt;typename KeyT, typename ValueT&gt;struct DenseMapPair : public std::pair&lt;KeyT, ValueT&gt; { DenseMapPair() {} DenseMapPair(const KeyT &amp;Key, const ValueT &amp;Value) : std::pair&lt;KeyT, ValueT&gt;(Key, Value) {} DenseMapPair(KeyT &amp;&amp;Key, ValueT &amp;&amp;Value) : std::pair&lt;KeyT, ValueT&gt;(std::move(Key), std::move(Value)) {} template &lt;typename AltKeyT, typename AltValueT&gt; DenseMapPair(AltKeyT &amp;&amp;AltKey, AltValueT &amp;&amp;AltValue, typename std::enable_if&lt; std::is_convertible&lt;AltKeyT, KeyT&gt;::value &amp;&amp; std::is_convertible&lt;AltValueT, ValueT&gt;::value&gt;::type * = 0) : std::pair&lt;KeyT, ValueT&gt;(std::forward&lt;AltKeyT&gt;(AltKey), std::forward&lt;AltValueT&gt;(AltValue)) {} template &lt;typename AltPairT&gt; DenseMapPair(AltPairT &amp;&amp;AltPair, typename std::enable_if&lt;std::is_convertible&lt; AltPairT, std::pair&lt;KeyT, ValueT&gt;&gt;::value&gt;::type * = 0) : std::pair&lt;KeyT, ValueT&gt;(std::forward&lt;AltPairT&gt;(AltPair)) {} KeyT &amp;getFirst() { return std::pair&lt;KeyT, ValueT&gt;::first; } const KeyT &amp;getFirst() const { return std::pair&lt;KeyT, ValueT&gt;::first; } ValueT &amp;getSecond() { return std::pair&lt;KeyT, ValueT&gt;::second; } const ValueT &amp;getSecond() const { return std::pair&lt;KeyT, ValueT&gt;::second; }}; 看起来很复杂的样子，但其实只要知道它的父类std::pair是干嘛的就好了。std::pair的作用是将两个数据组合成一个数据，两个数据可以是同一类型或者不同类型。它是一个模板结构体，主要的两个成员变量是first和second，这两个变量可以直接使用。再根据注释，可以推测出DenseMapPair作用是将 keyT 和 ValueT 两个类型的值保存在一起 继续之前的调试，在代码size_t&amp; refcntStorage = table.refcnts[this];打个断点，然后点击 continue program execution 跳转过去。 注意这里的size_t&amp;符号不是取内存地址意思，&amp; 在这里表示引用的意思。举个例子 123int a = 1;int&amp; b = a;b = 10; 对 b 赋值 10 后，a 的值也变成了 10。好了，继续 继续 step into 首先会跳转到类DisguisedPtr的一个初始化方法里面，这里对指针进行伪装并赋值给了成员对象 value。继续 step into 跳转到了这里。可以看出来DenseMap的父类DenseMapBase也重载了[]方法。参数类型为KeyT &amp;&amp;，也就是DisguisedPtr&lt;objc_object&gt; &amp;&amp;类型。这里的&amp;&amp;符号以及下面的std::move(Key)函数都是为了确定参数是右值引用，实现移动语义，减少不必要的参数拷贝。 继续 step into，跳转到了下面这里 之前我们讲DenseMapPair&lt;KeyT, ValueT&gt;的时候说到过，这个类的作用是将两个类型的值的组合成一个整体，类似于我们平常使用的字典。key 对应 first， value 对应 second。在FindAndConstruct方法中，首先会通过LookupBucketFor()查找是否已经有存在的 bucket，如果没有则通过InsertIntoBucket函数生成并返回对应的 bucket。 下面是LookupBucketFor()函数的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768template&lt;typename LookupKeyT&gt; bool LookupBucketFor(const LookupKeyT &amp;Val, const BucketT *&amp;FoundBucket) const { // 返回成员变量 Buckets const BucketT *BucketsPtr = getBuckets(); // 返回成员变量 NumBuckets const unsigned NumBuckets = getNumBuckets(); if (NumBuckets == 0) { FoundBucket = nullptr; return false; } // 保存在查找过程中碰到的墓碑 const BucketT *FoundTombstone = nullptr; // DenseMapInfo 的内联函数 getEmptyKey const KeyT EmptyKey = getEmptyKey(); // DenseMapInfo 的内联函数 getTombstoneKey const KeyT TombstoneKey = getTombstoneKey(); assert(!KeyInfoT::isEqual(Val, EmptyKey) &amp;&amp; !KeyInfoT::isEqual(Val, TombstoneKey) &amp;&amp; &quot;Empty/Tombstone value shouldn't be inserted into map!&quot;); //DenseMapInfo 的静态函数 getHashValue 计算哈希值，并与 NumBuckets-1 进行与运算，得到对应 BucketT 实例的 index unsigned BucketNo = getHashValue(Val) &amp; (NumBuckets-1); // 查找次数 unsigned ProbeAmt = 1; while (true) { const BucketT *ThisBucket = BucketsPtr + BucketNo; // Found Val's bucket? If so, return it. // 找到了对应的 BucketT 实例 if (LLVM_LIKELY(KeyInfoT::isEqual(Val, ThisBucket-&gt;getFirst()))) { FoundBucket = ThisBucket; return true; } // If we found an empty bucket, the key doesn't exist in the set. // Insert it and return the default value. // 如果对应的 bucket 是空的。如果是第一次查找的话则在这个 bucket 里面插入 key 和 value(在InsertIntoBucket函数中执行)。如果不是第一次并且之前找到了墓碑，则使用墓碑bucket插入key和value if (LLVM_LIKELY(KeyInfoT::isEqual(ThisBucket-&gt;getFirst(), EmptyKey))) { // If we've already seen a tombstone while probing, fill it in instead // of the empty bucket we eventually probed to. FoundBucket = FoundTombstone ? FoundTombstone : ThisBucket; return false; } // If this is a tombstone, remember it. If Val ends up not in the map, we // prefer to return it than something that would require more probing. // Ditto for zero values. // 如果找到一个墓碑，则使用 FoundTombstone 将这个墓碑记录下来 if (KeyInfoT::isEqual(ThisBucket-&gt;getFirst(), TombstoneKey) &amp;&amp; !FoundTombstone) FoundTombstone = ThisBucket; // Remember the first tombstone found. // 如果 FoundTombstone 为空并且 对应的 bucket 的 second 是 0，则用FoundTombstone保存下这个bucket if (ValueInfoT::isPurgeable(ThisBucket-&gt;getSecond()) &amp;&amp; !FoundTombstone) FoundTombstone = ThisBucket; // Otherwise, it's a hash collision or a tombstone, continue quadratic // probing. // 如果查找次数多余 NumBuckets ，则报错 if (ProbeAmt &gt; NumBuckets) { FatalCorruptHashTables(BucketsPtr, NumBuckets); } // 重新计算 BucketNo，重新查找 BucketNo += ProbeAmt++; BucketNo &amp;= (NumBuckets-1); } } 在上面的代码里写了点注释帮助理解。bucket 有两种状态，一种是 Empty，这个表示当前这个 bucket 还没有被使用的标记；另一个状态是 TombstoneKey，当一个 bucket 被使用了，当对象释放后该 bucket 被定义为这种状态 通过FindAndConstruct函数的分析我们知道，如果已经存在 bucket，则返回 YES，并将指针 TheBucket 指向这个 bucket。如果存在一个墓碑或者空的 bucket，则返回 false，并将指针 TheBucket 指向这个 bucket。 接着分析InsertIntoBucket()，下面是它的实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061template &lt;typename KeyArg, typename... ValueArgs&gt; BucketT *InsertIntoBucket(BucketT *TheBucket, KeyArg &amp;&amp;Key, ValueArgs &amp;&amp;... Values) { TheBucket = InsertIntoBucketImpl(Key, Key, TheBucket); // 保存 key 到 bucket 的成员变量 first 中 TheBucket-&gt;getFirst() = std::forward&lt;KeyArg&gt;(Key); // 初始化 ValueT 的实例并保存到 bucket 的成员变量 second 中 ::new (&amp;TheBucket-&gt;getSecond()) ValueT(std::forward&lt;ValueArgs&gt;(Values)...); return TheBucket; } template &lt;typename LookupKeyT&gt; BucketT *InsertIntoBucketImpl(const KeyT &amp;Key, const LookupKeyT &amp;Lookup, BucketT *TheBucket) { // If the load of the hash table is more than 3/4, or if fewer than 1/8 of // the buckets are empty (meaning that many are filled with tombstones), // grow the table. // // The later case is tricky. For example, if we had one empty bucket with // tons of tombstones, failing lookups (e.g. for insertion) would have to // probe almost the entire table until it found the empty bucket. If the // table completely filled with tombstones, no lookup would ever succeed, // causing infinite loops in lookup. unsigned NewNumEntries = getNumEntries() + 1; unsigned NumBuckets = getNumBuckets(); // 当 buckets 数组已经使用了超过 3/4 或者 空bucket的数量小于 1/8，则增加 buckets 数组的长度。 if (LLVM_UNLIKELY(NewNumEntries * 4 &gt;= NumBuckets * 3)) { // 扩增原来的 NumBuckets，新的 buckets 长度为旧的两倍，长度至少为 4。新的 buckets 生成后将旧数组里面的数据转移过去，并且旧数组删除 this-&gt;grow(NumBuckets * 2); // 因为重新生成了 buckets 数组，所以需要使用LookupBucketFor重新查找对应bucket，并用指针 TheBucket 指向 LookupBucketFor(Lookup, TheBucket); NumBuckets = getNumBuckets(); } else if (LLVM_UNLIKELY(NumBuckets-(NewNumEntries+getNumTombstones()) &lt;= NumBuckets/8)) { this-&gt;grow(NumBuckets); LookupBucketFor(Lookup, TheBucket); } ASSERT(TheBucket); // Only update the state after we've grown our bucket space appropriately // so that when growing buckets we have self-consistent entry count. // If we are writing over a tombstone or zero value, remember this. if (KeyInfoT::isEqual(TheBucket-&gt;getFirst(), getEmptyKey())) { // Replacing an empty bucket. // 使用空bucket，NumEntries + 1 incrementNumEntries(); } else if (KeyInfoT::isEqual(TheBucket-&gt;getFirst(), getTombstoneKey())) { // Replacing a tombstone. // 使用墓碑 bucket，NumEntries + 1， NumTombstones - 1 incrementNumEntries(); decrementNumTombstones(); } else { // we should be purging a zero. No accounting changes. // 如果 second 等于 0，则析构 second ASSERT(ValueInfoT::isPurgeable(TheBucket-&gt;getSecond())); TheBucket-&gt;getSecond().~ValueT(); } return TheBucket; } 通过InsertIntoBucket函数我们了解到，当 buckets 数组已经使用了超过 3/4 或者 空bucket的数量小于 1/8，则会生成一个新的 buckets，长度为原来的2倍（最小为4），并将旧数组的数据转移到新数组中，并重新查找 TheBucket 的 index。最后将伪装后的指针保存到bucket的first中，将引用计数保存到bucket的second中。 理论分析到这里。这几个函数的调试我就不贴出来了，比较长，你们可以自己调试下。 接下来在代码size_t oldRefcnt = refcntStorage;中打个断点，点击 continue program execution 跳转过去。 让我们回到objc_object::sidetable_addExtraRC_nolock函数中。因为我们刚刚在 sidetable 索引表里面插入了 bucket，所以这里 oldRefcnt 的值 为 0。接下来会对 oldRefcnt 进行校验，这说明 oldRefcnt 并没有把所有的 bit 都用来保存引用计数。 低 1 位(从低位往高位数第一位)用来标记是否是弱引用 低 2 位用来标记该变量是否在析构 高 1 位(从高位往低位数第一位)用来标记保存的引用计数是否已经溢出。 下面的代码我们好像看到过了，对，在将引用计数保存在 isa 指针那里 123456789101112uintptr_t carry;size_t newRefcnt = addc(oldRefcnt, delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT, 0, &amp;carry);if (carry) { refcntStorage = SIDE_TABLE_RC_PINNED | (oldRefcnt &amp; SIDE_TABLE_FLAG_MASK); return true;}else { refcntStorage = newRefcnt;return false;} 这几句的代码的作用是将 newRefcnt = oldRefcnt + delta_rc，如果值太大了溢出了则将 carry 赋值为1，并将 refcntStorage 的高1位赋值为1，并返回true。如果没有溢出的话则将 newRefcnt 赋值到 refcntStorage，并返回 false。 到这里，我们探究了当引用计数增加时，如何保存多余的引用计数。简单的归纳下： 有一个静态全局变量 SideTablesMap，实际上是 StripedMap 的实例。以便于在程序初始化的时候就能用到 变量 SideTablesMap 里面有一个长度为 8，类型为 SideTable 的数组成员array，每个元素占用的内存为64(spinlock_t内存4， RefcountMap内存24，weak_table_t内存32)。在保存引用计数的时候，根据指针地址来计算出相应 SideTable 的 index。 获取到相应的 SideTable 后，根据指针地址计算出相应的哈希值，然后查找 bucket。如果 bucket 不存在，则使用空 bucket 或者 墓碑 bucket。如果 bucket 的数量不够则扩容。将指针为 key 和 引用计数 为 value 保存到 bucket 当中。 注意：当一个对象创建后它的引用计数为 1，但是 isa 指针里的引用计数还是 0。因为初始化的时候并没有对引用计数进行操作。 减少引用计数这里我们只讨论有额外引用计数存储在 sidetable，且 isa 指针里面存储的引用计数为 0 时的临界情况。代码如下： 123456789101112void aoo(void) { NSObject *o1 = [[NSObject alloc] init]; for (int i = 0; i &lt; 512; i++) { _objc_rootRetain(o1); } for (int i = 0; i &lt; 129; i++) { if (i == 128) { int a = 1; } _objc_rootRelease(o1); }} 在代码int a = 1;处打个断点，此时 isa 保存的引用计数为 0。一直 step over，直到跳转到objc_object::rootRelease(bool performDealloc, bool handleUnderflow)函数。 一直点击 step over，直到停在newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry);那一行 用调试命令打印看一下此时 isa 指针里面的内容 因为使用的是模拟器，所以 isa 里面只有最高的 8 个bit用来保存引用计数，之前我们减少它的引用计数 128。所以此时它 isa 指针里面保存的引用计数为 0。调试输出结果extra_rc也为0，符合预期(0b是二进制符号) 接下来系统要将引用保存在 isa 指针的引用计数 -1，并判断是否溢流。此刻它的引用计数已经为 0 了，那么对它进行 -1 操作会发生什么呢？我们接着调试，点击 step over 可以看到变量carry == 1，表示出现溢流。让我们再看一下 isa 指针里面发生了什么。 我们可以看到保存引用计数的 8 个 bit 都变成了 1，这其实就是 -1 在无符号整数中的表现形式，不懂的同学可以去了解一下补码。 接着一直 step over，我们可以看到因为溢流所以跳转到了underflow部分。一直 step over 直到跳转到如下的位置 rootRelease_underflow最终调用的还是objc_object::rootRelease()函数，只不过参数 handleUnderflow 变成了 YES。进入该函数后，又会执行之前的那些代码，过程也是一样的，就不重复说了。接下来会来到这个位置 是的，因为没上锁，所以又会回到retry部分的代码。注释里写着是因为 Need to start over to avoid a race against the nonpointer -&gt; raw pointer transition. 不是很明白，但是过了。继续 step over 之前引用计数溢出时，我们将RC_HALF数目的引用计数存储到了sidetable当中，此时因为溢流，所以我们从sidetable中取回同样数目的引用计数。 step into 进入objc_object::sidetable_subExtraRC_nolock()函数 在最开始的代码中,我们增加了变量o1 512 的引用计数, 在 isa 指针中保存了 128, 还剩余 384. 但是因为最低两位没有用来保存数据, 所以在 bucket 中存储的数字应该是 384 &lt;&lt; 2, 即 1536, 符合预期 接下来的代码作用就是判断保存在 bucket 中的引用计数是否合理, 如何合理的话则将原有的数据减去RC_HALF并重新保存. 点击 step out 返回之前的函数 代码块1的作用是将从 sidetable 取回了保存着的一部分引用计数, -1 保存到 isa 指针里面 如果代码块1保存失败, 则用代码块2重新保存一次 如果代码块2保存失败了, 则将从 sidetable 取出的引用计数重新放回去. 然后又跳回到 retry 部分 保存成功则解锁, 并返回 false. 返回 true 表示这个对象需要 dealloc 了 另一种情况, 如果一个对象 isa 引用计数为 0, 且没有额外的引用计数. 那么它从 sidetable ‘借来的’ borrowed 为 0, 那么会将 isa 的 deallocating 赋值为 1, 并随后对其发送 delloc 消息进行内存消耗 最后以上就是此次对引用计数的探究, 欢迎留言告诉我错的或者不明白的地方~","link":"/2020/04/16/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-iOS-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"},{"title":"深入了解Tagged Pointer","text":"objc 源码版本：779.1当然还是推荐使用这个来学习：可编译的源码 在 2013 年苹果推出了首个使用 64 位架构的双核处理器的手机 iphone 5s。为了节约内存以及提高执行效率，苹果使用了一种叫做 ‘Tagged Pointer’ 的技术，现在跟着我来了解一下它吧。 Tagged Pointer从 5s 开始，iPhone 均使用 arm64 指令集的处理器。在 64 位系统上，一个指针占 8 个字节，而指针指向的实例变量至少需要 16 个字节，并且还需要执行额外的一些操作，例如：申请内存，销毁内存。为了达到优化的目的，苹果将一些存储数据的类，例如 NSString，NSNumber，当它们需要保存的数据不需要占用那么多的字节时，直接将数据保存在“指针”里面。 下面让我们用代码来证实Tagged Pointer的存在 1NSNumber *a = [NSNumber numberWithInt:1]; 然后打个断点，使用 lldb 的命令调试，x/8xg a，该命令的意思是从a的起始地址开始，打印 8 个 16进制的 8字节长度的值输出结果 说明指针 a 并不是指向 NSNumber 实例的指针。 或者下面这样更加直观一点 可以看到 a 并没有 isa 指针，所以它并不是一个 NSNumber 实例指针。 Tagged Pointer 如何存储数据这里你最好打开源码对照着看。 LSB在非 arm64 架构中，将最低位即 LSB 设置为 1，与正常的指针进行区分。这样做的原因是，OC 类在创建实例最终调用的是 C 标准库中的 calloc 函数，它所返回的内存地址是 16 字节对齐的，参考 Aligned memory management?。这样的结果就是指针地址低 4 位都是 0，用最低位来表示也合理的 MSB在 arm64 架构中，将最高位即 MSB 设置为 1，与正常的指针进行区分。这样做的原因的是因为在 arm64 架构中，指针只用了低位的 48 位，高 16 位都是空着的，原因可以看下这个 为什么64位机指针只用48个位? 在 objc-internal.h 372 行以及 384 行，我们 我们可以看到掩码 _OBJC_TAG_MASK 的定义： 1234567#if OBJC_MSB_TAGGED_POINTERS# define _OBJC_TAG_MASK (1UL&lt;&lt;63)# define _OBJC_TAG_INDEX_SHIFT 60#else# define _OBJC_TAG_MASK 1UL# define _OBJC_TAG_INDEX_SHIFT 1#endif 内置类型和扩展类型系统启动时生成两个全局的数组 objc_debug_taggedpointer_classes 和 objc_debug_taggedpointer_ext_classes。一个用来存储系统内置的Tagged Pointer类型，而另一个数组存储扩展的Tagged Pointer类型。 1234extern &quot;C&quot; { extern Class objc_debug_taggedpointer_classes[_OBJC_TAG_SLOT_COUNT]; extern Class objc_debug_taggedpointer_ext_classes[_OBJC_TAG_EXT_SLOT_COUNT];} 内置类型数组的数目为 8，使用高 2 - 高 4 的 3 个 bit 来存储数据 扩展类型数组的数目为 256，，使用高 5 - 高 12 的 8 个 bit 来存储数据 是否剩余的 bit 都用来保存数据了呢？答案是否定的，拿 NSUmber 举个例子，它属于内置类型，其 tagged pointer 额外使用 低 1 - 低 4 的 5 个 bit 用来保存数字的类型信息，即使用 56 个 bit 来保存数据。 内置类型如下： 1234567891011enum{ // 60-bit payloads OBJC_TAG_NSAtom = 0, OBJC_TAG_1 = 1, OBJC_TAG_NSString = 2, OBJC_TAG_NSNumber = 3, OBJC_TAG_NSIndexPath = 4, OBJC_TAG_NSManagedObjectID = 5, OBJC_TAG_NSDate = 6,} 而当指针的高 1 - 高 4 的 4 个 bit 位均为 1 时，表示这是一个扩展类型。系统自带的扩展类型如下： 123456789101112131415161718enum{ // ... // 52-bit payloads OBJC_TAG_Photos_1 = 8, OBJC_TAG_Photos_2 = 9, OBJC_TAG_Photos_3 = 10, OBJC_TAG_Photos_4 = 11, OBJC_TAG_XPC_1 = 12, OBJC_TAG_XPC_2 = 13, OBJC_TAG_XPC_3 = 14, OBJC_TAG_XPC_4 = 15, OBJC_TAG_NSColor = 16, OBJC_TAG_UIColor = 17, OBJC_TAG_CGColor = 18, OBJC_TAG_NSIndexSet = 19, // ...} 数据混淆运行下面的代码 1234567891011- (void)boo{ NSNumber *a = [NSNumber numberWithInt:1]; NSNumber *b = [NSNumber numberWithInt:2]; NSNumber *c = [NSNumber numberWithInt:16]; NSLog(@&quot;pointer a is %lx&quot;, a); NSLog(@&quot;pointer b is %lx&quot;, b); NSLog(@&quot;pointer c is %lx&quot;, c); NSLog(@&quot;pointer d is %lx&quot;, d);} 输出结果: 123pointer a is ef59c3d36981ed4bpointer b is ef59c3d36981ed7bpointer c is ef59c3d36981ec5b 等等，不是说 Tagged Pointer 最高 4 位用来保存类型信息，剩下的几位都只用来保存数据嘛，为什么输出结果看起来这么复杂呢？原因是从 iOS12 开始，为了系统安全，将数据与一个随机数进行 异或(^) 操作进行混淆，混淆函数如下： 12345static inline void * _Nonnull_objc_encodeTaggedPointer(uintptr_t ptr){ return (void *)(objc_debug_taggedpointer_obfuscator ^ ptr);} objc_debug_taggedpointer_obfuscator是一个extern关键字的常量，因为被 extern 声明，所以我们可以用下面的代码来解码，得到真正的值 123456789101112extern uintptr_t objc_debug_taggedpointer_obfuscator;- (void)foo{ NSNumber *a = [NSNumber numberWithInt:1]; NSNumber *b = [NSNumber numberWithInt:2]; NSNumber *c = [NSNumber numberWithInt:16]; NSLog(@&quot;pointer a real value is %lx&quot;, ((uintptr_t)a ^ objc_debug_taggedpointer_obfuscator)); NSLog(@&quot;pointer b real value is %lx&quot;, ((uintptr_t)b ^ objc_debug_taggedpointer_obfuscator)); NSLog(@&quot;pointer c real value is %lx&quot;, ((uintptr_t)c ^ objc_debug_taggedpointer_obfuscator));} 输出结果: 123pointer a real value is b000000000000012pointer b real value is b000000000000022pointer c real value is b000000000000102 从输出结果可以看出，这几个值都是 0Xb 开头，16进制的 b 用 二级制表示为 1011，最高1用来表示这是一个 Tagged Pointer，而剩余 3 位的10进制数为 3，符合之前的定义OBJC_TAG_NSNumber = 3。至于为什么结尾都是 0x2，这个后面再解释。下面让我们测试下 NSNumber 的 Tagged Pointer 使用多少位来保存数据。从之前的探究我们知道内置类型用 60 位来保存数据，而经过上面的实验我们可以看到还有 4 位用来做别的事了，那么是否剩余的 56 位都用来保存数据了呢？ 12345- (void)foo{ NSNumber *d = [NSNumber numberWithLongLong:-0x7FFFFFFFFFFFFF]; NSLog(@&quot;pointer a real value is %lx&quot;, ((uintptr_t)d ^ objc_debug_taggedpointer_obfuscator));} 输出结果： 1pointer d real value is b800000000000013 结果符合预期。至于为什么最高位 b 后面的数字是 8，是因为高位 5 的位置变成了 1，用来表示这个数是负数(0则表示正数), 而 7 的二进制表示为 ob111，高位 5-8 连起来就是 0b1111，也就是16进制的 8 了。还一个值得注意的是低位第一位的数字变成了 3，而不是之前的正整数 2，由此我们可以推测最低位的 4 位是用来表示存储数据类型的数据，例如 int,float,bool 这几个类型生成的 Tagged Pointer 最低4位数字应该是不同的。用下面的代表再来验证下： 123456789NSNumber *a = [NSNumber numberWithInt:1];NSNumber *b = [NSNumber numberWithShort:2];NSNumber *c = [NSNumber numberWithFloat:1.];NSNumber *d = [NSNumber numberWithLongLong:-0x7FFFFFFFFFFFFF];NSLog(@&quot;pointer a real value is %lx&quot;, ((uintptr_t)a ^ objc_debug_taggedpointer_obfuscator));NSLog(@&quot;pointer b real value is %lx&quot;, ((uintptr_t)b ^ objc_debug_taggedpointer_obfuscator));NSLog(@&quot;pointer c real value is %lx&quot;, ((uintptr_t)c ^ objc_debug_taggedpointer_obfuscator));NSLog(@&quot;pointer d real value is %lx&quot;, ((uintptr_t)d ^ objc_debug_taggedpointer_obfuscator)); 输出结果 1234pointer a real value is b000000000000012pointer b real value is b000000000000021pointer c real value is b000000000000014pointer d real value is b800000000000013 结果符合预期，说明我们的推测是正确的 参考NSNumber 与 Tagged Pointer深入解构 objc_msgSend 函数的实现 希望大家看了有所收获吧。","link":"/2020/04/02/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Tagged-Pointer/"},{"title":"谈Objective-C关联对象","text":"#前言前不久刚写了 谈Objective-C类成员变量 ，分析了成员变量的实现原理以及不能动态添加的原因，在这篇文章里我们来根据 objc4-646.tar.gz版本 源码来谈一下 Objective-C 关联对象的实现原理。 关联对象(Associated Objects)是 Objective-C 2.0运行时的一个特性，起始于OS X Snow Leopard和iOS 4。它允许开发者对已经存在的类在扩展中添加自定义的属性。相关参考可以查看 &lt;objc/runtime.h&gt; 中定义的三个允许你将任何键值在运行时关联到对象上的函数： void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) 用于给对象添加关联属性，传入nil则移除已有的关联对象 id objc_getAssociatedObject(id object, const void *key) 用于获取关联属性 void objc_removeAssociatedObjects(id object) 移除一个对象所有的关联属性，但不建议手动调用这个函数，因为这可能会导致其它人对其添加的属性也被移除了。你可以调用objc_setAssociatedObject方法并传入nil来指定移除某个关联 下面分析一下 objc_setAssociatedObject 两个参数 key 和 policy #key通常来说该属性应该是常量、唯一的，在getter和setter方法中都可以访问到。这里有两种常见的添加方式： 第一种是添加 static char 类型的变量，当然更推荐是指针型的。 12345static char kAssociatedObjectKey;- (void)setMenber:(NSString *)menber { objc_setAssociatedObject(self, &amp;kAssociatedObjectKey, menber, OBJC_ASSOCIATION_COPY_NONATOMIC);} 当然更推荐的是使用更简单的方式实现：用 selector(getter方法)： 123- (void)setMenber:(NSString *)menber { objc_setAssociatedObject(self, @selector(menber), menber, OBJC_ASSOCIATION_COPY_NONATOMIC);} #关联策略 policy关联策略跟属性修饰符的使用方法差不多，属性可以根据定义在 objc_AssociationPolicy 上的类型被关联到对象上： 关联策略 等价属性 说明 OBJC_ASSOCIATION_ASSIGN @property (assign)或 @property (unsafe_unretained) 弱引用关联对象 OBJC_ASSOCIATION_RETAIN_NONATOMIC @property (nonatomic, strong) 强引用关联对象，且为非原子操作 OBJC_ASSOCIATION_COPY_NONATOMIC @property (nonatomic, copy) 复制关联对象，且为非原子操作 OBJC_ASSOCIATION_RETAIN @property (atomic, strong) 强引用关联对象，且为原子操作 OBJC_ASSOCIATION_COPY @property (atomic, copy) 复制关联对象，且为原子操作 #关联对象实现下面让我们具体来分析一下这几个函数的具体实现吧！ 分析objc_setAssociatedObject实现在objc_setAssociatedObject的实现被定义在objc-auto.mm文件 467 行 12345678910GC_RESOLVER(objc_setAssociatedObject)#define GC_RESOLVER(name) \\ OBJC_EXPORT void *name##_resolver(void) __asm__(&quot;_&quot; #name); \\ void *name##_resolver(void) \\ { \\ __asm__(&quot;.symbol_resolver _&quot; #name); \\ if (UseGC) return (void*)name##_gc; \\ else return (void*)name##_non_gc; \\ } ## 符号: 连接宏。举个例子：#define COMMAND(A, B) A##B ， int COMMAND(temp, Int) = 10 等同于 int tempInt = 10 UseGC 是否使用垃圾回收，在 iPhone 平台上被定义为 NO 所以这个宏展开来为下面的代码 1234void GC_RESOLVER(name) { return (void*)objc_setAssociatedObject_non_gc(); } objc_setAssociatedObject_non_gc的实现在objc-runtime.m文件，再经过一些跳转，可以发现 objc_setAssociatedObject 最终会调用 _object_set_associative_reference方法 （objc-runtime.m 268行） 1234567891011121314151617181920212223242526272829303132333435363738394041424344void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) { // retain the new value (if any) outside the lock. ObjcAssociation old_association(0, nil); id new_value = value ? acquireValue(value, policy) : nil; { AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); if (new_value) { // break any existing association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { // secondary table exists ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) { old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value); } else { (*refs)[key] = ObjcAssociation(policy, new_value); } } else { // create the new association (first time). ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; (*refs)[key] = ObjcAssociation(policy, new_value); object-&gt;setHasAssociatedObjects(); } } else { // setting the association to nil breaks the association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) { old_association = j-&gt;second; refs-&gt;erase(j); } } } } // release the old value (outside of the lock). if (old_association.hasValue()) ReleaseValue()(old_association);} AssociationsManager manager;, 会创建一个AssociationsManager结构体的变量 manager，在调用它的构造函数时会上锁，调用析构函数时解锁。结构体内有一个静态变量 AssociationsHashMap, 懒加载该变量。 DISGUISE(object) 用来获取 object 的指针地址 AssociationsHashMap是一个无序的哈希表，维护了从对象地址到 ObjectAssociationMap 的映射 ObjectAssociationMap 是一个map，维护了从 key 到 ObjcAssociation 的映射 ObjcAssociation 是一个 C++ 类， 主要包括两个成员变量：uintptr_t _policy(关联策略) id _value(关联对象的值) 简单的讲解上面那个函数的流程： 新建一个 AssociationsManager 实例 manager，同时上锁。通过 manager 得到 AssociationsHashMap 关联哈希表 associations，通过 DISGUISE()函数得到 object 的指针 disguised_object。在哈希表 associations 中 根据 disguised_object 查找 ObjectAssociationMap，如果没有则新建一个 refs。 新建一个 ObjcAssociation 实例 new_association，存储在 refs 中 如果传入的value是nil，则在 refs 移除该映射关系 释放掉旧的 old_association 作用域结束释放掉 manager，解锁 分析objc_getAssociatedObject实现按照上一节的流程，我们首先找到 objc_getAssociatedObject 的最终实现源码： 123456789101112131415161718192021222324id _object_get_associative_reference(id object, void *key) { id value = nil; uintptr_t policy = OBJC_ASSOCIATION_ASSIGN; { AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) { ObjcAssociation &amp;entry = j-&gt;second; value = entry.value(); policy = entry.policy(); if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain); } } } if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) { ((id(*)(id, SEL))objc_msgSend)(value, SEL_autorelease); } return value;} 代码量比上一节少了还挺多哈，过程也类似，就不讲的很细了 先得到 AssociationsHashMap 实例 associations（静态变量）。根据 object 的指针地址，在 associations 得到映射的 ObjectAssociationMap refs。 在 refs 根据 key 得到映射的 ObjcAssociation 实例 entry，在 entry 中可以得到成员变量 _value，也就是我们所关联属性的值。 根据关联策略 policy 进行相应的操作(autorelease, retain)后返回 value 分析objc_removeAssociatedObjects实现12345678910111213141516171819202122void _object_remove_assocations(id object) { vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements; { AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); if (associations.size() == 0) return; disguised_ptr_t disguised_object = DISGUISE(object); AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { // copy all of the associations that need to be removed. ObjectAssociationMap *refs = i-&gt;second; for (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) { elements.push_back(j-&gt;second); } // remove the secondary table. delete refs; associations.erase(i); } } // the calls to releaseValue() happen outside of the lock. for_each(elements.begin(), elements.end(), ReleaseValue());} 其实不看代码应该也能够猜出个大概了吧. 根据 object地址 找到映射的 refs，遍历 refs，将保存着的 value 保存在 vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements 删除 refs， 然后一个个的释放 elements 里面的值 #给类对象关联对象看完源代码后，我们知道实例对象地址与 ObjectAssociationMap map是一一对应的。那么是否可以给类对象添加关联对象呢？答案是可以，因为Class也是一个对象，我们完全可以用同样的方式给类对象添加关联对象，只不过我们一般情况下不会这样做，因为更多时候可以通过 static 变量来实现类级别的变量。 你可以通过下面的代码这样操作 123456789101112@implementation NSObject (AssociatedObject)+ (NSString *)associatedObject { return objc_getAssociatedObject(self, @selector(associatedObject));}+ (void)setAssociatedObject:(NSString *)associatedObject { objc_setAssociatedObject(self, @selector(associatedObject), associatedObject, OBJC_ASSOCIATION_COPY_NONATOMIC);}@end- (void) foo { NSObject.associatedObject = @&quot;associatedObject&quot;;} #何时释放关联对象在 探究ARC下dealloc实现 中我们研究过，当对象引用计数变为0时会调用 dealloc 方法，然后最终调用 objc_destructInstance 方法来执行释放所有__weak修饰的指向该对象的指针，释放关联对象，释放该对象成员变量的操作 1234567891011121314151617181920212223242526272829303132333435363738void *objc_destructInstance(id obj) { if (obj) { // Read all of the flags at once for performance. bool cxx = obj-&gt;hasCxxDtor(); bool assoc = !UseGC &amp;&amp; obj-&gt;hasAssociatedObjects(); bool dealloc = !UseGC; // This order is important. if (cxx) object_cxxDestruct(obj); if (assoc) _object_remove_assocations(obj); if (dealloc) obj-&gt;clearDeallocating(); } return obj;}void _object_remove_assocations(id object) { vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements; { AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); if (associations.size() == 0) return; disguised_ptr_t disguised_object = DISGUISE(object); AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { // copy all of the associations that need to be removed. ObjectAssociationMap *refs = i-&gt;second; for (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) { elements.push_back(j-&gt;second); } // remove the secondary table. delete refs; associations.erase(i); } } // the calls to releaseValue() happen outside of the lock. for_each(elements.begin(), elements.end(), ReleaseValue());} 是不是有点熟悉呢，在上上节中我们刚刚分析过这个方法。当对象 dealloc 时，会自动调用 objc_removeAssociatedObjects 方法来释放所有的关联对象。 #总结一下 类实例跟关联对象(关联的属性)并没有直接的存储关系，关联对象在创建时后存储在一个静态哈希表中，根据类实例的指针映射到该关联对象 当类实例 dealloc 后，会从哈希表中释放该实例的所有的关联对象 关联对象的关联策略跟属性的修饰符非常的相似，要合理使用避免 crash 比起其他解决问题的方法，关联对象应该被视为最后的选择 #引用 Associated Objects","link":"/2019/06/28/%E8%B0%88Objective-C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/"},{"title":"谈Objective-C类成员变量","text":"#我是前言Objective-C 是一门动态语言，所以它总是将一些决定工作从编译延迟到运行时，也就是说只有编译器是不够的，还需要一个运行时系统来执行编译后的代码。这就是 runtime 存在的意义，它是 Objective-C 框架的一块基石。runtime 有两个版本：modeen 和 leagcy，我们现在使用的是 modern 版的。本文 runtime 源码为objc4-646.tar.gz版本 在老版本的 runtime 中，如果修改了基类的成员变量布局（比如增加成员变量），子类需要重新编译。 如果苹果发布了新的 iOS SDK，NSObject 增加了几个成员变量，那么我们原先的代码将无法运行。因为 MyObject 成员变量布局在编译时就确定了，父类新增的成员变量的地址跟子类成员变量的内存区域重叠了。此时，我们只能重新编译 MyObject 的代码，程序才能在新版本系统上运行。如果 MyObject 存在于别人编写的静态库，那我们只能希望作者快点发布新版本了。 非脆弱[Non-fragile]实例变量是新版 Objective-C 的一个新功能，应用于iPhone和64位Mac上。它们提供给框架开发者更多的灵活性，且不会失去二进制的兼容性 #如何寻址成员变量点开 runtime 的源码，让我们找到 ivar 的定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566typedef struct objc_class *Class;typedef struct objc_object *id;// 类实例struct objc_object {private: isa_t isa;// ...省略}union isa_t { isa_t() { } isa_t(uintptr_t value) : bits(value) { } Class cls; uintptr_t bits; // ...省略}// 类定义struct objc_class : objc_object { // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // ...省略}struct class_data_bits_t { // ...省略public: class_rw_t* data() { return (class_rw_t *)(bits &amp; FAST_DATA_MASK); } // ...省略}struct class_rw_t { uint32_t flags; uint32_t version; const class_ro_t *ro; // ...省略}struct class_ro_t { uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; const method_list_t * baseMethods; const protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; const property_list_t *baseProperties;}; 每个 OC 类实例实际上都是一个内存上指向objc_object结构体的指针，成员变量 isa 有指向objc_class结构体的指针Class cls; 在class_ro_t结构体中可以找到成员变量 const ivar_list_t * ivars，这个就是存储类所有成员变量的列表 在class_ro_t结构体中成员变量const uint8_t * ivarLayout;和const uint8_t * weakIvarLayout;的作用可以看一下孙源的这篇博客 1234@interface MyObject : NSObject { NSString *_age;}@end 使用 clang -rewrite-objc MyObject.h 将代码转化成 C++ 实现，你可以看到编译后的 MyObject 实例的内存布局： 1234567struct MyObject_IMPL { struct NSObject_IMPL NSObject_IVARS; NSString *__strong _age;};struct NSObject_IMPL { __unsafe_unretained Class isa;}; ivar_list_t 结构体的定义如下： 123456789101112struct ivar_list_t { uint32_t entsize; uint32_t count; ivar_t first;};struct ivar_t { int32_t *offset; const char *name; const char *type; // ...省略}; 我们可以看到ivar_t有名为offset的成员变量，这个就是成员变量在对象中的位置偏移量。在应用启动时，如果父类size变大时，runtime 会通过修改 offset，更新成员变量的偏移量，来正确的找到成员变量的地址。 1234567891011@interface MyObject : NSObject { NSString *_age;}@end@implementation MyObject- (void)test{ self -&gt; _age = @&quot;hhh&quot;;}@end 使用命令行clang -F -cc1 -S -emit-llvm -fblocks MyObject.m，将代码编译成 IR(intermediate representation)。注意要加*-F*，好多人的博客里面都少了这个标志，会报错。在 stackoverflow 找到答案。下面是编译后的代码： 12345678@&quot;OBJC_IVAR_$_MyObject._age&quot; = hidden global i64 8, section &quot;__DATA, __objc_ivar&quot;, align 8// ...%6 = load i64, i64* @&quot;OBJC_IVAR_$_MyObject._age&quot;, align 8, !invariant.load !8%7 = bitcast %0* %5 to i8*%8 = getelementptr inbounds i8, i8* %7, i64 %6%9 = bitcast i8* %8 to %1**store %1* bitcast (%struct.__NSConstantString_tag* @_unnamed_cfstring_ to %1*), %1** %9, align 8 可以简化成如下的代码 123int32_t g_ivar_MyClass_age = 8; // 全局变量*(NSString *)((uint8_t *)obj + g_ivar_MyObject_age) = @&quot;hhh&quot;; 编译时，LLVM 为每各类的每一个成员变量定义一个全局变量，用于存储该成员变量的偏移量 根据成员变量的偏移量，可以直接找到成员变量的地址并赋值 这也是为什么结构体ivar_t的成员变量offset是int32_t *类型，因为保存的是该全局变量的地址。 #Non Fragile ivars在前面部分我们已经知道该如何寻址成员变量，那么当基类的size变化时，runtime 是如何更新子类成员变量的offset呢？ 在应用程序启动后，main 函数执行之前，runtime 在加载类的时候，会使用static Class realizeClass(Class cls)函数对类进行初始化，分配其读写数据的内存，返回类的真实结构 123456789101112131415161718192021222324252627282930313233/* realizeClass* Performs first-time initialization on class cls, * including allocating its read-write data.* Returns the real class structure for the class. * Locking: runtimeLock must be write-locked by the caller*/static Class realizeClass(Class cls) { class_rw_t *rw = cls-&gt;data(); //...省略 if (ro-&gt;instanceStart &lt; super_ro-&gt;instanceSize) { // Superclass has changed size. This class's ivars must move. // Also slide layout bits in parallel. // This code is incapable of compacting the subclass to // compensate for a superclass that shrunk, so don't do that. class_ro_t *ro_w = make_ro_writeable(rw); ro = rw-&gt;ro; moveIvars(ro_w, super_ro-&gt;instanceSize, mergeLayouts ? &amp;ivarBitmap : nil, mergeLayouts ? &amp;weakBitmap : nil); gdb_objc_class_changed(cls, OBJC_CLASS_IVARS_CHANGED, ro-&gt;name); layoutsChanged = YES; } // ...省略}struct class_ro_t { uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; const ivar_list_t * ivars; // ...省略}; rw 是当前类的可读数据，ro 是类的 Ivar Layout，ro 的结构体定义在上面 在初始化类时，如果父类 ro 的instanceSize比子类的instanceStart大的话，那么会调用moveIvars函数更新子类的instanceSize以及子类成员变量的偏移量 再让我们看一下 moveIvars 的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/************************************************************************ moveIvars* Slides a class's ivars to accommodate the given superclass size.* Also slides ivar and weak GC layouts if provided.* Ivars are NOT compacted to compensate for a superclass that shrunk.* Locking: runtimeLock must be held by the caller.**********************************************************************/static void moveIvars(class_ro_t *ro, uint32_t superSize, layout_bitmap *ivarBitmap, layout_bitmap *weakBitmap){ rwlock_assert_writing(&amp;runtimeLock); uint32_t diff; uint32_t i; assert(superSize &gt; ro-&gt;instanceStart); diff = superSize - ro-&gt;instanceStart; if (ro-&gt;ivars) { // Find maximum alignment in this class's ivars uint32_t maxAlignment = 1; for (i = 0; i &lt; ro-&gt;ivars-&gt;count; i++) { ivar_t *ivar = ivar_list_nth(ro-&gt;ivars, i); if (!ivar-&gt;offset) continue; // anonymous bitfield uint32_t alignment = ivar-&gt;alignment(); if (alignment &gt; maxAlignment) maxAlignment = alignment; } // Compute a slide value that preserves that alignment uint32_t alignMask = maxAlignment - 1; if (diff &amp; alignMask) diff = (diff + alignMask) &amp; ~alignMask; // Slide all of this class's ivars en masse for (i = 0; i &lt; ro-&gt;ivars-&gt;count; i++) { ivar_t *ivar = ivar_list_nth(ro-&gt;ivars, i); if (!ivar-&gt;offset) continue; // anonymous bitfield uint32_t oldOffset = (uint32_t)*ivar-&gt;offset; uint32_t newOffset = oldOffset + diff; *ivar-&gt;offset = newOffset; if (PrintIvars) { _objc_inform(&quot;IVARS: offset %u -&gt; %u for %s (size %u, align %u)&quot;, oldOffset, newOffset, ivar-&gt;name, ivar-&gt;size, ivar-&gt;alignment()); } } // Slide GC layouts uint32_t oldOffset = ro-&gt;instanceStart; uint32_t newOffset = ro-&gt;instanceStart + diff; if (ivarBitmap) { layout_bitmap_slide(ivarBitmap, oldOffset &gt;&gt; WORD_SHIFT, newOffset &gt;&gt; WORD_SHIFT); } if (weakBitmap) { layout_bitmap_slide(weakBitmap, oldOffset &gt;&gt; WORD_SHIFT, newOffset &gt;&gt; WORD_SHIFT); } } *(uint32_t *)&amp;ro-&gt;instanceStart += diff; *(uint32_t *)&amp;ro-&gt;instanceSize += diff; if (!ro-&gt;ivars) { // No ivars slid, but superclass changed size. // Expand bitmap in preparation for layout_bitmap_splat(). if (ivarBitmap) layout_bitmap_grow(ivarBitmap, ro-&gt;instanceSize &gt;&gt; WORD_SHIFT); if (weakBitmap) layout_bitmap_grow(weakBitmap, ro-&gt;instanceSize &gt;&gt; WORD_SHIFT); }} 首先计算 superSize 与 instanceStart 之间的差值 diff 得到结构体中最大的成员变量的size：maxAlignment， 然后赋值：alignMask = maxAlignment - 1 比较 diff 和 alignMask，通过算法 if (diff &amp; alignMask) diff = (diff + alignMask) &amp; ~alignMask; 对diff重新赋值 编译器在给结构体开辟空间时，首先找到结构体中最大的基本数据类型，然后寻找内存地址能是该基本数据类型的整倍的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为对齐模数。为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。了解更多可以看这篇博客 更新成员变量的 offset，ivar.newOffset = diff + ivar.oldOffset 更新子类 ro 的 instanceStart 和 instanceSize，ro.newinstanceStart = ro.oldinstanceStart + diff，ro.newinstanceSize = ro.oldinstanceSize + diff 当父类变大时会调用该函数来移动子类ivar，当父类变小时则子类ivar不变化 通过这个函数，即使父类size变大了，我们还是可以通过子类的 ro.instanceStart + ivar.offset 访问到成员变量 #不能动态添加成员变量在 runtime 中有一个函数 class_addIvar()可以为类添加成员变量, 下面是该方法的一部分注释： his function may only be called after objc_allocateClassPair and before objc_registerClassPair. Adding an instance variable to an existing class is not supported.The class must not be a metaclass. Adding an instance variable to a metaclass is not supported. 上面的大致意思是该函数只能在类注册之前使用，且不能为元类添加成员变量。 让我们设想一下如果 OC 允许动态增加成员变量： 123456789@interface Father : NSObject@property (nonatomic, strong) NSString *name;@property (nonatomic, strong) NSString *age;@end@interface Son : Father@property (nonatomic, copy) NSArray *toys;@end 当Father初始化之后，instanceStart，instanceSize，offset已经确定。 为 Father 添加新的成员变量 sex，则使用 Son 的实例对象 son 会出错误，因为 son.instanceStart &lt; Father.instanceSize，即 father 成员变量的 sex 的内存区域会跟 son 的一部分重合 我们有时会在类目中动态的为类添加关联对象(添加对象)，为什么可以添加关联对象呢?具体的你可以看一下我的另一篇博客 谈Objective-C关联对象。这里我简单解释一下：关联对象被保存在一个静态的 map 中，以类实例的指针地址为映射，而不是保存在类实例的结构体中，不影响对象中成员变量的使用，所以可以在运行时添加成员变量。 #引用Objective-C类成员变量深度剖析","link":"/2019/06/27/%E8%B0%88Objective-C%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/"},{"title":"谈block、__weak和__strong","text":"最近在”翻新”公司的老项目的时候，发现一个奇怪的问题： 在一个 block 中，我使用了 RAC 为了避免 block 循环引用而定义的两个宏: @weakify和@strongify，但是如果在 block 内部使用下划线属性(成员变量)，还是会导致循环引用。 很多人都知道怎么处理这个问题，在使用了@weakify和@strongify的情况下，在 block 内部像self -&gt; ivar这样使用成员变量就可以避免循环引用了，但是为什么这样用就没问题呢？使用了@weakify和@strongify两个宏之后发生了什么呢？带着你在使用 block 时出现过的疑问，在后面的内容中你可能会得到答案。 block是什么block 是用于创建匿名函数的 C 语言扩展。用户使用 block 指针与 block 对象进行交互并传输 block 对象，block 指针表示为普通指针。block 可以从局部变量中捕获值;发生这种情况时，必须动态分配内存。初始分配在栈上完成，但 runtime 提供了一个Block_copy函数，给定一个 block 指针，将底层 block 对象复制到堆中，将其引用计数设置为1并返回新的 block 指针，或者（如果 block 对象已经在堆上）将其引用计数增加1.配对函数是Block_release，它将引用计数减少1并在计数达到零并且在堆上时销毁对象。翻译自苹果文档 上面的翻译来自于 谷歌翻译~。我对于 block 的理解就是一个指针，指向一个带有函数指针 (用于执行block内的代码) 的结构体，该结构体内有许多捕获的成员变量。在 ARC 环境下 block 会从 栈中自动复制到堆中，方便 runtime 管理内存生命周期；如果内部有全局变量则复制到数据区，生命周期为程序创建到程序结束。 [站外图片上传中…(image-1d1a52-1561035272667)] block的数据结构block 的数据结构定义如下[站外图片上传中…(image-f5b34b-1561035272667)] 结构体定义： 12345678910111213141516struct Block_layout { void *isa; int flags; int reserved; void (*invoke)(void *, ...); struct Block_descriptor *descriptor; /* Imported variables. */};struct Block_descriptor { unsigned long int reserved; unsigned long int size;// sizeof(struct Block_layout) void (*copy)(void *dst, void *src); void (*dispose)(void *);}; 通过它的数据结构，我们知道一个 block 实际上是由5部分组成的 isa 指针，所有对象都有该指针，用于实现对象相关的功能 flags，用于按 bit 位表示一些 block 的附加信息 reserved，保留变量 invoke，函数指针，指向具体的 block 实现的函数调用地址 descriptor， 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针 block的几种的类型 常见的 block 有下面三种，不用类型的 block 存放不同的区域，在 ARC 环境下只有_NSConcreteGlobalBlock和_NSConcreteMallocBlock两种类型的 block _NSConcreteGlobalBlock 全局的静态 block，不会访问任何外部变量。 _NSConcreteStackBlock 保存在栈中的 block，当函数返回时会被销毁。 _NSConcreteMallocBlock 保存在堆中的 block，当引用计数为 0 时会被销毁。 下面是详细的介绍 _NSConcreteStackBlock该类型的 block 仅存在在 MRC 环境中，数据存放在栈区，当函数返回时会被销毁。在 ARC 环境中，不存在_NSConcreteStackBlock类型，只存在_NSConcreteGlobalBlock和_NSConcreteMallocBlock 两个类型。在下面的例子中， block 的类型的打印结果是__NSMallocBlock__。原因可能是因为c语言的结构体中，编译器不能很好地管理初始化和销毁，这样对内存管理来说很不方便，所以就将 block 放到堆上，使用 runtime 来管理它们的生命周期。 12345678910int val = 1; void(^textBlock)(void) = ^{ NSLog(@&quot;[block] val&lt;%p&gt;: %d&quot;, &amp;val, val); NSLog(@&quot;val: %d&quot;, val);};NSLog(@&quot;val&lt;%p&gt;: %d&quot;, &amp;val, val);textBlock();NSLog(@&quot;textBlock: %@&quot;, textBlock); 打印结果为： 1234val&lt;0x16b523d1c&gt;: 1[block] val&lt;0x280a9fcb0&gt;: 1textBlock: &lt;__NSMallocBlock__: 0x28076a4c0&gt; 下面使用 clang -rewrite-objc filename 将代码转换成 C++ 的实现, 下面是关键部分的代码 123456789101112131415161718192021222324252627282930struct __MyObject__test_block_impl_0 { struct __block_impl impl; struct __MyObject__test_block_desc_0* Desc; int val; __MyObject__test_block_impl_0(void *fp, struct __MyObject__test_block_desc_0 *desc, int _val, int flags=0) : val(_val) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __MyObject__test_block_func_0(struct __MyObject__test_block_impl_0 *__cself) { int val = __cself-&gt;val; // bound by copy }static struct __MyObject__test_block_desc_0 { size_t reserved; size_t Block_size;} __MyObject__test_block_desc_0_DATA = { 0, sizeof(struct __MyObject__test_block_impl_0)};static void _I_MyObject_test(MyObject * self, SEL _cmd) { static int static_v = 1; int val = 1; void(*textBlock)(void) = ((void (*)())&amp;__MyObject__test_block_impl_0((void *)__MyObject__test_block_func_0, &amp;__MyObject__test_block_desc_0_DATA, val)); ((void (*)(__block_impl *))((__block_impl *)textBlock)-&gt;FuncPtr)((__block_impl *)textBlock);} 其中__MyObject__test_block_impl_0 是 block 的结构体类型 __MyObject__test_block_func_0 是 block 实现的函数，在 __MyObject__test_block_impl_0内有一个指针FuncPtr 指向该函数 __MyObject__test_block_desc_0 是 block 附件描述信息的结构体，包含着 block 结构体大小， copy 和 dispose 函数指针(这两个函数后面后讲到)等的描述信息，在 __MyObject__test_block_impl_0内有一个指针Desc 指向该结构体 在_I_MyObject_test 函数内可以看到 block 的初始化，void(*textBlock)(void) 说明 textBlock 是一个指向该 block 结构体的指针 首先观察这个__MyObject__test_block_impl_0的结构体： 123456789101112struct __MyObject__test_block_impl_0 { struct __block_impl impl; struct __MyObject__test_block_desc_0* Desc; int val; __MyObject__test_block_impl_0(void *fp, struct __MyObject__test_block_desc_0 *desc, int _val, int flags=0) : val(_val) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }}; 使用 clang 转换过的实现是 MRC 环境的，所以 isa 指针指向 _NSConcreteStackBlock 类型 在这个结构体中可以看到一个成员变量int val; ，没错，它就是 block 捕获的局部变量，从构造函数 __MyObject__test_block_impl_0(void *fp, struct __MyObject__test_block_desc_0 *desc, int _val, int flags=0) : val(_val) 中可以看到，block 仅仅捕获了该变量的值 __MyObject__test_block_impl_0中由于增加了一个变量 val，所以结构体的大小变大了，结构体大小被写在了__MyObject__test_block_desc_0中 block 捕获外部变量仅仅只 block 闭包里面会用到的值，其他用不到的值，它并不会去捕获。 再看一下__MyObject__test_block_func_0这个函数的实现： 12345static void __MyObject__test_block_func_0(struct __MyObject__test_block_impl_0 *__cself) { int val = __cself-&gt;val; // bound by copy } 我们可以发现，系统自动给我们加上的注释，bound by copy，自动变量 val 虽然被捕获进来了，但是是用 __cself-&gt;val 来访问的。block 仅仅捕获了 val 的值，并没有捕获 val 的内存地址。所以在__MyObject__test_block_func_0 这个函数中即使我们重写这个自动变量 val 的值，依旧没法去改变block外面变量 val 的值。 小结一下:基本数据类型的变量是以值传递方式传递到 block 的构造函数里面去的。block 只捕获 block 中会用到的变量。由于只捕获了自动变量的值，并非内存地址，所以 block 内部不能改变变量的值。 _NSConcreteMallocBlock修改一下上面的代码： 12345678910 __block int val = 1;void(^textBlock)(void) = ^{ val++; NSLog(@&quot;[block] val&lt;%p&gt;: %d&quot;, &amp;val, val);};NSLog(@&quot;val&lt;%p&gt;: %d&quot;, &amp;val, val);textBlock();NSLog(@&quot;val&lt;%p&gt;: %d&quot;, &amp;val, val);NSLog(@&quot;textBlock: %@&quot;, textBlock); 打印输出为： 12345val&lt;0x282db0858&gt;: 1[block] val&lt;0x282db0858&gt;: 2val&lt;0x282db0858&gt;: 2textBlock: &lt;__NSMallocBlock__: 0x2823d3450&gt; 重新用 clang 生成的c++实现 1234567891011121314151617181920212223242526272829303132333435363738394041struct __Block_byref_val_0 { void *__isa;__Block_byref_val_0 *__forwarding; int __flags; int __size; int val;};struct __MyObject__test_block_impl_0 { struct __block_impl impl; struct __MyObject__test_block_desc_0* Desc; __Block_byref_val_0 *val; // by ref __MyObject__test_block_impl_0(void *fp, struct __MyObject__test_block_desc_0 *desc, __Block_byref_val_0 *_val, int flags=0) : val(_val-&gt;__forwarding) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __MyObject__test_block_func_0(struct __MyObject__test_block_impl_0 *__cself) { __Block_byref_val_0 *val = __cself-&gt;val; // bound by ref (val-&gt;__forwarding-&gt;val)++; }static void __MyObject__test_block_copy_0(struct __MyObject__test_block_impl_0*dst, struct __MyObject__test_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;val, (void*)src-&gt;val, 8/*BLOCK_FIELD_IS_BYREF*/);}static void __MyObject__test_block_dispose_0(struct __MyObject__test_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;val, 8/*BLOCK_FIELD_IS_BYREF*/);}static struct __MyObject__test_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __MyObject__test_block_impl_0*, struct __MyObject__test_block_impl_0*); void (*dispose)(struct __MyObject__test_block_impl_0*);} __MyObject__test_block_desc_0_DATA = { 0, sizeof(struct __MyObject__test_block_impl_0), __MyObject__test_block_copy_0, __MyObject__test_block_dispose_0};static void _I_MyObject_test(MyObject * self, SEL _cmd) { __attribute__((__blocks__(byref))) __Block_byref_val_0 val = {(void*)0,(__Block_byref_val_0 *)&amp;val, 0, sizeof(__Block_byref_val_0), 1}; void(*textBlock)(void) = ((void (*)())&amp;__MyObject__test_block_impl_0((void *)__MyObject__test_block_func_0, &amp;__MyObject__test_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, 570425344)); ((void (*)(__block_impl *))((__block_impl *)textBlock)-&gt;FuncPtr)((__block_impl *)textBlock);} 在重新生成的代码中，我们看到新增了一个名为__Block_byref_val_0的结构体，它是用来替代我们__block修饰的变量 val 的。 它的第一个指针是 isa，说明它也是一个对象。 第二个指针是指向自身类的指针__forwarding 第三个是一个标记 flag 第四个是结构体的大小 第五个是变量 val 的值 在函数static void _I_MyObject_test(MyObject * self, SEL _cmd)我们可以看到该结构体的初始化代码： 123__attribute__((__blocks__(byref))) __Block_byref_val_0 val = {(void*)0,(__Block_byref_val_0 *)&amp;val, 0, sizeof(__Block_byref_val_0), 1}; 在初始化时， isa 指向了一个空指针 __forwarding指向了自己的地址 1是变量 val 的值。 使用 __block修饰的变量，无论是基本数据类型还是 OC 的类，在编译之后都是转换成一个新的结构体，该结构体的__forwarding指针会指向自己的地址，而成员变量 val 则为编译前的类型和值。至于这样的目的是什么，可以接着看下面。 1234567static struct __MyObject__test_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __MyObject__test_block_impl_0*, struct __MyObject__test_block_impl_0*); void (*dispose)(struct __MyObject__test_block_impl_0*);} __MyObject__test_block_desc_0_DATA = { 0, sizeof(struct __MyObject__test_block_impl_0), __MyObject__test_block_copy_0, __MyObject__test_block_dispose_0}; 在__MyObject__test_block_desc_0 这个结构体中，我们发现比之前的代码多了一个 copy 和 dispose 的函数指针。在c语言的结构体中，编译器没有很好地进行初始化和销毁，这样对内存管理来说很不方便，所以就在增加了这两个函数指针，方便进行内存管理。copy函数把block从栈上拷贝到堆上，dispose函数是把堆上的函数在废弃的时候销毁掉。 copy 和 dispose这两个函数指针对应的两个函数实现 12345static void __MyObject__test_block_copy_0(struct __MyObject__test_block_impl_0*dst, struct __MyObject__test_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;val, (void*)src-&gt;val, 8/*BLOCK_FIELD_IS_BYREF*/);}static void __MyObject__test_block_dispose_0(struct __MyObject__test_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;val, 8/*BLOCK_FIELD_IS_BYREF*/);} __MyObject__test_block_copy_0函数实现中出现了方法_Block_object_assign, __MyObject__test_block_dispose_0函数实现中出现了方法_Block_object_dispose。 下面是这两个方法的申明： 123456789101112131415161718192021#define Block_copy(...) ((__typeof(__VA_ARGS__))_Block_copy((const void *)(__VA_ARGS__)))#define Block_release(...) _Block_release((const void *)(__VA_ARGS__))// Create a heap based copy of a Block or simply add a reference to an existing one.// This must be paired with Block_release to recover memory, even when running// under Objective-C Garbage Collection.BLOCK_EXPORT void *_Block_copy(const void *aBlock) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);// Lose the reference, and if heap based and last reference, recover the memoryBLOCK_EXPORT void _Block_release(const void *aBlock) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);// Used by the compiler. Do not call this function yourself.BLOCK_EXPORT void _Block_object_assign(void *, const void *, const int) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);// Used by the compiler. Do not call this function yourself.BLOCK_EXPORT void _Block_object_dispose(const void *, const int) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2); 下面是这两个方法的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273static void *_Block_copy_internal(const void *arg, const int flags) { struct Block_layout *aBlock; const bool wantsOne = (WANTS_ONE &amp; flags) == WANTS_ONE; // 1 if (!arg) return NULL; // 2 aBlock = (struct Block_layout *)arg; // 3 if (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) { // latches on high latching_incr_int(&amp;aBlock-&gt;flags); return aBlock; } // 4 else if (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) { return aBlock; } // 5 struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size); if (!result) return (void *)0; // 6 memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first // 7 result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK); // XXX not needed result-&gt;flags |= BLOCK_NEEDS_FREE | 1; // 8 result-&gt;isa = _NSConcreteMallocBlock; // 9 if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) { (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup } return result;}void _Block_release(void *arg) { // 1 struct Block_layout *aBlock = (struct Block_layout *)arg; if (!aBlock) return; // 2 int32_t newCount; newCount = latching_decr_int(&amp;aBlock-&gt;flags) &amp; BLOCK_REFCOUNT_MASK; // 3 if (newCount &gt; 0) return; // 4 if (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) { if (aBlock-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE)(*aBlock-&gt;descriptor-&gt;dispose)(aBlock); _Block_deallocator(aBlock); } // 5 else if (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) { ; } // 6 else { printf(&quot;Block_release called upon a stack Block: %p, ignored\\n&quot;, (void *)aBlock); }} _Block_copy_internal是Block_copy的一个实现，实现了从_NSConcreteStackBlock复制到_NSConcreteMallocBlock的过程，有9个步骤。 在第8步中我们可以看到 isa 指针指向了_NSConcreteMallocBlock _Block_release是Block_release的一个实现，实现了一个block释放的过程，有6个步骤 扯的有点远了，现在让我们总结一下 __block 修饰的变量在block内发生了什么。 block 会在栈中被创建，然后通过Block_copy函数复制到堆中。由 runtime 管理它的生命周期 使用 __block 修饰的变量，在编译后会变成一个新的对象。在初始化时，成员变量__forwarding 会指向栈中该变量的地址，val 为该变量原本的值。当 block 的成员变量 __Block_byref_val_0 从栈中复制到堆中时，成员变量 __Block_byref_val_0的地址可能改变了，但是 __forwarding 指针指向的结构体是不会变的，仍然在栈中。 block 的实现函数__MyObject__test_block_func_0，block 通过 __Block_byref_val_0 *val = __cself-&gt;val;(val-&gt;__forwarding-&gt;val)++ 变量的地址修改 val，所以在 block 内部修改变量 val 是会影响到 block 外部的变量。 这就是为什么 block 内部和外部 val 的地址不同的原因(一个在栈上，一个在堆上)。因为他们__forwarding指向的结构体是一样的，所以在 block 内部修改变量会影响到外部， _NSConcreteGlobalBlockblock 内部只用到全局变量，包括全局变量，静态全局变量，静态变量，以及上述 block 的 copy 版本。数据存放在数据区，生命周期从应用创建到应用结束。 12345678910111213141516171819202122232425int global_v = 1;static int static_global_v = 1;@implementation MyObject- (void)test{ static int static_v = 1; NSLog(@&quot;val&lt;%p&gt;: %d&quot;, &amp;static_v, static_v); NSLog(@&quot;global_v&lt;%p&gt;: %d&quot;, &amp;global_v, global_v); NSLog(@&quot;static_global_v&lt;%p&gt;: %d&quot;, &amp;static_global_v, static_global_v); void(^textBlock)(void) = ^{ static_v++; global_v++; static_global_v++; NSLog(@&quot;[block] val&lt;%p&gt;: %d&quot;, &amp;static_v, static_v); NSLog(@&quot;[block] global_v&lt;%p&gt;: %d&quot;, &amp;global_v, global_v); NSLog(@&quot;[block] static_global_v&lt;%p&gt;: %d&quot;, &amp;static_global_v, static_global_v); }; textBlock(); NSLog(@&quot;textBlock: %@&quot;, textBlock);} 打印信息为： 12345678910val&lt;0x1034b8114&gt;: 1global_v&lt;0x1034b8110&gt;: 1static_global_v&lt;0x1034b8118&gt;: 1[block] val&lt;0x1034b8114&gt;: 2[block] global_v&lt;0x1034b8110&gt;: 2[block] static_global_v&lt;0x1034b8118&gt;: 2textBlock: &lt;__NSGlobalBlock__: 0x10343da40&gt; clang 之后 C++ 实现： 1234567891011121314151617181920212223242526272829303132int global_v = 1;static int static_global_v = 1;struct __MyObject__test_block_impl_0 { struct __block_impl impl; struct __MyObject__test_block_desc_0* Desc; int *static_v; __MyObject__test_block_impl_0(void *fp, struct __MyObject__test_block_desc_0 *desc, int *_static_v, int flags=0) : static_v(_static_v) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __MyObject__test_block_func_0(struct __MyObject__test_block_impl_0 *__cself) { int *static_v = __cself-&gt;static_v; // bound by copy (*static_v)++; global_v++; static_global_v++; }static struct __MyObject__test_block_desc_0 { size_t reserved; size_t Block_size;} __MyObject__test_block_desc_0_DATA = { 0, sizeof(struct __MyObject__test_block_impl_0)};static void _I_MyObject_test(MyObject * self, SEL _cmd) { static int static_v = 1;} block 仅仅捕获了静态变量 static_v 的地址作为自己的成员变量，因此在内部修改该变量可以影响到 block 外部。block 内部和外部该变量的地址相等 全局变量 global_v 和全局静态变量 static_global_v 并没有被 block 捕获，因为他们已经被保存在数据区中，可以直接使用 由于 clang 改写的方式跟 LLVM 不太一样，在这里并没有开启ARC，所以这里我们看到 isa 指向的还是 _NSConcreteStackBlock，但在开启ARC的时候，block 应该是 _NSConcreteGlobalBlock 类型。 block 与 self在前面的部分，我们已经分析过 局部变量，静态变量，全局变量，全局静态变量在 block 时的情况，那么，还有一种特殊的变量 self，它在 block 内部时又是怎么样运行的呢？ 123456789101112131415161718192021222324252627282930@interface MyObject () { NSString *_age;}@property (nonatomic, strong) NSString *name;@end@implementation MyObject- (void)test{ self.name = @&quot;n&quot;; _age = @&quot;10&quot;; NSLog(@&quot;self: %@&quot;, self); void(^textBlock)(void) = ^{ self.name = @&quot;a&quot;; _age = @&quot;11&quot;; NSLog(@&quot;[block] self: %@&quot;, self); NSLog(@&quot;[block] name&lt;%p&gt;: %@&quot;, self.name, self.name); NSLog(@&quot;[block] age&lt;%p&gt;: %@&quot;, _age, _age); }; NSLog(@&quot;name&lt;%p&gt;: %@&quot;, self.name, self.name); NSLog(@&quot;age&lt;%p&gt;: %@&quot;, _age, _age); textBlock(); NSLog(@&quot;name&lt;%p&gt;: %@&quot;, self.name, self.name); NSLog(@&quot;age&lt;%p&gt;: %@&quot;, _age, _age);} 打印结果： 1234567name&lt;0x102804818&gt;: nage&lt;0x102804838&gt;: 10[block] name&lt;0x102804858&gt;: a[block] age&lt;0x102804878&gt;: 11name&lt;0x102804858&gt;: aage&lt;0x102804878&gt;: 11 clang之后的C++实现 1234567891011121314151617181920212223242526272829303132333435363738struct __MyObject__test_block_impl_0 { struct __block_impl impl; struct __MyObject__test_block_desc_0* Desc; MyObject *self; __MyObject__test_block_impl_0(void *fp, struct __MyObject__test_block_desc_0 *desc, MyObject *_self, int flags=0) : self(_self) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __MyObject__test_block_func_0(struct __MyObject__test_block_impl_0 *__cself) { MyObject *self = __cself-&gt;self; // bound by copy ((void (*)(id, SEL, NSString *))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setName:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_xy_nncr8hn96cd0_rdymw2f0qcw0000gn_T_MyObject_2519b6_mi_2); (*(NSString **)((char *)self + OBJC_IVAR_$_MyObject$_age)) = (NSString *)&amp;__NSConstantStringImpl__var_folders_xy_nncr8hn96cd0_rdymw2f0qcw0000gn_T_MyObject_2519b6_mi_3; }static void __MyObject__test_block_copy_0(struct __MyObject__test_block_impl_0*dst, struct __MyObject__test_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;self, (void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);}static void __MyObject__test_block_dispose_0(struct __MyObject__test_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;self, 3/*BLOCK_FIELD_IS_OBJECT*/);}static struct __MyObject__test_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __MyObject__test_block_impl_0*, struct __MyObject__test_block_impl_0*); void (*dispose)(struct __MyObject__test_block_impl_0*);} __MyObject__test_block_desc_0_DATA = { 0, sizeof(struct __MyObject__test_block_impl_0), __MyObject__test_block_copy_0, __MyObject__test_block_dispose_0};static void _I_MyObject_test(MyObject * self, SEL _cmd) { ((void (*)(id, SEL, NSString *))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setName:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_xy_nncr8hn96cd0_rdymw2f0qcw0000gn_T_MyObject_2519b6_mi_0); (*(NSString **)((char *)self + OBJC_IVAR_$_MyObject$_age)) = (NSString *)&amp;__NSConstantStringImpl__var_folders_xy_nncr8hn96cd0_rdymw2f0qcw0000gn_T_MyObject_2519b6_mi_1; void(*textBlock)(void) = ((void (*)())&amp;__MyObject__test_block_impl_0((void *)__MyObject__test_block_func_0, &amp;__MyObject__test_block_desc_0_DATA, self, 570425344)); ((void (*)(__block_impl *))((__block_impl *)textBlock)-&gt;FuncPtr)((__block_impl *)textBlock);} 在__MyObject__test_block_impl_0中我们可以看到self也被 block 捕获成了成员变量 在__MyObject__test_block_impl_0的构造函数中我们可以看到 self 被当做参数被传入，而不是 self 的地址 因为 block 在内部和外部 self 指向的是相同的 MyObject 结构体，所以在 block 内部对 self 成员变量进行修改会影响到 block 外部 block 的结构体会强引用 self，所以需要小心使用，否则会引起循环应用 1234567static void __MyObject__test_block_func_0(struct __MyObject__test_block_impl_0 *__cself) { MyObject *self = __cself-&gt;self; // bound by copy((void (*)(id, SEL, NSString *))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setName:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_xy_nncr8hn96cd0_rdymw2f0qcw0000gn_T_MyObject_2519b6_mi_2);(*(NSString **)((char *)self + OBJC_IVAR_$_MyObject$_age)) = (NSString *)&amp;__NSConstantStringImpl__var_folders_xy_nncr8hn96cd0_rdymw2f0qcw0000gn_T_MyObject_2519b6_mi_3;} block 内部使用属性和成员变量是不一样的。直接使用属性时，走的是 obj_msgSend 消息发送(具体可以研究这篇博客)，而在使用成员变量时，应该是先通过 self 得到结构体的首地址，然后通过成员变量的偏移量然直接使用这个成员变量(其实我也没很理解。。。) 小结一下： block 内部使用 self 时的情况跟使用局部变量的情况是比较类似的，block 会捕获 self 的值而不是地址当做成员变量 在 block 内部使用属性和成员变量的情况是不一样的 __weak与__strong我们都知道使用__weak和__strong修饰符可以避免在block的使用中出现循环引用的问题，这是为什么呢？先让我们了解一下这两个修饰符吧！ ARC 环境下，OC的对象面前都需要加上所有权的修饰符，所有的修饰符有以下4种 __strong修饰符 __weak修饰符 __unsafe_unretained修饰符 __autoreleasing修饰符 默认的修饰符是__strong。 ARC下，self既不是strong也不是weak，而是unsafe_unretained的，也就是说，入参的self被表示为：（init系列方法的self除外）来源：博客 1234- (void)start { const __unsafe_unretained MyObject *self;} 想要弄清__weak与__strong的实现原理，需要研究一下clang中关于ARC的文档，有兴趣可以点进去仔细看看。 __strong12id __strong object = [[NSObject alloc] init]; 在终端使用命令xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 MyObject.m转换成 C++ 的实现 12id __attribute__((objc_ownership(strong))) object = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;)); = 右边的代码意思应该是对 NSObject 这个类发送 alloc 消息，然后再对生成的对象发送 init 消息，这两个方法的实现可以在 runtime 中找到，代码我也贴到下面了= 左边的代码，我不大理解objc_ownership这个函数，查了下搜不到是啥意思，看字面意思应该是两个对象间的持有关系，也就是自己持有自己的意思。 123456789+ alloc{ return (*_zoneAlloc)((Class)self, 0, malloc_default_zone()); }- init{ return self;} __weak123id __strong object = [[NSObject alloc] init];id __weak weakSelf = object; 在终端使用命令xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 MyObject.m转换成 C++ 实现 123id __attribute__((objc_ownership(strong))) object = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));id __attribute__((objc_ownership(weak))) weakSelf = object; 相应的会调用 123objc_initWeak(&amp;weakSelf,object);objc_destoryWeak(&amp;weakSelf); objc_initWeak方法的文档说明Precondition: object is a valid pointer which has not been registered as a __weak object. value is null or a pointer to a valid object. If value is a null pointer or the object to which it points has begun deallocation, object is zero-initialized. Otherwise, object is registered as a __weak object pointing to value. Equivalent to the following code: id objc_initWeak(id *object, id value) { *object = nil; return objc_storeWeak(object, value); } 这个函数会把传入的 object 置为nil，然后执行objc_storeWeak函数。 那么objc_storeWeak函数是干什么的呢？下面是这个方法的说明 Precondition: object is a valid pointer which either contains a null pointer or has been registered as a __weak object. value is null or a pointer to a valid object.If value is a null pointer or the object to which it points has begun deallocation, object is assigned null and unregistered as a __weak object. Otherwise, object is registered as a __weak object or has its registration updated to point to value.Returns the value of object after the call. objc_storeWeak函数的用途就很明显了。由于weak表也是用Hash table实现的，所以objc_storeWeak函数就把第一个入参的变量地址注册到weak表中，然后根据第二个入参来决定是否移除。如果第二个参数为0，那么就把__weak变量从weak表中删除记录，并从引用计数表中删除对应的键值记录 所以如果__weak引用的原对象如果被释放了，那么对应的__weak对象就会被指为nil。原来就是通过objc_storeWeak函数这些函数来实现的。 接下来是 objc_destoryWeak 函数的实现 1234void objc_destroyWeak(id *object) { objc_storeWeak(object, nil);} 还是调用上面的objc_storeWeak函数，因为传入的value为nil，所以object将从weak表中删除并且置为nil __weak与__strong的作用终于讲到这两个所有权修饰符的作用了。 首先是不使用这两个修饰符时的情况。在上面我们已经讲到过 block 存在 self 的一种情况了，下面我们要讲一下 block 存在 self 并且 self 强应用 block 时的情况 12345678910111213141516171819202122232425@interface MyObject ()@property (nonatomic, strong) NSString *name;@property (nonatomic, copy) void(^textBlock)(void);@end@implementation MyObject- (void)test{ self.textBlock = ^{ self.name = @&quot;n&quot;; }}@end@implementation OneViewController - (void)viewDidLoad { [super viewDidLoad]; self.object = [[MyObject alloc] init]; [self.object test]; } 对于 MyObject 来说是造成了循环引用的，因为它强引用了 block，而 block 内部也强引用着 self，所以 MyObject 是不能被dealloc的，但奇怪的是，将 MyObject 当做属性的 OneViewController 竟然可以dealloc，这估计是另一个问题了，等我有空再去研究一下这个。。。 使用 clang 得到的C++实现，这边只截取了block结构体和初始化block部分 1234567891011121314struct __MyObject__test_block_impl_0 { struct __block_impl impl; struct __MyObject__test_block_desc_0* Desc; MyObject *self; __MyObject__test_block_impl_0(void *fp, struct __MyObject__test_block_desc_0 *desc, MyObject *_self, int flags=0) : self(_self) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};// 初始化((void (*)())&amp;__MyObject__test_block_impl_0((void *)__MyObject__test_block_func_0, &amp;__MyObject__test_block_desc_0_DATA, self, 570425344) 在这个部分中可以看到 block 将 self(MyObject *指针)捕获成了自己的成员变量了(强引用), 而self指针的成员变量又包含block，造成循环引用。 仅仅使用__weak 12345678910111213141516@property (nonatomic, strong) NSString *name;@property (nonatomic, copy) void(^textBlock)(void);@end@implementation MyObject- (void)test{ __weak typeof(self) weakSelf = self; self.textBlock = ^{ weakSelf.name = @&quot;n&quot;; NSLog(@&quot;hh&quot;); }; self.textBlock();} 使用xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 MyObject.m得到C++实现 12345678910111213141516171819202122232425262728293031323334struct __MyObject__test_block_impl_0 { struct __block_impl impl; struct __MyObject__test_block_desc_0* Desc; MyObject *const __weak weakSelf; __MyObject__test_block_impl_0(void *fp, struct __MyObject__test_block_desc_0 *desc, MyObject *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __MyObject__test_block_func_0(struct __MyObject__test_block_impl_0 *__cself) { MyObject *const __weak weakSelf = __cself-&gt;weakSelf; // bound by copy ((void (*)(id, SEL, NSString *))(void *)objc_msgSend)((id)weakSelf, sel_registerName(&quot;setName:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_xy_nncr8hn96cd0_rdymw2f0qcw0000gn_T_MyObject_970d18_mi_0); }static void __MyObject__test_block_copy_0(struct __MyObject__test_block_impl_0*dst, struct __MyObject__test_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;weakSelf, (void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);}static void __MyObject__test_block_dispose_0(struct __MyObject__test_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);}static struct __MyObject__test_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __MyObject__test_block_impl_0*, struct __MyObject__test_block_impl_0*); void (*dispose)(struct __MyObject__test_block_impl_0*);} __MyObject__test_block_desc_0_DATA = { 0, sizeof(struct __MyObject__test_block_impl_0), __MyObject__test_block_copy_0, __MyObject__test_block_dispose_0};static void _I_MyObject_test(MyObject * self, SEL _cmd) { __attribute__((objc_ownership(weak))) typeof(self) weakSelf = self; ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setTextBlock:&quot;), ((void (*)())&amp;__MyObject__test_block_impl_0((void *)__MyObject__test_block_func_0, &amp;__MyObject__test_block_desc_0_DATA, weakSelf, 570425344))); ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(&quot;textBlock&quot;))();} 苹果使用一个全局的 weak 表来保存所有的 weak 引用。并将对象作为键，weak_entry_t 作为值。weak_entry_t 中保存了所有指向该对象的 weak 指针。当被指向的对象执行 dealloc 时候，将所有指向该对象的 weak 指针的设置为nil。 block 将 __weak 修饰的 self 捕获为成员变量 当 self 执行dealloc时，block 内的 self 置为nil，从而打破循环引用 当 self delloac 之后，在调用 block 的函数指针，block 内部的self置为nil。 同时使用__weak与__strong 123456789101112131415161718192021@interface MyObject ()//{// NSString *_age;//}@property (nonatomic, strong) NSString *name;@property (nonatomic, copy) void(^textBlock)(void);@end@implementation MyObject- (void)test{ __weak typeof(self) weakSelf = self; self.textBlock = ^{ __strong typeof(weakSelf) strongSelf = weakSelf; strongSelf.name = @&quot;n&quot;; NSLog(@&quot;hh&quot;); }; self.textBlock();} 使用xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 MyObject.m得到C++实现 1234567891011121314151617181920212223242526272829303132333435struct __MyObject__test_block_impl_0 { struct __block_impl impl; struct __MyObject__test_block_desc_0* Desc; MyObject *const __weak weakSelf; __MyObject__test_block_impl_0(void *fp, struct __MyObject__test_block_desc_0 *desc, MyObject *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __MyObject__test_block_func_0(struct __MyObject__test_block_impl_0 *__cself) { MyObject *const __weak weakSelf = __cself-&gt;weakSelf; // bound by copy __attribute__((objc_ownership(strong))) typeof(weakSelf) strongSelf = weakSelf; ((void (*)(id, SEL, NSString *))(void *)objc_msgSend)((id)strongSelf, sel_registerName(&quot;setName:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_xy_nncr8hn96cd0_rdymw2f0qcw0000gn_T_MyObject_0010b9_mi_0); }static void __MyObject__test_block_copy_0(struct __MyObject__test_block_impl_0*dst, struct __MyObject__test_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;weakSelf, (void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);}static void __MyObject__test_block_dispose_0(struct __MyObject__test_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;weakSelf, 3/*BLOCK_FIELD_IS_OBJECT*/);}static struct __MyObject__test_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __MyObject__test_block_impl_0*, struct __MyObject__test_block_impl_0*); void (*dispose)(struct __MyObject__test_block_impl_0*);} __MyObject__test_block_desc_0_DATA = { 0, sizeof(struct __MyObject__test_block_impl_0), __MyObject__test_block_copy_0, __MyObject__test_block_dispose_0};static void _I_MyObject_test(MyObject * self, SEL _cmd) { __attribute__((objc_ownership(weak))) typeof(self) weakSelf = self; ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setTextBlock:&quot;), ((void (*)())&amp;__MyObject__test_block_impl_0((void *)__MyObject__test_block_func_0, &amp;__MyObject__test_block_desc_0_DATA, weakSelf, 570425344))); ((void (*(*)(id, SEL))())(void *)objc_msgSend)((id)self, sel_registerName(&quot;textBlock&quot;))();} __MyObject__test_block_impl_0 block 仍然是将 __weak 修饰的 self 捕获为成员变量 当 self 执行dealloc时，block 内的 self 会被置为nil，从而打破循环引用 block 内的代码在__MyObject__test_block_func_0函数内，当使用strongSelf时，会先取出__weak修饰的成员变量self：MyObject *const __weak weakSelf = __cself-&gt;weakSelf;, 然后再生成一个__strong修饰的局部变量__attribute__((objc_ownership(strong))) typeof(weakSelf) strongSelf = weakSelf;，self 的引用计数 +1。这样的目的是在 block 内的代码块执行完之前避免 self 被dealloc掉。当 block 执行完毕之后，局部变量 strongSelf 被释放，self 的引用计数 -1。 @weakify 和 @strongify这两个是RAC中避免Block循环引用而开发的2个宏，实现过程很牛，值得我们学习。限于篇幅，我就不分析了，想了解可以点开这篇博客。这两个宏展开下来就相当于： 1234@weakify(self) = @autoreleasepool{} __weak __typeof__ (self) self_weak_ = self;@strongify(self) = @autoreleasepool{} __strong __typeof__(self) self = self_weak_; 回到开头好了，不知道你看了这么多头晕了没有。。。下面让我们回到开头我碰到的那个问题，为什么我使用了 @weakify 和 @strongify，然后直接使用下划线的成员变量还是会造成循环引用。原因就是_ivar直接使用成员变量，self 跟 weakSelf会同时被 block 捕获成 block 的成员变量，注意：self 还是会被 block 捕获的(前面好像没写例子，不过你可以自己写写看)，导致 block 还是强引用着 self，导致循环引用。解决办法就是 strongSelf -&gt; ivar这样使用成员变量 总结 block 会捕捉 block 内部的变量 当变量类型是局部变量(基本数据类型时或 oc 类)，仅捕获该变量的值，所以 block 内部和外部这两个变量的地址是不一样的，在block 内部修改变量的值也不会影响 block 外部的变量 当变量是 self 时的情况跟 局部变量时是差不多的 当变量类型是__block修饰的布局变量(基本数据类型或者 oc 类)，会新构建一个结构体，其中成员变量__forwarding会指向栈中该变量的地址，因此在 block 内部修改该变量会影响 block 外部的变量 当变量是全局变量或者全局静态变量时，block 不会捕获该变量，因为变量已经存在在数据区，可以直接调用。此时 block 也保存在数据区 当变量是静态变量时，block 会捕获该变量的地址，因此在 block 内部修改该变量会影响 block 外部的变量 block 结构体中的成员变量 descriptor 包含着 copy 和 dispose 两个函数指针。copy 函数把 block 从栈上拷贝到堆上，dispose函数是把堆上的函数在废弃的时候销毁掉。 苹果使用一个全局的 weak 表来保存所有的 weak 引用。并将对象作为键，weak_entry_t 作为值。weak_entry_t 中保存了所有指向该对象的 weak 指针。当被指向的对象执行 dealloc 时候，将所有指向该对象的 weak 指针的设置为nil。 在 block 外部使用 __weak 的原因是，让 block 将这个 __weak修饰的变量捕获成自己的成员变量，这样当外面的变量被 dealloc 后，block 内的该成员变量也将置为 nil，避免循环引用 在 block 里面使用的 __strong 修饰的 weakSelf 是为了在函数生命周期中防止 self 提前释放。strongSelf是一个局部变量，当block内的代码执行完毕就会释放，不会对 self 进行一直进行强引用。 引用ARC对self的内存管理深入研究 Block 捕获外部变量和 __block 实现原理深入研究 Block 用 weakSelf、strongSelf、@weakify、@strongify 解决循环引用 谈Objective-C block的实现","link":"/2019/06/20/%E8%B0%88block%E3%80%81-weak%E5%92%8C-strong/"}],"tags":[{"name":"NSError","slug":"NSError","link":"/tags/NSError/"},{"name":"runtime","slug":"runtime","link":"/tags/runtime/"},{"name":"引用计数","slug":"引用计数","link":"/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"},{"name":"内存分布","slug":"内存分布","link":"/tags/%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"},{"name":"YTKNetwork","slug":"YTKNetwork","link":"/tags/YTKNetwork/"},{"name":"源码","slug":"源码","link":"/tags/%E6%BA%90%E7%A0%81/"},{"name":"YYModel","slug":"YYModel","link":"/tags/YYModel/"},{"name":"EventKit","slug":"EventKit","link":"/tags/EventKit/"},{"name":"weak","slug":"weak","link":"/tags/weak/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"mach-o","slug":"mach-o","link":"/tags/mach-o/"},{"name":"dyld","slug":"dyld","link":"/tags/dyld/"},{"name":"审核","slug":"审核","link":"/tags/%E5%AE%A1%E6%A0%B8/"},{"name":"锁","slug":"锁","link":"/tags/%E9%94%81/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"GCD","slug":"GCD","link":"/tags/GCD/"},{"name":"Runloop","slug":"Runloop","link":"/tags/Runloop/"},{"name":"杂","slug":"杂","link":"/tags/%E6%9D%82/"},{"name":"block","slug":"block","link":"/tags/block/"},{"name":"Tagged Pointer","slug":"Tagged-Pointer","link":"/tags/Tagged-Pointer/"},{"name":"关联对象","slug":"关联对象","link":"/tags/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/"}],"categories":[{"name":"bug","slug":"bug","link":"/categories/bug/"},{"name":"iOS杂","slug":"iOS杂","link":"/categories/iOS%E6%9D%82/"},{"name":"搭建","slug":"搭建","link":"/categories/%E6%90%AD%E5%BB%BA/"},{"name":"cocoapods","slug":"cocoapods","link":"/categories/cocoapods/"}],"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}]}