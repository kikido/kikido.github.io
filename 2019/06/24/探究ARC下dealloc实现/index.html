<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>探究ARC下dealloc实现 - 千行的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="千行的博客"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="千行的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="我是前言目前正在看 oc 底层的东西，看了许多大牛的博客，发现有一些小问题：  runtime 的版本可能跟作者当时写的版本不一致 许多方法一笔带过，因为基础知识的薄弱看不懂。。。 没有标明苹果文档的出处  所以我打算解决上面的一些问题，然后重新发一版，当然大部分的内容还是原作者写的 。runtime 的源码为 objc4-646.tar.gz版本 进入正题在 ARC 环境下，我们不需要主动的调用"><meta property="og:type" content="blog"><meta property="og:title" content="探究ARC下dealloc实现"><meta property="og:url" content="http://example.com/2019/06/24/%E6%8E%A2%E7%A9%B6ARC%E4%B8%8Bdealloc%E5%AE%9E%E7%8E%B0/"><meta property="og:site_name" content="千行的博客"><meta property="og:description" content="我是前言目前正在看 oc 底层的东西，看了许多大牛的博客，发现有一些小问题：  runtime 的版本可能跟作者当时写的版本不一致 许多方法一笔带过，因为基础知识的薄弱看不懂。。。 没有标明苹果文档的出处  所以我打算解决上面的一些问题，然后重新发一版，当然大部分的内容还是原作者写的 。runtime 的源码为 objc4-646.tar.gz版本 进入正题在 ARC 环境下，我们不需要主动的调用"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://i.loli.net/2019/06/24/5d1038e8c739981387.jpg"><meta property="article:published_time" content="2019-06-24T03:11:35.000Z"><meta property="article:modified_time" content="2022-10-21T02:13:53.000Z"><meta property="article:author" content="千行"><meta property="article:tag" content="runtime"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://i.loli.net/2019/06/24/5d1038e8c739981387.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2019/06/24/%E6%8E%A2%E7%A9%B6ARC%E4%B8%8Bdealloc%E5%AE%9E%E7%8E%B0/"},"headline":"探究ARC下dealloc实现","image":["https://i.loli.net/2019/06/24/5d1038e8c739981387.jpg"],"datePublished":"2019-06-24T03:11:35.000Z","dateModified":"2022-10-21T02:13:53.000Z","author":{"@type":"Person","name":"千行"},"publisher":{"@type":"Organization","name":"千行的博客","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":"我是前言目前正在看 oc 底层的东西，看了许多大牛的博客，发现有一些小问题：  runtime 的版本可能跟作者当时写的版本不一致 许多方法一笔带过，因为基础知识的薄弱看不懂。。。 没有标明苹果文档的出处  所以我打算解决上面的一些问题，然后重新发一版，当然大部分的内容还是原作者写的 。runtime 的源码为 objc4-646.tar.gz版本 进入正题在 ARC 环境下，我们不需要主动的调用"}</script><link rel="canonical" href="http://example.com/2019/06/24/%E6%8E%A2%E7%A9%B6ARC%E4%B8%8Bdealloc%E5%AE%9E%E7%8E%B0/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-0VD5EHM46E" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-0VD5EHM46E');</script><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="千行的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-06-24T03:11:35.000Z" title="6/24/2019, 11:11:35 AM">2019-06-24</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">19 分钟读完 (大约2884个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">探究ARC下dealloc实现</h1><div class="content"><h3 id="我是前言"><a href="#我是前言" class="headerlink" title="我是前言"></a>我是前言</h3><p>目前正在看 oc 底层的东西，看了许多大牛的博客，发现有一些小问题：</p>
<ul>
<li>runtime 的版本可能跟作者当时写的版本不一致</li>
<li>许多方法一笔带过，因为基础知识的薄弱看不懂。。。</li>
<li>没有标明苹果文档的出处</li>
</ul>
<p>所以我打算解决上面的一些问题，然后重新发一版，当然大部分的内容还是<a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/">原作者</a>写的 。<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">runtime</a> 的源码为 <code>objc4-646.tar.gz</code>版本</p>
<h3 id="进入正题"><a href="#进入正题" class="headerlink" title="进入正题"></a>进入正题</h3><p>在 ARC 环境下，我们不需要主动的调用系统的析构函数 dealloc 就能够完成将对象以及父类的成员变量内存释放掉的操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ... //</span></span><br><span class="line">    <span class="comment">// 非Objc对象内存的释放，如CFRelease(...)</span></span><br><span class="line">    <span class="comment">// ... //</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>问题来了：</p>
<ol>
<li>这个对象成员变量（ivars）的释放操作去哪儿了？</li>
<li>没有主动调用 [super dealloc]，那么是什么时候调用这个方法的？</li>
</ol>
<h3 id="ARC文档中对dealloc过程的解释"><a href="#ARC文档中对dealloc过程的解释" class="headerlink" title="ARC文档中对dealloc过程的解释"></a>ARC文档中对dealloc过程的解释</h3><p>clang <a href="%5Bhttp://clang.llvm.org/docs/AutomaticReferenceCounting.html#dealloc%5D(http://clang.llvm.org/docs/AutomaticReferenceCounting.html#dealloc">ARC文档</a></p>
<blockquote>
<p>A class may provide a method definition for an instance method named dealloc. This method will be called after the final release of the object but before it is deallocated or any of its instance variables are destroyed. The superclass’s implementation of dealloc will be called automatically when the method returns.</p>
</blockquote>
<p>大概意思是：dealloc 方法在最后一次 release 后被调用，但此时实例变量（ivars）并未释放，父类的dealloc的方法将在子类dealloc方法返回后自动调用</p>
<blockquote>
<p>The instance variables for an ARC-compiled class will be destroyed at some point after control enters the dealloc method for the root class of the class. The ordering of the destruction of instance variables is unspecified, both within a single class and between subclasses and superclasses.</p>
</blockquote>
<p>ARC下对象的实例变量在根类 [NSObject dealloc] 中释放（通常root class都是NSObject），变量释放顺序各种不确定（一个类内的不确定，子类和父类间也不确定，也就是说不用care释放顺序）</p>
<hr>
<p>所以，我们不需要主动调用 [super dealloc] ，系统会自动调用，后面我们再讲这是怎么实现的。接下来我们来探究在根类 NSObject 析构时发生了什么</p>
<h3 id="NSObject的析构过程"><a href="#NSObject的析构过程" class="headerlink" title="NSObject的析构过程"></a>NSObject的析构过程</h3><p>通过 runtime 源码，我们可以发现 NSObject 调用 dealloc 时会调用 <code>_objc_rootDealloc</code>(NSObject.mm 2071行) 继而调用<code>object_dispose</code>(objc-object.h 301行) 随后调用<code>objc_destructInstance</code>(objc-runtime-new.mm 6838行), 下面讲一下<code>rootDealloc </code>和<code>objc_destructInstance</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">objc_object::rootDealloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!UseGC);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isa.indexed  &amp;&amp;  </span><br><span class="line">        !isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">        !isa.has_assoc  &amp;&amp;  </span><br><span class="line">        !isa.has_cxx_dtor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(!<span class="built_in">sidetable_present</span>());</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">object_dispose</span>((id)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>64位下，isa 指针的结构:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">struct &#123;</span><br><span class="line">        uintptr_t indexed           : 1;</span><br><span class="line">        uintptr_t has_assoc         : 1;</span><br><span class="line">        uintptr_t has_cxx_dtor      : 1;</span><br><span class="line">        uintptr_t shiftcls          : 30; // MACH_VM_MAX_ADDRESS 0x1a0000000</span><br><span class="line">        uintptr_t magic             : 9;</span><br><span class="line">        uintptr_t weakly_referenced : 1;</span><br><span class="line">        uintptr_t deallocating      : 1;</span><br><span class="line">        uintptr_t has_sidetable_rc  : 1;</span><br><span class="line">        uintptr_t extra_rc          : 19;</span><br><span class="line">#       define RC_ONE   (1ULL&lt;&lt;45)</span><br><span class="line">#       define RC_HALF  (1ULL&lt;&lt;18)</span><br><span class="line">    &#125;;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>

<ul>
<li>indexed(1 bit)	0 表示普通的 isa 指针，1 表示使用优化，即Tagged Pointer存储引用计数</li>
<li>has_assoc(1 bit) 表示该对象是否包含 associated object，如果没有，则析构(释放内存)时会更快</li>
<li>has_cxx_dtor(1 bit)	表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构（释放内存）时更快</li>
<li>shiftcls(30 bits) 类的指针</li>
<li>magic(9 bits) 固定值为 0xd2，用于在调试时分辨对象是否未完成初始化。</li>
<li>weakly_referenced(1 bit)	表示该对象是否有过 weak 对象，如果没有，则析构（释放内存）时更快</li>
<li>deallocating(1 bit) 表示该对象是否正在析构</li>
<li>has_sidetable_rc(1 bit)	表示该对象的引用计数值是否过大无法存储在 isa 指针</li>
<li>extra_jc(19 bits) 表示引用计数值减一后的结果。例如，如果对象引用计数为4，则extra_jc为3</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">objc_destructInstance</span><span class="params">(id obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="type">bool</span> cxx = obj-&gt;<span class="built_in">hasCxxDtor</span>();</span><br><span class="line">        <span class="type">bool</span> assoc = !UseGC &amp;&amp; obj-&gt;<span class="built_in">hasAssociatedObjects</span>();</span><br><span class="line">        <span class="type">bool</span> dealloc = !UseGC;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) <span class="built_in">object_cxxDestruct</span>(obj);</span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);</span><br><span class="line">        <span class="keyword">if</span> (dealloc) obj-&gt;<span class="built_in">clearDeallocating</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>objc_destructInstance</code>干了三件事情：</p>
<ol>
<li>执行了一个 <code>object_cxxDestruct</code> 函数</li>
<li>执行<code>_object_remove_assocations</code>函数去除和这个对象 assocate 的对象（常用于类目中添加的属性 ）</li>
<li>执行<code>clearDeallocating</code>， 清空引用计数并清除弱引用表，将所有使用__weak修饰的指向该对象的变量置为nil</li>
</ol>
<p>所以，ARC 自动释放实例变量的地方就在 <code>object_cxxDestruct</code> 这个方法里面没跑了。</p>
<h3 id="探究-object-cxxDestruct"><a href="#探究-object-cxxDestruct" class="headerlink" title="探究 object_cxxDestruct"></a>探究 object_cxxDestruct</h3><p>上面找到的名为<code>object_cxxDestruct</code>的方法最终成为下面的调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">object_cxxDestructFromClass</span><span class="params">(id obj, Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*dtor)(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call cls&#x27;s dtor first, then superclasses&#x27;s dtors.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; cls != <span class="literal">NULL</span>; cls = _class_getSuperclass(cls)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_class_hasCxxStructors(cls)) <span class="keyword">return</span>;</span><br><span class="line">        dtor = (<span class="built_in">void</span>(*)(id))</span><br><span class="line">            <span class="built_in">lookupMethodInClassAndLoadCache</span>(cls, SEL_cxx_destruct);</span><br><span class="line">        <span class="keyword">if</span> (dtor != (<span class="built_in">void</span>(*)(id))_objc_msgForward_internal) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PrintCxxCtors) &#123;</span><br><span class="line">                _objc_inform(<span class="string">&quot;CXX: calling C++ destructors for class %s&quot;</span>,</span><br><span class="line">                             _class_getName(cls));</span><br><span class="line">            &#125;</span><br><span class="line">            (*dtor)(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码的大致意思是通过继承链(isa)向上递归调用 <code>SEL_cxx_destruct</code>这个函数的函数实现<br>从<a target="_blank" rel="noopener" href="https://my.safaribooksonline.com/book/programming/objective-c/9780132908641/3dot-memory-management/ch03">这篇文章</a>提到：</p>
<blockquote>
<p>ARC actually creates a -.cxx_destruct method to handle freeing instance variables. This method was originally created for calling C++ destructors automatically when an object was destroyed.</p>
</blockquote>
<p>和《Effective Objective-C 2.0》中的：</p>
<blockquote>
<p>When the compiler saw that an object contained C++ objects, it would generate a method called .cxx_destruct. ARC piggybacks on this method and emits the required cleanup code within it.</p>
</blockquote>
<p>可以了解到<code>cxx_destruct</code>方法原本是为了 C++ 对象析构的，ARC 借用了这个方法插入代码实现了自动释放的工作。</p>
<h3 id="通过实验找出-cxx-destruct"><a href="#通过实验找出-cxx-destruct" class="headerlink" title="通过实验找出 .cxx_destruct"></a>通过实验找出 .cxx_destruct</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Father</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Son</span> : <span class="title">Father</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *toys;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>只有两个简单的属性，找个地方写简单的测试代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// before new</span></span><br><span class="line">    Son *son = [Son new];</span><br><span class="line">    son.name = <span class="string">@&quot;sark&quot;</span>;</span><br><span class="line">    son.toys = @[<span class="string">@&quot;sunny&quot;</span>, <span class="string">@&quot;xx&quot;</span>];</span><br><span class="line">    <span class="comment">// after new</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gone</span></span><br></pre></td></tr></table></figure>
<p>当过了大括号的作用域，son 对象就会被释放。所以在after new这行son对象初始化完成，在gone这行son对象被dealloc。</p>
<p>本次实验使用 <a target="_blank" rel="noopener" href="https://github.com/delebedev/DLIntrospection">NSObject+DLIntrospection</a> 这个扩展来作用调试工具，通过它可以轻松打出一个类的方法，成员变量等。<br>将这个扩展引入工程，在 after new 处设置一个断点，在这里打印出 Son 类所有的方法名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">po [[Son class] instanceMethods]</span><br><span class="line">&lt;__NSArrayI 0x280982520&gt;(</span><br><span class="line">- (void)setToys:(id)arg0 ,</span><br><span class="line">- (id)toys,</span><br><span class="line">- (void).cxx_destruct</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发现出现了<code>.cxx_destruct</code>这个方法，经过几次实验，发现：</p>
<ol>
<li>只有在ARC下这个方法才会出现（试验代码的情况下）</li>
<li>只有当前类拥有实例变量时（不论是不是用property）这个方法才会出现，且父类的实例变量不会导致子类拥有这个方法</li>
<li>出现这个方法和变量是否被赋值，赋值成什么没有关系</li>
</ol>
<h3 id="使用-watchpoint-定位内存释放时刻"><a href="#使用-watchpoint-定位内存释放时刻" class="headerlink" title="使用 watchpoint 定位内存释放时刻"></a>使用 watchpoint 定位内存释放时刻</h3><p>依然在 after new 断点处，输入 lldb 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">watchpoint set variable son-&gt;_name</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将<code>name</code>的变量加入watchpoint，当这个变量被修改时会触发trigger：<br>从中可以看出，在这个时刻，_name 从 0x0000000104ac5048 变成了0x0000000000000000，也就是nil，赶紧看下调用栈：<br>发现果然跟到了<code>.cxx_destruct</code>方法，而且是在<code>objc_storeStrong</code>方法中释放</p>
<p><img src="https://i.loli.net/2019/06/24/5d1038e8c739981387.jpg"></p>
<h3 id="刨根问底-cxx-destruct"><a href="#刨根问底-cxx-destruct" class="headerlink" title="刨根问底.cxx_destruct"></a>刨根问底.cxx_destruct</h3><p>知道了ARC环境下，对象实例变量的释放过程在 .cxx_destruct 内完成，但这个函数内部发生了什么，是如何调用 objc_storeStrong 释放变量的呢？<br>从上面的探究中知道，.cxx_destruct 是编译器生成的代码，那它很可能在clang前端编译时完成，这让我联想到clang的Code Generation，因为之前曾经使用clang -rewrite-objc xxx.m时查看过官方文档留下了些印象，于是google：<br><code>.cxx_destruct site:clang.llvm.org</code></p>
<p>结果发现clang的 doxygen 文档中 CodeGenModule 模块正是这部分的实现代码，cxx相关的代码生成部分源码在<br><a target="_blank" rel="noopener" href="http://clang.llvm.org/doxygen/CodeGenModule_8cpp-source.html">http://clang.llvm.org/doxygen/CodeGenModule_8cpp-source.html</a><br>位于1827行，删减掉离题部分如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// EmitObjCIvarInitializations - Emit information for ivar initialization</span></span><br><span class="line"><span class="comment">/// for an implementation.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CodeGenModule::EmitObjCIvarInitializations</span><span class="params">(ObjCImplementationDecl *D)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DeclContext* DC = <span class="built_in">const_cast</span>&lt;DeclContext*&gt;(<span class="built_in">dyn_cast</span>&lt;DeclContext&gt;(D));</span><br><span class="line">    <span class="built_in">assert</span>(DC &amp;&amp; <span class="string">&quot;EmitObjCIvarInitializations - null DeclContext&quot;</span>);</span><br><span class="line">    IdentifierInfo *II = &amp;<span class="built_in">getContext</span>().Idents.<span class="built_in">get</span>(<span class="string">&quot;.cxx_destruct&quot;</span>);</span><br><span class="line">    Selector cxxSelector = <span class="built_in">getContext</span>().Selectors.<span class="built_in">getSelector</span>(<span class="number">0</span>, &amp;II);</span><br><span class="line">    ObjCMethodDecl *DTORMethod = ObjCMethodDecl::<span class="built_in">Create</span>(<span class="built_in">getContext</span>(),</span><br><span class="line">                                                        D-&gt;<span class="built_in">getLocation</span>(),</span><br><span class="line">                                                        D-&gt;<span class="built_in">getLocation</span>(), cxxSelector,</span><br><span class="line">                                                        <span class="built_in">getContext</span>().VoidTy, <span class="number">0</span>,</span><br><span class="line">                                                        DC, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>,</span><br><span class="line">                                                        ObjCMethodDecl::Required);</span><br><span class="line">   D-&gt;<span class="built_in">addInstanceMethod</span>(DTORMethod);</span><br><span class="line">   <span class="built_in">CodeGenFunction</span>(*<span class="keyword">this</span>).<span class="built_in">GenerateObjCCtorDtorMethod</span>(D, DTORMethod, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数大概作用是：获取到 .cxx_destruct 的selector，创建 Method，然后加入到这个类的方法列表中，最后一行的调用才是真的创建这个方法的实现。这个方法位于<a target="_blank" rel="noopener" href="http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html">http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html</a> 1354行，包含了构造和析构的 cxx 方法，继续跟随 .cxx_destruct，最终调用 <code>emitCXXDestructMethod</code> 函数，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">emitCXXDestructMethod</span><span class="params">(CodeGenFunction &amp;CGF, ObjCImplementationDecl *impl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">CodeGenFunction::RunCleanupsScope <span class="title">scope</span><span class="params">(CGF)</span></span>;</span><br><span class="line"></span><br><span class="line">   llvm::Value *self = CGF.<span class="built_in">LoadObjCSelf</span>();</span><br><span class="line"></span><br><span class="line">   <span class="type">const</span> ObjCInterfaceDecl *iface = impl-&gt;<span class="built_in">getClassInterface</span>();</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">const</span> ObjCIvarDecl *ivar = iface-&gt;<span class="built_in">all_declared_ivar_begin</span>(); ivar; ivar = ivar-&gt;<span class="built_in">getNextIvar</span>())</span><br><span class="line">   &#123;</span><br><span class="line">     QualType type = ivar-&gt;<span class="built_in">getType</span>();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Check whether the ivar is a destructible type.</span></span><br><span class="line">     QualType::DestructionKind dtorKind = type.<span class="built_in">isDestructedType</span>();</span><br><span class="line">     <span class="keyword">if</span> (!dtorKind) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">     CodeGenFunction::Destroyer *destroyer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Use a call to objc_storeStrong to destroy strong ivars, for the</span></span><br><span class="line">     <span class="comment">// general benefit of the tools.</span></span><br><span class="line">     <span class="keyword">if</span> (dtorKind == QualType::DK_objc_strong_lifetime) &#123;</span><br><span class="line">       destroyer = destroyARCStrongWithStore;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Otherwise use the default for the destruction kind.</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       destroyer = CGF.<span class="built_in">getDestroyer</span>(dtorKind);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     CleanupKind cleanupKind = CGF.<span class="built_in">getCleanupKind</span>(dtorKind);</span><br><span class="line">     CGF.EHStack.<span class="built_in">pushCleanup</span>&lt;DestroyIvar&gt;(cleanupKind, self, ivar, destroyer,</span><br><span class="line">                                          cleanupKind &amp; EHCleanup);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">assert</span>(scope.<span class="built_in">requiresCleanups</span>() &amp;&amp; <span class="string">&quot;nothing to do in .cxx_destruct?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析这段代码以及其中调用后发现：它遍历当前对象所有的实例变量（Ivars)，调用<code>objc_storeStrong</code>，从clang的<a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#void-objc-storestrong-id-object-id-value">ARC文档</a>上可以找到 objc_storeStrong 的示意代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">objc_storeStrong</span><span class="params">(id *object, id value)</span> </span>&#123;</span><br><span class="line">  id oldValue = *object;</span><br><span class="line">  value = [value retain];</span><br><span class="line">  *object = value;</span><br><span class="line">  [oldValue release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 .cxx_destruct 进行形如 objc_storeStrong(&amp;ivar, null) 的调用后，这个实例变量就被release和设置成nil了</p>
<h3 id="自动调用-super-dealloc-的实现"><a href="#自动调用-super-dealloc-的实现" class="headerlink" title="自动调用[super dealloc]的实现"></a>自动调用[super dealloc]的实现</h3><p>按照上面的思路，自动调用 <code>[super dealloc]</code> 也一定是 <code>CodeGen</code> 的工作了，位于<a target="_blank" rel="noopener" href="http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html">http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html</a> 492行 <code>StartObjCMethod</code> 方法中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (ident-&gt;isStr(&quot;dealloc&quot;))</span><br><span class="line">   EHStack.pushCleanup&lt;FinishARCDealloc&gt;(getARCCleanupKind());</span><br></pre></td></tr></table></figure>

<p>上面代码可以得知在调用<code>dealloc</code>方法时被插入了代码，由<code>FinishARCDealloc</code>结构定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FinishARCDealloc</span> : EHScopeStack::Cleanup &#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Emit</span><span class="params">(CodeGenFunction &amp;CGF, Flags flags)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">     <span class="type">const</span> ObjCMethodDecl *method = <span class="built_in">cast</span>&lt;ObjCMethodDecl&gt;(CGF.CurCodeDecl);</span><br><span class="line"></span><br><span class="line">     <span class="type">const</span> ObjCImplDecl *impl = <span class="built_in">cast</span>&lt;ObjCImplDecl&gt;(method-&gt;<span class="built_in">getDeclContext</span>());</span><br><span class="line">     <span class="type">const</span> ObjCInterfaceDecl *iface = impl-&gt;<span class="built_in">getClassInterface</span>();</span><br><span class="line">     <span class="keyword">if</span> (!iface-&gt;<span class="built_in">getSuperClass</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">     <span class="type">bool</span> isCategory = <span class="built_in">isa</span>&lt;ObjCCategoryImplDecl&gt;(impl);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Call [super dealloc] if we have a superclass.</span></span><br><span class="line">     llvm::Value *self = CGF.<span class="built_in">LoadObjCSelf</span>();</span><br><span class="line"></span><br><span class="line">     CallArgList args;</span><br><span class="line">     CGF.CGM.<span class="built_in">getObjCRuntime</span>().<span class="built_in">GenerateMessageSendSuper</span>(CGF, <span class="built_in">ReturnValueSlot</span>(),</span><br><span class="line">                                                       CGF.<span class="built_in">getContext</span>().VoidTy,</span><br><span class="line">                                                       method-&gt;<span class="built_in">getSelector</span>(),</span><br><span class="line">                                                       iface,</span><br><span class="line">                                                       isCategory,</span><br><span class="line">                                                       self,</span><br><span class="line">                                                       <span class="comment">/*is class msg*/</span> <span class="literal">false</span>,</span><br><span class="line">                                                       args,</span><br><span class="line">                                                       method);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码基本上就是向父类转发dealloc的调用，实现了自动调用[super dealloc]方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>ARC下对象的成员变量在编译器插入的<code>.cxx_desctruct</code>方法自动释放</li>
<li>ARC下[super dealloc]方法也由编译器自动插入</li>
<li>所谓编译器插入代码过程需要进一步了解，还不清楚其运作方式</li>
</ul>
<hr>
<ul>
<li>ARC环境，对象的实例变量将在根类 NSObject 的 dealloc 方法中释放内存</li>
<li>Father 的实例变量(如果有)将在它的 <code>.cxx_desctruct</code>方法中被释放，而 Son 的实例变量(如果有)将在它的 <code>.cxx_desctruct</code>方法中被释放</li>
<li>子类在调用 dealloc 方法时会被插入代码，自动调用父类的 dealloc 方法</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/">ARC下dealloc过程及.cxx_destruct的探究</a><br><a target="_blank" rel="noopener" href="https://luoanhao.github.io/2016/03/29/Memory-Manage-2-MRC/">iOS内存管理之二</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>探究ARC下dealloc实现</p><p><a href="http://example.com/2019/06/24/探究ARC下dealloc实现/">http://example.com/2019/06/24/探究ARC下dealloc实现/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>千行</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2019-06-24</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-10-21</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/runtime/">runtime</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/06/27/%E8%B0%88Objective-C%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">谈Objective-C类成员变量</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/06/20/iOS%E6%A3%80%E6%B5%8B%E7%A7%81%E6%9C%89Api%E7%9A%84%E6%96%B9%E6%B3%95/"><span class="level-item">iOS检测私有Api的方法</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'http://example.com/2019/06/24/%E6%8E%A2%E7%A9%B6ARC%E4%B8%8Bdealloc%E5%AE%9E%E7%8E%B0/';
            this.page.identifier = '2019/06/24/探究ARC下dealloc实现/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'qianxingdeblog' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="千行"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">千行</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>杭州, 浙江</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">33</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/bug/"><span class="level-start"><span class="level-item">bug</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/cocoapods/"><span class="level-start"><span class="level-item">cocoapods</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS%E6%9D%82/"><span class="level-start"><span class="level-item">iOS杂</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%90%AD%E5%BB%BA/"><span class="level-start"><span class="level-item">搭建</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/EventKit/"><span class="tag">EventKit</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GCD/"><span class="tag">GCD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NSError/"><span class="tag">NSError</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Runloop/"><span class="tag">Runloop</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tagged-Pointer/"><span class="tag">Tagged Pointer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/YTKNetwork/"><span class="tag">YTKNetwork</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/YYModel/"><span class="tag">YYModel</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/block/"><span class="tag">block</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dyld/"><span class="tag">dyld</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mach-o/"><span class="tag">mach-o</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/runtime/"><span class="tag">runtime</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/weak/"><span class="tag">weak</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/"><span class="tag">关联对象</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"><span class="tag">内存分布</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%A1%E6%A0%B8/"><span class="tag">审核</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%A5%E5%85%B7/"><span class="tag">工具</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"><span class="tag">引用计数</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82/"><span class="tag">杂</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%BA%90%E7%A0%81/"><span class="tag">源码</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%94%81/"><span class="tag">锁</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="千行的博客" height="28"></a><p class="is-size-7"><span>&copy; 2022 千行</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>