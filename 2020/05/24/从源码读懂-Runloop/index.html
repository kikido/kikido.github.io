<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title> 从源码读懂 Runloop - 千行的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="千行的博客"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="千行的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="runloop 是和线程密切相关的一个组件，它帮助线程管理需要被处理的事件和消息，例如网络连接，异步回调，定时器…当有事件或消息要处理时唤醒线程处理，否则休眠等待接收 mach 消息。"><meta property="og:type" content="blog"><meta property="og:title" content=" 从源码读懂 Runloop"><meta property="og:url" content="http://example.com/2020/05/24/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%AF%BB%E6%87%82-Runloop/"><meta property="og:site_name" content="千行的博客"><meta property="og:description" content="runloop 是和线程密切相关的一个组件，它帮助线程管理需要被处理的事件和消息，例如网络连接，异步回调，定时器…当有事件或消息要处理时唤醒线程处理，否则休眠等待接收 mach 消息。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://i.loli.net/2020/05/21/NHLBOZ81j3fo6GD.jpg"><meta property="og:image" content="https://i.loli.net/2020/05/21/oLNKZCetPv2673b.jpg"><meta property="og:image" content="https://i.loli.net/2020/05/22/AIzo8xbkBrstN2E.jpg"><meta property="og:image" content="https://i.loli.net/2020/05/22/cxaKvQdfqphuM8i.jpg"><meta property="og:image" content="https://i.loli.net/2020/05/22/6EvfGwQZqy5NdTV.jpg"><meta property="og:image" content="https://i.loli.net/2020/05/22/2NOQEUPsklqwBVC.jpg"><meta property="og:image" content="https://i.loli.net/2020/05/22/vYko7gMJ5yx1PNz.jpg"><meta property="og:image" content="https://i.loli.net/2020/05/22/Akf7dxPI6EhJFj4.jpg"><meta property="og:image" content="https://i.loli.net/2020/05/22/oAy1mMQ5LZSU3Bf.jpg"><meta property="og:image" content="https://i.loli.net/2020/05/22/p5HWx7bzT6nc2r9.jpg"><meta property="og:image" content="https://i.loli.net/2020/05/22/dZFCS76NqtjUTs3.jpg"><meta property="og:image" content="https://i.loli.net/2020/05/22/GSLi4KC3F5XlPkI.jpg"><meta property="og:image" content="https://i.loli.net/2020/05/24/JTmUnZGoVMOrajB.jpg"><meta property="article:published_time" content="2020-05-24T09:34:59.000Z"><meta property="article:modified_time" content="2022-10-21T02:13:53.000Z"><meta property="article:author" content="千行"><meta property="article:tag" content="Runloop"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://i.loli.net/2020/05/21/NHLBOZ81j3fo6GD.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2020/05/24/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%AF%BB%E6%87%82-Runloop/"},"headline":" 从源码读懂 Runloop","image":["https://i.loli.net/2020/05/21/NHLBOZ81j3fo6GD.jpg","https://i.loli.net/2020/05/21/oLNKZCetPv2673b.jpg","https://i.loli.net/2020/05/22/AIzo8xbkBrstN2E.jpg","https://i.loli.net/2020/05/22/cxaKvQdfqphuM8i.jpg","https://i.loli.net/2020/05/22/6EvfGwQZqy5NdTV.jpg","https://i.loli.net/2020/05/22/2NOQEUPsklqwBVC.jpg","https://i.loli.net/2020/05/22/vYko7gMJ5yx1PNz.jpg","https://i.loli.net/2020/05/22/Akf7dxPI6EhJFj4.jpg","https://i.loli.net/2020/05/22/oAy1mMQ5LZSU3Bf.jpg","https://i.loli.net/2020/05/22/p5HWx7bzT6nc2r9.jpg","https://i.loli.net/2020/05/22/dZFCS76NqtjUTs3.jpg","https://i.loli.net/2020/05/22/GSLi4KC3F5XlPkI.jpg","https://i.loli.net/2020/05/24/JTmUnZGoVMOrajB.jpg"],"datePublished":"2020-05-24T09:34:59.000Z","dateModified":"2022-10-21T02:13:53.000Z","author":{"@type":"Person","name":"千行"},"publisher":{"@type":"Organization","name":"千行的博客","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":"runloop 是和线程密切相关的一个组件，它帮助线程管理需要被处理的事件和消息，例如网络连接，异步回调，定时器…当有事件或消息要处理时唤醒线程处理，否则休眠等待接收 mach 消息。"}</script><link rel="canonical" href="http://example.com/2020/05/24/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%AF%BB%E6%87%82-Runloop/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-0VD5EHM46E" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-0VD5EHM46E');</script><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="千行的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-05-24T09:34:59.000Z" title="5/24/2020, 5:34:59 PM">2020-05-24</time>发表</span><span class="level-item"><time dateTime="2022-10-21T02:13:53.000Z" title="10/21/2022, 10:13:53 AM">2022-10-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%E6%9D%82/">iOS杂</a></span><span class="level-item">1 小时读完 (大约9973个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"> 从源码读懂 Runloop</h1><div class="content"><p>runloop 是和线程密切相关的一个组件，它帮助线程管理需要被处理的事件和消息，例如网络连接，异步回调，定时器…<br>当有事件或消息要处理时唤醒线程处理，否则休眠等待接收 mach 消息。</p>
<span id="more"></span>
<p>runloop 提供了一个入口函数 CFRunLoopRun()。当线程执行这个函数，runloop 就会在默认 mode 下一直处于函数内部 <code>接收消息-&gt;等待-&gt;处理</code> 的循环中，就像它的名字一样 ‘run loop’，在一直跑圈。<br>正在情况下，当休眠时间超时或者当前 mode 中一个 mode item(observer&#x2F;timer&#x2F;source) 都没有，则 runloop 会直接退出，不再进入循环。<br>main runloop 的超时时间被设定为 DISPATCH_TIME_FOREVER，且系统会在应用启动时向默认 mode 注册许多的 mode item，这意味着 main runloop 将永远的执行下去，这保证了当前应用能够随时的响应用户时间，但却不一直占用 CPU 资源</p>
<p>runloop 的核心是 mach_msg() 函数。<br>使用这个函数，你可以向指定的 mach port 发送消息或者接受到 other 向某个 mach port 发送的消息，区别在于函数的参数 option 是什么值。在等待过程中，runloop 处于休眠状态且不占用 cpu 资源。</p>
<blockquote>
<p>以下内容摘抄自 <a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a><br>为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图：</p>
</blockquote>
<p>本文所用的源码为 Swift 版本的 CoreFoundation 源码 <a target="_blank" rel="noopener" href="https://github.com/apple/swift-corelibs-foundation/">https://github.com/apple/swift-corelibs-foundation/</a></p>
<h3 id="runloop-与线程的关系"><a href="#runloop-与线程的关系" class="headerlink" title="runloop 与线程的关系"></a>runloop 与线程的关系</h3><p>每个线程都有一个对应的 runloop。苹果不允许我们直接创建 runloop ，但他提供了两个函数来获取 runloop：CFRunLoopGetCurrent() 和 CFRunLoopGetMain()。<br>这两个函数的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef CFRunLoopGetMain(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    static CFRunLoopRef __main = NULL; // no retain needed</span><br><span class="line">    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed</span><br><span class="line">    return __main;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">    if (rl) return rl;</span><br><span class="line">    return _CFRunLoopGet0(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CHECK_FOR_FORK()</code> 这个宏应该是用来检查是否进程复制，相关内容我不大明白，这里略过。</p>
<p>可以看到这两个函数后面都调用了 <code>_CFRunLoopGet0()</code> 函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// should only be called by Foundation</span><br><span class="line">// t==0 is a synonym for &quot;main thread&quot; that always works</span><br><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(_CFThreadRef t) &#123;</span><br><span class="line">    /// kNilPthreadT == (pthread *)0x0</span><br><span class="line">    if (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">	t = pthread_main_thread_np();</span><br><span class="line">    &#125;</span><br><span class="line">    __CFLock(&amp;loopsLock);</span><br><span class="line">    if (!__CFRunLoops) &#123;</span><br><span class="line">    /// 创建缓存字典。随后创建主线程的 run loop，并且以 key(thread)/value(runloop) 的形式保存到缓存字典</span><br><span class="line">	CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">	CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">	/// 将 main runloop 保存到缓存字典中，其中 key 为主线程</span><br><span class="line">	CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line">	if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123;</span><br><span class="line">	    CFRelease(dict);</span><br><span class="line">	&#125;</span><br><span class="line">	CFRelease(mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CFRunLoopRef newLoop = NULL;</span><br><span class="line">    /// 在缓存中查找 runloop 是否已经创建</span><br><span class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    </span><br><span class="line">    if (!loop) &#123;</span><br><span class="line">    /// 如果 runloop 不存在则新建一个，并保存到缓存中</span><br><span class="line">	newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        </span><br><span class="line">        cf_trace(KDEBUG_EVENT_CFRL_LIFETIME|DBG_FUNC_START, newLoop, NULL, NULL, NULL);</span><br><span class="line">        CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">        loop = newLoop;</span><br><span class="line">    &#125;</span><br><span class="line">    __CFUnlock(&amp;loopsLock);</span><br><span class="line">    // don&#x27;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span><br><span class="line">    if (newLoop) &#123; CFRelease(newLoop); &#125;</span><br><span class="line">    </span><br><span class="line">    if (pthread_equal(t, pthread_self())) &#123;</span><br><span class="line">        /// TSD means thread specific data</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);</span><br><span class="line">        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">#if _POSIX_THREADS</span><br><span class="line">            /// PTHREAD_DESTRUCTOR_ITERATIONS 的定义为 4</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);</span><br><span class="line">#else</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, 0, &amp;__CFFinalizeRunLoop);</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_CFRunLoopGet0 函数大致做了下面几样事情</p>
<ul>
<li>进入到这个函数，首先会判断缓存字典 dict 是否存在，如果不存在则创建</li>
<li>随后在缓存中查找 main runloop 是否存在，若不存在则创建 main runloop，并以 key(thread)&#x2F;value(runloop) 的形式保存到缓存中，</li>
<li>接着在缓存中查找当前线程对应的 runloop 是否存在，若不存在则创建，并保存到缓存中</li>
</ul>
<p>在 _CFRunLoopGet0 函数结尾部分可以看到 <code>_CFSetTSD()</code> 和 <code>_CFGetTSD()</code> 这两个函数的出现</p>
<p>TSD 是 <code>thread specific data</code> 的缩写，你也可以叫它为 TLS(Thread-Local Storage)。它是线程私有的数据变量，其它线程无法访问，但同一个线程中的任意函数都可以访问到</p>
<p>下面是它在内存管理中的一个应用：<br>我们知道非 alloc&#x2F;new&#x2F;copy&#x2F;mutableCopy 方法创建的对象，需要先对其 autorelease，随后变量持有时再对其 retain。既然一加一减，那为什么不让变量持有对象呢？于是 ARC 为了优化，使用了objc_autoreleaseReturnValue() 和 objc_retainAutoreleasedReturnValue() 两个函数，在 autorelease 时在 TLS 中存入一个标记，在 retain 时从 TLS 取出这个标记，该标记即用来表示是否使用优化，如果使用，则跳过 autorelease 和 retain 两个步骤。</p>
<p>使用 TSD 时，</p>
<ul>
<li>我们需要先为其开辟一块内存空间，例如使用 calloc() 函数</li>
<li>使用 <code>pthread_key_create(pthread_key_t *key, void (*destructor)(void *))；</code> 函数，得到一个 pthread_key_t 类型的 key，destructor 函数的作用是线程结束时销毁该快内存。当 key 被创建出来后，任意线程都能访问它，但需要各自为它绑定不同的值</li>
<li>使用 <code>pthread_setspecific(__CFTSDIndexKey, arg)</code> 函数，将 key 与第一步中创建的内存空间绑定</li>
</ul>
<p>因为每个线程能够拥有的 TSD 数目是有限的，为了节约，所以你可以将 key 与一个数据结构(数组&#x2F;字典)绑定起来保存在 TSD 中。<br>在 runloop 中，key 对应的数据结构是 <code>__CFTSDTable</code> 在 TSD 。<code>__CFTSDTable</code> 有两个数组类型的成员变量：<code>data</code> 和 <code>destructors</code>。其中 data 用来保存数据，destructors 保存的函数在每次线程退出时调用。数组的容量是一个固定值：CF_TSD_MAX_SLOTS(70)<br>在 <code>_CFSetTSD()</code> 函数中，runloop 在数组下标为 __CFTSDKeyRunLoopCntr(3) 的位置插入数据 (PTHREAD_DESTRUCTOR_ITERATIONS&#x2F;<em>4</em>&#x2F;-1) 和函数 <code>__CFFinalizeRunLoop</code> 。当每次线程退出时，调用 <code>__CFFinalizeRunLoop</code> 函数，将下标 __CFTSDKeyRunLoopCntr 对应的值 -1，变为 0 时将 runloop 从缓存中清除</p>
<h3 id="runloop，mode-以及-mode-item"><a href="#runloop，mode-以及-mode-item" class="headerlink" title="runloop，mode 以及 mode item"></a>runloop，mode 以及 mode item</h3><p>一个 runloop 可以包含若干 mode，每个 mode 又包含若干 Source&#x2F;Timer&#x2F;Observer。<br>但是 runloop 每次只能指定一个 mode 运行，处理该 Mode 里面的 Source&#x2F;Timer&#x2F;Observer 事件，这个 mode 被称作 CurrentMode。如果需要切换 mode，可以强制当前 mode 退出(例如 CFRunLoopStop() 函数)，然后再指定别的 mode 进入。<br>苹果的这种设定，我的理解是为了优化效率：将不同的事件归类到不同的 mode 当中，线程只能处理某个 mode 的事件而不是所有的事件</p>
<p>函数 <code>CFRunLoopStop()</code> 可以使得 runloop 强制退出<br>CFRunLoopStop() 函数的作用是将当前 mode 标记为 stopped 状态，然后发送 mach 消息给当前 mode，runloop 被唤醒后识别出 mode 的 stopped 状态，随即退出循环。</p>
<p>CFRunLoop 的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">	 /// 类似于 isa</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    _CFRecursiveMutex _lock;	/* locked for accessing mode list */</span><br><span class="line">    /// other 可以向该 mach port 发送消息以唤醒 runloop</span><br><span class="line">    __CFPort _wakeUpPort;			// used for CFRunLoopWakeUp </span><br><span class="line">    /// 用来记录每次运行主函数时的一次信息，每次进入主函数时重置该属性</span><br><span class="line">    volatile _per_run_data *_perRunData;              // reset for runs of the run loop</span><br><span class="line">    /// runloop 对应的线程</span><br><span class="line">    _CFThreadRef _pthread;</span><br><span class="line">    /// 线程，windows 平台下用到的，</span><br><span class="line">    uint32_t _winthread;</span><br><span class="line">    /// common 类型的 mode 集合</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    /// 被添加到 kCFRunLoopCommonModes mode 中的 mode item 集合</span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    /// runloop 当前运行的 mode</span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    /// runloop 拥有的 mode 集合，Set</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">    /// 添加到 runloop 的 block，链表结构，这个是头</span><br><span class="line">    struct _block_item *_blocks_head;</span><br><span class="line">    /// 添加到 runloop 的 block，链表结构，这个是尾</span><br><span class="line">    struct _block_item *_blocks_tail;</span><br><span class="line">    /// runloop 运行时的时间戳，但源码内未见其实用 ？</span><br><span class="line">    CFAbsoluteTime _runTime;</span><br><span class="line">    /// runloop 累计的休眠时间</span><br><span class="line">    CFAbsoluteTime _sleepTime;</span><br><span class="line">    /// 对应的 NSRunLoop 对象</span><br><span class="line">    CFTypeRef _counterpart;</span><br><span class="line">    /// 貌似是用来标记是否在当前线程销毁别的线程的 runloop</span><br><span class="line">    _Atomic(uint8_t) _fromTSD;</span><br><span class="line">    /// 设置定时器时用到</span><br><span class="line">    CFLock_t _timerTSRLock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>CFRunLoop 的构建函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static CFRunLoopRef __CFRunLoopCreate(_CFThreadRef t) &#123;</span><br><span class="line">    CFRunLoopRef loop = NULL;</span><br><span class="line">    CFRunLoopModeRef rlm;</span><br><span class="line">    uint32_t size = sizeof(struct __CFRunLoop) - sizeof(CFRuntimeBase);</span><br><span class="line">    loop = (CFRunLoopRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, CFRunLoopGetTypeID(), size, NULL);</span><br><span class="line">    if (NULL == loop) &#123;</span><br><span class="line">	return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    (void)__CFRunLoopPushPerRunData(loop);</span><br><span class="line">    _CFRecursiveMutexCreate(&amp;loop-&gt;_lock);</span><br><span class="line">    loop-&gt;_wakeUpPort = __CFPortAllocate((uintptr_t)loop);</span><br><span class="line">    if (CFPORT_NULL == loop-&gt;_wakeUpPort) HALT;</span><br><span class="line">    __CFRunLoopSetIgnoreWakeUps(loop);</span><br><span class="line">    loop-&gt;_commonModes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    CFSetAddValue(loop-&gt;_commonModes, kCFRunLoopDefaultMode);</span><br><span class="line">    loop-&gt;_modes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    loop-&gt;_pthread = t;</span><br><span class="line">    loop-&gt;_timerTSRLock = CFLockInit;</span><br><span class="line">    rlm = __CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, true);</span><br><span class="line">    if (NULL != rlm) __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>注意到 runloop 使用 <code>loop-&gt;_wakeUpPort = __CFPortAllocate((uintptr_t)loop);</code> 代码为其生成了一个 wake up port。就像申请了一个 qq 号一样，你可以登录这个账号接收到别人发给你的消息，在这里，runloop 使用这个 mach port 来接受被 wake up 的消息<br>同时，runloop 还会创建一个 kCFRunLoopDefaultMode 默认类型的 mode</p>
<p>__CFRunLoopMode 结构如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    _CFRecursiveMutex _lock;	/* must have the run loop locked before locking this */</span><br><span class="line">    /// mode name，例如 kCFRunLoopDefaultMode</span><br><span class="line">    CFStringRef _name;</span><br><span class="line">    /// 标记 mode 是否停止</span><br><span class="line">    Boolean _stopped;</span><br><span class="line">    /// 为了内存对齐</span><br><span class="line">    char _padding[3];</span><br><span class="line">    /// sources0 集合，Set</span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line">    /// sources1 集合，Set</span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    /// observer 集合，Array</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    /// timer 集合，Array</span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">    /// 字典，映射关系 port -&gt; sources1</span><br><span class="line">    CFMutableDictionaryRef _portToV1SourceMap;</span><br><span class="line">    /// 可能接受到 mach 消息的 mach port 集合</span><br><span class="line">    __CFPortSet _portSet;</span><br><span class="line">    /// observer 注册的观察时间点</span><br><span class="line">    CFIndex _observerMask;</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">	 /// dispatch_source_t 类型的定时器</span><br><span class="line">    dispatch_source_t _timerSource;</span><br><span class="line">    /// dispatch_source_t 定时器运行的 dispatch_queue_t</span><br><span class="line">    dispatch_queue_t _queue;/// Run Loop Mode Queue</span><br><span class="line">    /// dispatch_source_t 定时器是否被触发</span><br><span class="line">    Boolean _timerFired; // set to true by the source when a timer has fired</span><br><span class="line">    /// 是否设置了 dispatch_source_t 定时器</span><br><span class="line">    Boolean _dispatchTimerArmed;</span><br><span class="line">#endif</span><br><span class="line">	/// mk_timer 定时器触发后发送消息的 mach port</span><br><span class="line">    __CFPort _timerPort;</span><br><span class="line">    /// 是否设置了 mk_timer 定时器</span><br><span class="line">    Boolean _mkTimerArmed;</span><br><span class="line">    /// 注册在 rlm 的 timer 中，最早的触发时间戳，单位为纳秒</span><br><span class="line">    uint64_t _timerSoftDeadline; /* TSR */</span><br><span class="line">    /// 注册在 rlm 的 timer 中，最早的触发时间戳 + 宽余量(tolerance)，单位为纳秒</span><br><span class="line">    uint64_t _timerHardDeadline; /* TSR */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>Source0&#x2F;Source1&#x2F;Timer&#x2F;Observer 被统称为 <code>mode item</code>，一个 mode item 可以被同时加入多个 mode，但重复加入同一个 mode 时是不会有效果的。Source0&#x2F;Source1 可以注册到多个 runloop 中，而 Timer&#x2F;Observer 只能注册在同一个 runloop<br>如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>
<p>有一个特殊的 mode，名字叫做 kCFRunLoopCommonModes，Foundation 中叫 NSRunLoopCommonModes。<br>说它特殊是因为 runloop 并不能在 mode 下运行，但是你却可以往它里面添加 mode item。mode item 添加后会放在 runloop-&gt;_commonModeItems 中，并同步到 ”common“ 类型的 mode 当中。我们熟知的 kCFRunLoopDefaultMode 和 UITrackingRunLoopMode 即是 ”common“ 类型。</p>
<p>我们可以看到 mode 的结构体中定义了两种类型的的定时器(NSTimer 我会称呼为 timer，底层的定时器称呼为 定时器，NSTimer 由 底层定时器实现，后面不在重复)：</p>
<ul>
<li>dispatch_source_t _timerSource</li>
<li>mk_timer</li>
</ul>
<p>实际上，NSTimer 由这两种定时器实现，具体使用哪一种根据创建 NSTimer 时指定的 tolerance(宽余量) 决定。<br>如果 tolerance 为 0 则使用 mk_timer，否则使用 dispatch_source_t。我猜测是因为 mk_timer 精度更高但是不能响应 tolerance，所以在 tolerance 不为 0 的情况下使用 dispatch_source_t。<br>这一部分在将 CFRunLoopTimerRef 这一节时还会介绍</p>
<p>__CFRunLoopMode 的构建函数如下，直接跳过也行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">static CFRunLoopModeRef __CFRunLoopFindMode(CFRunLoopRef rl, CFStringRef modeName, Boolean create) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    CFRunLoopModeRef rlm;</span><br><span class="line">    struct __CFRunLoopMode srlm;</span><br><span class="line">    memset(&amp;srlm, 0, sizeof(srlm));</span><br><span class="line">    _CFRuntimeSetInstanceTypeIDAndIsa(&amp;srlm, _kCFRuntimeIDCFRunLoopMode);</span><br><span class="line">    srlm._name = modeName;</span><br><span class="line">    rlm = (CFRunLoopModeRef)CFSetGetValue(rl-&gt;_modes, &amp;srlm);</span><br><span class="line">    if (NULL != rlm) &#123;</span><br><span class="line">	__CFRunLoopModeLock(rlm);</span><br><span class="line">	return rlm;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!create) &#123;</span><br><span class="line">	return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    rlm = (CFRunLoopModeRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, _kCFRuntimeIDCFRunLoopMode, sizeof(struct __CFRunLoopMode) - sizeof(CFRuntimeBase), NULL);</span><br><span class="line">    if (NULL == rlm) &#123;</span><br><span class="line">	return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    _CFRecursiveMutexCreate(&amp;rlm-&gt;_lock);</span><br><span class="line">    rlm-&gt;_name = CFStringCreateCopy(kCFAllocatorSystemDefault, modeName);</span><br><span class="line">    rlm-&gt;_portSet = __CFPortSetAllocate();</span><br><span class="line">    rlm-&gt;_timerSoftDeadline = UINT64_MAX;</span><br><span class="line">    rlm-&gt;_timerHardDeadline = UINT64_MAX;</span><br><span class="line">    </span><br><span class="line">    kern_return_t ret = KERN_SUCCESS;</span><br><span class="line">#if TARGET_OS_MAC</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">    rlm-&gt;_timerFired = false;</span><br><span class="line">    rlm-&gt;_queue = _dispatch_runloop_root_queue_create_4CF(&quot;Run Loop Mode Queue&quot;, 0);</span><br><span class="line">    mach_port_t queuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</span><br><span class="line">    if (queuePort == MACH_PORT_NULL) CRASH(&quot;*** Unable to create run loop mode queue port. (%d) ***&quot;, -1);</span><br><span class="line">    rlm-&gt;_timerSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, rlm-&gt;_queue);</span><br><span class="line">    </span><br><span class="line">    __block Boolean *timerFiredPointer = &amp;(rlm-&gt;_timerFired);</span><br><span class="line">    dispatch_source_set_event_handler(rlm-&gt;_timerSource, ^&#123;</span><br><span class="line">        *timerFiredPointer = true;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    // Set timer to far out there. The unique leeway makes this timer easy to spot in debug output.</span><br><span class="line">    dispatch_source_set_timer(rlm-&gt;_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 321);</span><br><span class="line">    dispatch_resume(rlm-&gt;_timerSource);</span><br><span class="line">    </span><br><span class="line">    ret = __CFPortSetInsert(queuePort, rlm-&gt;_portSet);</span><br><span class="line">    if (KERN_SUCCESS != ret) CRASH(&quot;*** Unable to insert timer port into port set. (%d) ***&quot;, ret);</span><br><span class="line">    </span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">    rlm-&gt;_timerPort = mk_timer_create();</span><br><span class="line">    if (rlm-&gt;_timerPort == MACH_PORT_NULL) &#123;</span><br><span class="line">        CRASH(&quot;*** Unable to create timer Port (%d) ***&quot;, rlm-&gt;_timerPort);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = __CFPortSetInsert(rlm-&gt;_timerPort, rlm-&gt;_portSet);</span><br><span class="line">    if (KERN_SUCCESS != ret) CRASH(&quot;*** Unable to insert timer port into port set. (%d) ***&quot;, ret);</span><br><span class="line"></span><br><span class="line">    ret = __CFPortSetInsert(rl-&gt;_wakeUpPort, rlm-&gt;_portSet);</span><br><span class="line">    if (KERN_SUCCESS != ret) CRASH(&quot;*** Unable to insert wake up port into port set. (%d) ***&quot;, ret);</span><br><span class="line">    </span><br><span class="line">#if TARGET_OS_WIN32</span><br><span class="line">    rlm-&gt;_msgQMask = 0;</span><br><span class="line">    rlm-&gt;_msgPump = NULL;</span><br><span class="line">#endif</span><br><span class="line">    CFSetAddValue(rl-&gt;_modes, rlm);</span><br><span class="line">    CFRelease(rlm);</span><br><span class="line">    __CFRunLoopModeLock(rlm);	/* return mode locked */</span><br><span class="line">    return rlm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一部分代码比较重要，这里我把它摘出来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> rlm-&gt;_timerFired = false;</span><br><span class="line">rlm-&gt;_queue = _dispatch_runloop_root_queue_create_4CF(&quot;Run Loop Mode Queue&quot;, 0);</span><br><span class="line">mach_port_t queuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</span><br><span class="line">if (queuePort == MACH_PORT_NULL) CRASH(&quot;*** Unable to create run loop mode queue port. (%d) ***&quot;, -1);</span><br><span class="line">rlm-&gt;_timerSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, rlm-&gt;_queue);</span><br><span class="line">    </span><br><span class="line">__block Boolean *timerFiredPointer = &amp;(rlm-&gt;_timerFired);</span><br><span class="line">dispatch_source_set_event_handler(rlm-&gt;_timerSource, ^&#123;</span><br><span class="line">    *timerFiredPointer = true;</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">// Set timer to far out there. The unique leeway makes this timer easy to spot in debug output.</span><br><span class="line">dispatch_source_set_timer(rlm-&gt;_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 321);</span><br><span class="line">dispatch_resume(rlm-&gt;_timerSource);</span><br><span class="line">    </span><br><span class="line">ret = __CFPortSetInsert(queuePort, rlm-&gt;_portSet);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rlm-&gt;_timerPort = mk_timer_create();</span><br><span class="line">if (rlm-&gt;_timerPort == MACH_PORT_NULL) &#123;</span><br><span class="line">    CRASH(&quot;*** Unable to create timer Port (%d) ***&quot;, rlm-&gt;_timerPort);</span><br><span class="line">&#125;</span><br><span class="line">ret = __CFPortSetInsert(rlm-&gt;_timerPort, rlm-&gt;_portSet);</span><br><span class="line">if (KERN_SUCCESS != ret) CRASH(&quot;*** Unable to insert timer port into port set. (%d) ***&quot;, ret);</span><br><span class="line"></span><br><span class="line">ret = __CFPortSetInsert(rl-&gt;_wakeUpPort, rlm-&gt;_portSet);</span><br><span class="line">if (KERN_SUCCESS != ret) CRASH(&quot;*** Unable to insert wake up port into port set. (%d) ***&quot;, ret);</span><br></pre></td></tr></table></figure>

<p>首先是 dispatch_source_t 部分：</p>
<p>为了让 dispatch_source_t 定时器能够开启，我们为当前 mode 创建了一个 dispatch_queue_t queue，这个 queue 用来执行定时器任务，并且为定时器触发设定了一个回调 <code>^&#123; *_timerFired = true; &#125;);</code>，即当定时器触发后将 _timerFired 设定为 true。<br>每个 dispatch_queue_t 都对应着一个 mach port，随后我们将其添加到 _portSet 中 </p>
<p>然后是 mk_timer 部分</p>
<p>为了让 mk_timer 触发后能够通知到 mode，我们为 mode 申请了一个 mach port <code>mk_timer_create</code>，并且将其添加到 _portSet 中</p>
<h3 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h3><p>CFRunLoopObserverRef 观察者。<br>Observer 可以观测的时间点有以下几个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop</span><br><span class="line">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU // 所有时间点</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>CFRunLoopObserverRef 的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopObserver &#123;</span><br><span class="line">    CFRuntimeBase _base; </span><br><span class="line">    _CFRecursiveMutex _lock;</span><br><span class="line">    CFRunLoopRef _runLoop;</span><br><span class="line">    /// 表示注册到了多少个 mode 中</span><br><span class="line">    CFIndex _rlCount;</span><br><span class="line">    /// 观测时间点</span><br><span class="line">    CFOptionFlags _activities;		/* immutable */</span><br><span class="line">    /// 优先级，数值越低表示优先级越高</span><br><span class="line">    CFIndex _order;			/* immutable */</span><br><span class="line">    /// 回调</span><br><span class="line">    CFRunLoopObserverCallBack _callout; /* immutable */</span><br><span class="line">    /// 回调执行需要的上下文</span><br><span class="line">    CFRunLoopObserverContext _context; /* immutable, except invalidation */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Observer 的结构定义比较简单，这里也不分析看看注释就好了。<br>我们可以使用 CFRunLoopAddObserver() 向 mode 添加 Observer，实现就不贴了(自己可以在源码中找到)，这里讲一下函数里面看到的几个点：</p>
<ul>
<li>Observer 如果已经被添加到了 runloop，那么它就不能被添加到别的 runloop 里了。但是它还可以被添加到其它的 mode 当中</li>
<li>Observer 被添加到 mode 的 _observers 时会根据其 _order 进行排序，_order 数值越大在数组中的位置越靠后</li>
<li>Observer 被添加到一个 mode 后其 _rlCount + 1，并将其 _activities 同步到 mode 的 _observerMask 当中</li>
</ul>
<p>每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。<br>当 runloop 在主函数中处于不同的时间点时，我们会通知注册了当前时间点的 Observer，对符合要求的 Observer 调用其回调函数。</p>
<p>需要注意的是，如果 Observer 不是重复的，那么当它执行一次回调后就会从 mode 中移除</p>
<h3 id="CFRunLoopSourceRef"><a href="#CFRunLoopSourceRef" class="headerlink" title="CFRunLoopSourceRef"></a>CFRunLoopSourceRef</h3><p>CFRunLoopSourceRef 的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopSource &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    _CFRecursiveMutex _lock;</span><br><span class="line">    /// 数值越低，优先级越高</span><br><span class="line">    CFIndex _order;			/* immutable */</span><br><span class="line">    /// 仅对 sourece0 有效。它的值是激活时的时间戳，有值时表示此 sourece0 已准备好被执行</span><br><span class="line">    _Atomic uint64_t _signaledTime;</span><br><span class="line">    /// source retain run loops</span><br><span class="line">    CFMutableBagRef _runLoops;</span><br><span class="line">    union &#123;</span><br><span class="line">    	/// source0</span><br><span class="line">	   CFRunLoopSourceContext version0; /* immutable, except invalidation */</span><br><span class="line">	   /// source1</span><br><span class="line">	   CFRunLoopSourceContext1 version1; /* immutable, except invalidation */</span><br><span class="line">    &#125; _context;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>可以看到 source1 与 source0 结构中的大部分成员变量都是相同的，除了最后的 _context 不同。<br>观察 <code>CFRunLoopSourceContext</code> 和 <code>CFRunLoopSourceContext1</code> 的结构体之后，我们可以知道：</p>
<ul>
<li>source1 相比于 source0 多了一个 mach port，这使得 source1 通过内核和其他线程相互发送消息，主动唤醒其它 runloop</li>
<li>source0 相比于 source1 多了两个函数指针 <code>schedule</code> 和 <code>cancel</code>，分别在创建和销毁时调用，具体作用不知道，猜测是为了用来做一些初始操作</li>
</ul>
<p>CFRunLoopSource 是添加到 runloop 中输入源的抽象表达。输入源通常会产生异步事件，例如网络端口上到达的消息或用户执行的操作。</p>
<p>输入源类型通常定义了一个用于创建和操作该类型对象的API，就像它是一个独立于 runloop 的实体一样。它提供一个函数来为对象创建一个CFRunLoopSource。CFRunLoopSource 可以被注册到 runloop，作为 runloop 和实际输入源类型对象之间的中介。输入源的例子包括CFMachPort、CFMessagePort和CFSocket。</p>
<p>CFRunLoopSource 有两类，Source0 由应用程序手动管理。当一个 Source0 准备好了被处理，应用程序的某些部分，也许是等待某个事件的线程上的代码，必须调用 CFRunLoopSourceSignal 来告诉 runloop  Source0 已经准备好了。<br>CFSocket的 runloop  Source目前是用 Source0 来实现的。</p>
<p>Source1 由 runloop 和内核管理。Source1 使用Mach端口来发出信号。当 Source1 的Mach端口上有消息到达时，内核会自动把 Source1 标记为激活状态。当 Source1 启动时，消息内容被交给 Source1 来处理。<br>CFMachPort和CFMessagePort的 runloop  Source 目前是用 Source0 来实现的。</p>
<p>Source 可以同时注册多个 runloop 和 runloop mode。当 Source 发出信号时，无论哪一个 runloop 恰好先检测到信号，都会启动该 Source。将 Source 添加到多个线程的 runloop 中，可用于管理正在处理离散数据集的 “工作线程 “池，例如通过网络的客户端-服务器消息。当消息到达时， Source 得到信号，一个随机线程接收并处理请求。</p>
<p>我们可以使用 CFRunLoopAddSource() 函数将 Source 添加到 mode，实现太长了这里就不贴了，自己可以翻源码。这里简单的分析下</p>
<ol>
<li>如果是 Source1，会预先测试该 mach port 是否能够发送消息，如果不能说明这个 Source1 有问题，直接崩溃</li>
<li>将 Source 依据类型分别添加到 rlm 的 _sources0 或者 _sources1 中。如果是 Source1 类型，则将其 mach port 添加到 rlm 的 _portSet，并以 key(mach port)&#x2F;value(Source1) 的形式添加到 rlm 的 _portToV1SourceMap</li>
<li>将 runloop 添加到 Source 的 _runLoops</li>
</ol>
<p>Source0 和 Source1 的处理函数分别是 __CFRunLoopDoSource0&#x2F;__CFRunLoopDoSource1<br>没什么好说的，就是调用各自的回调函数。执行完毕后，Source 也不会被移除，所以你可以向 runloop 添加一个 source 来保证其线程一直存活</p>
<h3 id="CFRunLoopTimerRef"><a href="#CFRunLoopTimerRef" class="headerlink" title="CFRunLoopTimerRef"></a>CFRunLoopTimerRef</h3><p>CFRunLoopTimerRef 的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopTimer &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    /// 用 Bit 保存信息。Bit 0 表示 fireing 状态，Bit 1 表示是否在调出时被触发(不是很明白)，Bit 2 表示是否处于销毁状态 Bit 3 表示是否有效</span><br><span class="line">    uint16_t _bits;</span><br><span class="line">    _CFRecursiveMutex _lock;</span><br><span class="line">    /// 包含此 timer 的 runloop</span><br><span class="line">    CFRunLoopRef _runLoop;</span><br><span class="line">    /// 包含此 timer 的 mode 集合</span><br><span class="line">    CFMutableSetRef _rlModes;</span><br><span class="line">    /// 下次触发的时间戳，单位秒</span><br><span class="line">    CFAbsoluteTime _nextFireDate;</span><br><span class="line">    /// 重复执行时的间隔。该值为 0 表示 timer 不重复</span><br><span class="line">    CFTimeInterval _interval;		/* immutable */</span><br><span class="line">    /// 偏差，一般设定为间隔的 10% 比较好</span><br><span class="line">    CFTimeInterval _tolerance;          /* mutable */</span><br><span class="line">    /// 下次触发时的 mach 时间戳</span><br><span class="line">    uint64_t _fireTSR;			/* TSR units */</span><br><span class="line">    /// 优先级，数值越低表示优先级越高。貌似对 timer 没什么作用</span><br><span class="line">    CFIndex _order;			/* immutable */</span><br><span class="line">    /// 触发时的回调</span><br><span class="line">    CFRunLoopTimerCallBack _callout; /* immutable */</span><br><span class="line">    /// 回调调用时需要的上下文</span><br><span class="line">    CFRunLoopTimerContext _context;  /* immutable, except invalidation */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>需要注意的是:</p>
<ul>
<li>_nextFireDate 是下次触发时间相对于 2001-1-1 00：00：00 的时间戳，单位是秒</li>
<li>_fireTSR 下一次触发时间的 macg 时间戳，单位为纳秒</li>
<li>_order 貌似在 timer 没什么用，至少在 CF 源码内没发现其用途</li>
</ul>
<p>在前面我们提到过，timer(NSTimer&#x2F;CFRunLoopTimerRef) 的功能实际上是由 mode 操作实现的。<br>对于一个有宽余量 tolerance 的 timer 来说，它的触发时间是在 (fireDate) ~ (fireDate + tolerance) 之间的，我们把它最早的触发时间称为 SoftDeadline，最晚的触发时间称为 HardDeadline。<br>一个 mode 可能管理着多个 timer，它们被集中放在 _timers 中。其中的每个 timer 都有自己的 SoftDeadline 和 HardDeadline。由于 _timers 是按触发时间的早晚来排序的，所以，这所有 timer 中， SoftDeadline 最小的肯定是 _timers 数组中第一个 timer 的 SoftDeadline，我们将其赋值给 mode 的成员变量 _timerSoftDeadline。<br>但是 HardDeadline 最小的却不一定是 _timers 数组中第一个 timer 的 HardDeadline，因为这还需要比较 tolerance 的大小，总之，我们将 HardDeadline 的最小值赋值给 mode 的成员变量 _timerHardDeadline<br>mode 在获取到 _timerSoftDeadline 和 _timerHardDeadline 之后，就开始设置定时器，如果 _timerSoftDeadline 和 _timerSoftDeadline 相等，说明 tolerance 等于 &#x3D;，此时 mode 使用 mk_timer 设置定时器; 否则 mode 使用 dispatch_source_t 设置定时器。<br>定时器触发，说明有 timer 需要执行回调了。这个时候我们在 _timers 数组中，判断哪些 timer 的 _fireTSR 时间小于等于当前时间，执行这些 timer 的回调，并重新计算出它们下一次的触发时间 <em>fireTSR，然后重新计算出 mode 的</em> timerSoftDeadline 和 _timerHardDeadline，并开启下一个定时器。</p>
<p>想知道这些在源码中具体是怎么样的，就看接下来的分析吧~</p>
<p>我们可以使用 CFRunLoopTimerCreate() 来创建 CFRunLoopTimerRef 实例。<br>这个函数比较长而且简单这里就不贴了<br>函数里面值得注意的有下面几点：</p>
<ul>
<li>默认的 _tolerance 为 0，但实际上即使你设置为 0 还是不能保证会准时出发</li>
<li>如果你设置的 fireDate 比现在要早，那么 _fireDate 会被赋值为 now，表示立刻触发。对于 repeat 的 timer 来讲，下一次触发时间还是会正常的</li>
</ul>
<p>timer 创建后自然是要添加到 mode 中去了，CFRunLoopAddTimer() 帮助我们完成这个操作。<br>因为同上的理由这里就不贴代码了，主要就是在验证 timer 是否有效，最后如果有效的话则调用 __CFRepositionTimerInMode() 函数将 timer 添加到 mode 的 _timers 中</p>
<p>下面是 __CFRepositionTimerInMode() 函数的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static void __CFRepositionTimerInMode(CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt, Boolean isInArray) &#123;</span><br><span class="line">    if (!rlt) return;</span><br><span class="line">    </span><br><span class="line">    CFMutableArrayRef timerArray = rlm-&gt;_timers;</span><br><span class="line">    if (!timerArray) return;</span><br><span class="line">    Boolean found = false;</span><br><span class="line">    </span><br><span class="line">    // If we know in advance that the timer is not in the array (just being added now) then we can skip this search</span><br><span class="line">    /// 如果已经在数组中，则执行这一步</span><br><span class="line">    if (isInArray) &#123;</span><br><span class="line">        CFIndex idx = CFArrayGetFirstIndexOfValue(timerArray, CFRangeMake(0, CFArrayGetCount(timerArray)), rlt);</span><br><span class="line">        if (kCFNotFound != idx) &#123;</span><br><span class="line">            CFRetain(rlt);</span><br><span class="line">            CFArrayRemoveValueAtIndex(timerArray, idx);</span><br><span class="line">            found = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!found &amp;&amp; isInArray) return;</span><br><span class="line">    /// 在数组中找到合适的位置</span><br><span class="line">    CFIndex newIdx = __CFRunLoopInsertionIndexInTimerArray(timerArray, rlt);</span><br><span class="line">    /// 在 timer 插入到上一步找到的位置中</span><br><span class="line">    CFArrayInsertValueAtIndex(timerArray, newIdx, rlt);</span><br><span class="line">    __CFArmNextTimerInMode(rlm, rlt-&gt;_runLoop);</span><br><span class="line">    if (isInArray) CFRelease(rlt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数主要做了下面几件事：</p>
<ul>
<li>如果该 timer 已经在数组中，则找到其位置并从数组中移除。然后在数组找到适合其插入的位置，找到后重新添加到数组中</li>
<li>如果该 timer 不在数组中，则在数组找到适合其插入的位置，找到后将其添加到数组中</li>
<li>以上两步将 timer 成功添加到数组后，调用 __CFArmNextTimerInMode() 重新计算 mode 的 _timerHardDeadline 和 _timerSoftDeadline</li>
</ul>
<p>__CFArmNextTimerInMode() 的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">static void __CFArmNextTimerInMode(CFRunLoopModeRef rlm, CFRunLoopRef rl) &#123;</span><br><span class="line">    /// min soft</span><br><span class="line">    uint64_t nextHardDeadline = UINT64_MAX;</span><br><span class="line">    /// min hard</span><br><span class="line">    uint64_t nextSoftDeadline = UINT64_MAX;</span><br><span class="line"></span><br><span class="line">    if (rlm-&gt;_timers) &#123;</span><br><span class="line">        // Look at the list of timers. We will calculate two TSR values; the next soft and next hard deadline.</span><br><span class="line">        // The next soft deadline is the first time we can fire any timer. This is the fire date of the first timer in our sorted list of timers.</span><br><span class="line">        // The next hard deadline is the last time at which we can fire the timer before we&#x27;ve moved out of the allowable tolerance of the timers in our list.</span><br><span class="line">        for (CFIndex idx = 0, cnt = CFArrayGetCount(rlm-&gt;_timers); idx &lt; cnt; idx++) &#123;</span><br><span class="line">            CFRunLoopTimerRef t = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm-&gt;_timers , idx);</span><br><span class="line">            // discount timers currently firing</span><br><span class="line">            if (__CFRunLoopTimerIsFiring(t)) continue;</span><br><span class="line">            </span><br><span class="line">            uint64_t oneTimerHardDeadline;</span><br><span class="line">            uint64_t oneTimerSoftDeadline = t-&gt;_fireTSR;</span><br><span class="line">            if (os_add_overflow(t-&gt;_fireTSR, __CFTimeIntervalToTSR(t-&gt;_tolerance), &amp;oneTimerHardDeadline)) &#123;</span><br><span class="line">                oneTimerHardDeadline = UINT64_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // We can stop searching if the soft deadline for this timer exceeds(超过 the current hard deadline. Otherwise, later timers with lower tolerance could still have earlier hard deadlines.</span><br><span class="line">            if (oneTimerSoftDeadline &gt; nextHardDeadline) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (oneTimerSoftDeadline &lt; nextSoftDeadline) &#123;</span><br><span class="line">                nextSoftDeadline = oneTimerSoftDeadline;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (oneTimerHardDeadline &lt; nextHardDeadline) &#123;</span><br><span class="line">                nextHardDeadline = oneTimerHardDeadline;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        /// 如果 _timerHardDeadline 和 _timerSoftDeadline 没变就不需要重新设置定时器了</span><br><span class="line">        if (nextSoftDeadline &lt; UINT64_MAX &amp;&amp; (nextHardDeadline != rlm-&gt;_timerHardDeadline || nextSoftDeadline != rlm-&gt;_timerSoftDeadline)) &#123;</span><br><span class="line">            if (CFRUNLOOP_NEXT_TIMER_ARMED_ENABLED()) &#123;</span><br><span class="line">                CFRUNLOOP_NEXT_TIMER_ARMED((unsigned long)(nextSoftDeadline - mach_absolute_time()));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            cf_trace(KDEBUG_EVENT_CFRL_NEXT_TIMER_ARMED, rl, rlm, (nextSoftDeadline - mach_absolute_time()), 0);</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">            // We&#x27;re going to hand off the range of allowable timer fire date to dispatch and let it fire when appropriate for the system.</span><br><span class="line">            /// 宽容度</span><br><span class="line">            uint64_t leeway = __CFTSRToNanoseconds(nextHardDeadline - nextSoftDeadline);</span><br><span class="line">            dispatch_time_t deadline = __CFTSRToDispatchTime(nextSoftDeadline);</span><br><span class="line">            if (leeway &gt; 0) &#123;/// 截止时间 - 预期时间 &gt; 0</span><br><span class="line">                // Only use the dispatch timer if we have any leeway</span><br><span class="line">                // &lt;rdar://problem/14447675&gt;</span><br><span class="line">                </span><br><span class="line">                // Cancel the mk timer</span><br><span class="line">                if (rlm-&gt;_mkTimerArmed &amp;&amp; rlm-&gt;_timerPort) &#123;</span><br><span class="line">                    AbsoluteTime dummy;</span><br><span class="line">                    mk_timer_cancel(rlm-&gt;_timerPort, &amp;dummy);</span><br><span class="line">                    rlm-&gt;_mkTimerArmed = false;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                // Arm the dispatch timer</span><br><span class="line">                dispatch_source_set_timer(rlm-&gt;_timerSource, deadline, DISPATCH_TIME_FOREVER, leeway);</span><br><span class="line">                rlm-&gt;_dispatchTimerArmed = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Cancel the dispatch timer</span><br><span class="line">                if (rlm-&gt;_dispatchTimerArmed) &#123;</span><br><span class="line">                    // Cancel the dispatch timer</span><br><span class="line">                    dispatch_source_set_timer(rlm-&gt;_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 888);</span><br><span class="line">                    rlm-&gt;_dispatchTimerArmed = false;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                // Arm the mk timer</span><br><span class="line">                if (rlm-&gt;_timerPort) &#123;</span><br><span class="line">                    mk_timer_arm(rlm-&gt;_timerPort, nextSoftDeadline);</span><br><span class="line">                    rlm-&gt;_mkTimerArmed = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">#else</span><br><span class="line">            if (rlm-&gt;_timerPort) &#123;</span><br><span class="line">                mk_timer_arm(rlm-&gt;_timerPort, nextSoftDeadline);</span><br><span class="line">            &#125;</span><br><span class="line">#endif</span><br><span class="line">        &#125; else if (nextSoftDeadline == UINT64_MAX) &#123;</span><br><span class="line">            // Disarm the timers - there is no timer scheduled</span><br><span class="line">            </span><br><span class="line">            if (rlm-&gt;_mkTimerArmed &amp;&amp; rlm-&gt;_timerPort) &#123;</span><br><span class="line">                AbsoluteTime dummy;</span><br><span class="line">                mk_timer_cancel(rlm-&gt;_timerPort, &amp;dummy);</span><br><span class="line">                rlm-&gt;_mkTimerArmed = false;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">            if (rlm-&gt;_dispatchTimerArmed) &#123;</span><br><span class="line">                dispatch_source_set_timer(rlm-&gt;_timerSource, DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 333);</span><br><span class="line">                rlm-&gt;_dispatchTimerArmed = false;</span><br><span class="line">            &#125;</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rlm-&gt;_timerHardDeadline = nextHardDeadline;</span><br><span class="line">    rlm-&gt;_timerSoftDeadline = nextSoftDeadline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数里面值得注意的有下面几点：</p>
<ul>
<li>_timerSoftDeadline 和 _timerSoftDeadline 取值都是 timer 中最小的 SoftDeadline 和 SoftDeadline，但是拥有最小 SoftDeadline 的 timer 的 SoftDeadline 却不一定是最小的，因为这还要考虑 _tolerance</li>
<li>如果 _timerSoftDeadline 和 _timerSoftDeadline 和之前的值相同，说明不需要重新设置 mode 里面的定时器了</li>
<li>如果 _timerSoftDeadline 和 _timerSoftDeadline 相同，则使用 mk_timer 设置定时器;否则使用 dispathch_source_t 设置定时器。我猜测是 mk_timer 精度更高，但是不能使用宽余量，所以此时用 dispatch_source_t 代替</li>
</ul>
<p>添加完成后，自然是要看如何执行 timer 的，__CFRunLoopDoTimers() 函数帮我们完成该操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static Boolean __CFRunLoopDoTimers(CFRunLoopRef rl, CFRunLoopModeRef rlm, uint64_t limitTSR) &#123;	/* DOES CALLOUT */</span><br><span class="line">    </span><br><span class="line">    cf_trace(KDEBUG_EVENT_CFRL_IS_DOING_TIMERS | DBG_FUNC_START, rl, rlm, limitTSR, 0);</span><br><span class="line">    </span><br><span class="line">    Boolean timerHandled = false;</span><br><span class="line">    CFMutableArrayRef timers = NULL;</span><br><span class="line">    for (CFIndex idx = 0, cnt = rlm-&gt;_timers ? CFArrayGetCount(rlm-&gt;_timers) : 0; idx &lt; cnt; idx++) &#123;</span><br><span class="line">        CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm-&gt;_timers, idx);</span><br><span class="line">        </span><br><span class="line">        if (__CFIsValid(rlt) &amp;&amp; !__CFRunLoopTimerIsFiring(rlt)) &#123;</span><br><span class="line">            /// 将符合触发要求的 timer 取出来放在 timers 数组中</span><br><span class="line">            if (rlt-&gt;_fireTSR &lt;= limitTSR) &#123;</span><br><span class="line">                if (!timers) timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeArrayCallBacks);</span><br><span class="line">                CFArrayAppendValue(timers, rlt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CFRUNLOOP_ARP_BEGIN;</span><br><span class="line">    </span><br><span class="line">    for (CFIndex idx = 0, cnt = timers ? CFArrayGetCount(timers) : 0; idx &lt; cnt; idx++) &#123;</span><br><span class="line">        CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(timers, idx);</span><br><span class="line">        Boolean did = __CFRunLoopDoTimer(rl, rlm, rlt);</span><br><span class="line">        timerHandled = timerHandled || did;</span><br><span class="line">    &#125;</span><br><span class="line">        if (timers) CFRelease(timers);</span><br><span class="line"></span><br><span class="line">    CFRUNLOOP_ARP_END;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cf_trace(KDEBUG_EVENT_CFRL_IS_DOING_TIMERS | DBG_FUNC_END, rl, rlm, limitTSR, 0);</span><br><span class="line">    </span><br><span class="line">    return timerHandled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法给定了一个触发时间 limitTSR，遍历 _timers 并收集所有触发时间 _fireTSR 小于 limitTSR 的 timer<br>对所有符合触发要求的 timer 调用 __CFRunLoopDoTimer() 函数，看样子具体的执行过程是在这里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static Boolean __CFRunLoopDoTimer(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt) &#123;	/* DOES CALLOUT */</span><br><span class="line">    </span><br><span class="line">    cf_trace(KDEBUG_EVENT_CFRL_TIMERS_FIRING | DBG_FUNC_START, rl, rlm, rlt, 0);</span><br><span class="line">    </span><br><span class="line">    Boolean timerHandled = false;</span><br><span class="line">    uint64_t oldFireTSR = 0;</span><br><span class="line"></span><br><span class="line">    /* Fire a timer */</span><br><span class="line">    CFRetain(rlt);</span><br><span class="line">    __CFRunLoopTimerLock(rlt);</span><br><span class="line"></span><br><span class="line">    if (__CFIsValid(rlt) &amp;&amp; rlt-&gt;_fireTSR &lt;= mach_absolute_time() &amp;&amp; !__CFRunLoopTimerIsFiring(rlt) &amp;&amp; rlt-&gt;_runLoop == rl) &#123; /// if1 start</span><br><span class="line">        void *context_info = NULL;</span><br><span class="line">        void (*context_release)(const void *) = NULL;</span><br><span class="line">        if (rlt-&gt;_context.retain) &#123;</span><br><span class="line">            context_info = (void *)rlt-&gt;_context.retain(rlt-&gt;_context.info);</span><br><span class="line">            context_release = rlt-&gt;_context.release;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            context_info = rlt-&gt;_context.info;</span><br><span class="line">        &#125;</span><br><span class="line">        /// _interval = 0 表示 timer 触发过一次过就会被置为不可用状态</span><br><span class="line">        Boolean doInvalidate = (0.0 == rlt-&gt;_interval);</span><br><span class="line">	__CFRunLoopTimerSetFiring(rlt);</span><br><span class="line">        // Just in case the next timer has exactly the same deadlines as this one, we reset these values so that the arm next timer code can correctly find the next timer in the list and arm the underlying timer.</span><br><span class="line">        /// SoftDeadline 表示第一个 timer 第一次 fire 的时间，HardDeadline 表示最后一个 timer 第一次 fire 的时间</span><br><span class="line">        /// 重设这两个值，便于找到下一个未处理的 timer</span><br><span class="line">        rlm-&gt;_timerSoftDeadline = UINT64_MAX;</span><br><span class="line">        rlm-&gt;_timerHardDeadline = UINT64_MAX;</span><br><span class="line">        __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">        __CFLock(&amp;rl-&gt;_timerTSRLock);</span><br><span class="line">	oldFireTSR = rlt-&gt;_fireTSR;</span><br><span class="line">        __CFUnlock(&amp;rl-&gt;_timerTSRLock);</span><br><span class="line"></span><br><span class="line">        __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line"></span><br><span class="line">	__CFRunLoopModeUnlock(rlm);</span><br><span class="line">	__CFRunLoopUnlock(rl);</span><br><span class="line">        </span><br><span class="line">        CFRunLoopTimerCallBack callout = rlt-&gt;_callout;</span><br><span class="line">        cf_trace(KDEBUG_EVENT_CFRL_IS_CALLING_TIMER | DBG_FUNC_START, callout, rlt, context_info, 0);</span><br><span class="line">	__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(callout, rlt, context_info);</span><br><span class="line">        cf_trace(KDEBUG_EVENT_CFRL_IS_CALLING_TIMER | DBG_FUNC_END, callout, rlt, context_info, 0);</span><br><span class="line">        </span><br><span class="line">	CHECK_FOR_FORK();</span><br><span class="line">        if (doInvalidate) &#123;</span><br><span class="line">            /// remove timer</span><br><span class="line">            CFRunLoopTimerInvalidate(rlt);      /* DOES CALLOUT */</span><br><span class="line">        &#125;</span><br><span class="line">        if (context_release) &#123;</span><br><span class="line">            context_release(context_info);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">	__CFRunLoopLock(rl);</span><br><span class="line">	__CFRunLoopModeLock(rlm);</span><br><span class="line">        __CFRunLoopTimerLock(rlt);</span><br><span class="line">	timerHandled = true;</span><br><span class="line">	__CFRunLoopTimerUnsetFiring(rlt);</span><br><span class="line">    &#125; /// if1 end</span><br><span class="line">    if (__CFIsValid(rlt) &amp;&amp; timerHandled) &#123; /// if2 start</span><br><span class="line">        /* This is just a little bit tricky: we want to support calling</span><br><span class="line">         * CFRunLoopTimerSetNextFireDate() from within the callout and</span><br><span class="line">         * honor that new time here if it is a later date, otherwise</span><br><span class="line">         * it is completely ignored. */</span><br><span class="line">        if (oldFireTSR &lt; rlt-&gt;_fireTSR) &#123; /// if3 start</span><br><span class="line">            /* Next fire TSR was set, and set to a date after the previous</span><br><span class="line">            * fire date, so we honor it. */</span><br><span class="line">            __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">            // The timer was adjusted and repositioned, during the</span><br><span class="line">            // callout, but if it was still the min timer, it was</span><br><span class="line">            // skipped because it was firing.  Need to redo the</span><br><span class="line">            // min timer calculation in case rlt should now be that</span><br><span class="line">            // timer instead of whatever was chosen.</span><br><span class="line">            __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            uint64_t nextFireTSR = 0LL;</span><br><span class="line">            uint64_t intervalTSR = 0LL;</span><br><span class="line">            if (rlt-&gt;_interval &lt;= 0.0) &#123;</span><br><span class="line">            &#125; else if (TIMER_INTERVAL_LIMIT &lt; rlt-&gt;_interval) &#123;</span><br><span class="line">        	intervalTSR = __CFTimeIntervalToTSR(TIMER_INTERVAL_LIMIT);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">        	intervalTSR = __CFTimeIntervalToTSR(rlt-&gt;_interval);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (LLONG_MAX - intervalTSR &lt;= oldFireTSR) &#123;</span><br><span class="line">                nextFireTSR = LLONG_MAX;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (intervalTSR == 0) &#123;</span><br><span class="line">                    // 15304159: Make sure we don&#x27;t accidentally loop forever here</span><br><span class="line">                    CRSetCrashLogMessage(&quot;A CFRunLoopTimer with an interval of 0 is set to repeat&quot;);</span><br><span class="line">                    HALT;</span><br><span class="line">                &#125;</span><br><span class="line">                uint64_t currentTSR = mach_absolute_time();</span><br><span class="line">                nextFireTSR = oldFireTSR;</span><br><span class="line">                while (nextFireTSR &lt;= currentTSR) &#123;</span><br><span class="line">                    nextFireTSR += intervalTSR;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            CFRunLoopRef rlt_rl = rlt-&gt;_runLoop;</span><br><span class="line">            if (rlt_rl) &#123; /// if3 start</span><br><span class="line">                CFRetain(rlt_rl);</span><br><span class="line">                CFIndex cnt = CFSetGetCount(rlt-&gt;_rlModes);</span><br><span class="line">                STACK_BUFFER_DECL(CFTypeRef, modes, cnt);</span><br><span class="line">                CFSetGetValues(rlt-&gt;_rlModes, (const void **)modes);</span><br><span class="line">                // To avoid A-&gt;B, B-&gt;A lock ordering issues when coming up</span><br><span class="line">                // towards the run loop from a source, the timer has to be</span><br><span class="line">                // unlocked, which means we have to protect from object</span><br><span class="line">                // invalidation, although that&#x27;s somewhat expensive.</span><br><span class="line">                for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</span><br><span class="line">                    CFRetain(modes[idx]);</span><br><span class="line">                &#125;</span><br><span class="line">                __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">                for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</span><br><span class="line">                    CFStringRef name = (CFStringRef)modes[idx];</span><br><span class="line">                    modes[idx] = (CFTypeRef)__CFRunLoopFindMode(rlt_rl, name, false);</span><br><span class="line">                    CFRelease(name);</span><br><span class="line">                &#125;</span><br><span class="line">                        __CFLock(&amp;rl-&gt;_timerTSRLock);</span><br><span class="line">                rlt-&gt;_fireTSR = nextFireTSR;</span><br><span class="line">                        rlt-&gt;_nextFireDate = CFAbsoluteTimeGetCurrent() + __CFTimeIntervalUntilTSR(nextFireTSR);</span><br><span class="line">                for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</span><br><span class="line">                    CFRunLoopModeRef rlm = (CFRunLoopModeRef)modes[idx];</span><br><span class="line">                    if (rlm) &#123;</span><br><span class="line">                                __CFRepositionTimerInMode(rlm, rlt, true);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                        __CFUnlock(&amp;rl-&gt;_timerTSRLock);</span><br><span class="line">                for (CFIndex idx = 0; idx &lt; cnt; idx++) &#123;</span><br><span class="line">                    __CFRunLoopModeUnlock((CFRunLoopModeRef)modes[idx]);</span><br><span class="line">                &#125;</span><br><span class="line">                CFRelease(rlt_rl);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">                        __CFLock(&amp;rl-&gt;_timerTSRLock);</span><br><span class="line">                rlt-&gt;_fireTSR = nextFireTSR;</span><br><span class="line">                        rlt-&gt;_nextFireDate = CFAbsoluteTimeGetCurrent() + __CFTimeIntervalUntilTSR(nextFireTSR);</span><br><span class="line">                        __CFUnlock(&amp;rl-&gt;_timerTSRLock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; /// if3 end</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">    &#125; /// if2 end</span><br><span class="line">    CFRelease(rlt);</span><br><span class="line">    </span><br><span class="line">    cf_trace(KDEBUG_EVENT_CFRL_TIMERS_FIRING | DBG_FUNC_END, rl, rlm, rlt, 0);</span><br><span class="line">    </span><br><span class="line">    return timerHandled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数比较长，但是也比较重要</p>
<ul>
<li>再判断一次 timer 是否满足</li>
<li>设置 timer 为触发状态，并设置 mode 的 _timerSoftDeadline，_timerHardDeadline 为 UINT64_MAX，调用 __CFArmNextTimerInMode() 在 mode 开启下一个定时器(因为之前设置的已经触发了)</li>
<li>执行 timer 的回调，结束之后如果 timer 不重复则将其从 mode 中移除，否则将 timer 设置为未触发状态</li>
<li>接下来重新调用一次 __CFArmNextTimerInMode()，因为上一次调用 __CFArmNextTimerInMode，这个 timer 处于触发状态所以不能参与，现在是未触发状态就可以参与了</li>
</ul>
<p>至此，CFRunLoopTimerRef 的分析完毕</p>
<h4 id="dispatch-source-t-使用"><a href="#dispatch-source-t-使用" class="headerlink" title="dispatch_source_t 使用"></a>dispatch_source_t 使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</span><br><span class="line">dispatch_source_set_timer(source, dispatch_time(DISPATCH_TIME_NOW, 0), 3 * NSEC_PER_SEC, 0);</span><br><span class="line">dispatch_source_set_event_handler(source, ^&#123;</span><br><span class="line">    //定时器触发时执行</span><br><span class="line">   NSLog(@&quot;timer响应了&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">//启动timer</span><br><span class="line">dispatch_resume(source);</span><br></pre></td></tr></table></figure>


<p>在 runloop 中，给 dispatch_source_t 的触发时间设置为 DISPATCH_TIME_FOREVER 达到取消定时器触发的目的</p>
<blockquote>
<p>需要注意的是，dispatch_source_set_timer() 函数中，如果触发时间是 DISPATCH_TIME_NOW 或者 dispatch_time 类型的，那么定时器将对照 mach 时间来触发; 否则，将对照 gettimeofday(3) 来触发</p>
</blockquote>
<h4 id="mk-timer-使用"><a href="#mk-timer-使用" class="headerlink" title="mk_timer 使用"></a>mk_timer 使用</h4><p>MK_TIMER的原理很简单，其核心就是：</p>
<ul>
<li>mk_timer_arm(mach_port_t, expire_time) 在 expire_time 的时候给指定了 mach_port 的发送消息</li>
<li>mk_timer_cancel(mach_port_t, &amp;result_time) 取消 mk_timer_arm 注册的消息</li>
</ul>
<h3 id="Runloop-主函数"><a href="#Runloop-主函数" class="headerlink" title="Runloop 主函数"></a>Runloop 主函数</h3><p>这里我也写一个 runloop 的内部逻辑，可以跳过先看后面的分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    @param seconds：超时时间</span><br><span class="line">    @param stopAfterHandle：处理完 source 即退出，默认为 false</span><br><span class="line">    @param previousMode：默认为 nil，如果不为空，则表示 __CFRunLoopRun 还未退出就又调用了一次 __CFRunLoopRun</span><br><span class="line">*/</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line"></span><br><span class="line">    // dispatchPort 表示 dispatch_main_queue port，可能为空</span><br><span class="line">    __CFPort dispatchPort = ...;</span><br><span class="line">    // modeQueuePort 表示 dispatch_rlm_queue port，可能为空</span><br><span class="line">    mach_port_name_t modeQueuePort = ...;</span><br><span class="line"></span><br><span class="line">    /// 当超时时间大于 0 且小于某个值，则用 dispatch_source_t 开启一个定时器</span><br><span class="line">    if (seconds &gt; 0 &amp;&amp; seconds &lt; DISPATCH_TIME_FOREVER) &#123;</span><br><span class="line">        dispatch_source_t timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">        dispatch_resume(timeout_timer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Boolean didDispatchPortLastTime = true;</span><br><span class="line">    int32_t retVal = 0;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        /// 可能会接收到 mach 消息 的 mach port 集合</span><br><span class="line">        __CFPortSet waitSet = rlm-&gt;_portSet;</span><br><span class="line"></span><br><span class="line">        /// 通知 Observers: RunLoop 即将处理 Timer</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line"></span><br><span class="line">        /// 通知 Observers: RunLoop 即将处理 Sources</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line"></span><br><span class="line">        /// 执行被加入的 block</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line"></span><br><span class="line">        /// 处理 Source0</span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        if (sourceHandledThisLoop) &#123;</span><br><span class="line">            ///  执行完 source0 的回调函数，可能会向 RunLoop 加入了一些新的 block，所以在这里执行它们</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /// poll 表示本次 loop 不会进入休眠状态，即不会休眠等待 mach msg</span><br><span class="line">        Boolean poll = ...;</span><br><span class="line"></span><br><span class="line">        /// 通知 Observers: RunLoop 即将休眠</span><br><span class="line">        if (!poll) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        /// 设置 runloop 为休眠状态</span><br><span class="line">        __CFRunLoopSetSleeping(rl);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        do &#123;</span><br><span class="line">            /**</span><br><span class="line">                休眠接受 mach msg，有以下几种情况会被唤醒</span><br><span class="line">                1. 定时器触发唤醒</span><br><span class="line">                2. source1 事件</span><br><span class="line">                3. 调用 CFRunLoopWakeUp() 唤醒</span><br><span class="line">                4. 超时唤醒</span><br><span class="line">             */</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort);</span><br><span class="line"></span><br><span class="line">            if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">                /// 定时器触发唤醒</span><br><span class="line">                if (rlm-&gt;_timerFired) &#123;</span><br><span class="line">                    rlm-&gt;_timerFired = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /// 其它情况唤醒</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (1)</span><br><span class="line"></span><br><span class="line">        /// 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span><br><span class="line">        __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">        handle_msg:;</span><br><span class="line"></span><br><span class="line">        if (MACH_PORT_NULL == livePort) &#123;</span><br><span class="line">            /// 被其它原因唤醒，例如 poll = true</span><br><span class="line">            // handle nothing</span><br><span class="line">        &#125; else if (livePort == rl-&gt;_wakeUpPort) &#123;</span><br><span class="line">            /// 被 CFRunLoopWakeUp 唤醒</span><br><span class="line">            // handle nothing</span><br><span class="line">        &#125; else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">            /// 被 dispatch_source_t 类型的定时器唤醒</span><br><span class="line">            /// 处理 timer</span><br><span class="line">            __CFRunLoopDoTimers(rl, rlm, mach_absolute_time())</span><br><span class="line">        &#125; else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</span><br><span class="line">            //// 被 mk_timer 类型的定时器唤醒</span><br><span class="line">            /// 处理 timer</span><br><span class="line">            __CFRunLoopDoTimers(rl, rlm, mach_absolute_time())</span><br><span class="line">        &#125; else if (livePort == dispatchPort) &#123;</span><br><span class="line">            /// 被 main_dispatch_queue port 发送的消息</span><br><span class="line">            /// 处理提交到主队列的任务</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /// 处理 source1</span><br><span class="line">            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply);</span><br><span class="line">            if (NULL != reply) &#123;</span><br><span class="line">                /// source1 可以向别的 port 发送消息</span><br><span class="line">                (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            /// 进入loop时参数说处理完事件就返回。</span><br><span class="line">            retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; else if (timeout) &#123;</span><br><span class="line">            /// 超出传入参数标记的超时时间了</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">        &#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">            /// 被外部调用者强制停止了</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">            /// source/timer/observer一个都没有了</span><br><span class="line">            retVal = kCFRunLoopRunFinished;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (ret)</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/05/21/NHLBOZ81j3fo6GD.jpg" alt="初始化 mach port"></p>
<p>初始化 dispatchPort 和 modeQueuePort 两个端口<br>dispatchPort 表示 dispatch_main_queue port(主队列的 mach port)，可能为空<br>modeQueuePort 表示 dispatch_rlm_queue port(当前 mode 队列的 mach port)，这个 port 是用来处理 timer 的，可能为空</p>
<p><img src="https://i.loli.net/2020/05/21/oLNKZCetPv2673b.jpg" alt="超时定时器"></p>
<p>当超时时间 second 大于 0 且小于某个值时，初始化一个dispatch_source_t 类型的定时器，并开启，用来处理 runloop 超时的情况。如果超时，则调用函数 CFRunLoopWakeUp() 唤醒 rl</p>
<p>接着进入了一个内部循环 do {} while () 中</p>
<p><img src="https://i.loli.net/2020/05/22/AIzo8xbkBrstN2E.jpg" alt="处理 source0 "></p>
<p>在处理 source0 之前我们先调用 __CFRunLoopDoBlocks() 函数处理加入的 block。<br>处理完 source0 之后立马又调用了一次 __CFRunLoopDoBlocks()，我裂解为在执行 source0 的回调函数中，有可能像 rlm 又添加了 block，所以要处理它们。</p>
<!--FIXME: GCD 与 runloop 的关系-->
<p>这里我有个猜测，使用 <code>dispatch_async(dispatch_queue_t queue, dispatch_block_t block)</code> 添加的 block 其实是添加到 rlm 里面的，只不过因为对 GCD 不熟悉现在还无法下结论。<br>但使用代码调试的时候可以看到 block 是在 __CFRunLoopDoBlocks 里面被调用的。</p>
<p><img src="https://i.loli.net/2020/05/22/cxaKvQdfqphuM8i.jpg"></p>
<p>这里分为两部分，首先声明了一个布尔值 poll，它表示 runloop 在此次 loop 中不会进入休眠等待 mach msg 的状态，处理完任务就退出。<br>它的成立条件可以是下面条件中的一种</p>
<ul>
<li>处理了 source0</li>
<li>超时时间为 0</li>
</ul>
<p>source0 并不能主动唤醒 runloop，所以处理 source0 之前必须要用 CFRunLoopWakeUp() 唤醒 runloop。<br>这也就能理解 poll 的作用了，人家唤醒你来处理任务，肯定是希望你赶紧处理完然后退出的，怎么还能让你浪费时间休眠接受 mach msg 呢</p>
<p>后面应该不可能调到红色框内，因为前面 didDispatchPortLastTime 初始化为了 true。<br>我猜测这是因为 swift 中这部分的实现跟 oc 中的实现不完全一样。总之这里就不管了了</p>
<p><img src="https://i.loli.net/2020/05/22/6EvfGwQZqy5NdTV.jpg"></p>
<p>runloop 进入休眠状态，调用 __CFRunLoopServiceMachPort() 接受 mach msg，接受到消息后被唤醒。</p>
<p>此时如果接收到消息的 port 不是 modeQueuePort(rlm_queue_port)，则继续走下。<br>如果是的话，则调用 _dispatch_runloop_root_queue_perform_4CF() 函数。</p>
<p>在创建 rlm 时我们创建一个 dispatch_queue_t，赋值给了 _queue。创建了一个 dispatch_source_t 定时器，并将其回调 handler block 提交给了 _queue。当定时器被触发时，发送消息给 modeQueuePort，接受到消息后，我们需要调用 _dispatch_runloop_root_queue_perform_4CF() 函数处理之前提交过的 handler block，而这个回调在初始化 rlm 就已经写死了：将 rlm-&gt;_timerFired 赋值为 true。</p>
<p>所以接下来有个判断 rlm-&gt;_timerFired 是否为 true，如果为 true 即定时器触发了，所以跳出循环去处理 timer 的回调。如果不是我就不清楚是什么情况了</p>
<p>接下来就是 runloop 处理被唤醒的原因了</p>
<p><img src="https://i.loli.net/2020/05/22/2NOQEUPsklqwBVC.jpg"></p>
<p>此种情况是因为在接受消息时因为各种原因没有正确的接收到消息而退出休眠的状态，例如设置超时时间为 0，mach_msg 还没接收到消息就退出接受状态了</p>
<p><img src="https://i.loli.net/2020/05/22/vYko7gMJ5yx1PNz.jpg"><br> runloop 被调用 CFRunLoopWakeUp 函数唤醒</p>
<p> <img src="https://i.loli.net/2020/05/22/Akf7dxPI6EhJFj4.jpg"></p>
<p> 被 rlm-&gt;_timerSource 定时器唤醒。</p>
<p> 此时去执行可用的 timer 回调。<br> 如果不存在符合要求的 timer，说明定时器触发早了了，说明我们设置的触发时间有问题。调用 __CFArmNextTimerInMode() 设置下一个触发的时间点</p>
<p> <img src="https://i.loli.net/2020/05/22/oAy1mMQ5LZSU3Bf.jpg"></p>
<p> 被 mk_timer 唤醒</p>
<p> 此时去执行可用的 timer 回调。<br>在 windows 平台 mk_timer 定时器可能提前触发，所以我们需要重新开启 mk_timer 定时器，除了调用 __CFArmNextTimerInMode 函数，还需要先将 rlm 的_timerSoftDeadline 和 _timerHardDeadline 改变才行。</p>
<p> <img src="https://i.loli.net/2020/05/22/p5HWx7bzT6nc2r9.jpg"></p>
<p> 被 dispatch_main_queue 唤醒<br> 调用 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong> 处理提交到 dispatch_main_queue 的任务</p>
<p> <img src="https://i.loli.net/2020/05/22/dZFCS76NqtjUTs3.jpg"></p>
<p> 被 source1 唤醒</p>
<p> 调用 <strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION</strong> 处理 source1。<br>因为 source1 自己拥有一个 mach port，在 source1 的回调函数中可能会往别的 port 发送消息</p>
<p><img src="https://i.loli.net/2020/05/22/GSLi4KC3F5XlPkI.jpg"><br>执行了上述可能的各种回调，可能又有 block 提交到了当前 runloop 当中，所以我们这里再调用一次 __CFRunLoopDoBlocks() </p>
<p><img src="https://i.loli.net/2020/05/24/JTmUnZGoVMOrajB.jpg"></p>
<p>最后，根据前面的处理结果来判断是否退出 loop</p>
<h3 id="用-RunLoop-实现的功能"><a href="#用-RunLoop-实现的功能" class="headerlink" title="用 RunLoop 实现的功能"></a>用 RunLoop 实现的功能</h3><p>这一部分我觉得 <a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/05/18/runloop/">https://blog.ibireme.com/2015/05/18/runloop/</a> 这一篇文章里面已经写的很好了，我这里就不赘述了。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/63184073">https://zhuanlan.zhihu.com/p/63184073</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p> 从源码读懂 Runloop</p><p><a href="http://example.com/2020/05/24/从源码读懂-Runloop/">http://example.com/2020/05/24/从源码读懂-Runloop/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>千行</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-05-24</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-10-21</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Runloop/">Runloop</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/07/13/YTKNetwork-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E4%B8%80-%E4%B9%8B-YTKBaseRequest/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">YTKNetwork 源码解读 (一) 之 YTKBaseRequest</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/05/11/%E6%8E%A2%E7%A9%B6-block-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><span class="level-item">探究 block 数据结构及内存管理</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'http://example.com/2020/05/24/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%AF%BB%E6%87%82-Runloop/';
            this.page.identifier = '2020/05/24/从源码读懂-Runloop/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'qianxingdeblog' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="千行"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">千行</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>杭州, 浙江</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">33</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#runloop-与线程的关系"><span class="level-left"><span class="level-item">1</span><span class="level-item">runloop 与线程的关系</span></span></a></li><li><a class="level is-mobile" href="#runloop，mode-以及-mode-item"><span class="level-left"><span class="level-item">2</span><span class="level-item">runloop，mode 以及 mode item</span></span></a></li><li><a class="level is-mobile" href="#CFRunLoopObserverRef"><span class="level-left"><span class="level-item">3</span><span class="level-item">CFRunLoopObserverRef</span></span></a></li><li><a class="level is-mobile" href="#CFRunLoopSourceRef"><span class="level-left"><span class="level-item">4</span><span class="level-item">CFRunLoopSourceRef</span></span></a></li><li><a class="level is-mobile" href="#CFRunLoopTimerRef"><span class="level-left"><span class="level-item">5</span><span class="level-item">CFRunLoopTimerRef</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#dispatch-source-t-使用"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">dispatch_source_t 使用</span></span></a></li><li><a class="level is-mobile" href="#mk-timer-使用"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">mk_timer 使用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Runloop-主函数"><span class="level-left"><span class="level-item">6</span><span class="level-item">Runloop 主函数</span></span></a></li><li><a class="level is-mobile" href="#用-RunLoop-实现的功能"><span class="level-left"><span class="level-item">7</span><span class="level-item">用 RunLoop 实现的功能</span></span></a></li><li><a class="level is-mobile" href="#参考"><span class="level-left"><span class="level-item">8</span><span class="level-item">参考</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/bug/"><span class="level-start"><span class="level-item">bug</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/cocoapods/"><span class="level-start"><span class="level-item">cocoapods</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS%E6%9D%82/"><span class="level-start"><span class="level-item">iOS杂</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%90%AD%E5%BB%BA/"><span class="level-start"><span class="level-item">搭建</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/EventKit/"><span class="tag">EventKit</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GCD/"><span class="tag">GCD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NSError/"><span class="tag">NSError</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Runloop/"><span class="tag">Runloop</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tagged-Pointer/"><span class="tag">Tagged Pointer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/YTKNetwork/"><span class="tag">YTKNetwork</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/YYModel/"><span class="tag">YYModel</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/block/"><span class="tag">block</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dyld/"><span class="tag">dyld</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mach-o/"><span class="tag">mach-o</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/runtime/"><span class="tag">runtime</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/weak/"><span class="tag">weak</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/"><span class="tag">关联对象</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/"><span class="tag">内存分布</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%A1%E6%A0%B8/"><span class="tag">审核</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%A5%E5%85%B7/"><span class="tag">工具</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"><span class="tag">引用计数</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82/"><span class="tag">杂</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%BA%90%E7%A0%81/"><span class="tag">源码</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%94%81/"><span class="tag">锁</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="千行的博客" height="28"></a><p class="is-size-7"><span>&copy; 2022 千行</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>